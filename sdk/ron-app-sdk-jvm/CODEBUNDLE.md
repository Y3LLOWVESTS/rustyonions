<!-- Generated by scripts/make_sdk_codex.sh on 2025-12-04T00:47:59Z -->
# Code Bundle — SDK `ron-app-sdk-jvm`

> Generated for review/sharing. Source of truth remains the repo.
> Includes all non-Markdown files under sdk/ron-app-sdk-jvm.
> Skips node_modules, dist, coverage, .git, virtualenvs, caches, vendor, var,
> and Java/Gradle/IDE build dirs (build, .gradle, .idea, .vscode, out, .settings),
> plus common binary artifacts (class/jar/war/ear/zip/tar).

## Table of Contents
- [sdk/ron-app-sdk-jvm/.editorconfig](#sdk-ron-app-sdk-jvm--editorconfig)
- [sdk/ron-app-sdk-jvm/.gitignore](#sdk-ron-app-sdk-jvm--gitignore)
- [sdk/ron-app-sdk-jvm/build.gradle.kts](#sdk-ron-app-sdk-jvm-build-gradle-kts)
- [sdk/ron-app-sdk-jvm/config/checkstyle.xml](#sdk-ron-app-sdk-jvm-config-checkstyle-xml)
- [sdk/ron-app-sdk-jvm/config/detekt.yml](#sdk-ron-app-sdk-jvm-config-detekt-yml)
- [sdk/ron-app-sdk-jvm/config/ktlint.gradle.kts](#sdk-ron-app-sdk-jvm-config-ktlint-gradle-kts)
- [sdk/ron-app-sdk-jvm/core/build.gradle.kts](#sdk-ron-app-sdk-jvm-core-build-gradle-kts)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/AppResponse.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-AppResponse-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/Page.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-Page-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/RonClient.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-RonClient-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/RonException.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-RonException-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/RonProblem.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-RonProblem-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/RonSdkVersion.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-RonSdkVersion-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/auth/RefreshingTokenProvider.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-auth-RefreshingTokenProvider-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/auth/StaticTokenProvider.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-auth-StaticTokenProvider-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/auth/TokenProvider.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-auth-TokenProvider-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/config/EnvConfigLoader.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-config-EnvConfigLoader-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/config/RonConfig.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-config-RonConfig-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/http/HttpClientAdapter.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-http-HttpClientAdapter-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/http/HttpRequestContext.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-http-HttpRequestContext-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/http/HttpResponse.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-http-HttpResponse-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/http/OkHttpClientAdapter.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-http-OkHttpClientAdapter-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/internal/BackoffStrategy.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-internal-BackoffStrategy-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/internal/JsonMapper.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-internal-JsonMapper-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/internal/ResponseSizeLimiter.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-internal-ResponseSizeLimiter-java)
- [sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/internal/RetryPolicy.java](#sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-internal-RetryPolicy-java)
- [sdk/ron-app-sdk-jvm/core/src/test/java/dev/roncore/sdk/ConfigEnvLoaderTest.java](#sdk-ron-app-sdk-jvm-core-src-test-java-dev-roncore-sdk-ConfigEnvLoaderTest-java)
- [sdk/ron-app-sdk-jvm/core/src/test/java/dev/roncore/sdk/ErrorParsingTest.java](#sdk-ron-app-sdk-jvm-core-src-test-java-dev-roncore-sdk-ErrorParsingTest-java)
- [sdk/ron-app-sdk-jvm/core/src/test/java/dev/roncore/sdk/RetryPolicyTest.java](#sdk-ron-app-sdk-jvm-core-src-test-java-dev-roncore-sdk-RetryPolicyTest-java)
- [sdk/ron-app-sdk-jvm/core/src/test/java/dev/roncore/sdk/RonClientBasicTest.java](#sdk-ron-app-sdk-jvm-core-src-test-java-dev-roncore-sdk-RonClientBasicTest-java)
- [sdk/ron-app-sdk-jvm/docs/arch.mmd](#sdk-ron-app-sdk-jvm-docs-arch-mmd)
- [sdk/ron-app-sdk-jvm/docs/sequence.mmd](#sdk-ron-app-sdk-jvm-docs-sequence-mmd)
- [sdk/ron-app-sdk-jvm/docs/state.mmd](#sdk-ron-app-sdk-jvm-docs-state-mmd)
- [sdk/ron-app-sdk-jvm/examples/android-sample/build.gradle.kts](#sdk-ron-app-sdk-jvm-examples-android-sample-build-gradle-kts)
- [sdk/ron-app-sdk-jvm/examples/android-sample/src/main/AndroidManifest.xml](#sdk-ron-app-sdk-jvm-examples-android-sample-src-main-AndroidManifest-xml)
- [sdk/ron-app-sdk-jvm/examples/android-sample/src/main/java/dev/roncore/sdk/examples/android/HelloViewModel.kt](#sdk-ron-app-sdk-jvm-examples-android-sample-src-main-java-dev-roncore-sdk-examples-android-HelloViewModel-kt)
- [sdk/ron-app-sdk-jvm/examples/android-sample/src/main/java/dev/roncore/sdk/examples/android/MainActivity.kt](#sdk-ron-app-sdk-jvm-examples-android-sample-src-main-java-dev-roncore-sdk-examples-android-MainActivity-kt)
- [sdk/ron-app-sdk-jvm/examples/android-sample/src/main/java/dev/roncore/sdk/examples/android/RonApp.kt](#sdk-ron-app-sdk-jvm-examples-android-sample-src-main-java-dev-roncore-sdk-examples-android-RonApp-kt)
- [sdk/ron-app-sdk-jvm/examples/android-sample/src/main/res/layout/activity_main.xml](#sdk-ron-app-sdk-jvm-examples-android-sample-src-main-res-layout-activitymain-xml)
- [sdk/ron-app-sdk-jvm/examples/java-cli/build.gradle.kts](#sdk-ron-app-sdk-jvm-examples-java-cli-build-gradle-kts)
- [sdk/ron-app-sdk-jvm/examples/java-cli/src/main/java/dev/roncore/sdk/examples/HelloCli.java](#sdk-ron-app-sdk-jvm-examples-java-cli-src-main-java-dev-roncore-sdk-examples-HelloCli-java)
- [sdk/ron-app-sdk-jvm/examples/kotlin-ktor/build.gradle.kts](#sdk-ron-app-sdk-jvm-examples-kotlin-ktor-build-gradle-kts)
- [sdk/ron-app-sdk-jvm/examples/kotlin-ktor/src/main/kotlin/dev/roncore/sdk/examples/ktor/KtorApp.kt](#sdk-ron-app-sdk-jvm-examples-kotlin-ktor-src-main-kotlin-dev-roncore-sdk-examples-ktor-KtorApp-kt)
- [sdk/ron-app-sdk-jvm/examples/kotlin-ktor/src/main/kotlin/dev/roncore/sdk/examples/ktor/Routes.kt](#sdk-ron-app-sdk-jvm-examples-kotlin-ktor-src-main-kotlin-dev-roncore-sdk-examples-ktor-Routes-kt)
- [sdk/ron-app-sdk-jvm/examples/spring-boot/build.gradle.kts](#sdk-ron-app-sdk-jvm-examples-spring-boot-build-gradle-kts)
- [sdk/ron-app-sdk-jvm/examples/spring-boot/src/main/java/dev/roncore/sdk/examples/spring/Application.java](#sdk-ron-app-sdk-jvm-examples-spring-boot-src-main-java-dev-roncore-sdk-examples-spring-Application-java)
- [sdk/ron-app-sdk-jvm/examples/spring-boot/src/main/java/dev/roncore/sdk/examples/spring/HelloController.java](#sdk-ron-app-sdk-jvm-examples-spring-boot-src-main-java-dev-roncore-sdk-examples-spring-HelloController-java)
- [sdk/ron-app-sdk-jvm/examples/spring-boot/src/main/java/dev/roncore/sdk/examples/spring/RonSdkConfig.java](#sdk-ron-app-sdk-jvm-examples-spring-boot-src-main-java-dev-roncore-sdk-examples-spring-RonSdkConfig-java)
- [sdk/ron-app-sdk-jvm/facets/build.gradle.kts](#sdk-ron-app-sdk-jvm-facets-build-gradle-kts)
- [sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetDefinition.kt](#sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetDefinition-kt)
- [sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetKind.kt](#sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetKind-kt)
- [sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetLimits.kt](#sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetLimits-kt)
- [sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetMeta.kt](#sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetMeta-kt)
- [sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetSecurity.kt](#sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetSecurity-kt)
- [sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetTomlWriter.kt](#sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetTomlWriter-kt)
- [sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/Integrity.kt](#sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-Integrity-kt)
- [sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/RouteDefinition.kt](#sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-RouteDefinition-kt)
- [sdk/ron-app-sdk-jvm/facets/src/test/kotlin/dev/roncore/sdk/facets/FacetSchemaInteropTest.kt](#sdk-ron-app-sdk-jvm-facets-src-test-kotlin-dev-roncore-sdk-facets-FacetSchemaInteropTest-kt)
- [sdk/ron-app-sdk-jvm/facets/src/test/kotlin/dev/roncore/sdk/facets/FacetTomlWriterTest.kt](#sdk-ron-app-sdk-jvm-facets-src-test-kotlin-dev-roncore-sdk-facets-FacetTomlWriterTest-kt)
- [sdk/ron-app-sdk-jvm/gradle.properties](#sdk-ron-app-sdk-jvm-gradle-properties)
- [sdk/ron-app-sdk-jvm/gradle/libs.versions.toml](#sdk-ron-app-sdk-jvm-gradle-libs-versions-toml)
- [sdk/ron-app-sdk-jvm/gradle/wrapper/gradle-wrapper.properties](#sdk-ron-app-sdk-jvm-gradle-wrapper-gradle-wrapper-properties)
- [sdk/ron-app-sdk-jvm/gradlew](#sdk-ron-app-sdk-jvm-gradlew)
- [sdk/ron-app-sdk-jvm/gradlew.bat](#sdk-ron-app-sdk-jvm-gradlew-bat)
- [sdk/ron-app-sdk-jvm/interop-tests/build.gradle.kts](#sdk-ron-app-sdk-jvm-interop-tests-build-gradle-kts)
- [sdk/ron-app-sdk-jvm/interop-tests/src/test/java/dev/roncore/sdk/interop/ErrorEnvelopeInteropTest.java](#sdk-ron-app-sdk-jvm-interop-tests-src-test-java-dev-roncore-sdk-interop-ErrorEnvelopeInteropTest-java)
- [sdk/ron-app-sdk-jvm/interop-tests/src/test/java/dev/roncore/sdk/interop/HappyPathInteropTest.java](#sdk-ron-app-sdk-jvm-interop-tests-src-test-java-dev-roncore-sdk-interop-HappyPathInteropTest-java)
- [sdk/ron-app-sdk-jvm/interop-tests/src/test/java/dev/roncore/sdk/interop/InteropSmokeTest.java](#sdk-ron-app-sdk-jvm-interop-tests-src-test-java-dev-roncore-sdk-interop-InteropSmokeTest-java)
- [sdk/ron-app-sdk-jvm/interop-tests/src/test/java/dev/roncore/sdk/interop/PaginationInteropTest.java](#sdk-ron-app-sdk-jvm-interop-tests-src-test-java-dev-roncore-sdk-interop-PaginationInteropTest-java)
- [sdk/ron-app-sdk-jvm/kotlin/build.gradle.kts](#sdk-ron-app-sdk-jvm-kotlin-build-gradle-kts)
- [sdk/ron-app-sdk-jvm/kotlin/src/main/kotlin/dev/roncore/sdk/kotlin/Ron.kt](#sdk-ron-app-sdk-jvm-kotlin-src-main-kotlin-dev-roncore-sdk-kotlin-Ron-kt)
- [sdk/ron-app-sdk-jvm/kotlin/src/main/kotlin/dev/roncore/sdk/kotlin/RonConfigDsl.kt](#sdk-ron-app-sdk-jvm-kotlin-src-main-kotlin-dev-roncore-sdk-kotlin-RonConfigDsl-kt)
- [sdk/ron-app-sdk-jvm/kotlin/src/main/kotlin/dev/roncore/sdk/kotlin/RonExtensions.kt](#sdk-ron-app-sdk-jvm-kotlin-src-main-kotlin-dev-roncore-sdk-kotlin-RonExtensions-kt)
- [sdk/ron-app-sdk-jvm/kotlin/src/main/kotlin/dev/roncore/sdk/kotlin/Streaming.kt](#sdk-ron-app-sdk-jvm-kotlin-src-main-kotlin-dev-roncore-sdk-kotlin-Streaming-kt)
- [sdk/ron-app-sdk-jvm/kotlin/src/test/kotlin/dev/roncore/sdk/kotlin/RonCoroutineTest.kt](#sdk-ron-app-sdk-jvm-kotlin-src-test-kotlin-dev-roncore-sdk-kotlin-RonCoroutineTest-kt)
- [sdk/ron-app-sdk-jvm/kotlin/src/test/kotlin/dev/roncore/sdk/kotlin/RonDslTest.kt](#sdk-ron-app-sdk-jvm-kotlin-src-test-kotlin-dev-roncore-sdk-kotlin-RonDslTest-kt)
- [sdk/ron-app-sdk-jvm/local.properties](#sdk-ron-app-sdk-jvm-local-properties)
- [sdk/ron-app-sdk-jvm/settings.gradle.kts](#sdk-ron-app-sdk-jvm-settings-gradle-kts)
- [sdk/ron-app-sdk-jvm/tools/ci/run-interop.sh](#sdk-ron-app-sdk-jvm-tools-ci-run-interop-sh)
- [sdk/ron-app-sdk-jvm/tools/ci/run-lint.sh](#sdk-ron-app-sdk-jvm-tools-ci-run-lint-sh)
- [sdk/ron-app-sdk-jvm/tools/ci/run-tests.sh](#sdk-ron-app-sdk-jvm-tools-ci-run-tests-sh)
- [sdk/ron-app-sdk-jvm/tools/codegen/openapi-config.yml](#sdk-ron-app-sdk-jvm-tools-codegen-openapi-config-yml)
- [sdk/ron-app-sdk-jvm/tools/codegen/regenerate-dtos.sh](#sdk-ron-app-sdk-jvm-tools-codegen-regenerate-dtos-sh)
- [sdk/ron-app-sdk-jvm/tools/make_codex.sh](#sdk-ron-app-sdk-jvm-tools-makecodex-sh)

### sdk/ron-app-sdk-jvm/.editorconfig
<a id="sdk-ron-app-sdk-jvm--editorconfig"></a>

```

```

### sdk/ron-app-sdk-jvm/.gitignore
<a id="sdk-ron-app-sdk-jvm--gitignore"></a>

```

```

### sdk/ron-app-sdk-jvm/build.gradle.kts
<a id="sdk-ron-app-sdk-jvm-build-gradle-kts"></a>

```kotlin
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    id("org.jetbrains.kotlin.jvm") version "1.9.25" apply false
    id("org.jlleitschuh.gradle.ktlint") version "12.1.1" apply false
    id("io.gitlab.arturbosch.detekt") version "1.23.6" apply false
}

allprojects {
    group = "dev.roncore"
    version = "0.1.0-SNAPSHOT"

    repositories {
        mavenCentral()
        google()
    }
}

subprojects {
    tasks.withType<Test>().configureEach {
        useJUnitPlatform()

        testLogging {
            events = setOf(
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED,
                TestLogEvent.FAILED
            )
        }
    }
}

```

### sdk/ron-app-sdk-jvm/config/checkstyle.xml
<a id="sdk-ron-app-sdk-jvm-config-checkstyle-xml"></a>

```xml

```

### sdk/ron-app-sdk-jvm/config/detekt.yml
<a id="sdk-ron-app-sdk-jvm-config-detekt-yml"></a>

```yaml

```

### sdk/ron-app-sdk-jvm/config/ktlint.gradle.kts
<a id="sdk-ron-app-sdk-jvm-config-ktlint-gradle-kts"></a>

```kotlin

```

### sdk/ron-app-sdk-jvm/core/build.gradle.kts
<a id="sdk-ron-app-sdk-jvm-core-build-gradle-kts"></a>

```kotlin
plugins {
    `java-library`
    id("checkstyle")
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
    withJavadocJar()
    withSourcesJar()
}

val libs = project.extensions.getByType<org.gradle.accessors.dm.LibrariesForLibs>()

dependencies {
    api(libs.jackson.annotations) // visible in public DTOs/envelopes if needed

    implementation(libs.okhttp)
    implementation(libs.jackson.core)
    implementation(libs.jackson.databind)
    implementation(libs.jackson.jsr310)

    testImplementation(libs.junit.jupiter)
}

tasks.withType<Checkstyle> {
    // You can wire config/checkstyle.xml later; using defaults for now.
    isIgnoreFailures = false
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/AppResponse.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-AppResponse-java"></a>

```java
package dev.roncore.sdk;

import java.util.Objects;

/**
 * RO:WHAT —
 *   Canonical application-plane response envelope for the JVM SDK.
 *
 * RO:WHY —
 *   Wraps either successful data or a {@link RonProblem} plus HTTP status,
 *   so call sites can handle success/error in a uniform way.
 *
 * RO:INTERACTS —
 *   - {@link RonClient} (returns this from HTTP calls).
 *   - {@link RonProblem} (structured error details).
 *
 * RO:INVARIANTS —
 *   - For any HTTP response, exactly one of {@code data} or {@code problem}
 *     will be non-null in well-formed responses.
 *   - {@code status} is always the HTTP status code observed on the wire.
 */
public final class AppResponse<T> {

    private final T data;
    private final RonProblem problem;
    private final int status;

    public AppResponse(T data, RonProblem problem, int status) {
        this.data = data;
        this.problem = problem;
        this.status = status;
    }

    /**
     * Convenience factory for a successful response.
     */
    public static <T> AppResponse<T> ok(T data, int status) {
        return new AppResponse<>(data, null, status);
    }

    /**
     * Convenience factory for an error response.
     */
    public static <T> AppResponse<T> error(RonProblem problem, int status) {
        return new AppResponse<>(null, problem, status);
    }

    public T getData() {
        return data;
    }

    public RonProblem getProblem() {
        return problem;
    }

    public int getStatus() {
        return status;
    }

    /**
     * Returns true if the response is considered a success (2xx HTTP status and no problem).
     * This matches the shape expected by tests (ok()) while preserving the older isOk() name.
     */
    public boolean ok() {
        return status >= 200 && status < 300 && problem == null;
    }

    /**
     * Alias kept for earlier code that used isOk().
     */
    public boolean isOk() {
        return ok();
    }

    @Override
    public String toString() {
        return "AppResponse{" +
                "status=" + status +
                ", ok=" + ok() +
                ", data=" + (data != null ? data.toString() : "null") +
                ", problem=" + (problem != null ? problem.toString() : "null") +
                '}';
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof AppResponse<?> other)) {
            return false;
        }
        return status == other.status
                && Objects.equals(data, other.data)
                && Objects.equals(problem, other.problem);
    }

    @Override
    public int hashCode() {
        return Objects.hash(data, problem, status);
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/Page.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-Page-java"></a>

```java
package dev.roncore.sdk;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

/**
 * RO:WHAT —
 *   Generic pagination envelope type with items and nextPageToken.
 *
 * RO:WHY —
 *   Mirrors the shared pagination schema so JVM apps can page through
 *   RON resources in a uniform way.
 *
 * RO:INTERACTS —
 *   - Used as a data payload in {@link AppResponse} for list endpoints.
 *
 * RO:INVARIANTS —
 *   - {@code items} is never null; defaults to an empty list if omitted.
 */
public final class Page<T> {

    @JsonProperty("items")
    private final List<T> items;

    @JsonProperty("next_page_token")
    private final String nextPageToken;

    public Page(
            @JsonProperty("items") List<T> items,
            @JsonProperty("next_page_token") String nextPageToken
    ) {
        this.items = items != null ? List.copyOf(items) : Collections.emptyList();
        this.nextPageToken = nextPageToken;
    }

    public List<T> getItems() {
        return items;
    }

    public String getNextPageToken() {
        return nextPageToken;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof Page<?> other)) {
            return false;
        }
        return Objects.equals(items, other.items)
                && Objects.equals(nextPageToken, other.nextPageToken);
    }

    @Override
    public int hashCode() {
        return Objects.hash(items, nextPageToken);
    }

    @Override
    public String toString() {
        return "Page{items=" + items + ", nextPageToken='" + nextPageToken + "'}";
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/RonClient.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-RonClient-java"></a>

```java
package dev.roncore.sdk;

import dev.roncore.sdk.auth.TokenProvider;
import dev.roncore.sdk.config.EnvConfigLoader;
import dev.roncore.sdk.config.RonConfig;
import dev.roncore.sdk.http.HttpClientAdapter;
import dev.roncore.sdk.http.HttpRequestContext;
import dev.roncore.sdk.http.HttpResponse;
import dev.roncore.sdk.http.OkHttpClientAdapter;
import dev.roncore.sdk.internal.JsonMapper;
import dev.roncore.sdk.internal.ResponseSizeLimiter;
import dev.roncore.sdk.internal.RetryPolicy;

import java.io.Closeable;
import java.io.IOException;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * RO:WHAT —
 *   Java-first RON client for JVM apps (Spring Boot, CLIs, desktop).
 *
 * RO:WHY —
 *   Provides an idiomatic API for calling `/app/*` endpoints with
 *   env-driven defaults, structured errors, and safety invariants.
 *
 * RO:INTERACTS —
 *   - {@link RonConfig} (configuration).
 *   - {@link HttpClientAdapter} (transport).
 *   - {@link TokenProvider} (auth).
 *   - {@link AppResponse} / {@link RonProblem} (envelopes).
 *
 * RO:INVARIANTS —
 *   - Thread-safe and intended to be shared per process or per DI scope.
 *   - All network calls are bounded by timeouts and optional retries.
 */
public final class RonClient implements Closeable {

    private final RonConfig config;
    private final HttpClientAdapter http;
    private final TokenProvider tokenProvider;
    private final JsonMapper jsonMapper;
    private final RetryPolicy retryPolicy;
    private final ResponseSizeLimiter responseSizeLimiter;

    private RonClient(Builder builder) {
        this.config = builder.config;
        this.http = builder.httpClientAdapter != null
                ? builder.httpClientAdapter
                : new OkHttpClientAdapter(config);
        this.tokenProvider = builder.tokenProvider;
        this.jsonMapper = builder.jsonMapper != null ? builder.jsonMapper : new JsonMapper();
        this.retryPolicy = builder.retryPolicy != null ? builder.retryPolicy : RetryPolicy.defaultPolicy();
        this.responseSizeLimiter = new ResponseSizeLimiter(config.getMaxResponseBytes());
    }

    public static Builder builder() {
        return new Builder();
    }

    /**
     * Performs a GET request to {@code /app/*}, returning an {@link AppResponse}.
     */
    public AppResponse<String> get(String path) {
        return get(path, String.class);
    }

    public <T> AppResponse<T> get(String path, Class<T> dataType) {
        return execute("GET", path, null, dataType);
    }

    public <T> AppResponse<T> post(String path, Object body, Class<T> dataType) {
        return execute("POST", path, body, dataType);
    }

    public <T> AppResponse<T> put(String path, Object body, Class<T> dataType) {
        return execute("PUT", path, body, dataType);
    }

    public <T> AppResponse<T> patch(String path, Object body, Class<T> dataType) {
        return execute("PATCH", path, body, dataType);
    }

    public <T> AppResponse<T> delete(String path, Class<T> dataType) {
        return execute("DELETE", path, null, dataType);
    }

    private <T> AppResponse<T> execute(String method, String path, Object body, Class<T> dataType) {
        Objects.requireNonNull(method, "method must not be null");
        Objects.requireNonNull(path, "path must not be null");

        final String url = buildUrl(path);
        final Map<String, String> headers = buildHeaders();

        final String jsonBody = jsonMapper.toJson(body);

        HttpRequestContext ctx = new HttpRequestContext(method, url, headers, jsonBody);

        try {
            HttpResponse httpResponse = retryPolicy.execute(method, () -> {
                HttpResponse response;
                try {
                    response = http.execute(ctx);
                } catch (IOException ex) {
                    throw RonException.transportError(
                            "TRANSPORT_IO_ERROR",
                            "I/O error during HTTP call",
                            true,
                            ex
                    );
                }

                String responseBody = response.getBody();
                if (responseBody != null) {
                    responseSizeLimiter.ensureWithinLimit(responseBody.length());
                }
                return response;
            });

            return jsonMapper.decodeAppResponse(httpResponse, dataType);
        } catch (RonException ex) {
            // Already structured; just bubble up.
            throw ex;
        } catch (RuntimeException ex) {
            throw RonException.transportError(
                    "UNEXPECTED_RUNTIME_ERROR",
                    "Unexpected error during request",
                    false,
                    ex
            );
        }
    }

    private String buildUrl(String path) {
        URI base = config.getBaseUri();
        String normalizedPath = path.startsWith("/app/") ? path : "/app" + (path.startsWith("/") ? path : "/" + path);
        String baseStr = base.toString();
        if (baseStr.endsWith("/") && normalizedPath.startsWith("/")) {
            return baseStr.substring(0, baseStr.length() - 1) + normalizedPath;
        }
        return baseStr + normalizedPath;
    }

    private Map<String, String> buildHeaders() {
        Map<String, String> headers = new HashMap<>();
        headers.put("User-Agent", "ron-app-sdk-jvm/" + RonSdkVersion.SDK_VERSION);
        headers.put("X-Ron-Protocol-Version", RonSdkVersion.PROTOCOL_VERSION);

        if (tokenProvider != null) {
            String token = tokenProvider.getToken();
            if (token != null && !token.isBlank()) {
                headers.put("Authorization", "Bearer " + token);
            }
        }

        return headers;
    }

    @Override
    public void close() {
        // OkHttp client does not strictly require close; we may expose a hook later
        // for shutting down connection pools or other resources.
    }

    /**
     * Builder for {@link RonClient}.
     */
    public static final class Builder {

        private RonConfig config;
        private RonConfig.Builder configBuilder;
        private HttpClientAdapter httpClientAdapter;
        private TokenProvider tokenProvider;
        private JsonMapper jsonMapper;
        private RetryPolicy retryPolicy;

        /**
         * Load configuration defaults from {@code RON_SDK_*} env vars.
         * Explicit builder calls can override these values via the builder.
         */
        public Builder fromEnv() {
            this.configBuilder = EnvConfigLoader.fromEnv();
            this.config = null;
            return this;
        }

        /**
         * Explicitly sets the base URL; overrides any env-derived base URL.
         * If no config has been set yet, starts from an empty RonConfig builder.
         */
        public Builder baseUrl(String baseUrl) {
            if (this.configBuilder == null) {
                this.configBuilder = RonConfig.builder();
            }
            this.configBuilder.baseUrl(baseUrl);
            this.config = null;
            return this;
        }

        /**
         * Use a fully-built {@link RonConfig}, bypassing env and builder state.
         */
        public Builder config(RonConfig config) {
            this.config = Objects.requireNonNull(config, "config must not be null");
            this.configBuilder = null;
            return this;
        }

        public Builder tokenProvider(TokenProvider tokenProvider) {
            this.tokenProvider = tokenProvider;
            return this;
        }

        public Builder httpClientAdapter(HttpClientAdapter httpClientAdapter) {
            this.httpClientAdapter = httpClientAdapter;
            return this;
        }

        public Builder jsonMapper(JsonMapper jsonMapper) {
            this.jsonMapper = jsonMapper;
            return this;
        }

        public Builder retryPolicy(RetryPolicy retryPolicy) {
            this.retryPolicy = retryPolicy;
            return this;
        }

        public RonClient build() {
            if (this.config == null) {
                if (this.configBuilder == null) {
                    throw RonException.configError(
                            "CONFIG_MISSING_BASE_URL",
                            "No config or baseUrl provided; call fromEnv(), config(), or baseUrl()."
                    );
                }
                this.config = this.configBuilder.build();
            }
            return new RonClient(this);
        }
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/RonException.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-RonException-java"></a>

```java
package dev.roncore.sdk;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * RO:WHAT —
 *   JVM exception type for SDK-level failures (config, transport, policy, app).
 *
 * RO:WHY —
 *   Gives callers a single, structured exception to catch, without leaking
 *   tokens or sensitive internals into messages or stack traces.
 *
 * RO:INTERACTS —
 *   - Thrown by {@link RonClient} for configuration and transport failures.
 *   - May wrap a {@link RonProblem} for app-level problems where throwing
 *     is more ergonomic than returning {@link AppResponse}.
 *
 * RO:INVARIANTS —
 *   - No secret material (tokens, headers) is ever embedded in message text.
 *   - {@code kind} and {@code code} are stable, machine-readable identifiers.
 */
public final class RonException extends RuntimeException {

    private final String kind;
    private final String code;
    private final String correlationId;
    private final boolean retryable;
    private final Map<String, Object> details;

    public RonException(
            String kind,
            String code,
            String message,
            String correlationId,
            boolean retryable,
            Map<String, Object> details,
            Throwable cause
    ) {
        super(message, cause);
        this.kind = kind;
        this.code = code;
        this.correlationId = correlationId;
        this.retryable = retryable;
        this.details = details != null ? Collections.unmodifiableMap(new HashMap<>(details)) : Collections.emptyMap();
    }

    public String getKind() {
        return kind;
    }

    public String getCode() {
        return code;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public boolean isRetryable() {
        return retryable;
    }

    public Map<String, Object> getDetails() {
        return details;
    }

    public static RonException configError(String code, String message) {
        return new RonException("config", code, message, null, false, Collections.emptyMap(), null);
    }

    public static RonException transportError(String code, String message, boolean retryable, Throwable cause) {
        return new RonException("transport", code, message, null, retryable, Collections.emptyMap(), cause);
    }

    public static RonException decodeError(String message, Throwable cause) {
        return new RonException("transport", "DECODE_ERROR", message, null, false, Collections.emptyMap(), cause);
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/RonProblem.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-RonProblem-java"></a>

```java
package dev.roncore.sdk;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * RO:WHAT —
 *   JVM representation of the canonical RON problem envelope.
 *
 * RO:WHY —
 *   Gives callers a structured view of application, policy, and transport
 *   problems instead of ad-hoc strings.
 *
 * RO:INTERACTS —
 *   - {@link AppResponse} (references a {@code RonProblem} when not ok()).
 *   - {@link RonException} (may wrap a {@code RonProblem}).
 *
 * RO:INVARIANTS —
 *   - Fields mirror the cross-language schema: code, message, kind,
 *     correlation_id, details.
 *   - Unknown fields are captured into {@code extra} but never crash parsing.
 */
public final class RonProblem {

    @JsonProperty("code")
    private final String code;

    @JsonProperty("message")
    private final String message;

    @JsonProperty("kind")
    private final String kind;

    @JsonProperty("correlation_id")
    private final String correlationId;

    @JsonProperty("details")
    private final Map<String, Object> details;

    @JsonIgnore
    private final Map<String, Object> extra;

    public RonProblem(
            @JsonProperty("code") String code,
            @JsonProperty("message") String message,
            @JsonProperty("kind") String kind,
            @JsonProperty("correlation_id") String correlationId,
            @JsonProperty("details") Map<String, Object> details
    ) {
        this.code = code;
        this.message = message;
        this.kind = kind;
        this.correlationId = correlationId;
        this.details = details != null ? Collections.unmodifiableMap(new HashMap<>(details)) : Collections.emptyMap();
        this.extra = new HashMap<>();
    }

    @JsonAnySetter
    private void putExtra(String key, Object value) {
        extra.put(key, value);
    }

    public String getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    public String getKind() {
        return kind;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public Map<String, Object> getDetails() {
        return details;
    }

    /**
     * Any additional fields the server may have sent that are not part
     * of the canonical envelope. Never null.
     */
    public Map<String, Object> getExtra() {
        return Collections.unmodifiableMap(extra);
    }

    @Override
    public String toString() {
        return "RonProblem{" +
                "code='" + code + '\'' +
                ", kind='" + kind + '\'' +
                ", correlationId='" + correlationId + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof RonProblem other)) {
            return false;
        }
        return Objects.equals(code, other.code)
                && Objects.equals(message, other.message)
                && Objects.equals(kind, other.kind)
                && Objects.equals(correlationId, other.correlationId)
                && Objects.equals(details, other.details)
                && Objects.equals(extra, other.extra);
    }

    @Override
    public int hashCode() {
        return Objects.hash(code, message, kind, correlationId, details, extra);
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/RonSdkVersion.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-RonSdkVersion-java"></a>

```java
package dev.roncore.sdk;

/**
 * RO:WHAT —
 *   Holds SDK and protocol version constants for logging and diagnostics.
 *
 * RO:WHY —
 *   Allows apps and support tooling to quickly identify which SDK and
 *   protocol version were used when making a request.
 *
 * RO:INVARIANTS —
 *   - Values are updated as part of release process; never mutated at runtime.
 */
public final class RonSdkVersion {

    public static final String SDK_VERSION = "0.1.0-SNAPSHOT";
    public static final String PROTOCOL_VERSION = "v0.1";

    private RonSdkVersion() {
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/auth/RefreshingTokenProvider.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-auth-RefreshingTokenProvider-java"></a>

```java
package dev.roncore.sdk.auth;

import java.time.Instant;
import java.util.Objects;
import java.util.function.Supplier;

/**
 * RO:WHAT —
 *   {@link TokenProvider} that refreshes tokens via a user-supplied callback.
 *
 * RO:WHY —
 *   Lets apps integrate with external auth systems (svc-passport, OAuth)
 *   without the SDK knowing details.
 *
 * RO:INVARIANTS —
 *   - Tokens are stored in memory only.
 *   - Minimal caching to avoid hammering upstream auth.
 */
public final class RefreshingTokenProvider implements TokenProvider {

    private final Supplier<String> refresher;
    private final long ttlSeconds;

    private volatile String cachedToken;
    private volatile Instant expiry;

    public RefreshingTokenProvider(Supplier<String> refresher, long ttlSeconds) {
        this.refresher = Objects.requireNonNull(refresher, "refresher must not be null");
        this.ttlSeconds = Math.max(0L, ttlSeconds);
    }

    @Override
    public String getToken() {
        if (ttlSeconds <= 0) {
            // No caching: always refresh.
            return refresher.get();
        }

        Instant now = Instant.now();
        String token = cachedToken;
        Instant exp = expiry;

        if (token != null && exp != null && now.isBefore(exp)) {
            return token;
        }

        synchronized (this) {
            token = cachedToken;
            exp = expiry;
            if (token != null && exp != null && now.isBefore(exp)) {
                return token;
            }

            token = refresher.get();
            cachedToken = token;
            expiry = now.plusSeconds(ttlSeconds);
            return token;
        }
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/auth/StaticTokenProvider.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-auth-StaticTokenProvider-java"></a>

```java
package dev.roncore.sdk.auth;

import java.util.Objects;

/**
 * RO:WHAT —
 *   Simple in-memory {@link TokenProvider} for tests and small tools.
 *
 * RO:WHY —
 *   Provides a straightforward way to inject a single token without
 *   introducing global statics or disk persistence.
 */
public final class StaticTokenProvider implements TokenProvider {

    private final String token;

    public StaticTokenProvider(String token) {
        this.token = Objects.requireNonNull(token, "token must not be null");
    }

    @Override
    public String getToken() {
        return token;
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/auth/TokenProvider.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-auth-TokenProvider-java"></a>

```java
package dev.roncore.sdk.auth;

/**
 * RO:WHAT —
 *   Functional interface for providing capability/macroon tokens on demand.
 *
 * RO:WHY —
 *   Allows JVM apps to centralize token rotation and storage instead of
 *   scattering Authorization headers across code.
 *
 * RO:INVARIANTS —
 *   - Implementations must keep tokens in memory only (no disk persistence).
 *   - SDK consumers must ensure least-privilege and rotation.
 */
@FunctionalInterface
public interface TokenProvider {

    /**
     * Returns the current token/macroon, or {@code null} if no token is available.
     *
     * Implementations must not log or otherwise leak the token.
     */
    String getToken();
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/config/EnvConfigLoader.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-config-EnvConfigLoader-java"></a>

```java
package dev.roncore.sdk.config;

import java.time.Duration;
import java.util.Map;

/**
 * RO:WHAT —
 *   Helpers that read {@code RON_SDK_*} env vars and apply sane defaults.
 *
 * RO:WHY —
 *   Mirrors TS SDK semantics on server/CLI: env provides defaults, explicit
 *   code config always wins. Android ignores env entirely.
 *
 * RO:INVARIANTS —
 *   - fromEnv() uses System.getenv() for convenience.
 *   - applyEnv(...) is deterministic and testable with a supplied map.
 */
public final class EnvConfigLoader {

    private EnvConfigLoader() {
    }

    /**
     * Convenience entrypoint that starts from an empty builder and
     * populates it from the process environment.
     */
    public static RonConfig.Builder fromEnv() {
        RonConfig.Builder builder = RonConfig.builder();
        applyEnv(builder, System.getenv());
        return builder;
    }

    /**
     * Applies environment-derived settings to an existing builder.
     *
     * Explicit builder values take precedence:
     *   - If baseUrl is already set on the builder, RON_SDK_GATEWAY_ADDR is ignored.
     */
    public static void applyEnv(RonConfig.Builder builder, Map<String, String> env) {
        if (env == null || env.isEmpty()) {
            return;
        }

        // Base URL
        String baseUrl = env.get("RON_SDK_GATEWAY_ADDR");
        if (!builder.hasBaseUrl() && baseUrl != null && !baseUrl.isBlank()) {
            builder.baseUrl(baseUrl.trim());
        }

        // Timeouts
        Long overallMs = parseMillis(env.get("RON_SDK_OVERALL_TIMEOUT_MS"));
        Long connectMs = parseMillis(env.get("RON_SDK_CONNECT_TIMEOUT_MS"));
        Long readMs = parseMillis(env.get("RON_SDK_READ_TIMEOUT_MS"));
        Long writeMs = parseMillis(env.get("RON_SDK_WRITE_TIMEOUT_MS"));

        if (overallMs != null) {
            builder.overallTimeoutMs(overallMs);
        } else {
            // default overall timeout if none is provided at all
            builder.overallTimeout(Duration.ofMillis(30_000L));
        }

        if (connectMs != null) {
            builder.connectTimeoutMs(connectMs);
        }
        if (readMs != null) {
            builder.readTimeoutMs(readMs);
        }
        if (writeMs != null) {
            builder.writeTimeoutMs(writeMs);
        }

        // Insecure HTTP flag
        String insecure = env.get("RON_SDK_INSECURE_HTTP");
        if (insecure != null) {
            boolean allow = "1".equals(insecure) || "true".equalsIgnoreCase(insecure);
            builder.allowInsecureHttp(allow);
        }
    }

    private static Long parseMillis(String value) {
        if (value == null) {
            return null;
        }
        try {
            long millis = Long.parseLong(value.trim());
            if (millis <= 0) {
                return null;
            }
            return millis;
        } catch (NumberFormatException ex) {
            return null;
        }
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/config/RonConfig.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-config-RonConfig-java"></a>

```java
package dev.roncore.sdk.config;

import dev.roncore.sdk.RonException;

import java.net.URI;
import java.net.URISyntaxException;
import java.time.Duration;
import java.util.Objects;

/**
 * RO:WHAT —
 *   Immutable configuration for {@code RonClient}: base URL, timeouts,
 *   retry/backoff options, and security-sensitive flags.
 *
 * RO:WHY —
 *   Centralizes config so defaults and env-derived values are consistent
 *   across JVM apps (server, desktop, CLI) while remaining safe for Android.
 *
 * RO:INTERACTS —
 *   - {@link dev.roncore.sdk.RonClient} consumes this config.
 *   - {@link EnvConfigLoader} populates it from {@code RON_SDK_*} env vars.
 *
 * RO:INVARIANTS —
 *   - HTTPS is required by default; plain HTTP must be explicitly allowed.
 *   - All timeouts are bounded and non-negative.
 */
public final class RonConfig {

    private final String baseUrl;   // string form (for tests / diagnostics)
    private final URI baseUri;      // parsed form (for RonClient)
    private final Duration connectTimeout;
    private final Duration readTimeout;
    private final Duration writeTimeout;
    private final Duration overallTimeout;
    private final boolean allowInsecureHttp;
    private final int maxRetries;
    private final long maxResponseBytes;

    private RonConfig(Builder builder) {
        this.baseUrl = builder.baseUrl;
        this.baseUri = builder.baseUri;
        this.connectTimeout = builder.connectTimeout;
        this.readTimeout = builder.readTimeout;
        this.writeTimeout = builder.writeTimeout;
        this.overallTimeout = builder.overallTimeout;
        this.allowInsecureHttp = builder.allowInsecureHttp;
        this.maxRetries = builder.maxRetries;
        this.maxResponseBytes = builder.maxResponseBytes;
    }

    /**
     * Human-friendly string representation of the base URL, matching
     * what the builder/env provided.
     */
    public String getBaseUrl() {
        return baseUrl;
    }

    /**
     * Parsed URI form, used internally by the client to concatenate paths.
     */
    public URI getBaseUri() {
        return baseUri;
    }

    public Duration getConnectTimeout() {
        return connectTimeout;
    }

    public Duration getReadTimeout() {
        return readTimeout;
    }

    public Duration getWriteTimeout() {
        return writeTimeout;
    }

    public Duration getOverallTimeout() {
        return overallTimeout;
    }

    public boolean isAllowInsecureHttp() {
        return allowInsecureHttp;
    }

    public int getMaxRetries() {
        return maxRetries;
    }

    public long getMaxResponseBytes() {
        return maxResponseBytes;
    }

    // Convenience getters in milliseconds for tests / diagnostics

    public long getConnectTimeoutMs() {
        return connectTimeout.toMillis();
    }

    public long getReadTimeoutMs() {
        return readTimeout.toMillis();
    }

    public long getWriteTimeoutMs() {
        return writeTimeout.toMillis();
    }

    public long getOverallTimeoutMs() {
        return overallTimeout.toMillis();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static final class Builder {

        String baseUrl;          // raw string
        URI baseUri;             // parsed form
        Duration connectTimeout = Duration.ofSeconds(5);
        Duration readTimeout = Duration.ofSeconds(30);
        Duration writeTimeout = Duration.ofSeconds(30);
        Duration overallTimeout = Duration.ofSeconds(30);
        boolean allowInsecureHttp = false;
        int maxRetries = 0;
        long maxResponseBytes = 5L * 1024L * 1024L; // 5 MiB default

        public Builder baseUrl(String url) {
            Objects.requireNonNull(url, "baseUrl must not be null");
            String trimmed = url.trim();
            this.baseUrl = trimmed;
            try {
                this.baseUri = new URI(trimmed);
            } catch (URISyntaxException e) {
                throw RonException.configError(
                        "CONFIG_INVALID_URL",
                        "Invalid baseUrl: " + e.getMessage()
                );
            }
            return this;
        }

        public Builder connectTimeout(Duration timeout) {
            this.connectTimeout = Objects.requireNonNull(timeout);
            return this;
        }

        public Builder readTimeout(Duration timeout) {
            this.readTimeout = Objects.requireNonNull(timeout);
            return this;
        }

        public Builder writeTimeout(Duration timeout) {
            this.writeTimeout = Objects.requireNonNull(timeout);
            return this;
        }

        public Builder overallTimeout(Duration timeout) {
            this.overallTimeout = Objects.requireNonNull(timeout);
            return this;
        }

        // Millisecond-based helpers used by tests and env loader

        public Builder connectTimeoutMs(long millis) {
            if (millis > 0) {
                this.connectTimeout = Duration.ofMillis(millis);
            }
            return this;
        }

        public Builder readTimeoutMs(long millis) {
            if (millis > 0) {
                this.readTimeout = Duration.ofMillis(millis);
            }
            return this;
        }

        public Builder writeTimeoutMs(long millis) {
            if (millis > 0) {
                this.writeTimeout = Duration.ofMillis(millis);
            }
            return this;
        }

        public Builder overallTimeoutMs(long millis) {
            if (millis > 0) {
                this.overallTimeout = Duration.ofMillis(millis);
            }
            return this;
        }

        public Builder allowInsecureHttp(boolean allowInsecureHttp) {
            this.allowInsecureHttp = allowInsecureHttp;
            return this;
        }

        public Builder maxRetries(int maxRetries) {
            this.maxRetries = Math.max(0, maxRetries);
            return this;
        }

        public Builder maxResponseBytes(long maxResponseBytes) {
            this.maxResponseBytes = maxResponseBytes;
            return this;
        }

        boolean hasBaseUrl() {
            return this.baseUrl != null;
        }

        public RonConfig build() {
            if (baseUrl == null || baseUrl.isBlank()) {
                throw RonException.configError(
                        "CONFIG_MISSING_BASE_URL",
                        "baseUrl is required (set RON_SDK_GATEWAY_ADDR or call baseUrl())."
                );
            }

            // Ensure baseUri is in sync with baseUrl (in case someone bypassed baseUrl())
            if (baseUri == null) {
                try {
                    baseUri = new URI(baseUrl);
                } catch (URISyntaxException e) {
                    throw RonException.configError(
                            "CONFIG_INVALID_URL",
                            "Invalid baseUrl: " + e.getMessage()
                    );
                }
            }

            String scheme = baseUri.getScheme();
            if (!"https".equalsIgnoreCase(scheme) && !allowInsecureHttp) {
                throw RonException.configError(
                        "CONFIG_INSECURE_HTTP_DISABLED",
                        "Plain HTTP is disabled by default; enable allowInsecureHttp(true) for dev/test only."
                );
            }

            return new RonConfig(this);
        }
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/http/HttpClientAdapter.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-http-HttpClientAdapter-java"></a>

```java
package dev.roncore.sdk.http;

import java.io.IOException;

/**
 * RO:WHAT —
 *   Internal abstraction for HTTP operations used by {@code RonClient}.
 *
 * RO:WHY —
 *   Allows swapping HTTP engines (OkHttp, Ktor, custom) without changing
 *   the public SDK surface.
 *
 * RO:INVARIANTS —
 *   - All calls are bounded by timeouts supplied via config.
 *   - Implementations never log secrets (headers/tokens).
 */
public interface HttpClientAdapter {

    HttpResponse execute(HttpRequestContext request) throws IOException;
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/http/HttpRequestContext.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-http-HttpRequestContext-java"></a>

```java
package dev.roncore.sdk.http;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * RO:WHAT —
 *   Immutable description of an HTTP request to the gateway.
 *
 * RO:WHY —
 *   Decouples {@code RonClient} from the concrete HTTP engine while
 *   keeping enough context for logging and backoff decisions.
 */
public final class HttpRequestContext {

    private final String method;
    private final String url;
    private final Map<String, String> headers;
    private final String body; // JSON or null

    public HttpRequestContext(String method, String url, Map<String, String> headers, String body) {
        this.method = method;
        this.url = url;
        this.headers = headers != null ? Collections.unmodifiableMap(new HashMap<>(headers)) : Collections.emptyMap();
        this.body = body;
    }

    public String getMethod() {
        return method;
    }

    public String getUrl() {
        return url;
    }

    public Map<String, String> getHeaders() {
        return headers;
    }

    public String getBody() {
        return body;
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/http/HttpResponse.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-http-HttpResponse-java"></a>

```java
package dev.roncore.sdk.http;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * RO:WHAT —
 *   Minimal HTTP response representation returned by HTTP adapters.
 *
 * RO:WHY —
 *   Keeps transport details out of higher layers while still exposing
 *   status, headers, and body for envelope parsing.
 */
public final class HttpResponse {

    private final int statusCode;
    private final String body;
    private final Map<String, List<String>> headers;

    public HttpResponse(int statusCode, String body, Map<String, List<String>> headers) {
        this.statusCode = statusCode;
        this.body = body;
        this.headers = headers != null ? Collections.unmodifiableMap(new HashMap<>(headers)) : Collections.emptyMap();
    }

    public int getStatusCode() {
        return statusCode;
    }

    public String getBody() {
        return body;
    }

    public Map<String, List<String>> getHeaders() {
        return headers;
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/http/OkHttpClientAdapter.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-http-OkHttpClientAdapter-java"></a>

```java
package dev.roncore.sdk.http;

import dev.roncore.sdk.RonException;
import dev.roncore.sdk.config.RonConfig;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

/**
 * RO:WHAT —
 *   Default {@link HttpClientAdapter} backed by OkHttp.
 *
 * RO:WHY —
 *   Provides a battle-tested HTTP client that works across JVM servers
 *   and Android, with connection pooling and timeouts.
 *
 * RO:INVARIANTS —
 *   - Uses timeouts from {@link RonConfig}.
 *   - Does not log or expose tokens.
 */
public final class OkHttpClientAdapter implements HttpClientAdapter {

    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");

    private final OkHttpClient client;

    public OkHttpClientAdapter(RonConfig config) {
        this.client = new OkHttpClient.Builder()
                .connectTimeout(config.getConnectTimeout())
                .readTimeout(config.getReadTimeout())
                .writeTimeout(config.getWriteTimeout())
                .build();
    }

    @Override
    public HttpResponse execute(HttpRequestContext requestContext) throws IOException {
        Request.Builder builder = new Request.Builder()
                .url(requestContext.getUrl());

        for (Map.Entry<String, String> header : requestContext.getHeaders().entrySet()) {
            builder.header(header.getKey(), header.getValue());
        }

        String method = requestContext.getMethod();
        String body = requestContext.getBody();

        if ("GET".equalsIgnoreCase(method) || "DELETE".equalsIgnoreCase(method)) {
            builder.method(method, null);
        } else {
            RequestBody requestBody = body == null
                    ? RequestBody.create(new byte[0], JSON)
                    : RequestBody.create(body, JSON);
            builder.method(method, requestBody);
        }

        try (Response response = client.newCall(builder.build()).execute()) {
            int statusCode = response.code();
            String responseBody = response.body() != null ? response.body().string() : null;

            Map<String, List<String>> headers = new HashMap<>();
            for (String name : response.headers().names()) {
                headers.put(name, new ArrayList<>(response.headers(name)));
            }

            return new HttpResponse(statusCode, responseBody, headers);
        } catch (IOException ex) {
            // Transport-level failure, mapped to RonException at a higher layer.
            throw ex;
        } catch (RuntimeException ex) {
            throw RonException.transportError("HTTP_CLIENT_ERROR", "HTTP client error", false, ex);
        }
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/internal/BackoffStrategy.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-internal-BackoffStrategy-java"></a>

```java
package dev.roncore.sdk.internal;

import java.time.Duration;
import java.util.concurrent.ThreadLocalRandom;

/**
 * RO:WHAT —
 *   Backoff strategy for retries (exponential with optional jitter).
 *
 * RO:WHY —
 *   Provides bounded, jittered delays to avoid thundering herds when
 *   multiple clients retry idempotent requests.
 */
public interface BackoffStrategy {

    /**
     * Returns the delay for the given 1-based attempt number.
     */
    Duration nextDelay(int attempt);

    static BackoffStrategy noBackoff() {
        return attempt -> Duration.ZERO;
    }

    /**
     * Exponential backoff with optional jitter.
     *
     * @param base   base delay (first attempt).
     * @param max    maximum delay cap.
     * @param jitter jitter fraction [0.0, 1.0]; 0.0 = no jitter, 1.0 = full jitter.
     */
    static BackoffStrategy exponential(Duration base, Duration max, double jitter) {
        final long baseMs = base.toMillis();
        final long maxMs = Math.max(1L, max.toMillis());
        final double j = Math.max(0.0, Math.min(1.0, jitter));

        return attempt -> {
            int a = Math.max(1, attempt);
            long exp = baseMs * (1L << Math.min(a - 1, 10)); // cap exponent growth
            long capped = Math.min(exp, maxMs);

            if (j == 0.0) {
                return Duration.ofMillis(capped);
            }

            long jitterRange = (long) (capped * j);
            long min = capped - jitterRange;
            long maxVal = capped + jitterRange;
            long chosen = ThreadLocalRandom.current().nextLong(min, maxVal + 1);
            if (chosen < 0) {
                chosen = 0;
            }
            return Duration.ofMillis(chosen);
        };
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/internal/JsonMapper.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-internal-JsonMapper-java"></a>

```java
package dev.roncore.sdk.internal;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import dev.roncore.sdk.AppResponse;
import dev.roncore.sdk.RonException;
import dev.roncore.sdk.RonProblem;
import dev.roncore.sdk.http.HttpResponse;

/**
 * RO:WHAT —
 *   Thin wrapper around Jackson for decoding RON envelopes.
 *
 * RO:WHY —
 *   Centralizes JSON mapping decisions (unknown fields, extra map, etc.)
 *   so they are consistent across the SDK.
 */
public final class JsonMapper {

    private final ObjectMapper mapper;

    public JsonMapper(ObjectMapper mapper) {
        this.mapper = mapper;
    }

    public JsonMapper() {
        this(new ObjectMapper());
    }

    public String toJson(Object value) {
        if (value == null) {
            return null;
        }
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException e) {
            throw RonException.decodeError("Failed to serialize request body", e);
        }
    }

    public <T> AppResponse<T> decodeAppResponse(HttpResponse httpResponse, Class<T> dataType) {
        int status = httpResponse.getStatusCode();
        String body = httpResponse.getBody();

        if (body == null || body.isBlank()) {
            return new AppResponse<>(null, null, status);
        }

        try {
            JsonNode root = mapper.readTree(body);

            RonProblem problem = null;
            if (root.hasNonNull("problem")) {
                problem = mapper.treeToValue(root.get("problem"), RonProblem.class);
            }

            T data = null;
            if (root.hasNonNull("data") && dataType != null && !dataType.equals(Void.class)) {
                JsonNode dataNode = root.get("data");
                data = mapper.treeToValue(dataNode, dataType);
            }

            return new AppResponse<>(data, problem, status);
        } catch (Exception e) {
            throw RonException.decodeError("Failed to decode response body", e);
        }
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/internal/ResponseSizeLimiter.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-internal-ResponseSizeLimiter-java"></a>

```java
package dev.roncore.sdk.internal;

import dev.roncore.sdk.RonException;

/**
 * RO:WHAT —
 *   Simple guard that enforces a maximum response size.
 *
 * RO:WHY —
 *   Reduces DoS risk when talking to misconfigured or hostile gateways.
 */
public final class ResponseSizeLimiter {

    private final long maxBytes;

    public ResponseSizeLimiter(long maxBytes) {
        this.maxBytes = maxBytes;
    }

    public void ensureWithinLimit(long actualBytes) {
        if (maxBytes <= 0) {
            return;
        }
        if (actualBytes > maxBytes) {
            throw RonException.transportError(
                    "RESPONSE_TOO_LARGE",
                    "Response exceeded configured size limit",
                    false,
                    null
            );
        }
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/main/java/dev/roncore/sdk/internal/RetryPolicy.java
<a id="sdk-ron-app-sdk-jvm-core-src-main-java-dev-roncore-sdk-internal-RetryPolicy-java"></a>

```java
package dev.roncore.sdk.internal;

import dev.roncore.sdk.RonException;

import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.Callable;

/**
 * RO:WHAT —
 *   Encapsulates retry behavior for idempotent requests.
 *
 * RO:WHY —
 *   Ensures all retries are bounded and obey SDK invariants about
 *   idempotency and backoff.
 */
public final class RetryPolicy {

    private final int maxRetries;
    private final BackoffStrategy backoff;

    public RetryPolicy(int maxRetries, BackoffStrategy backoff) {
        this.maxRetries = Math.max(0, maxRetries);
        this.backoff = Objects.requireNonNull(backoff, "backoff must not be null");
    }

    /**
     * SDK default: no retries.
     */
    public static RetryPolicy defaultPolicy() {
        return new RetryPolicy(0, BackoffStrategy.noBackoff());
    }

    /**
     * Factory for exponential backoff retry policy.
     */
    public static RetryPolicy exponentialBackoff(
            int maxRetries,
            Duration baseDelay,
            Duration maxDelay,
            double jitterFraction
    ) {
        return new RetryPolicy(maxRetries, BackoffStrategy.exponential(baseDelay, maxDelay, jitterFraction));
    }

    /**
     * Predicate used by tests and by execute(): should we retry this attempt?
     *
     * @param attempt     1-based attempt number
     * @param statusCode  HTTP status code (approximation; may be 503 for transport errors)
     * @param idempotent  whether the operation is idempotent (GET/HEAD)
     */
    public boolean shouldRetry(int attempt, int statusCode, boolean idempotent) {
        if (!idempotent) {
            return false;
        }
        if (attempt > maxRetries) {
            return false;
        }

        // Typical transient codes: 408, 429, 5xx
        if (statusCode == 408 || statusCode == 429) {
            return true;
        }
        return statusCode >= 500 && statusCode < 600;
    }

    /**
     * Execute a callable with retry behavior applied based on HTTP method.
     * This is what {@link dev.roncore.sdk.RonClient} uses.
     */
    public <T> T execute(String method, Callable<T> callable) {
        boolean idempotent = isIdempotent(method);
        int attempt = 0;

        while (true) {
            try {
                return callable.call();
            } catch (RonException ex) {
                // Already structured; if retryable and idempotent, fall through
                attempt++;
                if (!idempotent || !ex.isRetryable() || attempt > maxRetries) {
                    throw ex;
                }
                sleep(backoff.nextDelay(attempt));
            } catch (Exception ex) {
                // Transport / unexpected; approximate status as 503.
                attempt++;
                boolean canRetry = shouldRetry(attempt, 503, idempotent);
                if (!canRetry) {
                    throw RonException.transportError(
                            "TRANSPORT_ERROR",
                            "Transport error during request",
                            idempotent,
                            ex
                    );
                }
                sleep(backoff.nextDelay(attempt));
            }
        }
    }

    private static boolean isIdempotent(String method) {
        if (method == null) {
            return false;
        }
        String m = method.toUpperCase();
        return "GET".equals(m) || "HEAD".equals(m);
    }

    private static void sleep(Duration d) {
        long millis = d.toMillis();
        if (millis <= 0) {
            return;
        }
        try {
            Thread.sleep(millis);
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw RonException.transportError(
                    "RETRY_INTERRUPTED",
                    "Retry interrupted",
                    false,
                    ie
            );
        }
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/test/java/dev/roncore/sdk/ConfigEnvLoaderTest.java
<a id="sdk-ron-app-sdk-jvm-core-src-test-java-dev-roncore-sdk-ConfigEnvLoaderTest-java"></a>

```java
package dev.roncore.sdk;

import dev.roncore.sdk.config.EnvConfigLoader;
import dev.roncore.sdk.config.RonConfig;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Env config loader tests.
 *
 * RO:WHAT  — Verifies that EnvConfigLoader maps canonical env vars into RonConfig.
 * RO:WHY   — Mirrors TS SDK behavior: env vars provide sensible defaults but
 *            code options always win; ensures shared var names behave as expected.
 * RO:INTERACTS —
 *   - EnvConfigLoader
 *   - RonConfig.Builder
 * RO:INVARIANTS —
 *   - RON_SDK_GATEWAY_ADDR populates baseUrl when not set explicitly.
 *   - Timeout envs map to timeout fields.
 *   - Explicit builder values win over env defaults.
 */
public class ConfigEnvLoaderTest {

    @Test
    void envVarsPopulateConfigDefaults() {
        Map<String, String> env = new HashMap<>();
        env.put("RON_SDK_GATEWAY_ADDR", "https://node.env.example.com");
        env.put("RON_SDK_OVERALL_TIMEOUT_MS", "15000");
        env.put("RON_SDK_CONNECT_TIMEOUT_MS", "2000");
        env.put("RON_SDK_READ_TIMEOUT_MS", "4000");
        env.put("RON_SDK_WRITE_TIMEOUT_MS", "5000");

        RonConfig.Builder builder = RonConfig.builder();
        EnvConfigLoader.applyEnv(builder, env);

        RonConfig cfg = builder.build();

        assertEquals("https://node.env.example.com", cfg.getBaseUrl());
        assertEquals(15_000L, cfg.getOverallTimeoutMs());
        assertEquals(2_000L, cfg.getConnectTimeoutMs());
        assertEquals(4_000L, cfg.getReadTimeoutMs());
        assertEquals(5_000L, cfg.getWriteTimeoutMs());
    }

    @Test
    void explicitConfigOverridesEnvDefaults() {
        Map<String, String> env = new HashMap<>();
        env.put("RON_SDK_GATEWAY_ADDR", "https://node.env.example.com");

        RonConfig.Builder builder = RonConfig.builder()
                .baseUrl("https://node.code.example.com");

        EnvConfigLoader.applyEnv(builder, env);

        RonConfig cfg = builder.build();

        // Builder-provided value should win over env default.
        assertEquals("https://node.code.example.com", cfg.getBaseUrl());
    }

    @Test
    void missingEnvAndConfigShouldStillFailOnBuild() {
        RonConfig.Builder builder = RonConfig.builder();
        // No env, no baseUrl
        EnvConfigLoader.applyEnv(builder, new HashMap<>());

        RuntimeException ex = assertThrows(
                RuntimeException.class,
                builder::build,
                "Building config without baseUrl should fail even after env load"
        );

        String msg = ex.getMessage() == null ? "" : ex.getMessage().toLowerCase();
        assertTrue(
                msg.contains("baseurl") || msg.contains("base url"),
                "Error message should hint at missing baseUrl; got: " + ex.getMessage()
        );
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/test/java/dev/roncore/sdk/ErrorParsingTest.java
<a id="sdk-ron-app-sdk-jvm-core-src-test-java-dev-roncore-sdk-ErrorParsingTest-java"></a>

```java
package dev.roncore.sdk;

import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for the canonical error / response envelope types.
 *
 * RO:WHAT  — Validates AppResponse<T> and RonProblem wiring.
 * RO:WHY   — RON-CORE uses a canonical error envelope; the JVM SDK must
 *            reflect that shape faithfully for both languages.
 * RO:INTERACTS —
 *   - AppResponse<T>
 *   - RonProblem
 * RO:INVARIANTS —
 *   - Successful responses expose data + ok=true, problem=null.
 *   - Error responses expose problem + ok=false, data=null (for most cases).
 */
public class ErrorParsingTest {

    @Test
    void appResponseOkShouldExposeDataAndMarkOk() {
        AppResponse<String> response = AppResponse.ok("hello", 200);

        assertTrue(response.ok(), "ok() should be true for successful responses");
        assertEquals(200, response.getStatus());
        assertEquals("hello", response.getData());
        assertNull(response.getProblem(), "problem should be null on success");
    }

    @Test
    void appResponseErrorShouldExposeProblemAndMarkNotOk() {
        Map<String, Object> details = new HashMap<>();
        details.put("hint", "check token");

        RonProblem problem = new RonProblem(
                "AUTH_UNAUTHORIZED",
                "Unauthorized",
                "auth",
                "corr-123",
                details
        );

        AppResponse<Void> response = AppResponse.error(problem, 401);

        assertFalse(response.ok(), "ok() should be false when problem is present");
        assertEquals(401, response.getStatus());
        assertNull(response.getData(), "data should be null on error AppResponse");
        assertNotNull(response.getProblem(), "problem should not be null on error AppResponse");
        assertEquals("AUTH_UNAUTHORIZED", response.getProblem().getCode());
        assertEquals("auth", response.getProblem().getKind());
        assertEquals("corr-123", response.getProblem().getCorrelationId());
        assertEquals("check token", response.getProblem().getDetails().get("hint"));
    }

    @Test
    void ronProblemShouldBeImmutableAndDefensive() {
        Map<String, Object> details = new HashMap<>();
        details.put("foo", "bar");

        RonProblem problem = new RonProblem(
                "RATE_LIMITED",
                "Too many requests",
                "rate_limit",
                "corr-xyz",
                details
        );

        // Mutate original map — problem should not see this if it is defensive.
        details.put("foo", "baz");

        Map<String, Object> fromProblem = problem.getDetails();
        assertEquals("bar", fromProblem.get("foo"), "RonProblem should defensively copy details");

        // Ensure unmodifiable / safe to pass around
        assertThrows(UnsupportedOperationException.class, () -> {
            fromProblem.put("new", "value");
        }, "Details map should be unmodifiable");
    }

    @Test
    void appResponseStaticFactoryForEmptyErrorIsConvenient() {
        RonProblem problem = new RonProblem(
                "APP_ERROR",
                "Something bad happened",
                "app",
                null,
                Collections.emptyMap()
        );

        AppResponse<String> response = AppResponse.error(problem, 500);
        assertFalse(response.ok());
        assertEquals("APP_ERROR", response.getProblem().getCode());
        assertEquals(500, response.getStatus());
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/test/java/dev/roncore/sdk/RetryPolicyTest.java
<a id="sdk-ron-app-sdk-jvm-core-src-test-java-dev-roncore-sdk-RetryPolicyTest-java"></a>

```java
package dev.roncore.sdk;

import dev.roncore.sdk.internal.BackoffStrategy;
import dev.roncore.sdk.internal.RetryPolicy;
import org.junit.jupiter.api.Test;

import java.time.Duration;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Retry/backoff policy tests.
 *
 * RO:WHAT  — Tests for bounded retry behavior and exponential backoff.
 * RO:WHY   — Ensures we never spin infinite loops and that retries obey
 *            SDK_SECURITY / SDK_IDB invariants for bounded retries + jitter.
 * RO:INTERACTS —
 *   - RetryPolicy
 *   - BackoffStrategy
 * RO:INVARIANTS —
 *   - Non-idempotent requests do not retry by default.
 *   - Idempotent requests use bounded retries (maxRetries).
 *   - Backoff delays grow and are capped.
 */
public class RetryPolicyTest {

    @Test
    void nonIdempotentRequestsDoNotRetryByDefault() {
        RetryPolicy policy = RetryPolicy.defaultPolicy();

        // attempt is 1-based; simulate POST/DELETE (non-idempotent)
        boolean shouldRetry = policy.shouldRetry(
                1,
                500,      // server error
                false     // idempotent=false
        );

        assertFalse(shouldRetry, "Non-idempotent operations should not retry by default");
    }

    @Test
    void idempotentRequestsRetryUpToMaxRetries() {
        int maxRetries = 3;
        RetryPolicy policy = RetryPolicy.exponentialBackoff(
                maxRetries,
                Duration.ofMillis(100),
                Duration.ofSeconds(5),
                0.2 // jitter
        );

        // For an idempotent GET on transient errors, we should retry up to maxRetries
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            boolean shouldRetry = policy.shouldRetry(
                    attempt,
                    503,      // typical transient status
                    true      // idempotent=true
            );
            assertTrue(shouldRetry, "Should retry attempt " + attempt + " for transient idempotent request");
        }

        // Once we've hit maxRetries, the next attempt must not retry.
        boolean shouldRetryAfterMax = policy.shouldRetry(
                maxRetries + 1,
                503,
                true
        );
        assertFalse(shouldRetryAfterMax, "Should not retry after maxRetries has been reached");
    }

    @Test
    void backoffDelaysGrowAndAreCapped() {
        int maxRetries = 5;
        Duration base = Duration.ofMillis(100);
        Duration max = Duration.ofSeconds(2);

        BackoffStrategy strategy = BackoffStrategy.exponential(base, max, 0.0); // no jitter for deterministic test

        Duration d1 = strategy.nextDelay(1);
        Duration d2 = strategy.nextDelay(2);
        Duration d3 = strategy.nextDelay(3);
        // Use attempt number well beyond maxRetries to ensure we hit the cap.
        Duration dFar = strategy.nextDelay(maxRetries + 10);

        assertTrue(d2.compareTo(d1) > 0, "Second delay should be greater than first");
        assertTrue(d3.compareTo(d2) > 0, "Third delay should be greater than second");
        assertTrue(dFar.compareTo(max) <= 0, "Delay should be capped at max");
    }
}

```

### sdk/ron-app-sdk-jvm/core/src/test/java/dev/roncore/sdk/RonClientBasicTest.java
<a id="sdk-ron-app-sdk-jvm-core-src-test-java-dev-roncore-sdk-RonClientBasicTest-java"></a>

```java
package dev.roncore.sdk;

import dev.roncore.sdk.config.RonConfig;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Basic construction / config sanity tests for RonClient.
 *
 * RO:WHAT  — Smoke tests for the public RonClient + RonConfig builder.
 * RO:WHY   — Catch obvious misconfiguration (missing baseUrl, invalid URL)
 *            and ensure the “happy path” builder round-trip works.
 * RO:INTERACTS —
 *   - RonClient (core entry point)
 *   - RonConfig (config DTO / builder)
 * RO:INVARIANTS —
 *   - Missing baseUrl should fail fast (CONFIG_MISSING_BASE_URL).
 *   - Well-formed HTTPS baseUrl should build without error.
 */
public class RonClientBasicTest {

    @Test
    void buildWithoutBaseUrlShouldFailFast() {
        RuntimeException ex = assertThrows(
                RuntimeException.class,
                () -> RonClient.builder().build(),
                "Building a client without baseUrl should fail fast"
        );

        // We do not hard-code the exact exception type yet, only that it is
        // a runtime failure and the message hints about baseUrl / config.
        String msg = ex.getMessage() == null ? "" : ex.getMessage().toLowerCase();
        assertTrue(
                msg.contains("baseurl") || msg.contains("base url") || msg.contains("config"),
                "Error message should mention baseUrl or config; got: " + ex.getMessage()
        );
    }

    @Test
    void buildWithHttpsBaseUrlShouldSucceed() {
        RonClient client = RonClient.builder()
                .baseUrl("https://node.example.com")
                .build();

        assertNotNull(client, "RonClient should be created when baseUrl is provided");
    }

    @Test
    void configBuilderRoundTripKeepsValues() {
        RonConfig config = RonConfig.builder()
                .baseUrl("https://node.example.com")
                .overallTimeoutMs(10_000L)
                .connectTimeoutMs(2_000L)
                .readTimeoutMs(5_000L)
                .writeTimeoutMs(5_000L)
                .allowInsecureHttp(false)
                .build();

        assertEquals("https://node.example.com", config.getBaseUrl());
        assertEquals(10_000L, config.getOverallTimeoutMs());
        assertEquals(2_000L, config.getConnectTimeoutMs());
        assertEquals(5_000L, config.getReadTimeoutMs());
        assertEquals(5_000L, config.getWriteTimeoutMs());
        assertFalse(config.isAllowInsecureHttp(), "HTTPS should be the default / recommended path");
    }
}

```

### sdk/ron-app-sdk-jvm/docs/arch.mmd
<a id="sdk-ron-app-sdk-jvm-docs-arch-mmd"></a>

```mermaid

```

### sdk/ron-app-sdk-jvm/docs/sequence.mmd
<a id="sdk-ron-app-sdk-jvm-docs-sequence-mmd"></a>

```mermaid

```

### sdk/ron-app-sdk-jvm/docs/state.mmd
<a id="sdk-ron-app-sdk-jvm-docs-state-mmd"></a>

```mermaid

```

### sdk/ron-app-sdk-jvm/examples/android-sample/build.gradle.kts
<a id="sdk-ron-app-sdk-jvm-examples-android-sample-build-gradle-kts"></a>

```kotlin
plugins {
    id("com.android.application")
}

android {
    namespace = "dev.roncore.sdk.examples.android"
    compileSdk = 34

    defaultConfig {
        applicationId = "dev.roncore.sdk.examples.android"
        minSdk = 26
        targetSdk = 34
        versionCode = 1
        versionName = "0.1.0-dev"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"

        buildConfigField(
            "String",
            "RON_SDK_GATEWAY_ADDR",
            "\"http://10.0.2.2:8090\""
        )
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
        debug {
            applicationIdSuffix = ".debug"
            versionNameSuffix = "-debug"
        }
    }

    buildFeatures {
        buildConfig = true
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
}

dependencies {
    implementation(project(":core"))

    implementation("androidx.core:core-ktx:1.13.1")
    implementation("androidx.appcompat:appcompat:1.7.0")
    implementation("com.google.android.material:material:1.12.0")

    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.2.1")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.6.1")
}

```

### sdk/ron-app-sdk-jvm/examples/android-sample/src/main/AndroidManifest.xml
<a id="sdk-ron-app-sdk-jvm-examples-android-sample-src-main-AndroidManifest-xml"></a>

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:name=".RonApp"
        android:allowBackup="true"
        android:label="RON Android Sample"
        android:icon="@android:drawable/ic_dialog_info"
        android:supportsRtl="true"
        android:theme="@style/Theme.MaterialComponents.DayNight.DarkActionBar">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

    </application>
</manifest>

```

### sdk/ron-app-sdk-jvm/examples/android-sample/src/main/java/dev/roncore/sdk/examples/android/HelloViewModel.kt
<a id="sdk-ron-app-sdk-jvm-examples-android-sample-src-main-java-dev-roncore-sdk-examples-android-HelloViewModel-kt"></a>

```kotlin
package dev.roncore.sdk.examples.android;

import dev.roncore.sdk.AppResponse;
import dev.roncore.sdk.RonClient;
import dev.roncore.sdk.RonProblem;

public class HelloViewModel {

    private final RonClient ronClient;

    public HelloViewModel(RonClient ronClient) {
        this.ronClient = ronClient;
    }

    public String load() {
        try {
            AppResponse<String> response = ronClient.get("/ping", String.class);

            if (response.ok()) {
                String data = response.getData();
                return data != null ? data : "ok";
            } else {
                RonProblem problem = response.getProblem();
                return "Error from RON: " + (problem != null ? problem.toString() : "unknown");
            }
        } catch (Exception ex) {
            String message = ex.getMessage();
            return "Exception: " + (message != null ? message : "unknown");
        }
    }
}

```

### sdk/ron-app-sdk-jvm/examples/android-sample/src/main/java/dev/roncore/sdk/examples/android/MainActivity.kt
<a id="sdk-ron-app-sdk-jvm-examples-android-sample-src-main-java-dev-roncore-sdk-examples-android-MainActivity-kt"></a>

```kotlin
package dev.roncore.sdk.examples.android;

import android.os.Bundle;
import android.widget.Button;
import android.widget.TextView;

import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {

    private HelloViewModel viewModel;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        RonApp app = (RonApp) getApplication();
        viewModel = new HelloViewModel(app.getRonClient());

        TextView textView = findViewById(R.id.helloText);
        Button button = findViewById(R.id.pingButton);

        textView.setText("Tap the button to ping RON…");

        button.setOnClickListener(v -> {
            textView.setText("Pinging RON…");

            new Thread(() -> {
                String result = viewModel.load();
                runOnUiThread(() -> textView.setText(result));
            }).start();
        });
    }
}

```

### sdk/ron-app-sdk-jvm/examples/android-sample/src/main/java/dev/roncore/sdk/examples/android/RonApp.kt
<a id="sdk-ron-app-sdk-jvm-examples-android-sample-src-main-java-dev-roncore-sdk-examples-android-RonApp-kt"></a>

```kotlin
package dev.roncore.sdk.examples.android;

import android.app.Application;
import android.util.Log;

import dev.roncore.sdk.RonClient;
import dev.roncore.sdk.RonException;

public class RonApp extends Application {

    private RonClient ronClient;

    public RonClient getRonClient() {
        return ronClient;
    }

    @Override
    public void onCreate() {
        super.onCreate();

        String baseUrl = BuildConfig.RON_SDK_GATEWAY_ADDR;
        Log.i("RonApp", "RON Android sample starting; base URL = " + baseUrl);

        try {
            ronClient = RonClient.builder()
                    .baseUrl(baseUrl)
                    .build();
        } catch (RonException ex) {
            Log.e("RonApp", "Failed to build RonClient", ex);
            throw new RuntimeException("Failed to initialize RonClient", ex);
        }
    }
}

```

### sdk/ron-app-sdk-jvm/examples/android-sample/src/main/res/layout/activity_main.xml
<a id="sdk-ron-app-sdk-jvm-examples-android-sample-src-main-res-layout-activitymain-xml"></a>

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="24dp">

    <TextView
        android:id="@+id/helloText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Tap the button to ping RON…"
        android:textSize="18sp" />

    <Button
        android:id="@+id/pingButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Ping RON"
        android:layout_marginTop="16dp" />

</LinearLayout>

```

### sdk/ron-app-sdk-jvm/examples/java-cli/build.gradle.kts
<a id="sdk-ron-app-sdk-jvm-examples-java-cli-build-gradle-kts"></a>

```kotlin
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    `java`
    application
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

dependencies {
    implementation(project(":core"))

    testImplementation(libs.junit.jupiter)
}

tasks.test {
    useJUnitPlatform()

    testLogging {
        events = setOf(TestLogEvent.PASSED, TestLogEvent.SKIPPED, TestLogEvent.FAILED)
    }
}

application {
    // Matches the package + class below.
    mainClass.set("dev.roncore.sdk.examples.java.HelloCli")
}

```

### sdk/ron-app-sdk-jvm/examples/java-cli/src/main/java/dev/roncore/sdk/examples/HelloCli.java
<a id="sdk-ron-app-sdk-jvm-examples-java-cli-src-main-java-dev-roncore-sdk-examples-HelloCli-java"></a>

```java
package dev.roncore.sdk.examples.java;

import dev.roncore.sdk.AppResponse;
import dev.roncore.sdk.RonClient;
import dev.roncore.sdk.RonException;

import java.util.Map;

/**
 * RO:WHAT —
 *   Minimal Java CLI example for the RON-CORE JVM SDK.
 *
 * RO:WHY —
 *   Give Java developers a zero-friction way to:
 *     * configure via env vars, and
 *     * hit a simple /app/ping endpoint on a Micronode or Macronode.
 *
 * RO:INTERACTS —
 *   - RonClient (core HTTP client)
 *   - EnvConfigLoader (via RonClient.Builder.fromEnv())
 *   - JSON mapper (Jackson-based, via AppResponse<Map<String, Object>>)
 *
 * RO:INVARIANTS —
 *   - Requires RON_SDK_GATEWAY_ADDR to be set (e.g. "http://127.0.0.1:5304").
 *   - Uses /ping path which the SDK normalizes to /app/ping.
 *   - Respects RON_SDK_INSECURE_HTTP for local HTTP development.
 */
public final class HelloCli {

    private HelloCli() {
        // static-only
    }

    public static void main(String[] args) {
        System.out.println("=== RON-CORE JVM SDK — Hello CLI ===");
        System.out.println();

        String baseUrl = System.getenv("RON_SDK_GATEWAY_ADDR");
        if (baseUrl == null || baseUrl.isBlank()) {
            System.err.println("ERROR: RON_SDK_GATEWAY_ADDR is not set.");
            System.err.println();
            System.err.println("Set it to your Micronode/Macronode gateway URL, for example:");
            System.err.println("  RON_SDK_GATEWAY_ADDR=http://127.0.0.1:5304");
            System.err.println("  RON_SDK_INSECURE_HTTP=1   # if using HTTP instead of HTTPS");
            System.exit(1);
        }

        System.out.println("Using RON_SDK_GATEWAY_ADDR = " + baseUrl);
        String insecureFlag = System.getenv("RON_SDK_INSECURE_HTTP");
        if (insecureFlag != null) {
            System.out.println("RON_SDK_INSECURE_HTTP       = " + insecureFlag);
        }
        System.out.println();

        RonClient client;
        try {
            // Builder.fromEnv() pulls all RON_SDK_* env vars, including gateway + timeouts.
            client = RonClient.builder()
                    .fromEnv()
                    .build();
        } catch (RonException ex) {
            System.err.println("Failed to build RonClient from env:");
            ex.printStackTrace(System.err);
            System.exit(2);
            return; // unreachable, but keeps compiler happy
        }

        try {
            // The SDK will normalize "/ping" → "/app/ping" against the configured base URL.
            AppResponse<Map> response = client.get("/ping", Map.class);

            System.out.println("HTTP status: " + response.getStatus());
            if (response.ok()) {
                System.out.println("--- OK envelope ---");
                Map<?, ?> body = response.getData();
                if (body != null) {
                    System.out.println(body);
                } else {
                    System.out.println("(no data payload)");
                }
            } else {
                System.out.println("--- Problem envelope ---");
                System.out.println(response.getProblem());
            }
        } catch (RonException ex) {
            System.err.println("RON-CORE call failed with RonException:");
            ex.printStackTrace(System.err);
            System.exit(3);
        } catch (Exception ex) {
            System.err.println("Unexpected error while calling RON-CORE:");
            ex.printStackTrace(System.err);
            System.exit(4);
        }
    }
}

```

### sdk/ron-app-sdk-jvm/examples/kotlin-ktor/build.gradle.kts
<a id="sdk-ron-app-sdk-jvm-examples-kotlin-ktor-build-gradle-kts"></a>

```kotlin
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    id("org.jetbrains.kotlin.jvm")
    application
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

dependencies {
    implementation(project(":core"))

    // Ktor server (Netty engine + JSON via Jackson)
    implementation("io.ktor:ktor-server-core-jvm:2.3.13")
    implementation("io.ktor:ktor-server-netty-jvm:2.3.13")
    implementation("io.ktor:ktor-server-content-negotiation-jvm:2.3.13")
    implementation("io.ktor:ktor-serialization-jackson-jvm:2.3.13")
    implementation("io.ktor:ktor-server-call-logging-jvm:2.3.13")

    // Reuse SDK’s Jackson + coroutines from the version catalog
    implementation(libs.jackson.core)
    implementation(libs.jackson.databind)
    implementation(libs.jackson.annotations)
    implementation(libs.kotlin.coroutines.core)

    testImplementation(libs.junit.jupiter)
}

application {
    // Top-level main() in KtorApp.kt
    mainClass.set("dev.roncore.sdk.examples.ktor.KtorAppKt")
}

tasks.test {
    useJUnitPlatform()

    testLogging {
        events = setOf(
            TestLogEvent.PASSED,
            TestLogEvent.SKIPPED,
            TestLogEvent.FAILED
        )
    }
}

```

### sdk/ron-app-sdk-jvm/examples/kotlin-ktor/src/main/kotlin/dev/roncore/sdk/examples/ktor/KtorApp.kt
<a id="sdk-ron-app-sdk-jvm-examples-kotlin-ktor-src-main-kotlin-dev-roncore-sdk-examples-ktor-KtorApp-kt"></a>

```kotlin
package dev.roncore.sdk.examples.ktor

import dev.roncore.sdk.RonClient
import dev.roncore.sdk.RonException
import io.ktor.serialization.jackson.jackson
import io.ktor.server.application.Application
import io.ktor.server.application.install
import io.ktor.server.engine.embeddedServer
import io.ktor.server.netty.Netty
import io.ktor.server.plugins.callloging.CallLogging
import io.ktor.server.plugins.contentnegotiation.ContentNegotiation
import io.ktor.server.routing.routing
import org.slf4j.LoggerFactory

fun main() {
    val port = System.getenv("RON_EXAMPLE_KTOR_PORT")?.toIntOrNull() ?: 8080

    embeddedServer(
        Netty,
        port = port,
        host = "0.0.0.0"
    ) {
        ronExampleModule()
    }.start(wait = true)
}

fun Application.ronExampleModule() {
    val logger = LoggerFactory.getLogger("ron-example-ktor")

    install(CallLogging)

    install(ContentNegotiation) {
        jackson {
            findAndRegisterModules()
        }
    }

    val ronClient: RonClient? = try {
        RonClient.builder()
            .fromEnv() // Uses RON_SDK_GATEWAY_ADDR, RON_SDK_INSECURE_HTTP, etc.
            .build()
    } catch (ex: RonException) {
        logger.error("Failed to create RonClient from env; /ron/* routes will return 500", ex)
        null
    }

    routing {
        healthRoutes()
        ronRoutes(ronClient)
    }

    logger.info("Ktor example started on /healthz and /ron/ping")
}

```

### sdk/ron-app-sdk-jvm/examples/kotlin-ktor/src/main/kotlin/dev/roncore/sdk/examples/ktor/Routes.kt
<a id="sdk-ron-app-sdk-jvm-examples-kotlin-ktor-src-main-kotlin-dev-roncore-sdk-examples-ktor-Routes-kt"></a>

```kotlin
package dev.roncore.sdk.examples.ktor

import dev.roncore.sdk.AppResponse
import dev.roncore.sdk.RonClient
import dev.roncore.sdk.RonException
import dev.roncore.sdk.RonProblem
import io.ktor.http.HttpStatusCode
import io.ktor.server.application.call
import io.ktor.server.response.respond
import io.ktor.server.response.respondText
import io.ktor.server.routing.Route
import io.ktor.server.routing.get
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

fun Route.healthRoutes() {
    get("/healthz") {
        call.respondText("ok")
    }
}

fun Route.ronRoutes(ronClient: RonClient?) {
    get("/ron/ping") {
        if (ronClient == null) {
            call.respond(
                HttpStatusCode.InternalServerError,
                mapOf(
                    "ok" to false,
                    "error" to "RonClient not configured; check RON_SDK_GATEWAY_ADDR / env."
                )
            )
            return@get
        }

        val response: AppResponse<*> = try {
            withContext(Dispatchers.IO) {
                @Suppress("UNCHECKED_CAST")
                ronClient.get("/ping", Map::class.java as Class<Map<String, Any>>)
            }
        } catch (ex: RonException) {
            call.respond(
                HttpStatusCode.BadGateway,
                mapOf(
                    "ok" to false,
                    "kind" to ex.kind,
                    "code" to ex.code,
                    "message" to (ex.message ?: "RON-CORE call failed"),
                    "retryable" to ex.isRetryable,
                    "details" to ex.details
                )
            )
            return@get
        }

        if (response.ok()) {
            @Suppress("UNCHECKED_CAST")
            val data = (response.data as? Map<String, Any>) ?: emptyMap<String, Any>()

            call.respond(
                HttpStatusCode.OK,
                mapOf(
                    "ok" to true,
                    "status" to response.status,
                    "data" to data
                )
            )
        } else {
            val problem: RonProblem? = response.problem

            call.respond(
                HttpStatusCode.fromValue(response.status),
                mapOf(
                    "ok" to false,
                    "status" to response.status,
                    "problem" to problem
                )
            )
        }
    }
}

```

### sdk/ron-app-sdk-jvm/examples/spring-boot/build.gradle.kts
<a id="sdk-ron-app-sdk-jvm-examples-spring-boot-build-gradle-kts"></a>

```kotlin
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    id("org.springframework.boot") version "3.3.5"
    id("io.spring.dependency-management") version "1.1.5"
    java
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

dependencies {
    implementation(project(":core"))

    implementation("org.springframework.boot:spring-boot-starter-web")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

tasks.test {
    useJUnitPlatform()

    testLogging {
        events = setOf(TestLogEvent.PASSED, TestLogEvent.SKIPPED, TestLogEvent.FAILED)
    }
}

// Our main class lives in package dev.roncore.sdk.examples.spring
springBoot {
    mainClass.set("dev.roncore.sdk.examples.spring.Application")
}

```

### sdk/ron-app-sdk-jvm/examples/spring-boot/src/main/java/dev/roncore/sdk/examples/spring/Application.java
<a id="sdk-ron-app-sdk-jvm-examples-spring-boot-src-main-java-dev-roncore-sdk-examples-spring-Application-java"></a>

```java
package dev.roncore.sdk.examples.spring;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * RO:WHAT —
 *   Minimal Spring Boot application showcasing the RON-CORE JVM SDK.
 *
 * RO:WHY —
 *   Gives Spring / enterprise devs a copy-paste starting point for
 *   wiring RonClient into a standard Boot app.
 */
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

```

### sdk/ron-app-sdk-jvm/examples/spring-boot/src/main/java/dev/roncore/sdk/examples/spring/HelloController.java
<a id="sdk-ron-app-sdk-jvm-examples-spring-boot-src-main-java-dev-roncore-sdk-examples-spring-HelloController-java"></a>

```java
package dev.roncore.sdk.examples.spring;

import dev.roncore.sdk.AppResponse;
import dev.roncore.sdk.RonClient;
import dev.roncore.sdk.RonException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

/**
 * RO:WHAT —
 *   Simple controller that proxies a /ron/ping HTTP GET to RON-CORE.
 *
 * RO:WHY —
 *   Shows how to consume RonClient from a Spring REST controller
 *   and surface either OK data or a problem envelope.
 *
 * RO:INVARIANTS —
 *   - Uses RonClient configured via RonSdkConfig (RON_SDK_* env vars).
 *   - Returns 200 with data on success.
 *   - Returns 502 with a descriptive message on failure.
 */
@RestController
public class HelloController {

    private static final Logger log = LoggerFactory.getLogger(HelloController.class);

    private final RonClient client;

    public HelloController(RonClient client) {
        this.client = client;
    }

    @GetMapping("/ron/ping")
    public ResponseEntity<?> ping() {
        try {
            // The SDK normalizes "/ping" -> "/app/ping" on the gateway.
            AppResponse<Map> response = client.get("/ping", Map.class);

            log.info("RON-CORE /ping status={} ok={}", response.getStatus(), response.ok());

            if (response.ok()) {
                Map<?, ?> body = response.getData();
                return ResponseEntity.ok(body != null ? body : Map.of("note", "no data payload"));
            } else {
                // Bubble up the problem as a 502 for demo purposes.
                return ResponseEntity
                    .status(HttpStatus.BAD_GATEWAY)
                    .body(Map.of(
                        "error", "RON-CORE returned a problem envelope",
                        "status", response.getStatus(),
                        "problem", String.valueOf(response.getProblem())
                    ));
            }
        } catch (RonException ex) {
            log.warn("RON-CORE call failed with RonException", ex);
            return ResponseEntity
                .status(HttpStatus.BAD_GATEWAY)
                .body(Map.of(
                    "error", "RON-CORE call failed",
                    "type", ex.getClass().getSimpleName(),
                    "message", String.valueOf(ex.getMessage())
                ));
        } catch (Exception ex) {
            log.error("Unexpected error while calling RON-CORE", ex);
            return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of(
                    "error", "Unexpected error",
                    "type", ex.getClass().getSimpleName(),
                    "message", String.valueOf(ex.getMessage())
                ));
        }
    }
}

```

### sdk/ron-app-sdk-jvm/examples/spring-boot/src/main/java/dev/roncore/sdk/examples/spring/RonSdkConfig.java
<a id="sdk-ron-app-sdk-jvm-examples-spring-boot-src-main-java-dev-roncore-sdk-examples-spring-RonSdkConfig-java"></a>

```java
package dev.roncore.sdk.examples.spring;

import dev.roncore.sdk.RonClient;
import dev.roncore.sdk.RonException;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * RO:WHAT —
 *   Spring Boot configuration that exposes a singleton RonClient bean.
 *
 * RO:WHY —
 *   Centralizes env-based config (RON_SDK_* vars) and makes it easy
 *   to inject RonClient into controllers and services.
 *
 * RO:INVARIANTS —
 *   - Reads RON_SDK_GATEWAY_ADDR and friends via EnvConfigLoader
 *     (RonClient.Builder.fromEnv()).
 *   - Fails fast on startup if the SDK config is invalid.
 */
@Configuration
public class RonSdkConfig {

    @Bean
    public RonClient ronClient() {
        try {
            return RonClient.builder()
                .fromEnv()
                .build();
        } catch (RonException ex) {
            throw new IllegalStateException("Failed to configure RonClient from env", ex);
        }
    }
}

```

### sdk/ron-app-sdk-jvm/facets/build.gradle.kts
<a id="sdk-ron-app-sdk-jvm-facets-build-gradle-kts"></a>

```kotlin
plugins {
    id("org.jetbrains.kotlin.jvm")
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

dependencies {
    // Facets are intentionally lightweight: no core/HTTP deps.
    testImplementation(libs.junit.jupiter)
}

tasks.test {
    useJUnitPlatform()
}

```

### sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetDefinition.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetDefinition-kt"></a>

```kotlin
package dev.roncore.sdk.facets

/**
 * RO:WHAT —
 *   In-memory representation of a single facet manifest.
 *
 * RO:WHY —
 *   JVM apps can define facets using typed builders, then render them
 *   to TOML via [FacetTomlWriter].
 *
 * RO:INVARIANTS —
 *   - `id` MUST be non-blank.
 *   - `routes` MUST be non-empty.
 *   - Additional invariants are enforced by [FacetTomlWriter].
 */
data class FacetDefinition(
    val id: String,
    val kind: FacetKind = FacetKind.STATIC,
    val security: FacetSecurity? = null,
    val meta: FacetMeta? = null,
    val limits: FacetLimits? = null,
    val routes: List<RouteDefinition> = emptyList()
)

```

### sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetKind.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetKind-kt"></a>

```kotlin
package dev.roncore.sdk.facets

/**
 * RO:WHAT —
 *   Enumerates supported facet kinds.
 *
 * RO:WHY —
 *   Keeps JVM facet builders aligned with the canonical facet schema
 *   (static docs, echo/test facets, and future proxy facets).
 *
 * RO:INVARIANTS —
 *   - `wire()` returns the lower-case string used in TOML.
 *   - `fromWire` is case-insensitive and throws on unknown values.
 */
enum class FacetKind(
    private val wireValue: String
) {
    STATIC("static"),
    ECHO("echo"),
    PROXY("proxy");

    /**
     * Wire-format value used in TOML (`kind = "static"`).
     */
    fun wire(): String = wireValue

    companion object {
        /**
         * Resolve a facet kind from its wire-format string.
         */
        fun fromWire(value: String): FacetKind =
            entries.firstOrNull { it.wireValue.equals(value, ignoreCase = true) }
                ?: throw IllegalArgumentException("Unknown facet kind: $value")
    }
}

```

### sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetLimits.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetLimits-kt"></a>

```kotlin
package dev.roncore.sdk.facets

/**
 * RO:WHAT —
 *   Rate and concurrency hints for a facet.
 *
 * RO:WHY —
 *   Maps to `[facet.limits]` in TOML; Micronode can use these fields
 *   to enforce fair use and protect itself from overloads.
 *
 * RO:INVARIANTS —
 *   - Nulls are omitted.
 *   - If both fields are null, [facet.limits] is omitted.
 */
data class FacetLimits(
    val maxRps: Int? = null,
    val maxConcurrency: Int? = null
)

```

### sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetMeta.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetMeta-kt"></a>

```kotlin
package dev.roncore.sdk.facets

/**
 * RO:WHAT —
 *   Optional descriptive metadata for a facet.
 *
 * RO:WHY —
 *   Provides human-friendly context for operators and tools:
 *   description, owner, and version.
 *
 * RO:INVARIANTS —
 *   - Null fields are omitted from TOML.
 *   - If all fields are null, [facet.meta] is omitted.
 */
data class FacetMeta(
    val description: String? = null,
    val owner: String? = null,
    val version: String? = null
)

```

### sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetSecurity.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetSecurity-kt"></a>

```kotlin
package dev.roncore.sdk.facets

/**
 * RO:WHAT —
 *   Security hints for a facet: whether it is public and/or requires auth.
 *
 * RO:WHY —
 *   Maps directly to `[facet.security]` in the facet manifest TOML.
 *
 * RO:INVARIANTS —
 *   - Null values are treated as "unspecified" and omitted from TOML.
 *   - When both flags are null, the [facet.security] table is omitted.
 */
data class FacetSecurity(
    val public: Boolean? = null,
    val requiresAuth: Boolean? = null
)

```

### sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/FacetTomlWriter.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-FacetTomlWriter-kt"></a>

```kotlin
package dev.roncore.sdk.facets

/**
 * RO:WHAT —
 *   Serializes [FacetDefinition] into canonical facet TOML.
 *
 * RO:WHY —
 *   Gives JVM callers a safe, typed way to produce manifests
 *   that Micronode can ingest without hand-writing TOML.
 *
 * RO:INVARIANTS —
 *   - Enforces basic schema rules (id non-blank, absolute paths).
 *   - Static facets require `file` on each route.
 *   - Optional sections (security/meta/limits) are omitted when empty.
 */
object FacetTomlWriter {

    /**
     * Render a facet definition as TOML.
     */
    fun write(facet: FacetDefinition): String {
        validate(facet)

        val sb = StringBuilder()

        // [facet]
        sb.appendLine("[facet]")
        sb.appendLine("""id = "${escape(facet.id)}"""")
        sb.appendLine("""kind = "${facet.kind.wire()}"""")
        sb.appendLine()

        // [facet.security]
        facet.security?.let { sec ->
            if (sec.public != null || sec.requiresAuth != null) {
                sb.appendLine("[facet.security]")
                sec.public?.let { sb.appendLine("public = $it") }
                sec.requiresAuth?.let { sb.appendLine("requires_auth = $it") }
                sb.appendLine()
            }
        }

        // [facet.meta]
        facet.meta?.let { meta ->
            if (!meta.description.isNullOrBlank() ||
                !meta.owner.isNullOrBlank() ||
                !meta.version.isNullOrBlank()
            ) {
                sb.appendLine("[facet.meta]")
                meta.description?.let { sb.appendLine("""description = "${escape(it)}"""") }
                meta.owner?.let { sb.appendLine("""owner = "${escape(it)}"""") }
                meta.version?.let { sb.appendLine("""version = "${escape(it)}"""") }
                sb.appendLine()
            }
        }

        // [facet.limits]
        facet.limits?.let { limits ->
            if (limits.maxRps != null || limits.maxConcurrency != null) {
                sb.appendLine("[facet.limits]")
                limits.maxRps?.let { sb.appendLine("max_rps = $it") }
                limits.maxConcurrency?.let { sb.appendLine("max_concurrency = $it") }
                sb.appendLine()
            }
        }

        // [[route]] entries
        facet.routes.forEach { route ->
            sb.appendLine("[[route]]")
            sb.appendLine("""method = "${route.method.uppercase()}"""")
            sb.appendLine("""path = "${escape(normalizePath(route.path))}"""")

            route.file?.let {
                sb.appendLine("""file = "${escape(it)}"""")
            }

            route.upstreamPath?.let {
                sb.appendLine("""upstream_path = "${escape(normalizePath(it))}"""")
            }

            route.integrity?.let { integrity ->
                sb.appendLine(
                    """integrity = { algo = "${escape(integrity.algo)}", value = "${escape(integrity.value)}" }"""
                )
            }

            sb.appendLine()
        }

        return sb.toString()
    }

    private fun validate(facet: FacetDefinition) {
        require(facet.id.isNotBlank()) { "Facet id must not be blank" }
        require(facet.routes.isNotEmpty()) { "Facet must define at least one route" }

        facet.routes.forEach { route ->
            require(route.path.isNotBlank()) { "Route path must not be blank" }
            require(route.path.startsWith("/")) {
                "Route path must start with '/': ${route.path}"
            }

            if (facet.kind == FacetKind.STATIC) {
                require(!route.file.isNullOrBlank()) {
                    "Static facets require 'file' for each route (id=${facet.id})"
                }
            }
        }
    }

    private fun normalizePath(path: String): String =
        if (path.startsWith("/")) path else "/$path"

    private fun escape(value: String): String =
        buildString {
            value.forEach { ch ->
                when (ch) {
                    '\\' -> append("\\\\")
                    '"' -> append("\\\"")
                    '\n' -> append("\\n")
                    '\r' -> append("\\r")
                    '\t' -> append("\\t")
                    else -> append(ch)
                }
            }
        }
}

```

### sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/Integrity.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-Integrity-kt"></a>

```kotlin
package dev.roncore.sdk.facets

/**
 * RO:WHAT —
 *   Integrity info (SRI-style) for static assets.
 *
 * RO:WHY —
 *   Lets Micronode verify that a served asset matches an expected
 *   hash before returning it, reducing the risk of tampering.
 *
 * RO:INVARIANTS —
 *   - `algo` is a free-form string (e.g. "sha256").
 *   - `value` is the hash (usually hex or base64).
 */
data class Integrity(
    val algo: String,
    val value: String
)

```

### sdk/ron-app-sdk-jvm/facets/src/main/kotlin/dev/roncore/sdk/facets/RouteDefinition.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-main-kotlin-dev-roncore-sdk-facets-RouteDefinition-kt"></a>

```kotlin
package dev.roncore.sdk.facets

/**
 * RO:WHAT —
 *   Per-route configuration within a facet.
 *
 * RO:WHY —
 *   Describes how Micronode should map HTTP requests (method + path)
 *   to either a static file or an upstream route (for future proxy facets).
 *
 * RO:INVARIANTS —
 *   - `path` MUST be an absolute HTTP path (starts with "/").
 *   - For STATIC facets, `file` MUST be non-null.
 *   - For PROXY facets (future), `upstreamPath` MUST be non-null.
 */
data class RouteDefinition(
    val method: String,
    val path: String,
    val file: String? = null,
    val upstreamPath: String? = null,
    val integrity: Integrity? = null
)

```

### sdk/ron-app-sdk-jvm/facets/src/test/kotlin/dev/roncore/sdk/facets/FacetSchemaInteropTest.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-test-kotlin-dev-roncore-sdk-facets-FacetSchemaInteropTest-kt"></a>

```kotlin
package dev.roncore.sdk.facets

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

/**
 * RO:WHAT —
 *   Schema-level sanity tests for facet types.
 *
 * RO:WHY —
 *   Guards the enum wire-format and simple round-trips so that
 *   future changes do not silently break manifest compatibility.
 */
class FacetSchemaInteropTest {

    @Test
    fun `facet kind round-trips via wire value`() {
        FacetKind.entries.forEach { kind ->
            val wire = kind.wire()
            val decoded = FacetKind.fromWire(wire)
            assertEquals(kind, decoded)
        }
    }

    @Test
    fun `facet kind parsing is case-insensitive`() {
        val decoded = FacetKind.fromWire("STATIC")
        assertEquals(FacetKind.STATIC, decoded)
    }
}

```

### sdk/ron-app-sdk-jvm/facets/src/test/kotlin/dev/roncore/sdk/facets/FacetTomlWriterTest.kt
<a id="sdk-ron-app-sdk-jvm-facets-src-test-kotlin-dev-roncore-sdk-facets-FacetTomlWriterTest-kt"></a>

```kotlin
package dev.roncore.sdk.facets

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertThrows
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test

/**
 * RO:WHAT —
 *   Unit tests for [FacetTomlWriter].
 *
 * RO:WHY —
 *   Ensure JVM facet manifests render into TOML that matches the
 *   SDK schema expectations and basic invariants.
 */
class FacetTomlWriterTest {

    @Test
    fun `writes minimal static facet`() {
        val facet = FacetDefinition(
            id = "docs",
            kind = FacetKind.STATIC,
            routes = listOf(
                RouteDefinition(
                    method = "GET",
                    path = "/hello",
                    file = "facets/docs/hello.txt"
                )
            )
        )

        val toml = FacetTomlWriter.write(facet).trim()

        val expected = """
            [facet]
            id = "docs"
            kind = "static"

            [[route]]
            method = "GET"
            path = "/hello"
            file = "facets/docs/hello.txt"
        """.trimIndent().trim()

        assertEquals(expected, toml)
    }

    @Test
    fun `validates route path must start with slash`() {
        val facet = FacetDefinition(
            id = "docs",
            routes = listOf(
                RouteDefinition(
                    method = "GET",
                    path = "relative", // invalid
                    file = "facets/docs/hello.txt"
                )
            )
        )

        assertThrows(IllegalArgumentException::class.java) {
            FacetTomlWriter.write(facet)
        }
    }

    @Test
    fun `emits optional sections when provided`() {
        val facet = FacetDefinition(
            id = "docs",
            kind = FacetKind.STATIC,
            security = FacetSecurity(public = false, requiresAuth = true),
            meta = FacetMeta(
                description = "Docs facet",
                owner = "docs-team",
                version = "1.0.0"
            ),
            limits = FacetLimits(
                maxRps = 100,
                maxConcurrency = 10
            ),
            routes = listOf(
                RouteDefinition(
                    method = "GET",
                    path = "/hello",
                    file = "facets/docs/hello.txt",
                    integrity = Integrity(
                        algo = "sha256",
                        value = "abc123"
                    )
                )
            )
        )

        val toml = FacetTomlWriter.write(facet)

        listOf(
            "[facet]",
            """id = "docs"""",
            """kind = "static"""",
            "[facet.security]",
            "public = false",
            "requires_auth = true",
            "[facet.meta]",
            """description = "Docs facet"""",
            """owner = "docs-team"""",
            """version = "1.0.0"""",
            "[facet.limits]",
            "max_rps = 100",
            "max_concurrency = 10",
            "[[route]]",
            """method = "GET"""",
            """path = "/hello"""",
            """file = "facets/docs/hello.txt"""",
            """integrity = { algo = "sha256", value = "abc123" }"""
        ).forEach { snippet ->
            assertTrue(
                toml.contains(snippet),
                "Expected TOML to contain: $snippet\nActual:\n$toml"
            )
        }
    }
}

```

### sdk/ron-app-sdk-jvm/gradle.properties
<a id="sdk-ron-app-sdk-jvm-gradle-properties"></a>

```
org.gradle.jvmargs=-Xmx2g -Dfile.encoding=UTF-8
android.useAndroidX=true
android.enableJetifier=false

```

### sdk/ron-app-sdk-jvm/gradle/libs.versions.toml
<a id="sdk-ron-app-sdk-jvm-gradle-libs-versions-toml"></a>

```toml
[versions]
java = "17"
okhttp = "4.12.0"
jackson = "2.17.2"
junit = "5.11.0"
coroutines = "1.8.1"

[libraries]
okhttp = { module = "com.squareup.okhttp3:okhttp", version.ref = "okhttp" }

jackson-core        = { module = "com.fasterxml.jackson.core:jackson-core",        version.ref = "jackson" }
jackson-databind    = { module = "com.fasterxml.jackson.core:jackson-databind",    version.ref = "jackson" }
jackson-annotations = { module = "com.fasterxml.jackson.core:jackson-annotations", version.ref = "jackson" }
jackson-jsr310      = { module = "com.fasterxml.jackson.datatype:jackson-datatype-jsr310", version.ref = "jackson" }

junit-jupiter = { module = "org.junit.jupiter:junit-jupiter", version.ref = "junit" }

kotlin-coroutines-core = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core", version.ref = "coroutines" }

```

### sdk/ron-app-sdk-jvm/gradle/wrapper/gradle-wrapper.properties
<a id="sdk-ron-app-sdk-jvm-gradle-wrapper-gradle-wrapper-properties"></a>

```
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

### sdk/ron-app-sdk-jvm/gradlew
<a id="sdk-ron-app-sdk-jvm-gradlew"></a>

```
#!/bin/sh

#
# Copyright © 2015 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac



# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

### sdk/ron-app-sdk-jvm/gradlew.bat
<a id="sdk-ron-app-sdk-jvm-gradlew-bat"></a>

```
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line



@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

### sdk/ron-app-sdk-jvm/interop-tests/build.gradle.kts
<a id="sdk-ron-app-sdk-jvm-interop-tests-build-gradle-kts"></a>

```kotlin
plugins {
    java
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

dependencies {
    // Interop tests exercise the real RonClient against a live gateway.
    testImplementation(project(":core"))
    testImplementation(libs.junit.jupiter)
}

tasks.test {
    // Root build already configures JUnit Platform, but we keep this explicit.
    useJUnitPlatform()
}

```

### sdk/ron-app-sdk-jvm/interop-tests/src/test/java/dev/roncore/sdk/interop/ErrorEnvelopeInteropTest.java
<a id="sdk-ron-app-sdk-jvm-interop-tests-src-test-java-dev-roncore-sdk-interop-ErrorEnvelopeInteropTest-java"></a>

```java

```

### sdk/ron-app-sdk-jvm/interop-tests/src/test/java/dev/roncore/sdk/interop/HappyPathInteropTest.java
<a id="sdk-ron-app-sdk-jvm-interop-tests-src-test-java-dev-roncore-sdk-interop-HappyPathInteropTest-java"></a>

```java
package dev.roncore.sdk.interop;

import dev.roncore.sdk.AppResponse;
import dev.roncore.sdk.RonClient;
import dev.roncore.sdk.RonProblem;
import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.Test;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * RO:WHAT —
 *   "Happy path" interop test that expects a successful envelope from
 *   the canonical `/app/ping` route via the JVM SDK.
 *
 * RO:WHY —
 *   - Complements {@link InteropSmokeTest} (which is intentionally
 *     tolerant of early 404s / bare errors for dev-preview).
 *   - This test is for environments where we KNOW `/app/ping` is
 *     wired up and should return a success envelope (e.g. stable
 *     macronode profile or CI interop node).
 *
 * RO:INVARIANTS —
 *   - If `RON_SDK_GATEWAY_ADDR` is not set, the test is SKIPPED.
 *   - If `RON_SDK_INTEROP_EXPECT_PING_OK` is not "1", the test is SKIPPED.
 *   - When enabled, the test asserts:
 *       * HTTP status is 2xx.
 *       * `ok()` is true.
 *       * `problem` is null.
 *       * Data envelope is present (may be empty map).
 */
public class HappyPathInteropTest {

    @Test
    void pingReturnsOkWhenHappyPathIsEnabled() {
        String gatewayAddr = System.getenv("RON_SDK_GATEWAY_ADDR");
        Assumptions.assumeTrue(
                gatewayAddr != null && !gatewayAddr.isBlank(),
                "RON_SDK_GATEWAY_ADDR is not set; skipping happy-path interop test."
        );

        String expectOk = System.getenv("RON_SDK_INTEROP_EXPECT_PING_OK");
        Assumptions.assumeTrue(
                "1".equals(expectOk),
                "RON_SDK_INTEROP_EXPECT_PING_OK != 1; skipping strict happy-path test."
        );

        try (RonClient client = RonClient.builder()
                .fromEnv()
                .build()) {

            @SuppressWarnings("unchecked")
            AppResponse<Map<String, Object>> response =
                    client.get("/ping", (Class<Map<String, Object>>) (Class<?>) Map.class);

            assertNotNull(response, "AppResponse must not be null");

            int status = response.getStatus();
            assertTrue(
                    status >= 200 && status < 300,
                    "Expected 2xx status from /app/ping, got " + status
            );

            assertTrue(response.ok(), "Expected response.ok() to be true for /app/ping");

            RonProblem problem = response.getProblem();
            assertNull(problem, "Expected no problem envelope on happy-path /app/ping");

            Map<String, Object> data = response.getData();
            assertNotNull(data, "Expected non-null data for happy-path /app/ping");
        }
    }
}

```

### sdk/ron-app-sdk-jvm/interop-tests/src/test/java/dev/roncore/sdk/interop/InteropSmokeTest.java
<a id="sdk-ron-app-sdk-jvm-interop-tests-src-test-java-dev-roncore-sdk-interop-InteropSmokeTest-java"></a>

```java
package dev.roncore.sdk.interop;

import dev.roncore.sdk.AppResponse;
import dev.roncore.sdk.RonClient;
import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.Test;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * RO:WHAT —
 *   End-to-end smoke test that exercises RonClient against a real RON gateway.
 *
 * RO:WHY —
 *   Proves that:
 *   - Env-based configuration (RON_SDK_GATEWAY_ADDR, RON_SDK_INSECURE_HTTP, etc.)
 *     works in a real JVM process.
 *   - The client can connect to a running node and decode an AppResponse envelope
 *     when available.
 *
 * RO:INVARIANTS (DEV-PREVIEW) —
 *   - If RON_SDK_GATEWAY_ADDR is not set, the test is SKIPPED.
 *   - The test MUST NOT fail the build just because early macronode shells
 *     still return bare HTTP errors with no problem envelope.
 *   - When a problem envelope is present, it should at least carry a message.
 */
public class InteropSmokeTest {

    @Test
    void gatewayPingReturnsEnvelope() {
        // 1) Skip cleanly when no live gateway is configured.
        String gatewayAddr = System.getenv("RON_SDK_GATEWAY_ADDR");
        Assumptions.assumeTrue(
                gatewayAddr != null && !gatewayAddr.isBlank(),
                "RON_SDK_GATEWAY_ADDR is not set; skipping interop smoke test."
        );

        // 2) Build a client from env (same path used by examples and real apps).
        try (RonClient client = RonClient.builder()
                .fromEnv()
                .build()) {

            // The SDK will normalize "/ping" → "/app/ping" against the configured base URL.
            // Today this often returns 404 in early macronode shells; for dev-preview we
            // only require that we get *some* HTTP status and that we can decode when an
            // AppResponse envelope is present.
            AppResponse<Map> response = client.get("/ping", Map.class);

            assertNotNull(response, "AppResponse must not be null");

            int status = response.getStatus();
            assertTrue(
                    status >= 100 && status < 600,
                    "Status should be a valid HTTP status code, got " + status
            );

            // If the gateway already wraps errors in a problem envelope, assert that it is sane.
            if (!response.ok() && response.getProblem() != null) {
                assertNotNull(
                        response.getProblem().getMessage(),
                        "Problem envelope should carry a message when present"
                );
            }

            // If ok() is true, or if the gateway currently returns bare errors with no
            // problem envelope, we accept that for dev-preview — the key contract here
            // is connectivity and basic decoding, not full problem semantics.
        }
    }
}

```

### sdk/ron-app-sdk-jvm/interop-tests/src/test/java/dev/roncore/sdk/interop/PaginationInteropTest.java
<a id="sdk-ron-app-sdk-jvm-interop-tests-src-test-java-dev-roncore-sdk-interop-PaginationInteropTest-java"></a>

```java
package dev.roncore.sdk.interop;

import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.Test;

/**
 * RO:WHAT —
 *   Placeholder for future pagination interop tests (list endpoints, cursors, etc.).
 *
 * RO:WHY —
 *   We want a dedicated home for pagination behavior that hits a *real* RON-CORE
 *   node (Micronode/Macronode) once list APIs are available.
 *
 * RO:INVARIANTS —
 *   - MUST NOT fail CI today — pagination endpoints are not wired yet.
 *   - Clearly marked as a placeholder so future-you knows where to add real tests.
 */
final class PaginationInteropTest {

    @Test
    void paginationInteropPlaceholder() {
        // Always skip for now; this test is a marker that pagination interop
        // should exist, but there is no stable endpoint yet.
        Assumptions.assumeTrue(
                false,
                () -> "Skipping pagination interop: pagination endpoints not implemented yet"
        );
    }
}

```

### sdk/ron-app-sdk-jvm/kotlin/build.gradle.kts
<a id="sdk-ron-app-sdk-jvm-kotlin-build-gradle-kts"></a>

```kotlin
plugins {
    id("org.jetbrains.kotlin.jvm")
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

dependencies {
    implementation(project(":core"))

    implementation(libs.kotlin.coroutines.core)

    testImplementation(libs.junit.jupiter)
}

tasks.test {
    useJUnitPlatform()
}

```

### sdk/ron-app-sdk-jvm/kotlin/src/main/kotlin/dev/roncore/sdk/kotlin/Ron.kt
<a id="sdk-ron-app-sdk-jvm-kotlin-src-main-kotlin-dev-roncore-sdk-kotlin-Ron-kt"></a>

```kotlin
package dev.roncore.sdk.kotlin

import dev.roncore.sdk.AppResponse
import dev.roncore.sdk.RonClient
import dev.roncore.sdk.config.RonConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * RO:WHAT —
 *   Kotlin-first facade over {@link RonClient}.
 *
 * RO:WHY —
 *   Gives Kotlin apps a nicer entrypoint with coroutines and
 *   a config DSL, without hiding the underlying Java client.
 *
 * RO:INVARIANTS —
 *   - One Ron instance wraps one RonClient.
 *   - Safe to share across coroutines; underlying RonClient is thread-safe.
 */
class Ron private constructor(
    private val client: RonClient
) : AutoCloseable {

    companion object {

        /**
         * Build a Ron instance from a pre-built {@link RonConfig}.
         */
        @JvmStatic
        fun fromConfig(config: RonConfig): Ron {
            val client = RonClient.builder()
                .config(config)
                .build()
            return Ron(client)
        }

        /**
         * Build a Ron instance from env + Kotlin DSL overrides.
         *
         * Example:
         *   val ron = Ron.fromEnv {
         *       baseUrl = "https://127.0.0.1:5304"
         *       insecureHttp = true
         *   }
         */
        @JvmStatic
        fun fromEnv(block: RonConfigDsl.() -> Unit = {}): Ron {
            val config = ronConfig(block)
            val client = RonClient.builder()
                .config(config)
                .build()
            return Ron(client)
        }
    }

    /**
     * Coroutine-friendly GET wrapper returning an AppResponse.
     */
    suspend fun <T> get(path: String, clazz: Class<T>): AppResponse<T> =
        withContext(Dispatchers.IO) {
            client.get(path, clazz)
        }

    suspend fun getString(path: String): AppResponse<String> =
        get(path, String::class.java)

    override fun close() {
        client.close()
    }
}

```

### sdk/ron-app-sdk-jvm/kotlin/src/main/kotlin/dev/roncore/sdk/kotlin/RonConfigDsl.kt
<a id="sdk-ron-app-sdk-jvm-kotlin-src-main-kotlin-dev-roncore-sdk-kotlin-RonConfigDsl-kt"></a>

```kotlin
package dev.roncore.sdk.kotlin

import dev.roncore.sdk.config.EnvConfigLoader
import dev.roncore.sdk.config.RonConfig
import java.time.Duration

/**
 * RO:WHAT —
 *   Kotlin DSL for building {@link RonConfig} on top of env defaults.
 *
 * RO:WHY —
 *   JVM apps can keep behavior consistent with other SDKs by
 *   starting from RON_SDK_* env vars, then layering Kotlin overrides.
 *
 * RO:INVARIANTS —
 *   - Env provides sane defaults; explicit DSL wins.
 *   - No secrets (tokens) are handled here; only transport config.
 */
@DslMarker
annotation class RonDslMarker

@RonDslMarker
class RonConfigDsl internal constructor() {

    /**
     * Base URL of the gateway, e.g. "https://127.0.0.1:5304".
     * If null, falls back to RON_SDK_GATEWAY_ADDR env var.
     */
    var baseUrl: String? = null

    /**
     * Allow plain HTTP. Only for dev/test, never for production.
     * If null, uses RON_SDK_INSECURE_HTTP semantics.
     */
    var insecureHttp: Boolean? = null

    var connectTimeoutMs: Long? = null
    var readTimeoutMs: Long? = null
    var writeTimeoutMs: Long? = null
    var overallTimeoutMs: Long? = null

    var maxRetries: Int? = null
    var maxResponseBytes: Long? = null
}

/**
 * Builds a {@link RonConfig} by:
 *
 *   1. Starting from RON_SDK_* env vars (when present).
 *   2. Applying any overrides from the [block].
 */
fun ronConfig(block: RonConfigDsl.() -> Unit = {}): RonConfig {
    val dsl = RonConfigDsl().apply(block)
    val builder = EnvConfigLoader.fromEnv()

    dsl.baseUrl?.let { builder.baseUrl(it) }

    dsl.connectTimeoutMs?.let { builder.connectTimeout(Duration.ofMillis(it)) }
    dsl.readTimeoutMs?.let { builder.readTimeout(Duration.ofMillis(it)) }
    dsl.writeTimeoutMs?.let { builder.writeTimeout(Duration.ofMillis(it)) }
    dsl.overallTimeoutMs?.let { builder.overallTimeout(Duration.ofMillis(it)) }

    dsl.insecureHttp?.let { builder.allowInsecureHttp(it) }
    dsl.maxRetries?.let { builder.maxRetries(it) }
    dsl.maxResponseBytes?.let { builder.maxResponseBytes(it) }

    return builder.build()
}

```

### sdk/ron-app-sdk-jvm/kotlin/src/main/kotlin/dev/roncore/sdk/kotlin/RonExtensions.kt
<a id="sdk-ron-app-sdk-jvm-kotlin-src-main-kotlin-dev-roncore-sdk-kotlin-RonExtensions-kt"></a>

```kotlin
package dev.roncore.sdk.kotlin

import dev.roncore.sdk.AppResponse
import dev.roncore.sdk.RonClient
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlin.reflect.KClass

/**
 * RO:WHAT —
 *   Extension functions adding suspend + reified sugar on top of RonClient.
 *
 * RO:WHY —
 *   Keeps base Java client small and predictable while giving
 *   Kotlin callers a pleasant, type-safe API.
 */

@Suppress("unused")
suspend inline fun <reified T : Any> RonClient.get(path: String): AppResponse<T> =
    withContext(Dispatchers.IO) {
        this@get.get(path, T::class.java)
    }

@Suppress("unused")
suspend inline fun <reified T : Any> RonClient.post(path: String, body: Any?): AppResponse<T> =
    withContext(Dispatchers.IO) {
        this@post.post(path, body, T::class.java)
    }

@Suppress("unused")
suspend inline fun <reified T : Any> RonClient.put(path: String, body: Any?): AppResponse<T> =
    withContext(Dispatchers.IO) {
        this@put.put(path, body, T::class.java)
    }

@Suppress("unused")
suspend inline fun <reified T : Any> RonClient.patch(path: String, body: Any?): AppResponse<T> =
    withContext(Dispatchers.IO) {
        this@patch.patch(path, body, T::class.java)
    }

@Suppress("unused")
suspend inline fun <reified T : Any> RonClient.delete(path: String): AppResponse<T> =
    withContext(Dispatchers.IO) {
        this@delete.delete(path, T::class.java)
    }

/**
 * Variant that accepts a KClass (handy for reflection-heavy call sites).
 */
@Suppress("unused")
suspend fun <T : Any> RonClient.get(path: String, type: KClass<T>): AppResponse<T> =
    withContext(Dispatchers.IO) {
        this@get.get(path, type.java)
    }

```

### sdk/ron-app-sdk-jvm/kotlin/src/main/kotlin/dev/roncore/sdk/kotlin/Streaming.kt
<a id="sdk-ron-app-sdk-jvm-kotlin-src-main-kotlin-dev-roncore-sdk-kotlin-Streaming-kt"></a>

```kotlin
package dev.roncore.sdk.kotlin

/**
 * RO:WHAT —
 *   Placeholder for future streaming/Flow-based APIs.
 *
 * RO:WHY —
 *   Reserves a stable package and type name so we can add
 *   cold/hot streams (Flows, channels) without breaking callers.
 */
object Streaming

```

### sdk/ron-app-sdk-jvm/kotlin/src/test/kotlin/dev/roncore/sdk/kotlin/RonCoroutineTest.kt
<a id="sdk-ron-app-sdk-jvm-kotlin-src-test-kotlin-dev-roncore-sdk-kotlin-RonCoroutineTest-kt"></a>

```kotlin
package dev.roncore.sdk.kotlin

import dev.roncore.sdk.AppResponse
import dev.roncore.sdk.RonClient
import dev.roncore.sdk.config.RonConfig
import dev.roncore.sdk.http.HttpClientAdapter
import dev.roncore.sdk.http.HttpRequestContext
import dev.roncore.sdk.http.HttpResponse
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test

/**
 * RO:WHAT —
 *   Tests for the Kotlin coroutine extensions over RonClient.
 *
 * RO:WHY —
 *   Ensures the suspend functions delegate correctly to the underlying
 *   RonClient while remaining safe to call from coroutines.
 *
 * RO:INVARIANTS —
 *   - No real network calls are made; we use a fake HttpClientAdapter.
 *   - The coroutine wrapper that takes a KClass decodes the JSON
 *     "data" field into a simple Map, which does not require any
 *     Kotlin-specific Jackson modules.
 */
class RonCoroutineTest {

    /**
     * Minimal HttpClientAdapter that records the last request and returns
     * a synthetic JSON response envelope.
     */
    class RecordingHttpClientAdapter(
        private val body: String
    ) : HttpClientAdapter {

        @Volatile
        var lastRequest: HttpRequestContext? = null
            private set

        override fun execute(request: HttpRequestContext): HttpResponse {
            lastRequest = request
            return HttpResponse(
                200,
                body,
                emptyMap()
            )
        }
    }

    @Test
    fun `KClass-based coroutine get delegates to RonClient and decodes envelope into Map`() = runBlocking {
        // Arrange: fake adapter returns a valid AppResponse envelope whose "data"
        // is a simple object that can be mapped into Map<String, Object>.
        val jsonEnvelope = """
            {
              "data": { "value": "hello-from-test" },
              "problem": null
            }
        """.trimIndent()

        val adapter = RecordingHttpClientAdapter(jsonEnvelope)

        val config = RonConfig.builder()
            .baseUrl("https://node.example.com")
            .build()

        val client = RonClient.builder()
            .config(config)
            .httpClientAdapter(adapter)
            .build()

        // Act: use the Kotlin KClass-based extension:
        //   suspend fun <T : Any> RonClient.get(path: String, type: KClass<T>): AppResponse<T>
        //
        // We ask for a Map so Jackson can materialize the object without any
        // Kotlin-specific modules.
        @Suppress("UNCHECKED_CAST")
        val response: AppResponse<Map<String, Any?>> =
            client.get("/ping", Map::class) as AppResponse<Map<String, Any?>>

        // Assert: the response is OK and the data was decoded as expected.
        assertTrue(response.ok())
        val data = response.data
        assertNotNull(data)
        assertEquals("hello-from-test", data!!["value"])

        // Also ensure the adapter actually saw a request.
        val seen = adapter.lastRequest
        assertNotNull(seen)
        // Sanity-check that we normalized to /app/* on the gateway side.
        assertTrue(seen!!.url.startsWith("https://node.example.com/app/"))
    }
}

```

### sdk/ron-app-sdk-jvm/kotlin/src/test/kotlin/dev/roncore/sdk/kotlin/RonDslTest.kt
<a id="sdk-ron-app-sdk-jvm-kotlin-src-test-kotlin-dev-roncore-sdk-kotlin-RonDslTest-kt"></a>

```kotlin
package dev.roncore.sdk.kotlin

import dev.roncore.sdk.config.RonConfig
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test

/**
 * RO:WHAT —
 *   Tests for the Kotlin ronConfig DSL.
 *
 * RO:WHY —
 *   Ensures that the DSL correctly applies explicit overrides on top of
 *   the EnvConfigLoader defaults and produces a consistent RonConfig.
 *
 * RO:INVARIANTS —
 *   - DSL must be usable without any RON_SDK_* env vars set.
 *   - Explicit values in the DSL win over env/defaults.
 *   - All timeouts and limits round-trip as expected.
 */
class RonDslTest {

    @Test
    fun `ronConfig applies explicit overrides`() {
        val cfg: RonConfig = ronConfig {
            baseUrl = "https://node.example.com"
            insecureHttp = true

            connectTimeoutMs = 1_234L
            readTimeoutMs = 2_345L
            writeTimeoutMs = 3_456L
            overallTimeoutMs = 4_567L

            maxRetries = 5
            maxResponseBytes = 1024L * 1024L // 1 MiB
        }

        // Base URL + HTTPS invariants
        assertEquals("https://node.example.com", cfg.baseUrl)
        assertTrue(cfg.baseUri.toString().startsWith("https://"))

        // Timeouts (millis)
        assertEquals(1_234L, cfg.connectTimeout.toMillis())
        assertEquals(2_345L, cfg.readTimeout.toMillis())
        assertEquals(3_456L, cfg.writeTimeout.toMillis())
        assertEquals(4_567L, cfg.overallTimeout.toMillis())

        // Insecure HTTP flag + limits
        assertTrue(cfg.isAllowInsecureHttp())
        assertEquals(5, cfg.maxRetries)
        assertEquals(1024L * 1024L, cfg.maxResponseBytes)
    }
}

```

### sdk/ron-app-sdk-jvm/local.properties
<a id="sdk-ron-app-sdk-jvm-local-properties"></a>

```
sdk.dir=/Users/mymac/Library/Android/sdk

```

### sdk/ron-app-sdk-jvm/settings.gradle.kts
<a id="sdk-ron-app-sdk-jvm-settings-gradle-kts"></a>

```kotlin
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
    plugins {
        id("com.android.application") version "8.2.0"
    }
}

rootProject.name = "ron-app-sdk-jvm"

include("core")
include("kotlin")
include("facets")

include("examples:java-cli")
include("examples:spring-boot")
include("examples:kotlin-ktor")
include("examples:android-sample")

include("interop-tests")

```

### sdk/ron-app-sdk-jvm/tools/ci/run-interop.sh
<a id="sdk-ron-app-sdk-jvm-tools-ci-run-interop-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT —
#   Interop test runner for ron-app-sdk-jvm.
#
# RO:WHY —
#   Provides a single entry point for running JVM SDK interop tests against
#   a real RON-CORE Micronode/Macronode gateway.
#
# RO:INVARIANTS —
#   - MUST be safe to call even when no gateway is running.
#   - MUST print clear guidance instead of blowing up in CI/local dev.
#   - Does NOT rely on a multi-module Gradle graph; runs interop-tests
#     as a standalone Gradle project via -p interop-tests.

set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"

cd "$ROOT"

echo "[ron-app-sdk-jvm] Interop test runner"
echo "  ROOT=$ROOT"

# 1) Ensure we have a gateway address; without it, there is nothing meaningful to test.
if [[ -z "${RON_SDK_GATEWAY_ADDR:-}" ]]; then
  echo "[ron-app-sdk-jvm] RON_SDK_GATEWAY_ADDR is not set."
  echo "  - Skipping interop tests. To run them, export e.g.:"
  echo "      RON_SDK_GATEWAY_ADDR=http://127.0.0.1:8090"
  echo "      RON_SDK_INSECURE_HTTP=1"
  exit 0
fi

echo "[ron-app-sdk-jvm] Running interop tests against: ${RON_SDK_GATEWAY_ADDR}"

# 2) Run the interop-tests module as an independent Gradle project.
if [[ $# -gt 0 ]]; then
  ./gradlew -p interop-tests test "$@"
else
  ./gradlew -p interop-tests test
fi

```

### sdk/ron-app-sdk-jvm/tools/ci/run-lint.sh
<a id="sdk-ron-app-sdk-jvm-tools-ci-run-lint-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — JVM SDK lint/style runner for ron-app-sdk-jvm.
# RO:WHY  — Placeholder for future Java/Kotlin lint wiring that does NOT
#           block CI or local dev while the SDK is still stabilizing.
# RO:INVARIANTS —
#   - Never fails the build today (no-op placeholder).
#   - Clearly documents future intent (checkstyle + ktlint + detekt).
#   - Safe to invoke from any working directory inside the repo.

set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"

cd "$ROOT"

echo "[ron-app-sdk-jvm] lint checks are not wired yet."
echo
echo "  Planned future behavior:"
echo "    1) Java checkstyle for :core using config/checkstyle.xml"
echo "    2) ktlint for :kotlin and :facets via config/ktlint.gradle.kts"
echo "    3) detekt for Kotlin modules via config/detekt.yml"
echo
echo "  For now, this script is a no-op placeholder and exits successfully."
echo

exit 0

```

### sdk/ron-app-sdk-jvm/tools/ci/run-tests.sh
<a id="sdk-ron-app-sdk-jvm-tools-ci-run-tests-sh"></a>

```bash
#!/usr/bin/env bash

set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
cd "$ROOT"

echo "[ron-app-sdk-jvm] running JVM SDK tests..."
echo "  ROOT=$ROOT"
echo

echo "[ron-app-sdk-jvm] ::projects (sanity)"
./gradlew projects

echo "[ron-app-sdk-jvm] ::core:test"
./gradlew :core:test

echo "[ron-app-sdk-jvm] ::kotlin:test"
./gradlew :kotlin:test

echo "[ron-app-sdk-jvm] ::facets:test"
./gradlew :facets:test

echo "[ron-app-sdk-jvm] ::interop-tests:test"
./gradlew :interop-tests:test

echo "[ron-app-sdk-jvm] ::examples:java-cli:build"
./gradlew :examples:java-cli:build

echo
echo "[ron-app-sdk-jvm] all JVM SDK tests passed."

```

### sdk/ron-app-sdk-jvm/tools/codegen/openapi-config.yml
<a id="sdk-ron-app-sdk-jvm-tools-codegen-openapi-config-yml"></a>

```yaml

```

### sdk/ron-app-sdk-jvm/tools/codegen/regenerate-dtos.sh
<a id="sdk-ron-app-sdk-jvm-tools-codegen-regenerate-dtos-sh"></a>

```bash

```

### sdk/ron-app-sdk-jvm/tools/make_codex.sh
<a id="sdk-ron-app-sdk-jvm-tools-makecodex-sh"></a>

```bash
#!/bin/sh
# RO:WHAT — Generate a single Markdown file containing all code/docs for an SDK.
# RO:WHY  — DX/GOV; one-file review/share artifact without giant docs payloads.
# RO:INTERACTS — repo/sdk/<sdk>; emits CODEBUNDLE.md
# RO:INVARIANTS —
#   * skip all *.md / *.MD (Markdown)
#   * skip node_modules/, dist/, coverage/, .git/, venvs, caches, vendor/, var/, and .DS_Store
#   * additionally skip Java/Gradle/IDE build dirs: build/, .gradle/, .idea/, .vscode/, out/, .settings
#   * skip common binary artifacts: *.class, *.jar, *.war, *.ear, *.zip, *.tar, *.tar.gz
#   * deterministic sort; set -eu
#   * read-only source; atomic write for output
#
# Usage example:
#   scripts/make_sdk_codex.sh -s ron-app-sdk-ts
#
# Flags:
#   -s|--sdk   <sdk-name>   (required, e.g. ron-app-sdk-ts)
#   -o|--out   <outfile>    (optional, default: sdk/<sdk>/CODEBUNDLE.md)
#   --root     <repo-root>  (optional, overrides git root)
#   --force                 (optional, overwrite existing outfile)
#   -h|--help               (show usage)

set -eu

usage() {
  echo "Usage: $0 -s <sdk-name> [-o <output.md>] [--force] [--root <repo-root>]"
  echo "Examples:"
  echo "  $0 -s ron-app-sdk-ts"
  echo "  $0 -s ron-app-sdk-ts -o sdk/ron-app-sdk-ts/ALL_CODE.md"
}

SDK=""
OUTFILE=""
FORCE=0

# Try to find repo root via git; fall back to current dir.
if ROOT="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  :
else
  ROOT="$(pwd)"
fi

# Parse args (POSIX-friendly)
while [ $# -gt 0 ]; do
  case "$1" in
    -s|--sdk)
      [ $# -ge 2 ] || { echo "Missing value for $1" >&2; usage; exit 1; }
      SDK="$2"; shift 2;;
    -o|--out)
      [ $# -ge 2 ] || { echo "Missing value for $1" >&2; usage; exit 1; }
      OUTFILE="$2"; shift 2;;
    --root)
      [ $# -ge 2 ] || { echo "Missing value for $1" >&2; usage; exit 1; }
      ROOT="$2"; shift 2;;
    --force)
      FORCE=1; shift;;
    -h|--help)
      usage; exit 0;;
    *)
      echo "Unknown arg: $1" >&2; usage; exit 1;;
  esac
done

[ -n "$SDK" ] || { echo "Missing -s|--sdk" >&2; usage; exit 1; }

SDK_DIR="$ROOT/sdk/$SDK"
[ -d "$SDK_DIR" ] || { echo "Not an SDK dir: $SDK_DIR" >&2; exit 1; }

# Default output path
if [ -z "${OUTFILE:-}" ]; then
  OUTFILE="$SDK_DIR/CODEBUNDLE.md"
fi

TMP_OUT="${OUTFILE}.tmp"
LIST_FILE="$(mktemp "${TMPDIR:-/tmp}/sdk_codex_list.XXXXXX")"

if [ -f "$OUTFILE" ] && [ "$FORCE" -ne 1 ]; then
  echo "Refusing to overwrite existing $OUTFILE (use --force to overwrite)" >&2
  rm -f "$LIST_FILE"
  exit 1
fi

# Build newline-separated file list:
# - under sdk/<sdk>
# - exclude node_modules/, dist/, coverage/, .git/, venvs, and common caches
# - exclude vendor/ and var/ (PHP/composer build + cache dirs)
# - exclude Java/Gradle/IDE build dirs: build/, .gradle/, .idea/, .vscode/, out/, .settings
# - exclude all Markdown (*.md, *.MD, etc.)
# - exclude macOS .DS_Store files and common junk (*.pyc, *.log, *.class, *.jar, archives)
# - sort deterministically
find "$SDK_DIR" \
  -type d \( \
      -name node_modules -o \
      -name dist         -o \
      -name coverage     -o \
      -name .git         -o \
      -name .venv        -o \
      -name venv         -o \
      -name __pycache__  -o \
      -name .mypy_cache  -o \
      -name .ruff_cache  -o \
      -name .pytest_cache -o \
      -name .tox         -o \
      -name .hypothesis  -o \
      -name vendor       -o \
      -name var          -o \
      -name build        -o \
      -name .gradle      -o \
      -name .idea        -o \
      -name .vscode      -o \
      -name out          -o \
      -name .settings \
    \) -prune -o \
  -type f \
    ! -iname "*.md" \
    ! -name ".DS_Store" \
    ! -name "*.pyc" \
    ! -name "*.pyo" \
    ! -name "*.log" \
    ! -name "*.class" \
    ! -name "*.jar" \
    ! -name "*.war" \
    ! -name "*.ear" \
    ! -name "*.zip" \
    ! -name "*.tar" \
    ! -name "*.tar.gz" \
    -print \
  | LC_ALL=C sort > "$LIST_FILE"

COUNT="$(wc -l < "$LIST_FILE" | tr -d '[:space:]')"
[ "$COUNT" -gt 0 ] || {
  echo "No matching files found in $SDK_DIR" >&2
  rm -f "$LIST_FILE"
  exit 1
}

# Simple extension→language mapper for fenced code blocks
ext_to_lang() {
  case "$1" in
    ts)      echo "ts" ;;
    tsx)     echo "tsx" ;;
    js)      echo "javascript" ;;
    mjs)     echo "javascript" ;;
    cjs)     echo "javascript" ;;
    py)      echo "python" ;;
    php)     echo "php" ;;
    json)    echo "json" ;;
    toml)    echo "toml" ;;
    yaml|yml) echo "yaml" ;;
    sh|bash|zsh) echo "bash" ;;
    css)     echo "css" ;;
    html)    echo "html" ;;
    mmd)     echo "mermaid" ;;
    proto)   echo "proto" ;;
    sql)     echo "sql" ;;
    java)    echo "java" ;;
    kt|kts)  echo "kotlin" ;;
    xml)     echo "xml" ;;
    properties) echo "" ;;
    *)       echo "" ;;
  esac
}

# Safe anchor generator: replace spaces/slashes/dots with dashes, keep alnum & dash
mk_anchor() {
  a=$(echo "$1" | tr ' /.' '---')
  a=$(printf "%s" "$a" | tr -cd '[:alnum:]-')
  echo "$a"
}

# Header
{
  printf '<!-- Generated by scripts/make_sdk_codex.sh on %s -->\n' "$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  printf '# Code Bundle — SDK `%s`\n' "$SDK"
  printf '\n'
  printf '> Generated for review/sharing. Source of truth remains the repo.\n'
  printf '> Includes all non-Markdown files under sdk/%s.\n' "$SDK"
  printf '> Skips node_modules, dist, coverage, .git, virtualenvs, caches, vendor, var,\n'
  printf '> and Java/Gradle/IDE build dirs (build, .gradle, .idea, .vscode, out, .settings),\n'
  printf '> plus common binary artifacts (class/jar/war/ear/zip/tar).\n'
  printf '\n'
  printf '## Table of Contents\n'
  while IFS= read -r f; do
    rel="${f#$ROOT/}"
    anchor="$(mk_anchor "$rel")"
    printf -- '- [%s](#%s)\n' "$rel" "$anchor"
  done < "$LIST_FILE"
  printf '\n'
} > "$TMP_OUT"

# Body
while IFS= read -r f; do
  rel="${f#$ROOT/}"
  ext="${f##*.}"
  lang="$(ext_to_lang "$ext")"
  anchor="$(mk_anchor "$rel")"

  {
    printf '### %s\n' "$rel"
    printf '<a id="%s"></a>\n' "$anchor"
    printf '\n'
    if [ -n "$lang" ]; then
      printf '```%s\n' "$lang"
    else
      printf '```\n'
    fi
    cat "$f"
    printf '\n'
    printf '```\n'
    printf '\n'
  } >> "$TMP_OUT"
done < "$LIST_FILE"

# Atomic move + cleanup
mv -f "$TMP_OUT" "$OUTFILE"
rm -f "$LIST_FILE"

printf 'Wrote %s files to: %s\n' "$COUNT" "$OUTFILE"

```

