#!/bin/sh
# RO:WHAT — Generate a single Markdown file containing all code from a crate.
# RO:WHY — DX/GOV; one-file review/share artifact without giant docs payloads.
# RO:INTERACTS — repo/crates/<crate>; emits CODEBUNDLE.md
# RO:INVARIANTS — skip docs/ and all *.md; deterministic sort; set -eu
# RO:SECURITY — read-only source; atomic write for output
# RO:CONFIG — flags: -c <crate>, -o <outfile>, --force, --root <repo_root>
# RO:TEST — run against ron-kernel; inspect output

# Usage example: scripts/make_crate_codex.sh -c ron-kernel

set -eu

usage() {
  echo "Usage: $0 -c <crate-name> [-o <output.md>] [--force] [--root <repo-root>]"
  echo "Examples:"
  echo "  $0 -c ron-kernel"
  echo "  $0 -c svc-edge -o crates/svc-edge/ALL_CODE.md"
}

CRATE=""
OUTFILE=""
FORCE=0

# Try to find repo root via git; fall back to current dir.
if ROOT="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  :
else
  ROOT="$(pwd)"
fi

# Parse args (POSIX-friendly)
while [ $# -gt 0 ]; do
  case "$1" in
    -c|--crate)
      [ $# -ge 2 ] || { echo "Missing value for $1" >&2; usage; exit 1; }
      CRATE="$2"; shift 2;;
    -o|--out)
      [ $# -ge 2 ] || { echo "Missing value for $1" >&2; usage; exit 1; }
      OUTFILE="$2"; shift 2;;
    --root)
      [ $# -ge 2 ] || { echo "Missing value for $1" >&2; usage; exit 1; }
      ROOT="$2"; shift 2;;
    --force)
      FORCE=1; shift;;
    -h|--help)
      usage; exit 0;;
    *)
      echo "Unknown arg: $1" >&2; usage; exit 1;;
  esac
done

[ -n "$CRATE" ] || { echo "Missing -c|--crate" >&2; usage; exit 1; }

CRATE_DIR="$ROOT/crates/$CRATE"
[ -d "$CRATE_DIR" ] || { echo "Not a crate dir: $CRATE_DIR" >&2; exit 1; }

# Default output path
if [ -z "${OUTFILE:-}" ]; then
  OUTFILE="$CRATE_DIR/CODEBUNDLE.md"
fi

TMP_OUT="${OUTFILE}.tmp"
LIST_FILE="$(mktemp "${TMPDIR:-/tmp}/codex_list.XXXXXX")"

if [ -f "$OUTFILE" ] && [ "$FORCE" -ne 1 ]; then
  echo "Refusing to overwrite existing $OUTFILE (use --force to overwrite)" >&2
  rm -f "$LIST_FILE"
  exit 1
fi

# Extension whitelist (regex for grep -E)
INCLUDE_EXT_RE='\.(rs|toml|yaml|yml|sh|bash|zsh|ts|tsx|js|json|proto|sql|css|html)$'

# Build newline-separated file list:
# - under crates/<crate>
# - exclude docs/, target/, node_modules/, .git/, .cargo-vendor
# - exclude *.md anywhere
# - filter by whitelisted extensions
# - sort deterministically
find "$CRATE_DIR" \
  -type d \( -name docs -o -name target -o -name node_modules -o -name .git -o -name .cargo-vendor \) -prune -o \
  -type f ! -name "*.md" -print \
  | grep -E "$INCLUDE_EXT_RE" \
  | LC_ALL=C sort > "$LIST_FILE"

COUNT="$(wc -l < "$LIST_FILE" | tr -d '[:space:]')"
[ "$COUNT" -gt 0 ] || { echo "No matching code files found in $CRATE_DIR" >&2; rm -f "$LIST_FILE"; exit 1; }

# Helpers (POSIX): simple extension→language mapper
ext_to_lang() {
  case "$1" in
    rs) echo "rust" ;;
    toml) echo "toml" ;;
    yaml|yml) echo "yaml" ;;
    sh|bash|zsh) echo "bash" ;;
    ts) echo "ts" ;;
    tsx) echo "tsx" ;;
    js) echo "javascript" ;;
    json) echo "json" ;;
    proto) echo "proto" ;;
    sql) echo "sql" ;;
    css) echo "css" ;;
    html) echo "html" ;;
    *) echo "" ;;
  esac
}

# Safe anchor generator: replace spaces/slashes/dots with dashes, keep alnum & dash
mk_anchor() {
  a=$(echo "$1" | tr ' /.' '---')
  a=$(printf "%s" "$a" | tr -cd '[:alnum:]-')
  echo "$a"
}

# Header
{
  printf '<!-- Generated by scripts/make_crate_codex.sh on %s -->\n' "$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  printf '# Code Bundle — `%s`\n' "$CRATE"
  printf '\n'
  printf '> Generated for review/sharing. Source of truth remains the repo.\n'
  printf '> Skips `docs/` and all `*.md`; includes common code/config extensions.\n'
  printf '\n'
  printf '## Table of Contents\n'
  while IFS= read -r f; do
    rel="${f#$ROOT/}"
    anchor="$(mk_anchor "$rel")"
    printf -- '- [%s](#%s)\n' "$rel" "$anchor"
  done < "$LIST_FILE"
  printf '\n'
} > "$TMP_OUT"

# Body
while IFS= read -r f; do
  rel="${f#$ROOT/}"
  ext="${f##*.}"
  lang="$(ext_to_lang "$ext")"
  anchor="$(mk_anchor "$rel")"

  {
    printf '### %s\n' "$rel"
    printf '<a id="%s"></a>\n' "$anchor"
    printf '\n'
    if [ -n "$lang" ]; then
      printf '```%s\n' "$lang"
    else
      printf '```\n'
    fi
    cat "$f"
    printf '\n'
    printf '```\n'
    printf '\n'
  } >> "$TMP_OUT"
done < "$LIST_FILE"

# Atomic move + cleanup
mv -f "$TMP_OUT" "$OUTFILE"
rm -f "$LIST_FILE"

printf 'Wrote %s files to: %s\n' "$COUNT" "$OUTFILE"
