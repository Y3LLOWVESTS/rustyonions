#!/bin/sh
# RO:WHAT — Generate a single Markdown file containing all code/docs for an SDK.
# RO:WHY  — DX/GOV; one-file review/share artifact without giant docs payloads.
# RO:INTERACTS — repo/sdk/<sdk>; emits CODEBUNDLE.md
# RO:INVARIANTS —
#   * skip all *.md / *.MD (Markdown)
#   * skip node_modules/, dist/, coverage/, .git/, venvs, caches, vendor/, var/, and .DS_Store
#   * deterministic sort; set -eu
#   * read-only source; atomic write for output
#
# Usage example:
#   scripts/make_sdk_codex.sh -s ron-app-sdk-ts
#
# Flags:
#   -s|--sdk   <sdk-name>   (required, e.g. ron-app-sdk-ts)
#   -o|--out   <outfile>    (optional, default: sdk/<sdk>/CODEBUNDLE.md)
#   --root     <repo-root>  (optional, overrides git root)
#   --force                 (optional, overwrite existing outfile)
#   -h|--help               (show usage)

set -eu

usage() {
  echo "Usage: $0 -s <sdk-name> [-o <output.md>] [--force] [--root <repo-root>]"
  echo "Examples:"
  echo "  $0 -s ron-app-sdk-ts"
  echo "  $0 -s ron-app-sdk-ts -o sdk/ron-app-sdk-ts/ALL_CODE.md"
}

SDK=""
OUTFILE=""
FORCE=0

# Try to find repo root via git; fall back to current dir.
if ROOT="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  :
else
  ROOT="$(pwd)"
fi

# Parse args (POSIX-friendly)
while [ $# -gt 0 ]; do
  case "$1" in
    -s|--sdk)
      [ $# -ge 2 ] || { echo "Missing value for $1" >&2; usage; exit 1; }
      SDK="$2"; shift 2;;
    -o|--out)
      [ $# -ge 2 ] || { echo "Missing value for $1" >&2; usage; exit 1; }
      OUTFILE="$2"; shift 2;;
    --root)
      [ $# -ge 2 ] || { echo "Missing value for $1" >&2; usage; exit 1; }
      ROOT="$2"; shift 2;;
    --force)
      FORCE=1; shift;;
    -h|--help)
      usage; exit 0;;
    *)
      echo "Unknown arg: $1" >&2; usage; exit 1;;
  esac
done

[ -n "$SDK" ] || { echo "Missing -s|--sdk" >&2; usage; exit 1; }

SDK_DIR="$ROOT/sdk/$SDK"
[ -d "$SDK_DIR" ] || { echo "Not an SDK dir: $SDK_DIR" >&2; exit 1; }

# Default output path
if [ -z "${OUTFILE:-}" ]; then
  OUTFILE="$SDK_DIR/CODEBUNDLE.md"
fi

TMP_OUT="${OUTFILE}.tmp"
LIST_FILE="$(mktemp "${TMPDIR:-/tmp}/sdk_codex_list.XXXXXX")"

if [ -f "$OUTFILE" ] && [ "$FORCE" -ne 1 ]; then
  echo "Refusing to overwrite existing $OUTFILE (use --force to overwrite)" >&2
  rm -f "$LIST_FILE"
  exit 1
fi

# Build newline-separated file list:
# - under sdk/<sdk>
# - exclude node_modules/, dist/, coverage/, .git/, venvs, and common caches
# - exclude vendor/ and var/ (PHP/composer build + cache dirs)
# - exclude all Markdown (*.md, *.MD, etc.)
# - exclude macOS .DS_Store files and common junk (*.pyc, *.log)
# - sort deterministically
find "$SDK_DIR" \
  -type d \( \
      -name node_modules -o \
      -name dist -o \
      -name coverage -o \
      -name .git -o \
      -name .venv -o \
      -name venv -o \
      -name __pycache__ -o \
      -name .mypy_cache -o \
      -name .ruff_cache -o \
      -name .pytest_cache -o \
      -name .tox -o \
      -name .hypothesis -o \
      -name vendor -o \
      -name var \
    \) -prune -o \
  -type f \
    ! -iname "*.md" \
    ! -name ".DS_Store" \
    ! -name "*.pyc" \
    ! -name "*.pyo" \
    ! -name "*.log" \
    -print \
  | LC_ALL=C sort > "$LIST_FILE"

COUNT="$(wc -l < "$LIST_FILE" | tr -d '[:space:]')"
[ "$COUNT" -gt 0 ] || {
  echo "No matching files found in $SDK_DIR" >&2
  rm -f "$LIST_FILE"
  exit 1
}

# Simple extension→language mapper for fenced code blocks
ext_to_lang() {
  case "$1" in
    ts)   echo "ts" ;;
    tsx)  echo "tsx" ;;
    js)   echo "javascript" ;;
    mjs)  echo "javascript" ;;
    cjs)  echo "javascript" ;;
    py)   echo "python" ;;
    php)  echo "php" ;;
    json) echo "json" ;;
    toml) echo "toml" ;;
    yaml|yml) echo "yaml" ;;
    sh|bash|zsh) echo "bash" ;;
    css)  echo "css" ;;
    html) echo "html" ;;
    mmd)  echo "mermaid" ;;
    proto) echo "proto" ;;
    sql)  echo "sql" ;;
    *)    echo "" ;;
  esac
}

# Safe anchor generator: replace spaces/slashes/dots with dashes, keep alnum & dash
mk_anchor() {
  a=$(echo "$1" | tr ' /.' '---')
  a=$(printf "%s" "$a" | tr -cd '[:alnum:]-')
  echo "$a"
}

# Header
{
  printf '<!-- Generated by scripts/make_sdk_codex.sh on %s -->\n' "$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  printf '# Code Bundle — SDK `%s`\n' "$SDK"
  printf '\n'
  printf '> Generated for review/sharing. Source of truth remains the repo.\n'
  printf '> Includes all non-Markdown files under sdk/%s.\n' "$SDK"
  printf '> Skips node_modules, dist, coverage, .git, virtualenvs, caches, vendor, var, and common junk files.\n'
  printf '\n'
  printf '## Table of Contents\n'
  while IFS= read -r f; do
    rel="${f#$ROOT/}"
    anchor="$(mk_anchor "$rel")"
    printf -- '- [%s](#%s)\n' "$rel" "$anchor"
  done < "$LIST_FILE"
  printf '\n'
} > "$TMP_OUT"

# Body
while IFS= read -r f; do
  rel="${f#$ROOT/}"
  ext="${f##*.}"
  lang="$(ext_to_lang "$ext")"
  anchor="$(mk_anchor "$rel")"

  {
    printf '### %s\n' "$rel"
    printf '<a id="%s"></a>\n' "$anchor"
    printf '\n'
    if [ -n "$lang" ]; then
      printf '```%s\n' "$lang"
    else
      printf '```\n'
    fi
    cat "$f"
    printf '\n'
    printf '```\n'
    printf '\n'
  } >> "$TMP_OUT"
done < "$LIST_FILE"

# Atomic move + cleanup
mv -f "$TMP_OUT" "$OUTFILE"
rm -f "$LIST_FILE"

printf 'Wrote %s files to: %s\n' "$COUNT" "$OUTFILE"
