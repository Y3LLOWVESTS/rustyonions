#!/usr/bin/env bash
# Scaffolds the ron-app-sdk-ts project under sdk/ron-app-sdk-ts

set -euo pipefail

BASE_DIR="sdk/ron-app-sdk-ts"

echo "Scaffolding ron-app-sdk-ts into: $BASE_DIR"

# Create directories
mkdir -p "$BASE_DIR"
mkdir -p "$BASE_DIR/src"
mkdir -p "$BASE_DIR/src/utils"
mkdir -p "$BASE_DIR/src/facets"
mkdir -p "$BASE_DIR/test"
mkdir -p "$BASE_DIR/docs"

# Root files
cat > "$BASE_DIR/package.json" <<'EOF'
{
  "name": "ron-app-sdk-ts",
  "version": "0.1.0",
  "description": "TypeScript SDK for the RON-CORE app plane (/app/*).",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "sideEffects": false,
  "scripts": {
    "build": "tsc -p tsconfig.build.json",
    "lint": "eslint .",
    "format": "prettier --write .",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:integration": "vitest run --config vitest.config.ts --dir test",
    "clean": "rm -rf dist coverage"
  },
  "keywords": [
    "ron-core",
    "sdk",
    "typescript",
    "app-plane"
  ],
  "license": "MIT OR Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/Y3LLOWVESTS/RON-CORE"
  },
  "engines": {
    "node": ">=18"
  },
  "devDependencies": {
    "typescript": "^5.6.0",
    "vitest": "^2.1.0",
    "@vitest/coverage-v8": "^2.1.0",
    "eslint": "^9.0.0",
    "@eslint/js": "^9.0.0",
    "typescript-eslint": "^8.0.0",
    "prettier": "^3.3.0"
  },
  "dependencies": {}
}
EOF

cat > "$BASE_DIR/tsconfig.json" <<'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2020", "DOM"],
    "strict": true,
    "noImplicitAny": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "outDir": "dist",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "rootDir": "src"
  },
  "include": ["src", "test"],
  "exclude": ["dist", "coverage", "node_modules"]
}
EOF

cat > "$BASE_DIR/tsconfig.build.json" <<'EOF'
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false
  },
  "include": ["src"],
  "exclude": ["test", "docs"]
}
EOF

cat > "$BASE_DIR/vitest.config.ts" <<'EOF'
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    environment: "node",
    globals: true,
    include: ["test/**/*.test.ts"],
    coverage: {
      provider: "v8",
      reportsDirectory: "coverage"
    }
  }
});
EOF

cat > "$BASE_DIR/eslint.config.mjs" <<'EOF'
import js from "@eslint/js";
import tseslint from "typescript-eslint";

export default tseslint.config(
  js.configs.recommended,
  ...tseslint.configs.recommended,
  {
    ignores: ["dist", "coverage", "node_modules"],
    languageOptions: {
      parserOptions: {
        project: "./tsconfig.json",
        sourceType: "module"
      }
    },
    rules: {
      "no-console": "warn",
      "no-unused-vars": ["error", { "argsIgnorePattern": "^_" }]
    }
  }
);
EOF

cat > "$BASE_DIR/.prettierrc" <<'EOF'
{
  "singleQuote": true,
  "trailingComma": "all",
  "semi": true,
  "printWidth": 80
}
EOF

cat > "$BASE_DIR/.prettierignore" <<'EOF'
dist
coverage
node_modules
EOF

cat > "$BASE_DIR/.gitignore" <<'EOF'
dist
coverage
node_modules
*.log
EOF

cat > "$BASE_DIR/README.md" <<'EOF'
# ron-app-sdk-ts

> TypeScript / JavaScript SDK for the RON-CORE app plane (/app/*).  
> This README is generated by the scaffold script; see project root for the full God-tier version.

EOF

cat > "$BASE_DIR/SDK_IDB.md" <<'EOF'
# SDK_IDB — ron-app-sdk-ts

This file will hold the invariant-driven blueprint (IDB) for ron-app-sdk-ts.
See the main project docs for the fully populated version.
EOF

cat > "$BASE_DIR/SDK_SECURITY.md" <<'EOF'
# SDK_SECURITY — ron-app-sdk-ts

This file will hold the security checklist and invariants for ron-app-sdk-ts.
See the main project docs for the fully populated version.
EOF

cat > "$BASE_DIR/SDK_SCHEMA_IDB.md" <<'EOF'
# SDK_SCHEMA_IDB — ron-app-sdk-ts

This file will hold the unified schema & facet contract details for ron-app-sdk-ts.
See the main project docs for the fully populated version.
EOF

cat > "$BASE_DIR/NOTES.md" <<'EOF'
# NOTES — ron-app-sdk-ts

Rolling implementation notes and carry-over logs for ron-app-sdk-ts.
EOF

# src files
cat > "$BASE_DIR/src/index.ts" <<'EOF'
/**
 * ron-app-sdk-ts
 *
 * Public entrypoint. Re-export the primary Ron client and core types.
 */

export * from './types';
export * from './client';
EOF

cat > "$BASE_DIR/src/client.ts" <<'EOF'
/**
 * Ron client
 *
 * High-level client for calling /app/* on a RON-CORE node.
 * This is a scaffold; methods will be fully implemented later.
 */

import type { AppRequest, AppResponse, RonOptions } from './types';

export class Ron {
  private readonly options: RonOptions;

  constructor(options: RonOptions) {
    this.options = options;
  }

  async request<T = unknown>(_req: AppRequest): Promise<AppResponse<T>> {
    // TODO: implement transport + error mapping
    throw new Error('Ron.request not implemented yet (scaffold)');
  }

  async get<T = unknown>(
    path: string,
    query?: Record<string, string>,
  ): Promise<AppResponse<T>> {
    return this.request<T>({ method: 'GET', path, query });
  }

  async post<T = unknown>(
    path: string,
    body?: unknown,
    query?: Record<string, string>,
  ): Promise<AppResponse<T>> {
    return this.request<T>({ method: 'POST', path, body, query });
  }

  async put<T = unknown>(
    path: string,
    body?: unknown,
    query?: Record<string, string>,
  ): Promise<AppResponse<T>> {
    return this.request<T>({ method: 'PUT', path, body, query });
  }

  async patch<T = unknown>(
    path: string,
    body?: unknown,
    query?: Record<string, string>,
  ): Promise<AppResponse<T>> {
    return this.request<T>({ method: 'PATCH', path, body, query });
  }

  async delete<T = unknown>(
    path: string,
    query?: Record<string, string>,
  ): Promise<AppResponse<T>> {
    return this.request<T>({ method: 'DELETE', path, query });
  }
}
EOF

cat > "$BASE_DIR/src/types.ts" <<'EOF'
/**
 * Core types for ron-app-sdk-ts.
 *
 * These types are aligned with the SDK_IDB and SDK_SCHEMA_IDB documents.
 */

export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';

export interface AppRequest {
  method: HttpMethod;
  path: string;
  query?: Record<string, string>;
  headers?: Record<string, string>;
  body?: unknown;
}

export interface RonProblem {
  code: string;
  message?: string;
  kind?: string;
  correlationId?: string;
  retryable?: boolean;
  retryAfterMs?: number;
  reason?: string;
  details?: Record<string, unknown>;
}

export interface AppResponse<T = unknown> {
  status: number;
  ok: boolean;
  headers: Record<string, string>;
  data?: T;
  raw?: ArrayBuffer;
  problem?: RonProblem;
}

export interface RonOptions {
  baseUrl: string;
  authToken?: string;
  passportToken?: string;
  overallTimeoutMs?: number;
  connectTimeoutMs?: number;
  readTimeoutMs?: number;
  requestIdFactory?: () => string;
  onRequest?: (req: AppRequest & { url: string }) => void;
  onResponse?: <T>(res: AppResponse<T>) => void;
  headerProvider?: () =>
    | Record<string, string>
    | Promise<Record<string, string>>;
  allowInsecureHttp?: boolean;
  debug?: boolean;
}
EOF

cat > "$BASE_DIR/src/errors.ts" <<'EOF'
/**
 * SDK-local error types for misconfiguration or catastrophic local failures.
 * Server-originated problems are represented as RonProblem inside AppResponse.
 */

export class SdkConfigError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'SdkConfigError';
  }
}

export class LocalNetworkError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'LocalNetworkError';
  }
}
EOF

cat > "$BASE_DIR/src/config.ts" <<'EOF'
/**
 * Config resolution for ron-app-sdk-ts.
 *
 * Merges RonOptions with environment-derived defaults (Node) and enforces
 * security invariants like HTTPS-only-by-default.
 */

import type { RonOptions } from './types';
import { SdkConfigError } from './errors';

export function resolveConfig(options: RonOptions): RonOptions {
  const baseUrl =
    options.baseUrl ||
    (typeof process !== 'undefined'
      ? process.env.RON_SDK_GATEWAY_ADDR ?? ''
      : '');

  if (!baseUrl) {
    throw new SdkConfigError('baseUrl is required for Ron client');
  }

  if (!options.allowInsecureHttp && baseUrl.startsWith('http://')) {
    throw new SdkConfigError(
      'Insecure HTTP is disabled; set allowInsecureHttp: true for local dev only',
    );
  }

  return {
    overallTimeoutMs:
      options.overallTimeoutMs ??
      (typeof process !== 'undefined'
        ? Number(process.env.RON_SDK_OVERALL_TIMEOUT_MS || 10000)
        : 10000),
    ...options,
    baseUrl,
  };
}
EOF

cat > "$BASE_DIR/src/transport.ts" <<'EOF'
/**
 * Transport layer: wraps fetch() with URL construction, timeouts, and
 * response parsing.
 *
 * This is a scaffold; details will be filled in later.
 */

import type { AppRequest, AppResponse, RonOptions } from './types';

export async function sendRequest<T = unknown>(
  _options: RonOptions,
  _req: AppRequest,
): Promise<AppResponse<T>> {
  // TODO: implement URL building, header injection, timeouts, and problem parsing.
  throw new Error('sendRequest not implemented yet (scaffold)');
}
EOF

# utils
cat > "$BASE_DIR/src/utils/headers.ts" <<'EOF'
/**
 * Header utilities: merge user headers with required SDK headers,
 * and generate request/correlation IDs.
 */

import type { AppRequest } from '../types';

export function generateRequestId(): string {
  // Simple placeholder; will be replaced with a UUIDv4 implementation.
  return `ron-${Math.random().toString(16).slice(2)}-${Date.now()}`;
}

export function buildHeaders(
  base: Record<string, string> | undefined,
  extra: Record<string, string>,
): Record<string, string> {
  return { ...(base ?? {}), ...extra };
}

export function applyObservabilityHeaders(
  req: AppRequest,
  requestIdFactory: () => string,
): AppRequest {
  const requestId = requestIdFactory();
  const headers = buildHeaders(req.headers, {
    'x-request-id': requestId,
    'x-correlation-id': requestId,
  });
  return { ...req, headers };
}
EOF

cat > "$BASE_DIR/src/utils/url.ts" <<'EOF'
/**
 * URL utilities: validate baseUrl, build /app/* URLs, and attach query strings.
 */

export function joinBaseAndPath(baseUrl: string, path: string): string {
  const base = baseUrl.replace(/\/+$/, '');
  const p = path.startsWith('/') ? path : `/${path}`;
  return `${base}/app${p}`;
}

export function toQueryString(
  query?: Record<string, string>,
): string | undefined {
  if (!query) return undefined;
  const params = new URLSearchParams();
  for (const [k, v] of Object.entries(query)) {
    params.set(k, v);
  }
  const s = params.toString();
  return s.length ? `?${s}` : undefined;
}
EOF

cat > "$BASE_DIR/src/utils/timeouts.ts" <<'EOF'
/**
 * Timeout utilities: create AbortSignal for overall request timeout.
 */

export function withTimeout(
  ms: number,
  controller?: AbortController,
): { signal: AbortSignal; cancel: () => void } {
  const c = controller ?? new AbortController();
  const id = setTimeout(() => c.abort(), ms);
  const cancel = () => clearTimeout(id);
  return { signal: c.signal, cancel };
}
EOF

cat > "$BASE_DIR/src/utils/problem.ts" <<'EOF'
/**
 * Problem utilities: parse canonical RON Problem JSON into RonProblem.
 */

import type { RonProblem } from '../types';

export async function parseProblem(
  res: Response,
): Promise<RonProblem | undefined> {
  const contentType = res.headers.get('content-type') ?? '';
  if (!contentType.includes('application/json')) {
    return {
      code: 'transport_error',
      message: 'Non-JSON error response',
      kind: 'transport',
      retryable: false,
    };
  }

  try {
    const body = (await res.json()) as any;
    const problem: RonProblem = {
      code: String(body.code ?? 'unknown_error'),
      message: typeof body.message === 'string' ? body.message : undefined,
      kind: typeof body.kind === 'string' ? body.kind : undefined,
      correlationId:
        typeof body.correlation_id === 'string'
          ? body.correlation_id
          : undefined,
      retryable:
        typeof body.retryable === 'boolean' ? body.retryable : undefined,
      retryAfterMs:
        typeof body.retry_after_ms === 'number'
          ? body.retry_after_ms
          : undefined,
      reason: typeof body.reason === 'string' ? body.reason : undefined,
      details:
        body.details && typeof body.details === 'object'
          ? (body.details as Record<string, unknown>)
          : undefined,
    };
    return problem;
  } catch {
    return {
      code: 'transport_error',
      message: 'Failed to parse error body',
      kind: 'transport',
      retryable: false,
    };
  }
}
EOF

# facets
cat > "$BASE_DIR/src/facets/manifest.ts" <<'EOF'
/**
 * Facet manifest types and future helpers for emitting TOML facet configs.
 * This is a scaffold aligned with the SDK_SCHEMA_IDB manifest schema.
 */

export type FacetKind = 'static' | 'echo' | 'proxy';

export interface FacetSecurity {
  public?: boolean;
  requiresAuth?: boolean;
}

export interface FacetMeta {
  description?: string;
  owner?: string;
  version?: string;
}

export interface FacetRouteStatic {
  method: 'GET' | 'HEAD';
  path: string;
  file: string;
}

export interface FacetUpstream {
  scheme: 'http' | 'https';
  host: string;
  port: number;
  basePath?: string;
}

export interface FacetRouteProxy {
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  path: string;
  upstreamPath?: string;
}
EOF

# test files
cat > "$BASE_DIR/test/client.basic.test.ts" <<'EOF'
import { describe, it, expect } from 'vitest';
import { Ron } from '../src/client';

describe('Ron client (basic scaffold)', () => {
  it('constructs with baseUrl', () => {
    const ron = new Ron({ baseUrl: 'https://example.com' });
    expect(ron).toBeTruthy();
  });
});
EOF

cat > "$BASE_DIR/test/transport.timeouts.test.ts" <<'EOF'
import { describe, it, expect } from 'vitest';

describe('transport timeouts (scaffold)', () => {
  it('placeholder', () => {
    expect(true).toBe(true);
  });
});
EOF

cat > "$BASE_DIR/test/errors.mapping.test.ts" <<'EOF'
import { describe, it, expect } from 'vitest';

describe('error mapping (scaffold)', () => {
  it('placeholder', () => {
    expect(true).toBe(true);
  });
});
EOF

cat > "$BASE_DIR/test/security.no_secrets.test.ts" <<'EOF'
import { describe, it, expect } from 'vitest';

describe('security: no secrets in URLs (scaffold)', () => {
  it('placeholder', () => {
    expect(true).toBe(true);
  });
});
EOF

cat > "$BASE_DIR/test/schema.interop.test.ts" <<'EOF'
import { describe, it, expect } from 'vitest';

describe('schema interop (scaffold)', () => {
  it('placeholder', () => {
    expect(true).toBe(true);
  });
});
EOF

# docs
cat > "$BASE_DIR/docs/ron-app-sdk-ts-arch.mmd" <<'EOF'
flowchart LR
  subgraph App["App code (browser / Node)"]
    A[Caller] -->|import Ron| B[ron-app-sdk-ts]
  end

  B -->|HTTPS /app/*| C[svc-gateway]
  C -->|/v1/app/*| D[omnigate]
  D -->|app-plane| E[App handlers (ron-app-sdk-rs)]

  style B fill:#0b7285,stroke:#083344,color:#fff
EOF

cat > "$BASE_DIR/docs/ron-app-sdk-ts-state.mmd" <<'EOF'
stateDiagram-v2
  [*] --> Idle
  Idle --> Requesting: ron.request()
  Requesting --> Waiting: fetch in flight
  Waiting --> Completed: response ok
  Waiting --> Failed: problem / network error
  Completed --> Idle
  Failed --> Idle
EOF

cat > "$BASE_DIR/docs/ron-app-sdk-ts-seq-app-call.mmd" <<'EOF'
sequenceDiagram
  actor App
  participant SDK as ron-app-sdk-ts
  participant GW as svc-gateway
  participant OG as omnigate
  participant AH as App Handler

  App->>SDK: Ron.get("/hello")
  SDK->>GW: HTTPS GET /app/hello
  GW->>OG: HTTP /v1/app/hello
  OG->>AH: Invoke handler
  AH-->>OG: Response/Problem
  OG-->>GW: HTTP response
  GW-->>SDK: HTTP response
  SDK-->>App: AppResponse{ ok/data/problem }
EOF

echo "ron-app-sdk-ts scaffold created."
