<!-- Generated by scripts/make_crate_codex.sh on 2025-11-23T01:09:00Z -->
# Code Bundle — `svc-gateway`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-gateway/.github/workflows/api-stability.yml](#crates-svc-gateway--github-workflows-api-stability-yml)
- [crates/svc-gateway/.github/workflows/ci.yml](#crates-svc-gateway--github-workflows-ci-yml)
- [crates/svc-gateway/.github/workflows/fuzz-nightly.yml](#crates-svc-gateway--github-workflows-fuzz-nightly-yml)
- [crates/svc-gateway/.github/workflows/perf-guard.yml](#crates-svc-gateway--github-workflows-perf-guard-yml)
- [crates/svc-gateway/Cargo.toml](#crates-svc-gateway-Cargo-toml)
- [crates/svc-gateway/benches/baseline.json](#crates-svc-gateway-benches-baseline-json)
- [crates/svc-gateway/benches/bench_gateway.sh](#crates-svc-gateway-benches-benchgateway-sh)
- [crates/svc-gateway/build.rs](#crates-svc-gateway-build-rs)
- [crates/svc-gateway/configs/svc-gateway.sample.toml](#crates-svc-gateway-configs-svc-gateway-sample-toml)
- [crates/svc-gateway/fuzz/targets/oap_frame.rs](#crates-svc-gateway-fuzz-targets-oapframe-rs)
- [crates/svc-gateway/fuzz/targets/taxonomy_mapper.rs](#crates-svc-gateway-fuzz-targets-taxonomymapper-rs)
- [crates/svc-gateway/scripts/chaos_burst.sh](#crates-svc-gateway-scripts-chaosburst-sh)
- [crates/svc-gateway/scripts/decode_guard_smoke.sh](#crates-svc-gateway-scripts-decodeguardsmoke-sh)
- [crates/svc-gateway/scripts/dev_run.sh](#crates-svc-gateway-scripts-devrun-sh)
- [crates/svc-gateway/scripts/export_metrics.sh](#crates-svc-gateway-scripts-exportmetrics-sh)
- [crates/svc-gateway/scripts/run_gateway.sh](#crates-svc-gateway-scripts-rungateway-sh)
- [crates/svc-gateway/scripts/sanity_rate_limit.sh](#crates-svc-gateway-scripts-sanityratelimit-sh)
- [crates/svc-gateway/scripts/smoke_gateway.sh](#crates-svc-gateway-scripts-smokegateway-sh)
- [crates/svc-gateway/scripts/soak_test.sh](#crates-svc-gateway-scripts-soaktest-sh)
- [crates/svc-gateway/scripts/stop_gateway.sh](#crates-svc-gateway-scripts-stopgateway-sh)
- [crates/svc-gateway/scripts/test_body_cap.sh](#crates-svc-gateway-scripts-testbodycap-sh)
- [crates/svc-gateway/scripts/test_rate_limit.sh](#crates-svc-gateway-scripts-testratelimit-sh)
- [crates/svc-gateway/src/admission/capabilities.rs](#crates-svc-gateway-src-admission-capabilities-rs)
- [crates/svc-gateway/src/admission/classifier.rs](#crates-svc-gateway-src-admission-classifier-rs)
- [crates/svc-gateway/src/admission/mod.rs](#crates-svc-gateway-src-admission-mod-rs)
- [crates/svc-gateway/src/admission/payments.rs](#crates-svc-gateway-src-admission-payments-rs)
- [crates/svc-gateway/src/admission/quotas.rs](#crates-svc-gateway-src-admission-quotas-rs)
- [crates/svc-gateway/src/admission/residency.rs](#crates-svc-gateway-src-admission-residency-rs)
- [crates/svc-gateway/src/admission/taxonomy.rs](#crates-svc-gateway-src-admission-taxonomy-rs)
- [crates/svc-gateway/src/cli/mod.rs](#crates-svc-gateway-src-cli-mod-rs)
- [crates/svc-gateway/src/config/amnesia.rs](#crates-svc-gateway-src-config-amnesia-rs)
- [crates/svc-gateway/src/config/env.rs](#crates-svc-gateway-src-config-env-rs)
- [crates/svc-gateway/src/config/mod.rs](#crates-svc-gateway-src-config-mod-rs)
- [crates/svc-gateway/src/config/safety.rs](#crates-svc-gateway-src-config-safety-rs)
- [crates/svc-gateway/src/consts.rs](#crates-svc-gateway-src-consts-rs)
- [crates/svc-gateway/src/errors.rs](#crates-svc-gateway-src-errors-rs)
- [crates/svc-gateway/src/forward/index_client.rs](#crates-svc-gateway-src-forward-indexclient-rs)
- [crates/svc-gateway/src/forward/mod.rs](#crates-svc-gateway-src-forward-mod-rs)
- [crates/svc-gateway/src/forward/overlay_client.rs](#crates-svc-gateway-src-forward-overlayclient-rs)
- [crates/svc-gateway/src/forward/storage_client.rs](#crates-svc-gateway-src-forward-storageclient-rs)
- [crates/svc-gateway/src/headers/etag.rs](#crates-svc-gateway-src-headers-etag-rs)
- [crates/svc-gateway/src/headers/mod.rs](#crates-svc-gateway-src-headers-mod-rs)
- [crates/svc-gateway/src/layers/auth.rs](#crates-svc-gateway-src-layers-auth-rs)
- [crates/svc-gateway/src/layers/body_caps.rs](#crates-svc-gateway-src-layers-bodycaps-rs)
- [crates/svc-gateway/src/layers/concurrency.rs](#crates-svc-gateway-src-layers-concurrency-rs)
- [crates/svc-gateway/src/layers/corr.rs](#crates-svc-gateway-src-layers-corr-rs)
- [crates/svc-gateway/src/layers/decode_guard.rs](#crates-svc-gateway-src-layers-decodeguard-rs)
- [crates/svc-gateway/src/layers/drr.rs](#crates-svc-gateway-src-layers-drr-rs)
- [crates/svc-gateway/src/layers/mod.rs](#crates-svc-gateway-src-layers-mod-rs)
- [crates/svc-gateway/src/layers/rate_limit.rs](#crates-svc-gateway-src-layers-ratelimit-rs)
- [crates/svc-gateway/src/layers/tarpit.rs](#crates-svc-gateway-src-layers-tarpit-rs)
- [crates/svc-gateway/src/layers/timeouts.rs](#crates-svc-gateway-src-layers-timeouts-rs)
- [crates/svc-gateway/src/lib.rs](#crates-svc-gateway-src-lib-rs)
- [crates/svc-gateway/src/main.rs](#crates-svc-gateway-src-main-rs)
- [crates/svc-gateway/src/observability/http_metrics.rs](#crates-svc-gateway-src-observability-httpmetrics-rs)
- [crates/svc-gateway/src/observability/logging.rs](#crates-svc-gateway-src-observability-logging-rs)
- [crates/svc-gateway/src/observability/metrics.rs](#crates-svc-gateway-src-observability-metrics-rs)
- [crates/svc-gateway/src/observability/metrics_boot.rs](#crates-svc-gateway-src-observability-metricsboot-rs)
- [crates/svc-gateway/src/observability/mod.rs](#crates-svc-gateway-src-observability-mod-rs)
- [crates/svc-gateway/src/observability/readiness.rs](#crates-svc-gateway-src-observability-readiness-rs)
- [crates/svc-gateway/src/observability/ready_metrics.rs](#crates-svc-gateway-src-observability-readymetrics-rs)
- [crates/svc-gateway/src/observability/rejects.rs](#crates-svc-gateway-src-observability-rejects-rs)
- [crates/svc-gateway/src/observability/tracing.rs](#crates-svc-gateway-src-observability-tracing-rs)
- [crates/svc-gateway/src/policy/abuse.rs](#crates-svc-gateway-src-policy-abuse-rs)
- [crates/svc-gateway/src/policy/mod.rs](#crates-svc-gateway-src-policy-mod-rs)
- [crates/svc-gateway/src/policy/residency.rs](#crates-svc-gateway-src-policy-residency-rs)
- [crates/svc-gateway/src/pq/mod.rs](#crates-svc-gateway-src-pq-mod-rs)
- [crates/svc-gateway/src/pq/policy.rs](#crates-svc-gateway-src-pq-policy-rs)
- [crates/svc-gateway/src/readiness/keys.rs](#crates-svc-gateway-src-readiness-keys-rs)
- [crates/svc-gateway/src/readiness/mod.rs](#crates-svc-gateway-src-readiness-mod-rs)
- [crates/svc-gateway/src/result.rs](#crates-svc-gateway-src-result-rs)
- [crates/svc-gateway/src/routes/app.rs](#crates-svc-gateway-src-routes-app-rs)
- [crates/svc-gateway/src/routes/dev.rs](#crates-svc-gateway-src-routes-dev-rs)
- [crates/svc-gateway/src/routes/health.rs](#crates-svc-gateway-src-routes-health-rs)
- [crates/svc-gateway/src/routes/metrics.rs](#crates-svc-gateway-src-routes-metrics-rs)
- [crates/svc-gateway/src/routes/mod.rs](#crates-svc-gateway-src-routes-mod-rs)
- [crates/svc-gateway/src/routes/objects.rs](#crates-svc-gateway-src-routes-objects-rs)
- [crates/svc-gateway/src/routes/objects_range.rs](#crates-svc-gateway-src-routes-objectsrange-rs)
- [crates/svc-gateway/src/routes/ready.rs](#crates-svc-gateway-src-routes-ready-rs)
- [crates/svc-gateway/src/routes/version.rs](#crates-svc-gateway-src-routes-version-rs)
- [crates/svc-gateway/src/state.rs](#crates-svc-gateway-src-state-rs)
- [crates/svc-gateway/src/tls/mod.rs](#crates-svc-gateway-src-tls-mod-rs)
- [crates/svc-gateway/tests/app_proxy.rs](#crates-svc-gateway-tests-appproxy-rs)
- [crates/svc-gateway/tests/integration/caps_limits.rs](#crates-svc-gateway-tests-integration-capslimits-rs)
- [crates/svc-gateway/tests/integration/interop_vectors.rs](#crates-svc-gateway-tests-integration-interopvectors-rs)
- [crates/svc-gateway/tests/integration/loom_readiness.rs](#crates-svc-gateway-tests-integration-loomreadiness-rs)
- [crates/svc-gateway/tests/integration/readyz_degrade.rs](#crates-svc-gateway-tests-integration-readyzdegrade-rs)
- [crates/svc-gateway/tests/integration/taxonomy_stability.rs](#crates-svc-gateway-tests-integration-taxonomystability-rs)
- [crates/svc-gateway/tests/smoke.rs](#crates-svc-gateway-tests-smoke-rs)
- [crates/svc-gateway/tests/vectors/error_taxonomy.json](#crates-svc-gateway-tests-vectors-errortaxonomy-json)
- [crates/svc-gateway/tests/vectors/manifest_digest.json](#crates-svc-gateway-tests-vectors-manifestdigest-json)
- [crates/svc-gateway/tests/vectors/oap1_frame_roundtrip.json](#crates-svc-gateway-tests-vectors-oap1frameroundtrip-json)

### crates/svc-gateway/.github/workflows/api-stability.yml
<a id="crates-svc-gateway--github-workflows-api-stability-yml"></a>

```yaml
name: api-stability
on:
  pull_request:
    paths:
      - "src/**"
      - "Cargo.toml"
jobs:
  api:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: public api (placeholder)
        run: echo "wire cargo-public-api / semver-checks here"

```

### crates/svc-gateway/.github/workflows/ci.yml
<a id="crates-svc-gateway--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: fmt
        run: cargo fmt --all -- --check
      - name: clippy
        run: cargo clippy --all-targets --all-features -- -D warnings
      - name: test
        run: cargo test --all-features
      - name: deny (licenses/advisories)
        run: echo "placeholder — add cargo-deny later"

```

### crates/svc-gateway/.github/workflows/fuzz-nightly.yml
<a id="crates-svc-gateway--github-workflows-fuzz-nightly-yml"></a>

```yaml
name: fuzz-nightly
on:
  schedule:
    - cron: "0 3 * * *"
jobs:
  fuzz:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: fuzz (placeholder)
        run: echo "wire cargo-fuzz here"

```

### crates/svc-gateway/.github/workflows/perf-guard.yml
<a id="crates-svc-gateway--github-workflows-perf-guard-yml"></a>

```yaml
name: perf-guard
on:
  pull_request:
    paths:
      - "benches/**"
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: benches (placeholder)
        run: echo "run benches, compare benches/baseline.json"

```

### crates/svc-gateway/Cargo.toml
<a id="crates-svc-gateway-Cargo-toml"></a>

```toml
[package]
name = "svc-gateway"
version = "0.1.0"
edition = "2021"
rust-version = "1.78"
license = "MIT OR Apache-2.0"
publish = false
resolver = "2"
build = "build.rs"

[features]
default = []
tls = ["tokio-rustls"]        # enable TLS server via rustls
pq = []                       # reserved for post-quantum toggles
cli = []                      # reserved for a future CLI surface

# --- Crate targets -----------------------------------------------------------

[lib]
name = "svc_gateway"          # underscores for the lib crate name
path = "src/lib.rs"

[[bin]]
name = "svc-gateway"          # hyphen ok for the binary name
path = "src/main.rs"

# --- Dependencies ------------------------------------------------------------

[dependencies]
anyhow = "1"
thiserror = "1"

# Axum stack (minimal features; stays on Tower 0.5)
axum = { version = "0.7", default-features = false, features = ["http1", "http2", "json", "tokio"] }
http = "1"
hyper = { version = "1", features = ["http1", "http2", "server"] }

# Ensure Tower 0.5 only (matches axum 0.7 and tower-http 0.6)
tower = { version = "0.5", features = ["util","timeout"] }
tower-http = { version = "0.6", features = [
  "trace",
  "request-id",
  "util",
  "cors",
  "limit",
  "timeout",
  "compression-full",
  "decompression-full",
  "set-header",
  "catch-panic"
] }

tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "io-util", "time"] }
tokio-util = "0.7"
tokio-rustls = { version = "0.26", optional = true }

prometheus = "0.14"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
once_cell = "1"
bytes = "1"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter", "json"] }
humantime = "2"
byte-unit = { version = "5", default-features = false, features = ["byte"] }
percent-encoding = "2"
uuid = { version = "1", features = ["v4"] }
headers = "0.4"
mime = "0.3"
futures-util = "0.3"

# HTTP client for app-plane hop → omnigate
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls-native-roots", "json"] }

# Internal workspace crates
ron-kernel  = { path = "../ron-kernel" }
ron-metrics = { path = "../ron-metrics" }
ron-bus     = { path = "../ron-bus" }
ron-proto   = { path = "../ron-proto" }

[dev-dependencies]
tokio   = { version = "1", features = ["rt-multi-thread", "macros", "time"] }

[build-dependencies]

```

### crates/svc-gateway/benches/baseline.json
<a id="crates-svc-gateway-benches-baseline-json"></a>

```json
{
  "_comment": "Performance baseline placeholder. Fill with real numbers after first bench run."
}

```

### crates/svc-gateway/benches/bench_gateway.sh
<a id="crates-svc-gateway-benches-benchgateway-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

: "${BIND_ADDR:=127.0.0.1:5304}"
: "${HEALTH_PATH:=/healthz}"
: "${READY_PATH:=/readyz}"
: "${DEV_RL_PATH:=/dev/rl}"
: "${DEV_ECHO_PATH:=/dev/echo}"

# Load gen knobs
: "${DUR:=30s}"
: "${THREADS:=4}"
: "${CONNS:=128}"
: "${QPS:=0}"           # 0 = unlimited for hey; ignored by wrk

# Gateway knobs (explicit to make runs reproducible)
: "${SVC_GATEWAY_DEV_ROUTES:=${SVC_GATEWAY_DEV:-1}}"
: "${SVC_GATEWAY_READY_TIMEOUT_MS:=1000}"
: "${SVC_GATEWAY_READY_MAX_INFLIGHT:=1024}"
: "${SVC_GATEWAY_RL_RPS:=3}"
: "${SVC_GATEWAY_RL_BURST:=5}"
: "${SVC_GATEWAY_RL_TARPIT_MS:=0}"    # 0 = no tarpit (keeps /dev/rl bench fast)
: "${SVC_GATEWAY_MAX_BODY_BYTES:=1048576}" # 1 MiB
: "${SVC_GATEWAY_DEV_READY:=1}"            # force ready during health/ready bench
: "${SVC_GATEWAY_READY_SLEEP_MS:=0}"

LOG_DIR="${LOG_DIR:-./target/bench-logs}"
mkdir -p "$LOG_DIR"

echo "killing any existing svc-gateway…"
pkill -f svc-gateway || true
sleep 0.2

echo "starting gateway…"
GLOG="$LOG_DIR/gateway.log"
BIND_ADDR="$BIND_ADDR" \
SVC_GATEWAY_DEV_ROUTES="$SVC_GATEWAY_DEV_ROUTES" \
SVC_GATEWAY_READY_TIMEOUT_MS="$SVC_GATEWAY_READY_TIMEOUT_MS" \
SVC_GATEWAY_READY_MAX_INFLIGHT="$SVC_GATEWAY_READY_MAX_INFLIGHT" \
SVC_GATEWAY_RL_RPS="$SVC_GATEWAY_RL_RPS" \
SVC_GATEWAY_RL_BURST="$SVC_GATEWAY_RL_BURST" \
SVC_GATEWAY_RL_TARPIT_MS="$SVC_GATEWAY_RL_TARPIT_MS" \
SVC_GATEWAY_MAX_BODY_BYTES="$SVC_GATEWAY_MAX_BODY_BYTES" \
SVC_GATEWAY_DEV_READY="$SVC_GATEWAY_DEV_READY" \
SVC_GATEWAY_READY_SLEEP_MS="$SVC_GATEWAY_READY_SLEEP_MS" \
RUST_LOG="${RUST_LOG:-info,svc_gateway=debug}" \
cargo run -p svc-gateway >"$GLOG" 2>&1 &

PID=$!
trap 'kill "$PID" 2>/dev/null || true' EXIT
echo "PID: $PID (logs -> $GLOG)"

# wait for health
att=0
until [ $att -ge 100 ]; do
  code="$(curl -s -o /dev/null -w "%{http_code}" "http://${BIND_ADDR}${HEALTH_PATH}" || true)"
  [ "$code" = "200" ] && break
  att=$((att+1)); sleep 0.1
done
[ "$code" = "200" ] || { echo "gateway not ready"; tail -n 120 "$GLOG" || true; exit 1; }

have_hey=0; have_wrk=0
command -v hey >/dev/null && have_hey=1
command -v wrk >/dev/null && have_wrk=1
[ "$have_hey" = 0 ] && [ "$have_wrk" = 0 ] && { echo "install hey or wrk"; exit 1; }

bench_hey() {
  local name="$1" url="$2"
  local out="$LOG_DIR/${name}_hey.txt"
  local q=()
  [ "$QPS" != "0" ] && q=(-q "$QPS")
  echo "== hey: $name -> $url"
  hey -z "$DUR" -c "$CONNS" "${q[@]}" "$url" | tee "$out"
}

bench_wrk() {
  local name="$1" url="$2"
  local out="$LOG_DIR/${name}_wrk.txt"
  echo "== wrk: $name -> $url"
  wrk -t"$THREADS" -c"$CONNS" -d"$DUR" "$url" | tee "$out"
}

bench() {
  local name="$1" path="$2"
  local url="http://${BIND_ADDR}${path}"
  if [ "$have_hey" = 1 ]; then bench_hey "$name" "$url"; else bench_wrk "$name" "$url"; fi
}

echo
echo "===== 1) Fast path: ${HEALTH_PATH} ====="
bench "healthz" "$HEALTH_PATH"

echo
echo "===== 2) Guarded path: ${READY_PATH} (no sleep, forced ready) ====="
bench "readyz" "$READY_PATH"

echo
echo "===== 3) Rejection hot path: ${DEV_RL_PATH} (will produce 429s) ====="
bench "dev_rl" "$DEV_RL_PATH"

echo
echo "===== 4) Rejection hot path: ${DEV_ECHO_PATH} (413 via body cap) ====="
bigfile="$(mktemp)"; head -c $((SVC_GATEWAY_MAX_BODY_BYTES+1024)) </dev/zero | tr '\0' 'A' > "$bigfile"
for i in $(seq 1 10); do
  curl -s -o /dev/null -w "%{http_code}\n" -X POST --data-binary @"$bigfile" "http://${BIND_ADDR}${DEV_ECHO_PATH}"
done | tee "$LOG_DIR/dev_echo_413.txt"
rm -f "$bigfile"

echo
echo "===== 5) Metrics snapshot ====="
curl -s "http://${BIND_ADDR}/metrics" \
 | grep -E 'gateway_http_requests_total|gateway_request_latency_seconds|gateway_rejections_total' \
 | sed -n '1,200p' > "$LOG_DIR/metrics.txt"
sed -n '1,200p' "$LOG_DIR/metrics.txt"

echo "Done. To stop: kill $PID"

```

### crates/svc-gateway/build.rs
<a id="crates-svc-gateway-build-rs"></a>

```rust
// Stamp SVC_GATEWAY_BUILD_TS (UNIX seconds) into the binary at compile time.
// Zero deps; works in any workspace layout.
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    // Ensure rebuild when these change (the git lines are optional)
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs");

    let ts = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_secs())
        .unwrap_or(0);

    println!("cargo:rustc-env=SVC_GATEWAY_BUILD_TS={}", ts);
}

```

### crates/svc-gateway/configs/svc-gateway.sample.toml
<a id="crates-svc-gateway-configs-svc-gateway-sample-toml"></a>

```toml
# Sample config — svc-gateway2
# Role: Declarative knobs (timeouts, caps, quotas, amnesia, PQ/TLS policy).
[server]
bind = "127.0.0.1:9300"
metrics_bind = "127.0.0.1:9301"

[caps]
body_max_bytes = 1048576      # 1 MiB
decoded_max_bytes = 8388608   # 8 MiB
decoded_ratio_max = 10.0

[limits]
global_rps = 500

[amnesia]
enabled = true

[pq]
hybrid_enabled = false

```

### crates/svc-gateway/fuzz/targets/oap_frame.rs
<a id="crates-svc-gateway-fuzz-targets-oapframe-rs"></a>

```rust
//! oap_frame.rs — fuzz target placeholder.
//! Role: enforce 1 MiB frame invariants in OAP/1 envelope parsing.

```

### crates/svc-gateway/fuzz/targets/taxonomy_mapper.rs
<a id="crates-svc-gateway-fuzz-targets-taxonomymapper-rs"></a>

```rust
//! taxonomy_mapper.rs — fuzz target placeholder.
//! Role: guarantee deterministic, bounded error mapping.

```

### crates/svc-gateway/scripts/chaos_burst.sh
<a id="crates-svc-gateway-scripts-chaosburst-sh"></a>

```bash
#!/usr/bin/env bash
# Burst traffic and simulate downstream slowness (placeholder).
set -euo pipefail
echo "chaos_burst placeholder — add chaos injection once routes exist"

```

### crates/svc-gateway/scripts/decode_guard_smoke.sh
<a id="crates-svc-gateway-scripts-decodeguardsmoke-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# One-shot test for decode guard:
# - gzip body -> 413 encoded_body_unsupported (or decoded_cap if your cap is tiny)
# - stacked encodings -> 415 stacked_encoding
# - declared len > cap -> 413 decoded_cap
#
# Starts the gateway with DEV routes + metrics and DECODE_ABS_CAP_BYTES=8,
# runs probes, prints relevant metrics, and stops the process.

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || echo .)"
PID_FILE="$ROOT/target/gateway.pid"

export SVC_GATEWAY_DEV_ROUTES=1
export SVC_GATEWAY_DEV_METRICS=1
export SVC_GATEWAY_DECODE_ABS_CAP_BYTES=8

"${ROOT}/crates/svc-gateway/scripts/run_gateway.sh"

PID="$(cat "$PID_FILE")"
sleep 0.4

echo
echo "== 1) encoded body (gzip) => expect 415 encoded_body_unsupported (or 413 if cap trips)"
printf hi | gzip | curl -s -i -X POST --data-binary @- \
  -H 'Content-Encoding: gzip' \
  http://127.0.0.1:5304/dev/echo | sed -n '1,20p'

echo
echo "== 2) stacked encodings => expect 415 stacked_encoding"
curl -s -i -X POST --data-binary 'x' \
  -H 'Content-Encoding: gzip, br' \
  http://127.0.0.1:5304/dev/echo | sed -n '1,20p'

echo
echo "== 3) declared length > cap (16 > 8) => expect 413 decoded_cap"
curl -s -i -X POST --data-binary @<(head -c 16 </dev/zero | tr '\0' A) \
  http://127.0.0.1:5304/dev/echo | sed -n '1,20p'

echo
echo "== metrics snapshot (decode-related rejects) =="
curl -s http://127.0.0.1:5304/metrics | egrep 'gateway_rejections_total{reason="(decode_cap|stacked_encoding|encoded_body)"}' || true

"${ROOT}/crates/svc-gateway/scripts/stop_gateway.sh"

```

### crates/svc-gateway/scripts/dev_run.sh
<a id="crates-svc-gateway-scripts-devrun-sh"></a>

```bash
#!/usr/bin/env bash
# Starts svc-gateway2 with local env/config (placeholder runtime).
set -euo pipefail
echo "dev_run placeholder — wire up cargo run once implemented"

```

### crates/svc-gateway/scripts/export_metrics.sh
<a id="crates-svc-gateway-scripts-exportmetrics-sh"></a>

```bash
#!/usr/bin/env bash
# Quick metrics scrape (placeholder).
set -euo pipefail
curl -s http://127.0.0.1:9301/metrics || echo "metrics endpoint not yet implemented"

```

### crates/svc-gateway/scripts/run_gateway.sh
<a id="crates-svc-gateway-scripts-rungateway-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Minimal runner that builds, starts svc-gateway, waits for /healthz,
# prints first metrics lines, and writes the PID to ./target/gateway.pid.

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || echo .)"
CRATE_DIR="$ROOT/crates/svc-gateway"
PID_FILE="$ROOT/target/gateway.pid"
LOG_DIR="$ROOT/target/run-logs"
LOG_FILE="$LOG_DIR/gateway.log"

mkdir -p "$LOG_DIR"

echo "fmt + clippy + build…"
cargo fmt -p svc-gateway
cargo clippy -p svc-gateway --no-deps -- -D warnings
cargo build -p svc-gateway

echo "killing old svc-gateway (if any)…"
if [[ -f "$PID_FILE" ]]; then
  OLD_PID="$(cat "$PID_FILE" || true)"
  if [[ -n "${OLD_PID:-}" ]] && ps -p "$OLD_PID" >/dev/null 2>&1; then
    kill "$OLD_PID" || true
    sleep 0.2
  fi
  rm -f "$PID_FILE"
fi
pkill -f 'svc-gateway' 2>/dev/null || true

echo "starting svc-gateway…"
# Honor caller-provided env like SVC_GATEWAY_DEV_ROUTES etc.
RUST_LOG="${RUST_LOG:-info,svc_gateway=debug}" \
cargo run -p svc-gateway >"$LOG_FILE" 2>&1 &

GWPID=$!
echo "$GWPID" > "$PID_FILE"
echo "PID: $GWPID (logs: $LOG_FILE)"

# Short grace before first probe (avoid noisy connection-refused)
sleep 1

# Wait until /healthz answers (quiet probes)
printf "waiting for /healthz… "
for i in {1..60}; do
  if curl -fsS --max-time 0.2 http://127.0.0.1:5304/healthz >/dev/null 2>&1; then
    echo "ready."
    break
  fi
  sleep 0.2
  if ! ps -p "$GWPID" >/dev/null 2>&1; then
    echo "gateway exited early; last 60 lines:"
    tail -n 60 "$LOG_FILE" || true
    exit 1
  fi
done

echo "healthz:"
curl -is http://127.0.0.1:5304/healthz | sed -n '1,12p'

echo "readyz:"
curl -is http://127.0.0.1:5304/readyz  | sed -n '1,12p' || true

echo
echo "metrics (first lines):"
curl -s http://127.0.0.1:5304/metrics | head -n 12 || true

echo "Done. Gateway is running (PID $(cat "$PID_FILE")). To stop: crates/svc-gateway/scripts/stop_gateway.sh"

```

### crates/svc-gateway/scripts/sanity_rate_limit.sh
<a id="crates-svc-gateway-scripts-sanityratelimit-sh"></a>

```bash
#!/usr/bin/env bash
# Deterministic sanity for rate_limit: expect 200 then 429s.
set -euo pipefail

# -------- Knobs (override via env) --------
: "${BIND_ADDR:=127.0.0.1:5304}"
: "${SVC_GATEWAY_DEV_ROUTES:=1}"   # enable /dev/*
: "${SVC_GATEWAY_RL_RPS:=1}"       # 1 token/sec
: "${SVC_GATEWAY_RL_BURST:=1}"     # burst = 1 token
: "${SVC_GATEWAY_RL_TARPIT_MS:=0}" # no tarpit to keep it snappy
: "${RUST_LOG:=info,svc_gateway=debug}"
: "${WAIT_MS:=10000}"              # up to 10s for /healthz

log="$(mktemp -t svc-gateway-sanity.XXXXXX.log)"
pids=()

cleanup() {
  set +e
  if [ "${#pids[@]}" -gt 0 ]; then
    for p in "${pids[@]}"; do kill "$p" 2>/dev/null || true; done
  fi
}
trap cleanup EXIT

echo "killing any prior gateway…"
pkill -f svc-gateway || true
sleep 0.2

echo "priming build…"
cargo build -p svc-gateway >/dev/null

echo "starting gateway (RPS=$SVC_GATEWAY_RL_RPS BURST=$SVC_GATEWAY_RL_BURST TARPIT=${SVC_GATEWAY_RL_TARPIT_MS}ms)…"
BIND_ADDR="$BIND_ADDR" \
SVC_GATEWAY_DEV_ROUTES="$SVC_GATEWAY_DEV_ROUTES" \
SVC_GATEWAY_RL_RPS="$SVC_GATEWAY_RL_RPS" \
SVC_GATEWAY_RL_BURST="$SVC_GATEWAY_RL_BURST" \
SVC_GATEWAY_RL_TARPIT_MS="$SVC_GATEWAY_RL_TARPIT_MS" \
RUST_LOG="$RUST_LOG" \
cargo run -p svc-gateway >"$log" 2>&1 &

PID=$!
pids+=("$PID")
echo "PID: $PID (logs: $log)"

# -------- Wait for /healthz (portable: attempts * 100ms) --------
attempts=$(( (WAIT_MS + 99) / 100 ))  # ceil(WAIT_MS/100)
code=""
for _ in $(seq 1 "$attempts"); do
  if ! kill -0 "$PID" 2>/dev/null; then
    echo "gateway exited early"; tail -n 120 "$log" || true; exit 1
  fi
  code="$(curl -s -o /dev/null -w '%{http_code}' "http://${BIND_ADDR}/healthz" || true)"
  [ "$code" = "200" ] && break
  sleep 0.1
done
[ "$code" = "200" ] || { echo "gateway not healthy in ${WAIT_MS}ms"; tail -n 200 "$log" || true; exit 1; }
echo "gateway healthy."

# -------- Deterministic 3-hit probe --------
hit() { curl -s -o /dev/null -w '%{http_code}' "http://${BIND_ADDR}/dev/rl" || echo "ERR"; }

echo "probing /dev/rl (3 rapid hits; expect 200 then 429/429)…"
c1="$(hit)"; echo "hit 1 -> $c1"
c2="$(hit)"; echo "hit 2 -> $c2"
c3="$(hit)"; echo "hit 3 -> $c3"

# -------- Validate expectation --------
errs=0; [ "$c1" = "ERR" ] && errs=$((errs+1)); [ "$c2" = "ERR" ] && errs=$((errs+1)); [ "$c3" = "ERR" ] && errs=$((errs+1))

if [ "$c1" != "200" ] || [ $errs -gt 0 ]; then
  echo "FAIL: expected hit1=200 and no curl errors; saw: $c1 $c2 $c3 (ERRS=$errs)"
  echo "--- tail logs ($log) ---"; tail -n 200 "$log" || true
  echo "--- metrics (snippet) ---"
  curl -s "http://${BIND_ADDR}/metrics" | grep -E 'gateway_rejections_total\{reason="rate_limit"\}|gateway_http_requests_total\{.*dev_rl' || true
  exit 2
fi

count_429=0
[ "$c2" = "429" ] && count_429=$((count_429+1))
[ "$c3" = "429" ] && count_429=$((count_429+1))

if [ $count_429 -lt 1 ]; then
  echo "FAIL: expected at least one 429 under RPS=1,BURST=1 but saw: $c1 $c2 $c3"
  echo "--- tail logs ---"; tail -n 200 "$log" || true
  echo "--- metrics (snippet) ---"
  curl -s "http://${BIND_ADDR}/metrics" | grep -E 'gateway_rejections_total\{reason="rate_limit"\}|gateway_http_requests_total\{.*dev_rl' || true
  exit 3
fi

echo "OK: observed $count_429 x 429 (as expected)."
echo "metrics (rate_limit counters):"
curl -s "http://${BIND_ADDR}/metrics" | grep -E 'gateway_rejections_total\{reason="rate_limit"\}|gateway_http_requests_total\{.*dev_rl' || true

echo "Done. To stop: kill $PID (or Ctrl-C to trigger trap)."

```

### crates/svc-gateway/scripts/smoke_gateway.sh
<a id="crates-svc-gateway-scripts-smokegateway-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

echo "fmt+clippy+build…"
cargo fmt -p svc-gateway
cargo clippy -p svc-gateway --no-deps -- -D warnings
cargo build -p svc-gateway

pkill -f svc-gateway || true
RUST_LOG=info,target=svc_gateway=debug cargo run -p svc-gateway &

sleep 0.5
echo "healthz:";  curl -si http://127.0.0.1:5304/healthz | head -n 1
echo "readyz:";   curl -si http://127.0.0.1:5304/readyz  | head -n 1
echo "metrics:";  curl -s  http://127.0.0.1:5304/metrics | head -n 10

```

### crates/svc-gateway/scripts/soak_test.sh
<a id="crates-svc-gateway-scripts-soaktest-sh"></a>

```bash
#!/usr/bin/env bash
# Long-running load to validate SLOs (placeholder).
set -euo pipefail
echo "soak_test placeholder — integrate your load tool"

```

### crates/svc-gateway/scripts/stop_gateway.sh
<a id="crates-svc-gateway-scripts-stopgateway-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || echo .)"
PID_FILE="$ROOT/target/gateway.pid"

if [[ -f "$PID_FILE" ]]; then
  PID="$(cat "$PID_FILE" || true)"
  if [[ -n "${PID:-}" ]] && ps -p "$PID" >/dev/null 2>&1; then
    echo "Stopping svc-gateway (PID $PID)…"
    kill "$PID" || true
    sleep 0.3
    if ps -p "$PID" >/dev/null 2>&1; then
      echo "Sending SIGKILL…"
      kill -9 "$PID" || true
    fi
  else
    echo "No live process found for PID file."
  fi
  rm -f "$PID_FILE"
else
  echo "No PID file; trying pkill fallback…"
  pkill -f 'svc-gateway' 2>/dev/null || true
fi

echo "Stopped."

```

### crates/svc-gateway/scripts/test_body_cap.sh
<a id="crates-svc-gateway-scripts-testbodycap-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

: "${BIND_ADDR:=127.0.0.1:5304}"
: "${SVC_GATEWAY_DEV_ROUTES:=1}"          # enable /dev/echo
: "${SVC_GATEWAY_MAX_BODY_BYTES:=1024}"   # 1 KiB limit for the test
: "${RUST_LOG:=info,svc_gateway=debug}"

echo "killing old gateway (if any)…"
pkill -f svc-gateway || true
sleep 0.2

echo "start gateway with body cap..."
log="$(mktemp -t svc-gateway-test.XXXXXX.log)"
BIND_ADDR="$BIND_ADDR" \
SVC_GATEWAY_DEV_ROUTES="$SVC_GATEWAY_DEV_ROUTES" \
SVC_GATEWAY_MAX_BODY_BYTES="$SVC_GATEWAY_MAX_BODY_BYTES" \
RUST_LOG="$RUST_LOG" \
cargo run -p svc-gateway >"$log" 2>&1 &
PID=$!
echo "PID: $PID (logs: $log)"

# wait for /healthz up, but also detect early process death
att=0
code=""
while [ $att -lt 100 ]; do
  if ! kill -0 "$PID" 2>/dev/null; then
    echo "gateway process exited early. recent log:"
    tail -n 80 "$log" || true
    exit 1
  fi
  code="$(curl -s -o /dev/null -w "%{http_code}" "http://${BIND_ADDR}/healthz" || true)"
  [ "$code" = "200" ] && break
  att=$((att+1))
  sleep 0.1
done
if [ "$code" != "200" ]; then
  echo "gateway not up (last code: ${code:-none}). recent log:"
  tail -n 80 "$log" || true
  exit 1
fi

echo "== small ok =="
printf 'hi' | curl -s -i -X POST --data-binary @- "http://${BIND_ADDR}/dev/echo" | sed -n '1,10p'

echo "== too big =="
bigfile="$(mktemp)"
head -c 2048 </dev/zero | tr '\0' 'A' > "$bigfile"
curl -s -i -X POST --data-binary @"$bigfile" "http://${BIND_ADDR}/dev/echo" | sed -n '1,10p'
rm -f "$bigfile"

echo "== metrics =="
curl -s "http://${BIND_ADDR}/metrics" | grep -E 'gateway_rejections_total\{reason="body_cap"\}|gateway_ready_' | sed -n '1,50p'

echo "Done. To stop: kill $PID"

```

### crates/svc-gateway/scripts/test_rate_limit.sh
<a id="crates-svc-gateway-scripts-testratelimit-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

: "${BIND_ADDR:=127.0.0.1:5304}"
: "${PAR:=20}"                 # concurrent requests
: "${REQ_TIMEOUT:=2}"          # seconds per HTTP request max
: "${CONNECT_TIMEOUT:=1}"

# Force dev routes on regardless of shell env
export SVC_GATEWAY_DEV_ROUTES=1
export SVC_GATEWAY_DEV=1

: "${SVC_GATEWAY_RL_RPS:=3}"
: "${SVC_GATEWAY_RL_BURST:=5}"
: "${SVC_GATEWAY_RL_TARPIT_MS:=0}"
: "${RUST_LOG:=info,svc_gateway=debug}"

echo "killing old gateway (if any)…"
pkill -f svc-gateway || true
sleep 0.2

echo "start gateway with RL rps=${SVC_GATEWAY_RL_RPS} burst=${SVC_GATEWAY_RL_BURST} tarpit=${SVC_GATEWAY_RL_TARPIT_MS}ms..."
log="$(mktemp -t svc-gateway-rl.XXXXXX.log)"
BIND_ADDR="$BIND_ADDR" \
SVC_GATEWAY_RL_RPS="$SVC_GATEWAY_RL_RPS" \
SVC_GATEWAY_RL_BURST="$SVC_GATEWAY_RL_BURST" \
SVC_GATEWAY_RL_TARPIT_MS="$SVC_GATEWAY_RL_TARPIT_MS" \
RUST_LOG="$RUST_LOG" \
cargo run -p svc-gateway >"$log" 2>&1 &

PID=$!
echo "PID: $PID (logs: $log)"

# Wait for health
att=0; code=""
while [ $att -lt 100 ]; do
  if ! kill -0 "$PID" 2>/dev/null; then tail -n 200 "$log" || true; exit 1; fi
  code="$(curl -s -o /dev/null -w "%{http_code}" "http://${BIND_ADDR}/healthz" || true)"
  [ "$code" = "200" ] && break
  att=$((att+1)); sleep 0.1
done
[ "$code" = "200" ] || { echo "gateway not up"; tail -n 200 "$log" || true; exit 1; }

# Global watchdog so this script can never hang
WATCHDOG_SECS=$((REQ_TIMEOUT + 8))
( sleep "$WATCHDOG_SECS"; if ps -p "$PID" >/dev/null 2>&1; then
    echo "Watchdog: requests still running after ${WATCHDOG_SECS}s; dumping logs…"
    tail -n 200 "$log" || true
  fi ) & WD=$!

echo "bursting /dev/rl… (${PAR} concurrent hits)"
tmp="$(mktemp -t rl_hits.XXXXXX)"

# IMPORTANT: temporarily relax -e/pipefail for this pipeline so any single timeout
# doesn’t kill the whole script. We restore strict mode immediately after.
set +e
( yes 1 | head -n "$PAR" | xargs -P "$PAR" -I{} \
  sh -c '
    code=$(curl -sS -o /dev/null \
      --connect-timeout '"$CONNECT_TIMEOUT"' \
      --max-time '"$REQ_TIMEOUT"' \
      -w "%{http_code}" "http://'"$BIND_ADDR"'/dev/rl" 2>/dev/null || echo 000);
    echo "$code"
  ' ) >>"$tmp"
xargs_rc=$?
set -e

# Kill watchdog (we finished requests batch, even if some errored)
kill "$WD" >/dev/null 2>&1 || true

if [ $xargs_rc -ne 0 ]; then
  echo "note: some requests failed (xargs rc=$xargs_rc); see tallies and logs below."
fi

# Tally
ok=$(grep -c '^200$' "$tmp" || true)
rl=$(grep -c '^429$' "$tmp" || true)
ot=$(grep -c '^000$' "$tmp" || true)
echo "OK: $ok  RL(429): $rl  ERR/TO: $ot"

echo "metrics:"
curl -s "http://${BIND_ADDR}/metrics" | grep -E 'gateway_rejections_total\{reason="rate_limit"\}' || true

echo "Done. To stop: kill $PID"

```

### crates/svc-gateway/src/admission/capabilities.rs
<a id="crates-svc-gateway-src-admission-capabilities-rs"></a>

```rust
#[must_use]
pub fn has_cap(_cap: &str) -> bool {
    // Stub: wire to passport/policy later.
    true
}

```

### crates/svc-gateway/src/admission/classifier.rs
<a id="crates-svc-gateway-src-admission-classifier-rs"></a>

```rust
#[must_use]
pub fn classify(_path: &str) -> &'static str {
    // Stub: return a class label that DRR/rate-limiters might key on later.
    "default"
}

```

### crates/svc-gateway/src/admission/mod.rs
<a id="crates-svc-gateway-src-admission-mod-rs"></a>

```rust
//! Admission classifiers & quotas (stubs now).
pub mod capabilities;
pub mod classifier;
pub mod payments;
pub mod quotas;
pub mod residency;
pub mod taxonomy;

```

### crates/svc-gateway/src/admission/payments.rs
<a id="crates-svc-gateway-src-admission-payments-rs"></a>

```rust
//! admission/payments.rs — (feature = "econ") enforce paid writes/prepaid quotas — placeholder.

```

### crates/svc-gateway/src/admission/quotas.rs
<a id="crates-svc-gateway-src-admission-quotas-rs"></a>

```rust
#[must_use]
pub fn allow(_tenant: &str) -> bool {
    // Stub: tie into svc-index/svc-registry later.
    true
}

```

### crates/svc-gateway/src/admission/residency.rs
<a id="crates-svc-gateway-src-admission-residency-rs"></a>

```rust
//! admission/residency.rs — Thin adapter to `policy::residency` — placeholder.

#[must_use]
pub fn region_ok(_tenant: &str, _region: &str) -> bool {
    true
}

```

### crates/svc-gateway/src/admission/taxonomy.rs
<a id="crates-svc-gateway-src-admission-taxonomy-rs"></a>

```rust
//! admission/taxonomy.rs — Deterministic reason/status mapping — placeholder.

```

### crates/svc-gateway/src/cli/mod.rs
<a id="crates-svc-gateway-src-cli-mod-rs"></a>

```rust
//! cli/mod.rs — CLI flags (binds, pq policy, econ enforcement) — placeholder.

```

### crates/svc-gateway/src/config/amnesia.rs
<a id="crates-svc-gateway-src-config-amnesia-rs"></a>

```rust
//! Amnesia-mode toggles (RAM-only, extra redaction).
//! Operator doc references.

/// Whether amnesia mode is enabled for this process.
///
/// In this slice this is a simple stub wired via config defaults/env later.
#[inline]
#[must_use]
pub fn amnesia_enabled() -> bool {
    false
}

```

### crates/svc-gateway/src/config/env.rs
<a id="crates-svc-gateway-src-config-env-rs"></a>

```rust
//! Env-driven config overrides for svc-gateway.
//!
//! RO:WHAT  Small helper to project selected env vars onto `Config`.
//! RO:WHY   Keeps `Config::load()` simple and testable.

use std::net::SocketAddr;

use anyhow::{Context, Result};

use super::Config;

/// Apply environment variable overrides onto a mutable `Config`.
///
/// Supported keys:
/// - `SVC_GATEWAY_BIND_ADDR` or `BIND_ADDR`
/// - `SVC_GATEWAY_MAX_BODY_BYTES`
/// - `SVC_GATEWAY_DECODE_ABS_CAP_BYTES`
/// - `SVC_GATEWAY_OMNIGATE_BASE_URL`
///
/// # Errors
///
/// Returns an error if any present env value is malformed (e.g., invalid
/// socket address or integer).
pub fn apply_env_overrides(cfg: &mut Config) -> Result<()> {
    // Bind addr: prefer svc-specific, fall back to legacy BIND_ADDR.
    if let Ok(addr) = std::env::var("SVC_GATEWAY_BIND_ADDR").or_else(|_| std::env::var("BIND_ADDR"))
    {
        validate_bind_addr(&addr).context("invalid SVC_GATEWAY_BIND_ADDR/BIND_ADDR")?;
        cfg.server.bind_addr = addr;
    }

    // Max body bytes (request cap).
    if let Ok(v) = std::env::var("SVC_GATEWAY_MAX_BODY_BYTES") {
        let n: u64 = v
            .parse()
            .context("invalid SVC_GATEWAY_MAX_BODY_BYTES (expected u64)")?;
        cfg.limits.max_body_bytes = n;
    }

    // Decode absolute cap bytes.
    if let Ok(v) = std::env::var("SVC_GATEWAY_DECODE_ABS_CAP_BYTES") {
        let n: u64 = v
            .parse()
            .context("invalid SVC_GATEWAY_DECODE_ABS_CAP_BYTES (expected u64)")?;
        cfg.limits.decode_abs_cap_bytes = n;
    }

    // Omnigate app-plane base URL.
    if let Ok(v) = std::env::var("SVC_GATEWAY_OMNIGATE_BASE_URL") {
        cfg.upstreams.omnigate_base_url = v;
    }

    Ok(())
}

/// Parse and validate a `SocketAddr` for the bind address.
///
/// # Errors
///
/// Returns an error if the string is not a valid socket address.
fn validate_bind_addr(s: &str) -> Result<SocketAddr> {
    s.parse::<SocketAddr>()
        .with_context(|| format!("invalid bind addr {s}"))
}

```

### crates/svc-gateway/src/config/mod.rs
<a id="crates-svc-gateway-src-config-mod-rs"></a>

```rust
//! Config model + defaults for svc-gateway.
//!
//! RO:WHAT  Minimal config for bind addr, caps, and omnigate upstream.
//! RO:WHY   Keep it small and env-driven for now; TOML/FS loaders can plug in later.

use crate::consts::{
    DEFAULT_BODY_CAP_BYTES, DEFAULT_DECODE_ABS_CAP_BYTES, DEFAULT_MAX_CONNS, DEFAULT_RPS,
};
use serde::Deserialize;

pub mod env;

/// Server-level configuration (bind addr, connection caps, RPS).
#[derive(Debug, Clone, Deserialize)]
pub struct Server {
    /// Socket address to bind the HTTP listener to.
    pub bind_addr: String,
    /// Maximum concurrent connections accepted by the listener.
    pub max_conns: usize,
    /// Target requests-per-second for simple rate limiting.
    pub rps: u64,
}

/// Request/response body limits and decompression caps.
#[derive(Debug, Clone, Deserialize)]
pub struct Limits {
    /// Maximum accepted request body size in bytes.
    pub max_body_bytes: u64,
    /// Absolute cap on decompressed body bytes.
    pub decode_abs_cap_bytes: u64,
}

/// Amnesia / logging / disk toggle placeholder.
#[derive(Debug, Clone, Default, Deserialize)]
pub struct Amnesia {
    /// When true, prefer RAM-only behavior and avoid disk where possible.
    pub enabled: bool,
}

/// Upstream service endpoints (omnigate app plane, later storage/overlay/index).
#[derive(Debug, Clone, Deserialize)]
pub struct Upstreams {
    /// Base URL for omnigate app plane (e.g. <http://127.0.0.1:9090>).
    pub omnigate_base_url: String,
}

fn default_bind_addr() -> String {
    "127.0.0.1:5304".to_owned()
}

fn default_omnigate_base_url() -> String {
    "http://127.0.0.1:9090".to_owned()
}

impl Default for Server {
    fn default() -> Self {
        Self {
            bind_addr: default_bind_addr(),
            max_conns: DEFAULT_MAX_CONNS,
            rps: DEFAULT_RPS,
        }
    }
}

impl Default for Limits {
    fn default() -> Self {
        Self {
            max_body_bytes: DEFAULT_BODY_CAP_BYTES as u64,
            decode_abs_cap_bytes: DEFAULT_DECODE_ABS_CAP_BYTES as u64,
        }
    }
}

impl Default for Upstreams {
    fn default() -> Self {
        Self {
            omnigate_base_url: default_omnigate_base_url(),
        }
    }
}

/// Top-level config for svc-gateway.
///
/// RO:INVARS
/// - Defaults are safe for local dev.
/// - Env overrides are applied via `Config::load()`.
#[derive(Debug, Clone, Deserialize, Default)]
pub struct Config {
    pub server: Server,
    pub limits: Limits,
    pub amnesia: Amnesia,
    pub upstreams: Upstreams,
}

impl Config {
    /// Load configuration from environment variables.
    ///
    /// # Errors
    ///
    /// Returns an error if any env value is malformed.
    pub fn load() -> anyhow::Result<Self> {
        let mut cfg = Self::default();
        env::apply_env_overrides(&mut cfg)?;
        Ok(cfg)
    }
}

```

### crates/svc-gateway/src/config/safety.rs
<a id="crates-svc-gateway-src-config-safety-rs"></a>

```rust
//! Safety guard to prevent weakening defaults unless `danger_ok=true`.
//! Hardening checklist refs. :contentReference[oaicite:7]{index=7}

#[inline]
pub fn assert_safe(danger_ok: bool) {
    if !danger_ok { /* keep defaults enforced */ }
}

```

### crates/svc-gateway/src/consts.rs
<a id="crates-svc-gateway-src-consts-rs"></a>

```rust
// crates/svc-gateway/src/consts.rs
#![allow(clippy::module_name_repetitions)]

pub const DEFAULT_MAX_CONNS: usize = 2_048;

// 1 MiB (avoid `1 * 1024 * 1024` which trips clippy::identity_op)
pub const DEFAULT_BODY_CAP_BYTES: usize = 1_048_576;

// Decompression guard
pub const DEFAULT_DECODE_RATIO_MAX: usize = 10;
pub const DEFAULT_DECODE_ABS_CAP_BYTES: usize = 16 * 1_048_576; // 16 MiB

// Read timeouts
pub const DEFAULT_READ_TIMEOUT_SECS: u64 = 10;
pub const DEFAULT_WRITE_TIMEOUT_SECS: u64 = 10;
pub const DEFAULT_IDLE_TIMEOUT_SECS: u64 = 30;

// Rate limit (as u64 to match config field)
pub const DEFAULT_RPS: u64 = 500;

```

### crates/svc-gateway/src/errors.rs
<a id="crates-svc-gateway-src-errors-rs"></a>

```rust
//! Carry-over: `Problem{code,message,retryable,retry_after_ms?,reason?}`.

use axum::{
    http::{self, HeaderValue, StatusCode},
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;

#[derive(Serialize)]
pub struct Problem<'a> {
    pub code: &'a str,
    pub message: &'a str,
    pub retryable: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retry_after_ms: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<&'a str>,
}

impl Problem<'_> {
    #[must_use]
    pub fn into_response_with(self, status: StatusCode) -> Response {
        (status, Json(self)).into_response()
    }
}

/// 429 Too Many Requests with Retry-After (seconds). Never panics.
pub fn rate_limited_retry_after(ms: u64) -> Response {
    let mut resp = Problem {
        code: "rate_limited",
        message: "Too many requests",
        retryable: true,
        retry_after_ms: Some(ms),
        reason: None,
    }
    .into_response_with(StatusCode::TOO_MANY_REQUESTS);

    // Best-effort Retry-After header; if conversion fails, omit it.
    if let Ok(v) = HeaderValue::from_str(&(ms / 1000).to_string()) {
        let headers = resp.headers_mut();
        headers.insert(http::header::RETRY_AFTER, v);
    }
    resp
}

/// 503 Busy with Retry-After (seconds). Never panics.
pub fn too_busy_retry_after(ms: u64) -> Response {
    let mut resp = Problem {
        code: "too_busy",
        message: "Server busy",
        retryable: true,
        retry_after_ms: Some(ms),
        reason: None,
    }
    .into_response_with(StatusCode::SERVICE_UNAVAILABLE);

    if let Ok(v) = HeaderValue::from_str(&(ms / 1000).to_string()) {
        let headers = resp.headers_mut();
        headers.insert(http::header::RETRY_AFTER, v);
    }
    resp
}

```

### crates/svc-gateway/src/forward/index_client.rs
<a id="crates-svc-gateway-src-forward-indexclient-rs"></a>

```rust
//! Index client stub.

```

### crates/svc-gateway/src/forward/mod.rs
<a id="crates-svc-gateway-src-forward-mod-rs"></a>

```rust
//! Clients to overlay/index/storage (stubs).

pub mod index_client;
pub mod overlay_client;
pub mod storage_client;

```

### crates/svc-gateway/src/forward/overlay_client.rs
<a id="crates-svc-gateway-src-forward-overlayclient-rs"></a>

```rust
/// Fetch raw bytes from overlay given an address + relative path.
///
/// # Errors
///
/// As a stub this never errors and returns an empty vec. When implemented,
/// it will return I/O or protocol errors from the overlay client.
pub fn get_bytes(_addr: &str, _rel: &str) -> anyhow::Result<Vec<u8>> {
    Ok(Vec::new())
}

```

### crates/svc-gateway/src/forward/storage_client.rs
<a id="crates-svc-gateway-src-forward-storageclient-rs"></a>

```rust
//! `forward/storage_client.rs` — Optional: read-only media proxy; range-reads — placeholder.

/// Stubbed storage fetch.
///
/// # Errors
///
/// See `overlay_client` notes (not implemented here yet).
pub fn get_object(_key: &str) -> anyhow::Result<Vec<u8>> {
    Ok(Vec::new())
}

```

### crates/svc-gateway/src/headers/etag.rs
<a id="crates-svc-gateway-src-headers-etag-rs"></a>

```rust
//! Produce a quoted `ETag` value for a BLAKE3 address (e.g., `b3:abcd...`).

#[must_use]
pub fn etag_from_b3(addr: &str) -> String {
    // clippy(pedantic): prefer inline args over `"{}"`
    format!("\"{addr}\"")
}

```

### crates/svc-gateway/src/headers/mod.rs
<a id="crates-svc-gateway-src-headers-mod-rs"></a>

```rust
pub mod etag;

```

### crates/svc-gateway/src/layers/auth.rs
<a id="crates-svc-gateway-src-layers-auth-rs"></a>

```rust
#[must_use]
pub fn enabled() -> bool {
    false
}

```

### crates/svc-gateway/src/layers/body_caps.rs
<a id="crates-svc-gateway-src-layers-bodycaps-rs"></a>

```rust
//! Body-size cap (route-scoped).
//! RO:WHAT  Reject requests with `Content-Length` exceeding a configured cap.
//! RO:WHY   Cheap protection against oversized uploads; observable via metrics.
//! RO:CONF  `SVC_GATEWAY_MAX_BODY_BYTES` (default 1 MiB). Header-only (no streaming).
//! RO:OBS   Increments `gateway_rejections_total{reason="body_cap"}` on reject.

use axum::{
    body::Body,
    http::{Request, StatusCode},
    middleware::Next,
    response::{IntoResponse, Response},
};

/// Middleware: if `Content-Length` is present and exceeds the cap, reject with 413.
///
/// This version is header-only. If `Content-Length` is absent or invalid, we let the request
/// pass through; a streaming cap (for unknown/incorrect lengths) can be added later.
pub async fn body_cap_mw(req: Request<Body>, next: Next) -> Response {
    let cap = std::env::var("SVC_GATEWAY_MAX_BODY_BYTES")
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(1_048_576); // 1 MiB default

    if let Some(len) = req.headers().get(axum::http::header::CONTENT_LENGTH) {
        if let Ok(len_str) = len.to_str() {
            if let Ok(n) = len_str.parse::<u64>() {
                if n > cap {
                    // Reuse the shared rejects counter to avoid AlreadyReg panics.
                    crate::observability::rejects::counter()
                        .with_label_values(&["body_cap"])
                        .inc();
                    return (StatusCode::PAYLOAD_TOO_LARGE, "payload too large").into_response();
                }
            }
        }
    }

    next.run(req).await
}

```

### crates/svc-gateway/src/layers/concurrency.rs
<a id="crates-svc-gateway-src-layers-concurrency-rs"></a>

```rust
//! Concurrency guard (route-scoped).
//! RO:WHAT  Cheap backpressure using a `Semaphore` permit per in-flight request.
//! RO:WHY   Fail fast with `503 Service Unavailable` instead of tail spikes.
//! RO:NOTE  Axum 0.7 middleware shape (`Next` has no generics). Global static,
//!          but applied only to selected routes (e.g., `/readyz`).

use axum::{
    body::Body,
    http::Request,
    middleware::Next,
    response::{IntoResponse, Response},
};
use once_cell::sync::OnceCell;
use tokio::sync::{Semaphore, SemaphorePermit};

fn semaphore() -> &'static Semaphore {
    static SEM: OnceCell<Semaphore> = OnceCell::new();
    SEM.get_or_init(|| {
        // ENV knob, default small to make behavior easy to see locally.
        let max = std::env::var("SVC_GATEWAY_READY_MAX_INFLIGHT")
            .ok()
            .and_then(|s| s.parse::<usize>().ok())
            .unwrap_or(64);
        Semaphore::new(max)
    })
}

/// Acquire a single permit or return 503 when saturated.
pub async fn ready_concurrency_mw(req: Request<Body>, next: Next) -> Response {
    // Fast-fail if saturated (non-blocking).
    let permit: Option<SemaphorePermit<'_>> = semaphore().try_acquire().ok();
    if permit.is_none() {
        return (axum::http::StatusCode::SERVICE_UNAVAILABLE, "busy").into_response();
    }

    // Hold the permit for the duration of the downstream call.
    let _permit = permit;
    next.run(req).await
}

```

### crates/svc-gateway/src/layers/corr.rs
<a id="crates-svc-gateway-src-layers-corr-rs"></a>

```rust
//! Correlation ID middleware (route-scoped).
//! RO:WHAT  Ensure each request has an `x-request-id`; echo it on the response.
//! RO:WHY   Stable correlation for tracing/logs with zero deps.
//! RO:NOTE  Axum 0.7 `Next` has no generic parameter; `Request` must be `Request<Body>`.

use axum::{
    body::Body,
    http::{HeaderValue, Request},
    middleware::Next,
    response::Response,
};
use std::sync::atomic::{AtomicU64, Ordering};

static REQ_COUNTER: AtomicU64 = AtomicU64::new(1);

/// Axum 0.7 middleware entry point.
///
/// # Behavior
/// * Respects incoming `x-request-id` if present and valid UTF-8.
/// * Otherwise synthesizes `r-<hex>` from a monotonic counter (cheap, unique-enough for dev).
/// * Echoes the final id back on the response header.
///
/// # Errors
/// Never errors; always returns a `Response`.
pub async fn mw(mut req: Request<Body>, next: Next) -> Response {
    // Try to get an existing request id.
    let maybe_id = req
        .headers()
        .get("x-request-id")
        .and_then(|v| v.to_str().ok())
        .map(str::to_owned); // clippy: method reference instead of redundant closure

    let id = maybe_id.unwrap_or_else(|| {
        let n = REQ_COUNTER.fetch_add(1, Ordering::Relaxed);
        format!("r-{n:016x}")
    });

    // Ensure header is present for downstream handlers.
    if !req.headers().contains_key("x-request-id") {
        if let Ok(v) = HeaderValue::from_str(&id) {
            req.headers_mut().insert("x-request-id", v);
        }
    }

    let mut resp = next.run(req).await;

    // Always mirror the id back on the response.
    if let Ok(v) = HeaderValue::from_str(&id) {
        resp.headers_mut().insert("x-request-id", v);
    }

    resp
}

```

### crates/svc-gateway/src/layers/decode_guard.rs
<a id="crates-svc-gateway-src-layers-decodeguard-rs"></a>

```rust
//! Decode guard: reject stacked encodings and enforce decoded absolute cap.
//!
//! MVP behavior (no on-the-fly decompression yet):
//! - If `Content-Encoding` has multiple values (comma-separated) → 415 `stacked_encoding`
//! - If `Content-Encoding` is one of {gzip, deflate, br, zstd} → 415 `encoded_body_unsupported`
//! - If `Content-Length` > `SVC_GATEWAY_DECODE_ABS_CAP_BYTES` (or config default) → 413 `decoded_cap`
//!
//! Metrics: increments `gateway_rejections_total{reason=...}`
//!
//! Future: replace with a true streaming decode stage, enforcing `ratio_max`.

use axum::{
    body::Body,
    http::{HeaderMap, Request, StatusCode},
    middleware::Next,
    response::{IntoResponse, Response},
    Json,
};

use crate::consts::DEFAULT_DECODE_ABS_CAP_BYTES;
use crate::errors::Problem;
use crate::observability::rejects::counter as rejects;

fn parse_len(headers: &HeaderMap) -> Option<u64> {
    headers
        .get(axum::http::header::CONTENT_LENGTH)
        .and_then(|v| v.to_str().ok())
        .and_then(|s| s.parse::<u64>().ok())
}

fn content_encoding(headers: &HeaderMap) -> Option<String> {
    headers
        .get(axum::http::header::CONTENT_ENCODING)
        .and_then(|v| v.to_str().ok())
        .map(|s| s.trim().to_ascii_lowercase())
}

fn abs_cap_from_env() -> u64 {
    std::env::var("SVC_GATEWAY_DECODE_ABS_CAP_BYTES")
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(DEFAULT_DECODE_ABS_CAP_BYTES as u64)
}

fn encoded_kind(enc: &str) -> Option<&'static str> {
    match enc {
        "gzip" => Some("gzip"),
        "deflate" => Some("deflate"),
        "br" => Some("br"),
        "zstd" => Some("zstd"),
        _ => None,
    }
}

pub async fn decode_guard_mw(req: Request<Body>, next: Next) -> Response {
    let headers = req.headers();
    let cap = abs_cap_from_env();

    // 1) Absolute cap on declared length
    if let Some(n) = parse_len(headers) {
        if n > cap {
            rejects().with_label_values(&["decode_cap"]).inc();
            let body = Problem {
                code: "decoded_cap",
                message: "decoded size exceeds cap",
                retryable: false,
                retry_after_ms: None,
                reason: None,
            };
            return (StatusCode::PAYLOAD_TOO_LARGE, Json(body)).into_response();
        }
    }

    // 2) Content-Encoding checks
    if let Some(enc) = content_encoding(headers) {
        if enc.contains(',') {
            rejects().with_label_values(&["stacked_encoding"]).inc();
            let body = Problem {
                code: "stacked_encoding",
                message: "stacked content-encoding not supported",
                retryable: false,
                retry_after_ms: None,
                reason: None,
            };
            return (StatusCode::UNSUPPORTED_MEDIA_TYPE, Json(body)).into_response();
        }
        if encoded_kind(&enc).is_some() {
            rejects().with_label_values(&["encoded_body"]).inc();
            let body = Problem {
                code: "encoded_body_unsupported",
                message: "encoded request bodies are not supported",
                retryable: false,
                retry_after_ms: None,
                reason: None,
            };
            return (StatusCode::UNSUPPORTED_MEDIA_TYPE, Json(body)).into_response();
        }
    }

    next.run(req).await
}

```

### crates/svc-gateway/src/layers/drr.rs
<a id="crates-svc-gateway-src-layers-drr-rs"></a>

```rust
//! RO:WHAT   DRR/fair-queue placeholder layer.
//! RO:WHY    Slot-in for future dispatcher; currently pass-through.

use axum::http::Request;
use axum::response::Response;
use std::task::{Context, Poll};
use tower::{Layer, Service};

use crate::observability::metrics::MetricsHandles;

#[derive(Clone)]
pub struct DrrLayer {
    pub max_inflight: usize,
    pub metrics: MetricsHandles,
}

impl<S> Layer<S> for DrrLayer {
    type Service = Drr<S>;
    fn layer(&self, inner: S) -> Self::Service {
        Drr {
            inner,
            max_inflight: self.max_inflight,
            metrics: self.metrics.clone(),
        }
    }
}

#[derive(Clone)]
pub struct Drr<S> {
    inner: S,
    #[allow(dead_code)]
    max_inflight: usize,
    #[allow(dead_code)]
    metrics: MetricsHandles,
}

impl<S, B> Service<Request<B>> for Drr<S>
where
    S: Service<Request<B>, Response = Response> + Clone + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Send + 'static,
{
    type Response = Response;
    type Error = S::Error;
    type Future = S::Future;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        // TODO: implement fair queueing; for now pass-through.
        self.inner.call(req)
    }
}

```

### crates/svc-gateway/src/layers/mod.rs
<a id="crates-svc-gateway-src-layers-mod-rs"></a>

```rust
//! Order (inner→outer): timeouts → `body_caps` → `decode_guard` → `rate_limit` → drr → tarpit → auth → corr

pub mod body_caps;
pub mod concurrency;
pub mod corr;
pub mod decode_guard;
pub mod rate_limit;
pub mod timeouts;

```

### crates/svc-gateway/src/layers/rate_limit.rs
<a id="crates-svc-gateway-src-layers-ratelimit-rs"></a>

```rust
//! Global token-bucket rate limit (lock-free fast path).
//! RO:WHAT   Enforce RPS with fixed-capacity bucket; emit 429 + Retry-After.
//! RO:WHY    Cheap back-pressure/abuse damping without mutex contention.
//! RO:METRICS increments `gateway_rejections_total{reason="rate_limit"}` on reject.
//! RO:CONFIG `SVC_GATEWAY_RL_RPS` (u64), `SVC_GATEWAY_RL_BURST` (u64), `SVC_GATEWAY_RL_TARPIT_MS` (u64).

use axum::{
    body::Body,
    http::{Request, StatusCode},
    middleware::Next,
    response::{IntoResponse, Response},
};
use once_cell::sync::OnceCell;
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use tokio::time::sleep;

use crate::observability::rejects::counter as rejects_counter;

#[derive(Debug)]
struct TokenBucket {
    /// steady refill rate (tokens/sec)
    rps: u64,
    /// hard cap on tokens (burst)
    capacity: u64,
    /// current tokens (0..=capacity)
    tokens: AtomicU64,
    /// last whole second we refilled (unix seconds)
    last_sec: AtomicU64,
}

impl TokenBucket {
    fn new(rps: u64, burst: u64) -> Self {
        let now = now_secs();
        // capacity must be at least 1 to avoid degenerate 0-cap bucket
        let cap = burst.max(1);
        Self {
            rps: rps.max(1),
            capacity: cap,
            tokens: AtomicU64::new(cap), // start full
            last_sec: AtomicU64::new(now),
        }
    }

    #[inline]
    fn refill_if_needed(&self) {
        let cur = now_secs();
        let last = self.last_sec.load(Ordering::Relaxed);

        if cur > last
            && self
                .last_sec
                .compare_exchange(last, cur, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
        {
            // elapsed whole seconds since the last successful refill tick
            let elapsed = cur.saturating_sub(last);
            if elapsed > 0 {
                let add = elapsed.saturating_mul(self.rps);
                // cap at capacity; safe because both are u64
                let before = self.tokens.load(Ordering::Relaxed);
                let after = before.saturating_add(add).min(self.capacity);
                // store (not critical if we race; any winner that writes <= capacity is fine)
                self.tokens.store(after, Ordering::Relaxed);
            }
        }
    }

    /// Try to consume one token.
    /// Never panics; never underflows; wait-free fast path on success.
    #[must_use]
    #[inline]
    fn try_take(&self) -> bool {
        self.refill_if_needed();

        // lock-free decrement with CAS so we never subtract below zero
        let mut cur = self.tokens.load(Ordering::Relaxed);
        loop {
            if cur == 0 {
                return false;
            }
            // we know cur > 0, so cur - 1 is safe; CAS guards against races
            match self.tokens.compare_exchange_weak(
                cur,
                cur - 1,
                Ordering::Relaxed,
                Ordering::Relaxed,
            ) {
                Ok(_) => return true,
                Err(observed) => {
                    cur = observed;
                    // retry until we either see 0 or win the CAS
                }
            }
        }
    }
}

#[inline]
fn now_secs() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_else(|_| Duration::from_secs(0))
        .as_secs()
}

/// Route-scoped middleware: enforce global RPS (lock-free).
///
/// # Behavior
/// - Honors env:
///   - `SVC_GATEWAY_RL_RPS` (default 5000)
///   - `SVC_GATEWAY_RL_BURST` (default = RPS)
///   - `SVC_GATEWAY_RL_TARPIT_MS` (default 0; add small sleep on reject)
/// - On reject: returns 429 and `Retry-After: 1` header, increments `gateway_rejections_total{reason="rate_limit"}`
///
/// # Errors
/// Never returns an error directly; upstream handler may.
pub async fn rate_limit_mw(req: Request<Body>, next: Next) -> Response {
    static BUCKET: OnceCell<TokenBucket> = OnceCell::new();
    static TARPIT_MS: OnceCell<u64> = OnceCell::new();

    let rps = std::env::var("SVC_GATEWAY_RL_RPS")
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(5_000);
    let burst = std::env::var("SVC_GATEWAY_RL_BURST")
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(rps);
    let tarpit_ms = *TARPIT_MS.get_or_init(|| {
        std::env::var("SVC_GATEWAY_RL_TARPIT_MS")
            .ok()
            .and_then(|s| s.parse::<u64>().ok())
            .unwrap_or(0)
    });

    let bucket = BUCKET.get_or_init(|| TokenBucket::new(rps, burst));

    if bucket.try_take() {
        next.run(req).await
    } else {
        rejects_counter().with_label_values(&["rate_limit"]).inc();
        if tarpit_ms > 0 {
            sleep(Duration::from_millis(tarpit_ms)).await;
        }
        (
            StatusCode::TOO_MANY_REQUESTS,
            [("Retry-After", "1")],
            "rate limited",
        )
            .into_response()
    }
}

```

### crates/svc-gateway/src/layers/tarpit.rs
<a id="crates-svc-gateway-src-layers-tarpit-rs"></a>

```rust
#[must_use]
pub fn enabled() -> bool {
    false
}

```

### crates/svc-gateway/src/layers/timeouts.rs
<a id="crates-svc-gateway-src-layers-timeouts-rs"></a>

```rust
//! Route-scoped timeout middleware.
//! RO:WHAT  Enforce a simple request timeout using Tokio's `timeout`.
//! RO:WHY   Prevents hung readiness checks from stalling callers.
//! RO:NOTE  Axum 0.7 middleware shape (`Next` has no generics).
//! RO:CONF  Duration via `SVC_GATEWAY_READY_TIMEOUT_MS` (default 200ms).

use axum::{
    body::Body,
    http::Request,
    middleware::Next,
    response::{IntoResponse, Response},
};
use std::time::Duration;
use tokio::time::timeout;

/// Timeout wrapper for `/readyz`.
/// - Reads `SVC_GATEWAY_READY_TIMEOUT_MS` (u64) from env (default 200ms).
/// - On timeout, returns `504 Gateway Timeout` with "timeout".
pub async fn ready_timeout_mw(req: Request<Body>, next: Next) -> Response {
    let ms = std::env::var("SVC_GATEWAY_READY_TIMEOUT_MS")
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(200);

    match timeout(Duration::from_millis(ms), next.run(req)).await {
        Ok(resp) => resp,
        Err(_) => (axum::http::StatusCode::GATEWAY_TIMEOUT, "timeout").into_response(),
    }
}

```

### crates/svc-gateway/src/lib.rs
<a id="crates-svc-gateway-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]
#![deny(clippy::all, clippy::pedantic)]
#![allow(clippy::module_name_repetitions)]

pub mod consts;
pub mod errors;
pub mod result;
pub mod state;

pub mod config;
pub mod headers;
pub mod observability;
pub mod policy;
pub mod pq;
pub mod readiness;
pub mod tls;

pub mod admission;
pub mod forward;
pub mod layers;
pub mod routes;

```

### crates/svc-gateway/src/main.rs
<a id="crates-svc-gateway-src-main-rs"></a>

```rust
//! svc-gateway binary (stub bootstrap)

use axum::Router;
use svc_gateway::{config::Config, observability::metrics, routes, state::AppState};
use tokio::net::TcpListener;
use tracing::{info, Level};
use tracing_subscriber::EnvFilter;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Minimal tracing; respects RUST_LOG if set.
    let _ = tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env().add_directive(Level::INFO.into()))
        .with_target(false)
        .try_init();

    let cfg = Config::load()?;
    let metrics_handles = metrics::register()?;

    // App state requires both Config and MetricsHandles
    let state = AppState::new(cfg.clone(), metrics_handles);

    // Build the router from crate routes
    let router: Router = routes::build_router(&state);

    // Avoid moving the bind address out of cfg so we can both bind and log it.
    let bind_addr = cfg.server.bind_addr.clone();
    let listener = TcpListener::bind(&bind_addr).await?;
    info!("svc-gateway listening on {}", bind_addr);

    axum::serve(listener, router)
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    Ok(())
}

async fn shutdown_signal() {
    // CTRL+C to stop
    let _ = tokio::signal::ctrl_c().await;
}

```

### crates/svc-gateway/src/observability/http_metrics.rs
<a id="crates-svc-gateway-src-observability-httpmetrics-rs"></a>

```rust
//! HTTP metrics wiring + tiny middleware.
//! RO:WHAT   Record request totals and latency buckets with stable labels.
//! RO:WHY    Golden counters for SREs; cheap + predictable.
//! RO:LABELS route,method,status (counter) and route,method (histogram).
//! RO:SAFETY Registered once via `OnceCell`; no panics after success.
//! RO:NOTE   `prewarm()` creates child series so dashboards light up immediately.

use axum::{body::Body, http::Request, middleware::Next, response::Response};
use once_cell::sync::OnceCell;
use prometheus::{HistogramOpts, HistogramVec, IntCounterVec, Opts};
use std::time::Instant;

static HTTP_REQS: OnceCell<IntCounterVec> = OnceCell::new();
static LAT_HIST: OnceCell<HistogramVec> = OnceCell::new();

fn reqs() -> &'static IntCounterVec {
    HTTP_REQS.get_or_init(|| {
        let vec = IntCounterVec::new(
            Opts::new(
                "gateway_http_requests_total",
                "Total HTTP requests (svc-gateway middleware)",
            ),
            &["route", "method", "status"],
        )
        .expect("IntCounterVec");
        prometheus::register(Box::new(vec.clone())).expect("register gateway_http_requests_total");
        vec
    })
}

fn lats() -> &'static HistogramVec {
    LAT_HIST.get_or_init(|| {
        // Buckets chosen to match docs (ms in seconds representation).
        let buckets = vec![
            0.0005, 0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1.0,
        ];
        let opts = HistogramOpts::new(
            "gateway_request_latency_seconds",
            "Request latency in seconds (svc-gateway middleware)",
        )
        .buckets(buckets);
        let vec = HistogramVec::new(opts, &["route", "method"]).expect("HistogramVec");
        prometheus::register(Box::new(vec.clone()))
            .expect("register gateway_request_latency_seconds");
        vec
    })
}

/// Derive a compact, low-cardinality route label from the path.
/// We keep it stable for core endpoints; everything else falls back
/// to the first segment (or "root").
fn route_label(path: &str) -> &'static str {
    match path {
        "/healthz" => "healthz",
        "/readyz" => "readyz",
        "/metrics" => "metrics",
        "/version" => "version",
        "/dev/echo" => "dev_echo",
        "/dev/rl" => "dev_rl",
        _ => {
            if path == "/" {
                "root"
            } else {
                "other"
            }
        }
    }
}

/// Middleware: measure latency + count by labels.
/// Apply at route scope where appropriate.
///
/// # Errors
/// Never returns an error directly; upstream handler may.
pub async fn mw(req: Request<Body>, next: Next) -> Response {
    // Compute labels BEFORE moving `req` into `next.run(...)`.
    let route = route_label(req.uri().path());
    let method_owned = req.method().as_str().to_owned();

    let start = Instant::now();
    let response = next.run(req).await;
    let status = response.status().as_u16().to_string();
    let secs = start.elapsed().as_secs_f64();

    reqs()
        .with_label_values(&[route, method_owned.as_str(), &status])
        .inc();
    lats()
        .with_label_values(&[route, method_owned.as_str()])
        .observe(secs);

    response
}

/// Pre-create common label series so dashboards don’t start “empty”.
/// Call this once during startup before serving traffic.
pub fn prewarm() {
    // Counters (route, method, status)
    for (route, method, statuses) in [
        ("healthz", "GET", &["200"][..]),
        ("readyz", "GET", &["200", "503"][..]),
        ("metrics", "GET", &["200"][..]),
        ("version", "GET", &["200"][..]),
        ("dev_echo", "POST", &["200", "413"][..]),
        ("dev_rl", "GET", &["200", "429"][..]),
    ] {
        for &st in statuses {
            let _ = reqs().get_metric_with_label_values(&[route, method, st]);
        }
        let _ = lats().get_metric_with_label_values(&[route, method]);
    }
}

```

### crates/svc-gateway/src/observability/logging.rs
<a id="crates-svc-gateway-src-observability-logging-rs"></a>

```rust
use tracing_subscriber::{fmt::format::FmtSpan, EnvFilter};

pub fn init() {
    let filter =
        std::env::var("RUST_LOG").unwrap_or_else(|_| "info,axum=warn,tower_http=warn".into());
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::new(filter))
        .with_span_events(FmtSpan::CLOSE)
        .json()
        .flatten_event(true)
        .init();
}

```

### crates/svc-gateway/src/observability/metrics.rs
<a id="crates-svc-gateway-src-observability-metrics-rs"></a>

```rust
//! Prometheus registry + golden metrics wiring.
//! Dashboard hints & names aligned with docs. :contentReference[oaicite:9]{index=9}

use prometheus::{
    register_histogram_vec, register_int_counter_vec, register_int_gauge, HistogramVec,
    IntCounterVec, IntGauge,
};

/// Handles to all gateway metrics registered in the global Prometheus registry.
#[derive(Clone)]
pub struct MetricsHandles {
    /// Total HTTP requests, partitioned by `route`, `method`, and `status`.
    pub http_reqs: IntCounterVec,
    /// Request latency histogram (seconds), partitioned by `route` and `method`.
    pub http_lat: HistogramVec,
    /// Current number of in-flight requests across the gateway.
    pub inflight: IntGauge,
    /// Count of rejected requests by `reason` (e.g., `rate_limit`, `body_cap`, `timeout`).
    pub rejected: IntCounterVec,

    pub ready_inflight_current: IntGauge,
    pub ready_error_rate_pct: IntGauge,
    pub ready_queue_saturated: IntGauge,
}

/// Register metrics; returns handles.
///
/// # Errors
///
/// Returns an error if metrics of the same name are already registered.
pub fn register() -> anyhow::Result<MetricsHandles> {
    let http_reqs = register_int_counter_vec!(
        "http_requests_total",
        "HTTP requests",
        &["route", "method", "status"]
    )?;
    let http_lat = register_histogram_vec!(
        "request_latency_seconds",
        "Request latencies",
        &["route", "method"]
    )?;
    let inflight = register_int_gauge!("inflight_requests", "In-flight requests")?;
    let rejected = register_int_counter_vec!(
        "rejected_total",
        "Rejected by reason (e.g., rate_limit, body_cap, timeout)",
        &["reason"]
    )?;

    // Readiness gauges (carry-over names). :contentReference[oaicite:10]{index=10}
    let ready_inflight_current =
        register_int_gauge!("ready_inflight_current", "Current inflight across gateway")?;
    let ready_error_rate_pct =
        register_int_gauge!("ready_error_rate_pct", "Observed 429/503 % over window")?;
    let ready_queue_saturated =
        register_int_gauge!("ready_queue_saturated", "Queue saturated indicator")?;

    Ok(MetricsHandles {
        http_reqs,
        http_lat,
        inflight,
        rejected,
        ready_inflight_current,
        ready_error_rate_pct,
        ready_queue_saturated,
    })
}

```

### crates/svc-gateway/src/observability/metrics_boot.rs
<a id="crates-svc-gateway-src-observability-metricsboot-rs"></a>

```rust
//! Metrics boot helpers.
//! RO:WHAT   (Placeholder) Hooks to pre-warm metric label sets at startup.
//! RO:WHY    Avoid first-hit allocations when a route is hit under burst.
//! RO:PLAN   Once `observability::http_metrics` exposes a `prewarm_labels(...)`
//!           we call it here for the known {route,method,status} tuples.
//! RO:SAFE   Currently a no-op to avoid any registration conflicts.

/// Pre-warm metric label sets (currently a no-op).
///
/// # Notes
/// - Intentionally empty until `http_metrics` exposes a safe prewarm function.
/// - Kept as a separate module so wiring it later is a one-line change.
pub fn prewarm() {
    // no-op (will call into http_metrics once the prewarm function is exposed)
}

```

### crates/svc-gateway/src/observability/mod.rs
<a id="crates-svc-gateway-src-observability-mod-rs"></a>

```rust
pub mod http_metrics;
pub mod logging;
pub mod metrics;
pub mod readiness;
pub mod ready_metrics;
pub mod rejects;
pub mod tracing;

```

### crates/svc-gateway/src/observability/readiness.rs
<a id="crates-svc-gateway-src-observability-readiness-rs"></a>

```rust
//! Readiness sampler (lightweight, no `AppState` changes).
//! RO:WHAT   Maintain a global readiness snapshot updated on a short interval.
//! RO:WHY    Let `/readyz` consult real gates instead of a hard-coded toggle.
//! RO:SHAPE  Global `OnceLock` + Atomics so we don't touch `AppState` (tiny blast radius).
//! RO:FUTURE Hook real signals (inflight, error rate, queue depth) as they land.

use std::sync::{
    atomic::{AtomicBool, AtomicU64, Ordering},
    OnceLock,
};
use std::time::Duration;
use tokio::task::JoinHandle;

#[derive(Clone, Copy, Debug)]
pub struct Snapshot {
    pub inflight_current: u64,
    pub error_rate_pct: u64,
    pub queue_saturated: bool,
}

struct ReadyState {
    inflight_current: AtomicU64,
    error_rate_pct: AtomicU64,
    queue_saturated: AtomicBool,
}

impl ReadyState {
    const fn new() -> Self {
        Self {
            inflight_current: AtomicU64::new(0),
            error_rate_pct: AtomicU64::new(0),
            queue_saturated: AtomicBool::new(false),
        }
    }

    fn snapshot(&self) -> Snapshot {
        Snapshot {
            inflight_current: self.inflight_current.load(Ordering::Relaxed),
            error_rate_pct: self.error_rate_pct.load(Ordering::Relaxed),
            queue_saturated: self.queue_saturated.load(Ordering::Relaxed),
        }
    }
}

static READY: OnceLock<ReadyState> = OnceLock::new();
static TASK: OnceLock<JoinHandle<()>> = OnceLock::new();

fn ready() -> &'static ReadyState {
    READY.get_or_init(ReadyState::new)
}

pub fn ensure_started() {
    if TASK.get().is_some() {
        return;
    }
    let handle = tokio::spawn(async move {
        let tick = Duration::from_millis(500);
        loop {
            // Take a snapshot and publish as gauges (gateway-prefixed to avoid collisions).
            let snap = ready().snapshot();
            crate::observability::ready_metrics::set_inflight(snap.inflight_current);
            crate::observability::ready_metrics::set_error_pct(snap.error_rate_pct);
            crate::observability::ready_metrics::set_queue_saturated(snap.queue_saturated);
            tokio::time::sleep(tick).await;
        }
    });
    let _ = TASK.set(handle);
}

#[must_use]
pub fn snapshot() -> Snapshot {
    ready().snapshot()
}

#[derive(Clone, Copy)]
pub struct Thresholds {
    pub max_error_pct: u64,
    pub max_inflight: u64,
    pub allow_queue_saturation: bool,
}

impl Default for Thresholds {
    fn default() -> Self {
        Self {
            max_error_pct: 5,
            max_inflight: 10_000,
            allow_queue_saturation: false,
        }
    }
}

```

### crates/svc-gateway/src/observability/ready_metrics.rs
<a id="crates-svc-gateway-src-observability-readymetrics-rs"></a>

```rust
//! Readiness metrics helpers.
//! RO:WHAT   Export gauges used by `/readyz` truth table.
//! RO:LABELS none (singletons).
//! RO:METRICS
//!   - `gateway_ready_inflight_current` (gauge, `i64`)
//!   - `gateway_ready_error_rate_pct`   (gauge, `i64`)
//!   - `gateway_ready_queue_saturated`  (gauge, `i64`: 0/1)

use once_cell::sync::OnceCell;
use prometheus::{IntGauge, Opts};

fn inflight_gauge() -> &'static IntGauge {
    static G: OnceCell<IntGauge> = OnceCell::new();
    G.get_or_init(|| {
        let g = IntGauge::with_opts(Opts::new(
            "gateway_ready_inflight_current",
            "Current inflight across gateway",
        ))
        .expect("IntGauge");
        prometheus::register(Box::new(g.clone())).expect("register gateway_ready_inflight_current");
        g
    })
}

fn error_pct_gauge() -> &'static IntGauge {
    static G: OnceCell<IntGauge> = OnceCell::new();
    G.get_or_init(|| {
        let g = IntGauge::with_opts(Opts::new(
            "gateway_ready_error_rate_pct",
            "Observed 429/503 % over window",
        ))
        .expect("IntGauge");
        prometheus::register(Box::new(g.clone())).expect("register gateway_ready_error_rate_pct");
        g
    })
}

fn queue_sat_gauge() -> &'static IntGauge {
    static G: OnceCell<IntGauge> = OnceCell::new();
    G.get_or_init(|| {
        let g = IntGauge::with_opts(Opts::new(
            "gateway_ready_queue_saturated",
            "Queue saturated indicator",
        ))
        .expect("IntGauge");
        prometheus::register(Box::new(g.clone())).expect("register gateway_ready_queue_saturated");
        g
    })
}

/// Update inflight (safe cast; saturates at `i64::MAX`).
pub fn set_inflight(v: u64) {
    let as_i64 = i64::try_from(v).unwrap_or(i64::MAX);
    inflight_gauge().set(as_i64);
}

/// Update error percentage (0..=100 expected; safe cast).
pub fn set_error_pct(v: u64) {
    let as_i64 = i64::try_from(v).unwrap_or(i64::MAX);
    error_pct_gauge().set(as_i64);
}

/// Update saturation flag.
pub fn set_queue_saturated(v: bool) {
    queue_sat_gauge().set(i64::from(v));
}

```

### crates/svc-gateway/src/observability/rejects.rs
<a id="crates-svc-gateway-src-observability-rejects-rs"></a>

```rust
//! Shared “rejections” counter handle.
//! RO:WHAT   Central place for `gateway_rejections_total{reason}`.
//! RO:WHY    Avoid double-register; give callers a tiny, stable API.

use once_cell::sync::OnceCell;
use prometheus::{IntCounterVec, Opts};

const NAME: &str = "gateway_rejections_total";

/// Get the shared rejections counter (`reason` label).
///
/// # Panics
/// Panics once at process start if Prometheus registration fails. This
/// indicates a programmer error such as attempting to re-register the
/// same metric name with a different type/help text.
pub fn counter() -> &'static IntCounterVec {
    static CTR: OnceCell<IntCounterVec> = OnceCell::new();
    CTR.get_or_init(|| {
        let vec = IntCounterVec::new(Opts::new(NAME, "Gateway rejections by reason"), &["reason"])
            .expect("IntCounterVec");
        prometheus::register(Box::new(vec.clone())).expect("register gateway_rejections_total");
        vec
    })
}

```

### crates/svc-gateway/src/observability/tracing.rs
<a id="crates-svc-gateway-src-observability-tracing-rs"></a>

```rust
//! observability/tracing.rs — Trace subscriber & context propagation — placeholder.

```

### crates/svc-gateway/src/policy/abuse.rs
<a id="crates-svc-gateway-src-policy-abuse-rs"></a>

```rust
#[derive(Clone, Default)]
pub struct AbusePolicy;

```

### crates/svc-gateway/src/policy/mod.rs
<a id="crates-svc-gateway-src-policy-mod-rs"></a>

```rust
//! Residency/abuse policy stubs; attach via Extension<> AFTER inner layers.
//! Carry-over: Extension order discipline. :contentReference[oaicite:13]{index=13}
pub mod abuse;
pub mod residency;

#[derive(Clone, Default)]
pub struct PolicyBundle;

```

### crates/svc-gateway/src/policy/residency.rs
<a id="crates-svc-gateway-src-policy-residency-rs"></a>

```rust
#[derive(Clone, Default)]
pub struct ResidencyPolicy;

```

### crates/svc-gateway/src/pq/mod.rs
<a id="crates-svc-gateway-src-pq-mod-rs"></a>

```rust
//! Post-quantum plumbing stub (hybrid later).
pub mod policy;

```

### crates/svc-gateway/src/pq/policy.rs
<a id="crates-svc-gateway-src-pq-policy-rs"></a>

```rust
//! PQ policy toggles (off|hybrid). Kept as stub for now.
#[derive(Clone, Copy, Debug)]
pub enum PqMode {
    Off,
    Hybrid,
}

```

### crates/svc-gateway/src/readiness/keys.rs
<a id="crates-svc-gateway-src-readiness-keys-rs"></a>

```rust
//! Names kept stable for dashboards/tests. :contentReference[oaicite:12]{index=12}
pub const READY_INFLIGHT_CURRENT: &str = "ready_inflight_current";
pub const READY_ERROR_RATE_PCT: &str = "ready_error_rate_pct";
pub const READY_QUEUE_SATURATED: &str = "ready_queue_saturated";

```

### crates/svc-gateway/src/readiness/mod.rs
<a id="crates-svc-gateway-src-readiness-mod-rs"></a>

```rust
//! Tiny readiness/degradation flag exposed to /readyz.

use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};

#[derive(Default)]
struct ReadyStateInner {
    degraded: AtomicBool,
}

#[derive(Clone)]
pub struct ReadyState(Arc<ReadyStateInner>);

impl Default for ReadyState {
    fn default() -> Self {
        Self::new()
    }
}

impl ReadyState {
    #[must_use]
    pub fn new() -> Self {
        Self(Arc::new(ReadyStateInner::default()))
    }

    pub fn set_degraded(&self, d: bool) {
        self.0.degraded.store(d, Ordering::Relaxed);
    }

    #[must_use]
    pub fn is_degraded(&self) -> bool {
        self.0.degraded.load(Ordering::Relaxed)
    }

    /// Consider "ready" when not degraded (you can enrich later with more gates).
    #[must_use]
    pub fn ready(&self) -> bool {
        !self.is_degraded()
    }
}

```

### crates/svc-gateway/src/result.rs
<a id="crates-svc-gateway-src-result-rs"></a>

```rust
pub type Result<T, E = anyhow::Error> = std::result::Result<T, E>;

```

### crates/svc-gateway/src/routes/app.rs
<a id="crates-svc-gateway-src-routes-app-rs"></a>

```rust
//! /app/* proxy to omnigate app plane.
//!
//! RO:WHAT  Forward `/app/{tail}` to omnigate `/v1/app/{tail}`.
//! RO:WHY   First-hop app-plane gateway for micronode/macronode apps.
//! RO:CONF  `SVC_GATEWAY_OMNIGATE_BASE_URL` controls the upstream base URL.

use crate::state::AppState;
use axum::{
    body::{Body, Bytes},
    extract::{Path, State},
    http::{header, HeaderMap, Method, StatusCode},
    response::{IntoResponse, Response},
    Router,
};

/// Router for `/app/*` subtree.
///
/// Mounted from `routes::build_router` as:
/// `router.nest("/app", app::router())`
pub fn router() -> Router<AppState> {
    use axum::routing::any;
    Router::new().route("/*tail", any(proxy))
}

/// Proxy handler: `/app/{tail}` → `{omnigate_base}/v1/app/{tail}`.
pub async fn proxy(
    State(state): State<AppState>,
    method: Method,
    Path(tail): Path<String>,
    headers: HeaderMap,
    body: Bytes,
) -> Response {
    let base = &state.cfg.upstreams.omnigate_base_url;
    // Simple join; omnigate_base_url is expected to have no trailing slash.
    let url = format!("{base}/v1/app/{tail}");

    let mut req_builder = state.omnigate_client.request(method, &url);

    // Forward headers, skipping Host (reqwest sets its own).
    for (name, value) in &headers {
        if name == header::HOST {
            continue;
        }
        req_builder = req_builder.header(name, value);
    }

    // Send upstream request.
    let Ok(upstream_res) = req_builder.body(body).send().await else {
        return (StatusCode::BAD_GATEWAY, "upstream connect error").into_response();
    };

    let status = upstream_res.status();
    let upstream_headers = upstream_res.headers().clone();

    // Extract body bytes from upstream (this consumes `upstream_res`).
    let Ok(body_bytes) = upstream_res.bytes().await else {
        return (StatusCode::BAD_GATEWAY, "upstream read error").into_response();
    };

    // Build downstream response.
    let mut resp = Response::new(Body::from(body_bytes));
    *resp.status_mut() = status;

    let resp_headers = resp.headers_mut();
    for (name, value) in &upstream_headers {
        resp_headers.insert(name.clone(), value.clone());
    }

    resp
}

```

### crates/svc-gateway/src/routes/dev.rs
<a id="crates-svc-gateway-src-routes-dev-rs"></a>

```rust
//! Dev-only routes (opt-in via env).
//! RO:CONF  `SVC_GATEWAY_DEV_ROUTES=1` to enable.
//! RO:NOTE  Guarded by body caps / rate limit in router assembly.

use axum::{
    body::{Body, Bytes},
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;

/// Toggle for mounting dev routes.
#[must_use]
pub fn enabled() -> bool {
    std::env::var("SVC_GATEWAY_DEV_ROUTES")
        .map(|v| v == "1" || v.eq_ignore_ascii_case("true") || v.eq_ignore_ascii_case("yes"))
        .unwrap_or(false)
}

#[derive(Serialize)]
struct EchoResp<'a> {
    echo: &'a str,
    len: usize,
}

/// POST /dev/echo — echoes body length; body caps enforced by middleware.
pub async fn echo_post(body: Bytes) -> impl IntoResponse {
    let resp = EchoResp {
        echo: "hi",
        len: body.len(),
    };
    (StatusCode::OK, Json(resp))
}

/// GET /dev/rl — trivial “OK” for rate-limit tests (429 comes from middleware).
pub async fn burst_ok() -> Response {
    (StatusCode::OK, Body::from("ok")).into_response()
}

```

### crates/svc-gateway/src/routes/health.rs
<a id="crates-svc-gateway-src-routes-health-rs"></a>

```rust
//! RO:WHAT  /healthz — liveness probe.
//! RO:WHY   Simple process up check. Always 200 "ok".

use axum::response::{IntoResponse, Response};

pub async fn handler() -> Response {
    "ok".into_response()
}

```

### crates/svc-gateway/src/routes/metrics.rs
<a id="crates-svc-gateway-src-routes-metrics-rs"></a>

```rust
//! Prometheus metrics endpoint (text format).
//! RO:WHAT  Expose the default registry in plain text format for Prometheus.
//! RO:WHY   Our current handler returns a JSON-escaped string; Prometheus expects text/plain.
//! RO:INVARS  No allocations beyond the encode buffer; no blocking; no SHA usage anywhere.

use axum::http::{header::CONTENT_TYPE, HeaderMap};
use axum::response::{IntoResponse, Response};
use prometheus::{Encoder, TextEncoder};

/// Return metrics in Prometheus text format (`text/plain; version=0.0.4`).
///
/// # Behavior
/// - Encodes the default registry (`prometheus::gather()`) using `TextEncoder`.
/// - Sets the canonical content type expected by Prometheus.
/// - On unexpected encode errors, emits an empty body with the same content type.
pub async fn get_metrics() -> Response {
    let metric_families = prometheus::gather();
    let encoder = TextEncoder::new();

    let mut buf = Vec::with_capacity(16 * 1024);
    let _ = encoder.encode(&metric_families, &mut buf);

    let mut headers = HeaderMap::new();
    // Prometheus canonical content type for text exposition format
    headers.insert(
        CONTENT_TYPE,
        "text/plain; version=0.0.4; charset=utf-8"
            .parse()
            .expect("static content type"),
    );

    (headers, buf).into_response()
}

```

### crates/svc-gateway/src/routes/mod.rs
<a id="crates-svc-gateway-src-routes-mod-rs"></a>

```rust
//! Router assembly + core admin plane.
//!
//! RO:ORDER  Keep layers minimal; apply correlation + HTTP metrics to `/healthz`,
//!           request-timeout + concurrency cap to `/readyz`, and body cap / rate limit
//!           only to dev routes. Optionally add `http_metrics` to dev routes when
//!           `SVC_GATEWAY_DEV_METRICS` is truthy for benching visibility.

use crate::state::AppState;
use axum::{
    routing::{get, post},
    Router,
};

pub mod app;
pub mod dev;
pub mod health;
mod metrics;
pub mod ready;

/// Return true if `SVC_GATEWAY_DEV_METRICS` is set to a truthy value.
/// Accepted values (case-insensitive): "1", "true", "yes", "on".
fn dev_metrics_enabled() -> bool {
    match std::env::var("SVC_GATEWAY_DEV_METRICS") {
        Ok(v) => {
            let s = v.trim().to_ascii_lowercase();
            matches!(s.as_str(), "1" | "true" | "yes" | "on")
        }
        Err(_) => false,
    }
}

pub fn build_router(state: &AppState) -> Router {
    // Ensure readiness sampler is ticking.
    crate::observability::readiness::ensure_started();

    // Prewarm metric label series so dashboards light up right away.
    crate::observability::http_metrics::prewarm();

    // --- /healthz: correlation + request metrics (outermost) ---
    let health_with_layers = Router::new()
        .route("/healthz", get(health::handler))
        .route_layer(axum::middleware::from_fn(crate::layers::corr::mw))
        .route_layer(axum::middleware::from_fn(
            crate::observability::http_metrics::mw,
        ));

    // --- /readyz: guarded with timeout + concurrency cap ---
    let ready_with_guards = Router::new()
        .route("/readyz", get(ready::handler))
        .route_layer(axum::middleware::from_fn(
            crate::layers::timeouts::ready_timeout_mw,
        ))
        .route_layer(axum::middleware::from_fn(
            crate::layers::concurrency::ready_concurrency_mw,
        ));

    // --- /dev/*: body cap + rate limit; optionally add http_metrics when benching ---
    let dev_routes = if dev::enabled() {
        let dev_base = Router::new()
            .route("/dev/echo", post(dev::echo_post))
            .route("/dev/rl", get(dev::burst_ok))
            // inner: functional guards
            .route_layer(axum::middleware::from_fn(
                crate::layers::body_caps::body_cap_mw,
            ))
            .route_layer(axum::middleware::from_fn(
                crate::layers::rate_limit::rate_limit_mw, // lock-free RL
            ));

        // If enabled, make http_metrics the outermost layer on /dev/*
        if dev_metrics_enabled() {
            dev_base.route_layer(axum::middleware::from_fn(
                crate::observability::http_metrics::mw,
            ))
        } else {
            dev_base
        }
    } else {
        Router::new()
    };

    Router::new()
        .merge(health_with_layers)
        .merge(ready_with_guards)
        .merge(dev_routes)
        .route("/metrics", get(metrics::get_metrics))
        // App-plane proxy: /app/* → omnigate /v1/app/*
        .nest("/app", app::router())
        .with_state(state.clone())
}

```

### crates/svc-gateway/src/routes/objects.rs
<a id="crates-svc-gateway-src-routes-objects-rs"></a>

```rust
//! GET /o/{addr}

use crate::headers::etag::etag_from_b3;
use axum::{extract::Path, response::IntoResponse};

pub async fn get_object(Path(addr): Path<String>) -> impl IntoResponse {
    // MVP: echo stub (no overlay forwarding yet).
    (
        [(http::header::ETAG, etag_from_b3(&addr))],
        axum::body::Body::from(format!("object stub for {}", addr)),
    )
}

```

### crates/svc-gateway/src/routes/objects_range.rs
<a id="crates-svc-gateway-src-routes-objectsrange-rs"></a>

```rust
//! GET /o/{addr} with Range (separate route for clarity)

use axum::{extract::Path, response::IntoResponse};

pub async fn get_range(Path(addr): Path<String>) -> impl IntoResponse {
    // MVP: range not implemented yet
    (
        http::StatusCode::NOT_IMPLEMENTED,
        format!("range read stub for {}", addr),
    )
}

```

### crates/svc-gateway/src/routes/ready.rs
<a id="crates-svc-gateway-src-routes-ready-rs"></a>

```rust
//! Readiness endpoint.
//! RO:WHAT   Truthful readiness gate (env override remains for dev).
//! RO:WHY    Operators need a real signal; keep override for quick local bring-up.
//! RO:TEST   Set `SVC_GATEWAY_READY_SLEEP_MS` to simulate slow work and exercise
//!           the concurrency cap + timeout layers.

use crate::state::AppState;
use axum::{
    extract::State,
    http::StatusCode,
    response::{IntoResponse, Response},
};
use std::time::Duration;
use tokio::time::sleep;

/// `/readyz` handler consulting sampler thresholds, with optional sleep to
/// simulate slow checks and exercise guards.
///
/// # Errors
/// This function does not fail; it always returns a `Response`.
pub async fn handler(State(_state): State<AppState>) -> Response {
    // Optional: simulate slow work to demonstrate concurrency/timeout guards.
    if let Ok(ms_str) = std::env::var("SVC_GATEWAY_READY_SLEEP_MS") {
        if let Ok(ms) = ms_str.parse::<u64>() {
            sleep(Duration::from_millis(ms)).await;
        }
    }

    // Dev override wins if explicitly set.
    if matches!(std::env::var("SVC_GATEWAY_DEV_READY").as_deref(), Ok("1")) {
        return (StatusCode::OK, "ready").into_response();
    }

    // Truth table based on the sampler snapshot.
    let snap = crate::observability::readiness::snapshot();
    let thr = crate::observability::readiness::Thresholds::default();

    let inflight_ok = snap.inflight_current <= thr.max_inflight;
    let error_ok = snap.error_rate_pct <= thr.max_error_pct;
    let queue_ok = thr.allow_queue_saturation || !snap.queue_saturated;

    if inflight_ok && error_ok && queue_ok {
        (StatusCode::OK, "ready").into_response()
    } else {
        (StatusCode::SERVICE_UNAVAILABLE, "not ready").into_response()
    }
}

```

### crates/svc-gateway/src/routes/version.rs
<a id="crates-svc-gateway-src-routes-version-rs"></a>

```rust
//! `/version` endpoint (no SHA), exposes crate name, semver, and build timestamp.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct VersionDto<'a> {
    name: &'a str,
    version: &'a str,
    built_at_unix: u64,
}

pub async fn handler() -> impl IntoResponse {
    let version = env!("CARGO_PKG_VERSION");
    let built_at_unix = option_env!("SVC_GATEWAY_BUILD_TS")
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(0);

    Json(VersionDto {
        name: "svc-gateway",
        version,
        built_at_unix,
    })
}

```

### crates/svc-gateway/src/state.rs
<a id="crates-svc-gateway-src-state-rs"></a>

```rust
//! RO:WHAT   Process state container passed to handlers and layers.
//! RO:WHY    Centralizes config, metrics handles, readiness gate, and shared clients.
//! RO:INVARS Send + Sync; cheap to clone via Arcs.

use std::sync::Arc;

use crate::config::Config;
use crate::observability::metrics::{self, MetricsHandles};
use crate::readiness::ReadyState;
use reqwest::Client;

#[derive(Clone)]
pub struct AppState {
    pub cfg: Config,
    pub metrics: MetricsHandles,
    pub readiness: Arc<ReadyState>,
    /// Shared HTTP client for talking to omnigate app plane.
    pub omnigate_client: Client,
}

impl AppState {
    /// Build a new state from provided parts.
    #[must_use]
    pub fn new(cfg: Config, metrics: MetricsHandles) -> Self {
        Self {
            cfg,
            metrics,
            readiness: Arc::new(ReadyState::new()),
            omnigate_client: Client::new(),
        }
    }

    /// Convenience ctor for early bring-up until real loaders are wired.
    ///
    /// # Panics
    /// Panics if metric registration fails (should not happen under normal conditions).
    #[must_use]
    pub fn new_default() -> Self {
        let cfg = Config::default();
        let metrics = metrics::register().expect("register metrics");
        Self::new(cfg, metrics)
    }
}

```

### crates/svc-gateway/src/tls/mod.rs
<a id="crates-svc-gateway-src-tls-mod-rs"></a>

```rust
//! TLS scaffolding (tokio-rustls) — enable with `--features tls`.

```

### crates/svc-gateway/tests/app_proxy.rs
<a id="crates-svc-gateway-tests-appproxy-rs"></a>

```rust
//! app_proxy.rs — integration test for `/app/*` → omnigate app plane.
//!
//! RO:WHAT  Spin up a dummy omnigate, then a real svc-gateway, and assert that
//!          `/app/ping` returns whatever omnigate returns.
//! RO:WHY   Proves env wiring (`SVC_GATEWAY_OMNIGATE_BASE_URL`) and proxy plumbing.

use std::net::SocketAddr;
use std::time::Duration;

use axum::{http::StatusCode, routing::get, Json, Router};
use serde_json::Value;
use svc_gateway::{config::Config, observability::metrics, routes, state::AppState};
use tokio::net::TcpListener;

/// Start a dummy omnigate app-plane server that answers `/v1/app/ping` with `{ "ok": true }`.
async fn start_dummy_omnigate() -> SocketAddr {
    async fn ping_handler() -> Json<Value> {
        Json(serde_json::json!({ "ok": true }))
    }

    let router = Router::new().route("/v1/app/ping", get(ping_handler));

    let listener = TcpListener::bind("127.0.0.1:0")
        .await
        .expect("bind dummy omnigate");
    let addr = listener.local_addr().expect("omnigate local_addr");

    tokio::spawn(async move {
        axum::serve(listener, router)
            .await
            .expect("dummy omnigate serve");
    });

    addr
}

/// Happy-path roundtrip: `/app/ping` should be forwarded to omnigate and
/// return whatever omnigate replies.
///
/// This uses env vars to wire the base URL:
/// - `SVC_GATEWAY_OMNIGATE_BASE_URL`
/// - `SVC_GATEWAY_BIND_ADDR`
#[tokio::test]
async fn app_proxy_happy_path() {
    // 1) Start dummy omnigate.
    let omnigate_addr = start_dummy_omnigate().await;
    let omnigate_base = format!("http://{}", omnigate_addr);

    // 2) Configure gateway via env.
    std::env::set_var("SVC_GATEWAY_OMNIGATE_BASE_URL", &omnigate_base);
    std::env::set_var("SVC_GATEWAY_BIND_ADDR", "127.0.0.1:0");

    // 3) Build gateway state and router.
    let cfg = Config::load().expect("load config with env overrides");
    let metrics_handles = metrics::register().expect("register metrics");
    let state = AppState::new(cfg.clone(), metrics_handles);

    let router = routes::build_router(&state);

    // 4) Bind gateway listener (letting OS choose port).
    let listener = TcpListener::bind(&cfg.server.bind_addr)
        .await
        .expect("bind gateway");
    let gateway_addr = listener.local_addr().expect("gateway local_addr");

    tokio::spawn(async move {
        axum::serve(listener, router).await.expect("gateway serve");
    });

    // Give both servers a moment to boot.
    tokio::time::sleep(Duration::from_millis(100)).await;

    // 5) Call /app/ping on the gateway and assert we get omnigate's response.
    let url = format!("http://{}/app/ping", gateway_addr);
    let client = reqwest::Client::new();
    let resp = client
        .get(&url)
        .send()
        .await
        .expect("gateway /app/ping response");

    assert_eq!(
        resp.status(),
        StatusCode::OK,
        "expected 200 from gateway, got {}",
        resp.status()
    );

    let body: Value = resp.json().await.expect("parse JSON body");
    assert_eq!(body, serde_json::json!({ "ok": true }));
}

```

### crates/svc-gateway/tests/integration/caps_limits.rs
<a id="crates-svc-gateway-tests-integration-capslimits-rs"></a>

```rust
//! caps_limits.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/integration/interop_vectors.rs
<a id="crates-svc-gateway-tests-integration-interopvectors-rs"></a>

```rust
//! interop_vectors.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/integration/loom_readiness.rs
<a id="crates-svc-gateway-tests-integration-loomreadiness-rs"></a>

```rust
//! loom_readiness.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/integration/readyz_degrade.rs
<a id="crates-svc-gateway-tests-integration-readyzdegrade-rs"></a>

```rust
//! readyz_degrade.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/integration/taxonomy_stability.rs
<a id="crates-svc-gateway-tests-integration-taxonomystability-rs"></a>

```rust
//! taxonomy_stability.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/smoke.rs
<a id="crates-svc-gateway-tests-smoke-rs"></a>

```rust
#[test]
fn smoke() {
    assert_eq!(2 + 2, 4);
}

```

### crates/svc-gateway/tests/vectors/error_taxonomy.json
<a id="crates-svc-gateway-tests-vectors-errortaxonomy-json"></a>

```json
{ "_comment": "Deterministic error taxonomy mapping placeholder." }

```

### crates/svc-gateway/tests/vectors/manifest_digest.json
<a id="crates-svc-gateway-tests-vectors-manifestdigest-json"></a>

```json
{ "_comment": "BLAKE3 manifest digest vector placeholder." }

```

### crates/svc-gateway/tests/vectors/oap1_frame_roundtrip.json
<a id="crates-svc-gateway-tests-vectors-oap1frameroundtrip-json"></a>

```json
{ "_comment": "OAP/1 frame roundtrip vector placeholder." }

```

