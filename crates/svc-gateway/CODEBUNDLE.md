<!-- Generated by scripts/make_crate_codex.sh on 2025-11-04T04:02:24Z -->
# Code Bundle — `svc-gateway`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-gateway/.github/workflows/api-stability.yml](#crates-svc-gateway--github-workflows-api-stability-yml)
- [crates/svc-gateway/.github/workflows/ci.yml](#crates-svc-gateway--github-workflows-ci-yml)
- [crates/svc-gateway/.github/workflows/fuzz-nightly.yml](#crates-svc-gateway--github-workflows-fuzz-nightly-yml)
- [crates/svc-gateway/.github/workflows/perf-guard.yml](#crates-svc-gateway--github-workflows-perf-guard-yml)
- [crates/svc-gateway/Cargo.toml](#crates-svc-gateway-Cargo-toml)
- [crates/svc-gateway/benches/baseline.json](#crates-svc-gateway-benches-baseline-json)
- [crates/svc-gateway/configs/svc-gateway.sample.toml](#crates-svc-gateway-configs-svc-gateway-sample-toml)
- [crates/svc-gateway/fuzz/targets/oap_frame.rs](#crates-svc-gateway-fuzz-targets-oapframe-rs)
- [crates/svc-gateway/fuzz/targets/taxonomy_mapper.rs](#crates-svc-gateway-fuzz-targets-taxonomymapper-rs)
- [crates/svc-gateway/scripts/chaos_burst.sh](#crates-svc-gateway-scripts-chaosburst-sh)
- [crates/svc-gateway/scripts/dev_run.sh](#crates-svc-gateway-scripts-devrun-sh)
- [crates/svc-gateway/scripts/export_metrics.sh](#crates-svc-gateway-scripts-exportmetrics-sh)
- [crates/svc-gateway/scripts/smoke_gateway.sh](#crates-svc-gateway-scripts-smokegateway-sh)
- [crates/svc-gateway/scripts/soak_test.sh](#crates-svc-gateway-scripts-soaktest-sh)
- [crates/svc-gateway/src/admission/capabilities.rs](#crates-svc-gateway-src-admission-capabilities-rs)
- [crates/svc-gateway/src/admission/classifier.rs](#crates-svc-gateway-src-admission-classifier-rs)
- [crates/svc-gateway/src/admission/mod.rs](#crates-svc-gateway-src-admission-mod-rs)
- [crates/svc-gateway/src/admission/payments.rs](#crates-svc-gateway-src-admission-payments-rs)
- [crates/svc-gateway/src/admission/quotas.rs](#crates-svc-gateway-src-admission-quotas-rs)
- [crates/svc-gateway/src/admission/residency.rs](#crates-svc-gateway-src-admission-residency-rs)
- [crates/svc-gateway/src/admission/taxonomy.rs](#crates-svc-gateway-src-admission-taxonomy-rs)
- [crates/svc-gateway/src/cli/mod.rs](#crates-svc-gateway-src-cli-mod-rs)
- [crates/svc-gateway/src/config/amnesia.rs](#crates-svc-gateway-src-config-amnesia-rs)
- [crates/svc-gateway/src/config/env.rs](#crates-svc-gateway-src-config-env-rs)
- [crates/svc-gateway/src/config/mod.rs](#crates-svc-gateway-src-config-mod-rs)
- [crates/svc-gateway/src/config/safety.rs](#crates-svc-gateway-src-config-safety-rs)
- [crates/svc-gateway/src/consts.rs](#crates-svc-gateway-src-consts-rs)
- [crates/svc-gateway/src/errors.rs](#crates-svc-gateway-src-errors-rs)
- [crates/svc-gateway/src/forward/index_client.rs](#crates-svc-gateway-src-forward-indexclient-rs)
- [crates/svc-gateway/src/forward/mod.rs](#crates-svc-gateway-src-forward-mod-rs)
- [crates/svc-gateway/src/forward/overlay_client.rs](#crates-svc-gateway-src-forward-overlayclient-rs)
- [crates/svc-gateway/src/forward/storage_client.rs](#crates-svc-gateway-src-forward-storageclient-rs)
- [crates/svc-gateway/src/headers/etag.rs](#crates-svc-gateway-src-headers-etag-rs)
- [crates/svc-gateway/src/headers/mod.rs](#crates-svc-gateway-src-headers-mod-rs)
- [crates/svc-gateway/src/layers/auth.rs](#crates-svc-gateway-src-layers-auth-rs)
- [crates/svc-gateway/src/layers/body_caps.rs](#crates-svc-gateway-src-layers-bodycaps-rs)
- [crates/svc-gateway/src/layers/corr.rs](#crates-svc-gateway-src-layers-corr-rs)
- [crates/svc-gateway/src/layers/decode_guard.rs](#crates-svc-gateway-src-layers-decodeguard-rs)
- [crates/svc-gateway/src/layers/drr.rs](#crates-svc-gateway-src-layers-drr-rs)
- [crates/svc-gateway/src/layers/mod.rs](#crates-svc-gateway-src-layers-mod-rs)
- [crates/svc-gateway/src/layers/rate_limit.rs](#crates-svc-gateway-src-layers-ratelimit-rs)
- [crates/svc-gateway/src/layers/tarpit.rs](#crates-svc-gateway-src-layers-tarpit-rs)
- [crates/svc-gateway/src/layers/timeouts.rs](#crates-svc-gateway-src-layers-timeouts-rs)
- [crates/svc-gateway/src/lib.rs](#crates-svc-gateway-src-lib-rs)
- [crates/svc-gateway/src/main.rs](#crates-svc-gateway-src-main-rs)
- [crates/svc-gateway/src/observability/logging.rs](#crates-svc-gateway-src-observability-logging-rs)
- [crates/svc-gateway/src/observability/metrics.rs](#crates-svc-gateway-src-observability-metrics-rs)
- [crates/svc-gateway/src/observability/mod.rs](#crates-svc-gateway-src-observability-mod-rs)
- [crates/svc-gateway/src/observability/tracing.rs](#crates-svc-gateway-src-observability-tracing-rs)
- [crates/svc-gateway/src/policy/abuse.rs](#crates-svc-gateway-src-policy-abuse-rs)
- [crates/svc-gateway/src/policy/mod.rs](#crates-svc-gateway-src-policy-mod-rs)
- [crates/svc-gateway/src/policy/residency.rs](#crates-svc-gateway-src-policy-residency-rs)
- [crates/svc-gateway/src/pq/mod.rs](#crates-svc-gateway-src-pq-mod-rs)
- [crates/svc-gateway/src/pq/policy.rs](#crates-svc-gateway-src-pq-policy-rs)
- [crates/svc-gateway/src/readiness/keys.rs](#crates-svc-gateway-src-readiness-keys-rs)
- [crates/svc-gateway/src/readiness/mod.rs](#crates-svc-gateway-src-readiness-mod-rs)
- [crates/svc-gateway/src/result.rs](#crates-svc-gateway-src-result-rs)
- [crates/svc-gateway/src/routes/health.rs](#crates-svc-gateway-src-routes-health-rs)
- [crates/svc-gateway/src/routes/metrics.rs](#crates-svc-gateway-src-routes-metrics-rs)
- [crates/svc-gateway/src/routes/mod.rs](#crates-svc-gateway-src-routes-mod-rs)
- [crates/svc-gateway/src/routes/objects.rs](#crates-svc-gateway-src-routes-objects-rs)
- [crates/svc-gateway/src/routes/objects_range.rs](#crates-svc-gateway-src-routes-objectsrange-rs)
- [crates/svc-gateway/src/routes/ready.rs](#crates-svc-gateway-src-routes-ready-rs)
- [crates/svc-gateway/src/routes/version.rs](#crates-svc-gateway-src-routes-version-rs)
- [crates/svc-gateway/src/state.rs](#crates-svc-gateway-src-state-rs)
- [crates/svc-gateway/src/tls/mod.rs](#crates-svc-gateway-src-tls-mod-rs)
- [crates/svc-gateway/tests/integration/caps_limits.rs](#crates-svc-gateway-tests-integration-capslimits-rs)
- [crates/svc-gateway/tests/integration/interop_vectors.rs](#crates-svc-gateway-tests-integration-interopvectors-rs)
- [crates/svc-gateway/tests/integration/loom_readiness.rs](#crates-svc-gateway-tests-integration-loomreadiness-rs)
- [crates/svc-gateway/tests/integration/readyz_degrade.rs](#crates-svc-gateway-tests-integration-readyzdegrade-rs)
- [crates/svc-gateway/tests/integration/taxonomy_stability.rs](#crates-svc-gateway-tests-integration-taxonomystability-rs)
- [crates/svc-gateway/tests/vectors/error_taxonomy.json](#crates-svc-gateway-tests-vectors-errortaxonomy-json)
- [crates/svc-gateway/tests/vectors/manifest_digest.json](#crates-svc-gateway-tests-vectors-manifestdigest-json)
- [crates/svc-gateway/tests/vectors/oap1_frame_roundtrip.json](#crates-svc-gateway-tests-vectors-oap1frameroundtrip-json)

### crates/svc-gateway/.github/workflows/api-stability.yml
<a id="crates-svc-gateway--github-workflows-api-stability-yml"></a>

```yaml
name: api-stability
on:
  pull_request:
    paths:
      - "src/**"
      - "Cargo.toml"
jobs:
  api:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: public api (placeholder)
        run: echo "wire cargo-public-api / semver-checks here"

```

### crates/svc-gateway/.github/workflows/ci.yml
<a id="crates-svc-gateway--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: fmt
        run: cargo fmt --all -- --check
      - name: clippy
        run: cargo clippy --all-targets --all-features -- -D warnings
      - name: test
        run: cargo test --all-features
      - name: deny (licenses/advisories)
        run: echo "placeholder — add cargo-deny later"

```

### crates/svc-gateway/.github/workflows/fuzz-nightly.yml
<a id="crates-svc-gateway--github-workflows-fuzz-nightly-yml"></a>

```yaml
name: fuzz-nightly
on:
  schedule:
    - cron: "0 3 * * *"
jobs:
  fuzz:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: fuzz (placeholder)
        run: echo "wire cargo-fuzz here"

```

### crates/svc-gateway/.github/workflows/perf-guard.yml
<a id="crates-svc-gateway--github-workflows-perf-guard-yml"></a>

```yaml
name: perf-guard
on:
  pull_request:
    paths:
      - "benches/**"
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: benches (placeholder)
        run: echo "run benches, compare benches/baseline.json"

```

### crates/svc-gateway/Cargo.toml
<a id="crates-svc-gateway-Cargo-toml"></a>

```toml
[package]
name = "svc-gateway"
version = "0.1.0"
edition = "2021"
rust-version = "1.78"
license = "MIT OR Apache-2.0"
publish = false
resolver = "2"

[features]
default = []
tls = ["tokio-rustls"]        # enable TLS server via rustls
pq = []                       # reserved for post-quantum toggles
cli = []                      # reserved for a future CLI surface

# --- Crate targets -----------------------------------------------------------

[lib]
name = "svc_gateway"          # underscores for the lib crate name
path = "src/lib.rs"

[[bin]]
name = "svc-gateway"          # hyphen ok for the binary name
path = "src/main.rs"

# --- Dependencies ------------------------------------------------------------

[dependencies]
anyhow = "1"
thiserror = "1"

# Axum stack (minimal features; stays on Tower 0.5)
axum = { version = "0.7", default-features = false, features = ["http1", "http2", "json", "tokio"] }
http = "1"
hyper = { version = "1", features = ["http1", "http2", "server"] }

# Ensure Tower 0.5 only (matches axum 0.7 and tower-http 0.6)
tower = { version = "0.5", features = ["util","timeout"] }
tower-http = { version = "0.6", features = [
  "trace",
  "request-id",
  "util",
  "cors",
  "limit",
  "timeout",
  "compression-full",
  "decompression-full",
  "set-header",
  "catch-panic"
] }

tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "io-util", "time"] }
tokio-util = "0.7"
tokio-rustls = { version = "0.26", optional = true }

prometheus = "0.14"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
once_cell = "1"
bytes = "1"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter", "json"] }
humantime = "2"
byte-unit = { version = "5", default-features = false, features = ["byte"] }
percent-encoding = "2"
uuid = { version = "1", features = ["v4"] }
headers = "0.4"
mime = "0.3"
futures-util = "0.3"

# Internal workspace crates
ron-kernel  = { path = "../ron-kernel" }
ron-metrics = { path = "../ron-metrics" }
ron-bus     = { path = "../ron-bus" }
ron-proto   = { path = "../ron-proto" }

[dev-dependencies]
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls-native-roots", "json"] }
tokio   = { version = "1", features = ["rt-multi-thread", "macros", "time"] }

```

### crates/svc-gateway/benches/baseline.json
<a id="crates-svc-gateway-benches-baseline-json"></a>

```json
{
  "_comment": "Performance baseline placeholder. Fill with real numbers after first bench run."
}

```

### crates/svc-gateway/configs/svc-gateway.sample.toml
<a id="crates-svc-gateway-configs-svc-gateway-sample-toml"></a>

```toml
# Sample config — svc-gateway2
# Role: Declarative knobs (timeouts, caps, quotas, amnesia, PQ/TLS policy).
[server]
bind = "127.0.0.1:9300"
metrics_bind = "127.0.0.1:9301"

[caps]
body_max_bytes = 1048576      # 1 MiB
decoded_max_bytes = 8388608   # 8 MiB
decoded_ratio_max = 10.0

[limits]
global_rps = 500

[amnesia]
enabled = true

[pq]
hybrid_enabled = false

```

### crates/svc-gateway/fuzz/targets/oap_frame.rs
<a id="crates-svc-gateway-fuzz-targets-oapframe-rs"></a>

```rust
//! oap_frame.rs — fuzz target placeholder.
//! Role: enforce 1 MiB frame invariants in OAP/1 envelope parsing.

```

### crates/svc-gateway/fuzz/targets/taxonomy_mapper.rs
<a id="crates-svc-gateway-fuzz-targets-taxonomymapper-rs"></a>

```rust
//! taxonomy_mapper.rs — fuzz target placeholder.
//! Role: guarantee deterministic, bounded error mapping.

```

### crates/svc-gateway/scripts/chaos_burst.sh
<a id="crates-svc-gateway-scripts-chaosburst-sh"></a>

```bash
#!/usr/bin/env bash
# Burst traffic and simulate downstream slowness (placeholder).
set -euo pipefail
echo "chaos_burst placeholder — add chaos injection once routes exist"

```

### crates/svc-gateway/scripts/dev_run.sh
<a id="crates-svc-gateway-scripts-devrun-sh"></a>

```bash
#!/usr/bin/env bash
# Starts svc-gateway2 with local env/config (placeholder runtime).
set -euo pipefail
echo "dev_run placeholder — wire up cargo run once implemented"

```

### crates/svc-gateway/scripts/export_metrics.sh
<a id="crates-svc-gateway-scripts-exportmetrics-sh"></a>

```bash
#!/usr/bin/env bash
# Quick metrics scrape (placeholder).
set -euo pipefail
curl -s http://127.0.0.1:9301/metrics || echo "metrics endpoint not yet implemented"

```

### crates/svc-gateway/scripts/smoke_gateway.sh
<a id="crates-svc-gateway-scripts-smokegateway-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

echo "fmt+clippy+build…"
cargo fmt -p svc-gateway
cargo clippy -p svc-gateway --no-deps -- -D warnings
cargo build -p svc-gateway

pkill -f svc-gateway || true
RUST_LOG=info,target=svc_gateway=debug cargo run -p svc-gateway &

sleep 0.5
echo "healthz:";  curl -si http://127.0.0.1:5304/healthz | head -n 1
echo "readyz:";   curl -si http://127.0.0.1:5304/readyz  | head -n 1
echo "metrics:";  curl -s  http://127.0.0.1:5304/metrics | head -n 10

```

### crates/svc-gateway/scripts/soak_test.sh
<a id="crates-svc-gateway-scripts-soaktest-sh"></a>

```bash
#!/usr/bin/env bash
# Long-running load to validate SLOs (placeholder).
set -euo pipefail
echo "soak_test placeholder — integrate your load tool"

```

### crates/svc-gateway/src/admission/capabilities.rs
<a id="crates-svc-gateway-src-admission-capabilities-rs"></a>

```rust
#[must_use]
pub fn has_cap(_cap: &str) -> bool {
    // Stub: wire to passport/policy later.
    true
}

```

### crates/svc-gateway/src/admission/classifier.rs
<a id="crates-svc-gateway-src-admission-classifier-rs"></a>

```rust
#[must_use]
pub fn classify(_path: &str) -> &'static str {
    // Stub: return a class label that DRR/rate-limiters might key on later.
    "default"
}

```

### crates/svc-gateway/src/admission/mod.rs
<a id="crates-svc-gateway-src-admission-mod-rs"></a>

```rust
//! Admission classifiers & quotas (stubs now).
pub mod capabilities;
pub mod classifier;
pub mod payments;
pub mod quotas;
pub mod residency;
pub mod taxonomy;

```

### crates/svc-gateway/src/admission/payments.rs
<a id="crates-svc-gateway-src-admission-payments-rs"></a>

```rust
//! admission/payments.rs — (feature = "econ") enforce paid writes/prepaid quotas — placeholder.

```

### crates/svc-gateway/src/admission/quotas.rs
<a id="crates-svc-gateway-src-admission-quotas-rs"></a>

```rust
#[must_use]
pub fn allow(_tenant: &str) -> bool {
    // Stub: tie into svc-index/svc-registry later.
    true
}

```

### crates/svc-gateway/src/admission/residency.rs
<a id="crates-svc-gateway-src-admission-residency-rs"></a>

```rust
//! admission/residency.rs — Thin adapter to `policy::residency` — placeholder.

#[must_use]
pub fn region_ok(_tenant: &str, _region: &str) -> bool {
    true
}

```

### crates/svc-gateway/src/admission/taxonomy.rs
<a id="crates-svc-gateway-src-admission-taxonomy-rs"></a>

```rust
//! admission/taxonomy.rs — Deterministic reason/status mapping — placeholder.

```

### crates/svc-gateway/src/cli/mod.rs
<a id="crates-svc-gateway-src-cli-mod-rs"></a>

```rust
//! cli/mod.rs — CLI flags (binds, pq policy, econ enforcement) — placeholder.

```

### crates/svc-gateway/src/config/amnesia.rs
<a id="crates-svc-gateway-src-config-amnesia-rs"></a>

```rust
//! Amnesia-mode toggles (RAM-only, extra redaction). 
//! Operator doc references. :contentReference[oaicite:8]{index=8}
#[inline]
pub fn amnesia_enabled() -> bool { false }

```

### crates/svc-gateway/src/config/env.rs
<a id="crates-svc-gateway-src-config-env-rs"></a>

```rust
//! Placeholder: add real env mapping (SVC_GATEWAY_*).
//! Docs show examples and precedence. :contentReference[oaicite:6]{index=6}

```

### crates/svc-gateway/src/config/mod.rs
<a id="crates-svc-gateway-src-config-mod-rs"></a>

```rust
//! RO:WHAT   Config model + loaders (env/file) with hard defaults.
//! RO:WHY    Keep caps & readiness guards aligned with blueprint.
//! Env prefix `SVC_GATEWAY`_. Docs show precedence + examples. :contentReference[oaicite:5]{index=5}

use crate::consts::{
    DEFAULT_BODY_CAP_BYTES, DEFAULT_DECODE_ABS_CAP_BYTES, DEFAULT_DECODE_RATIO_MAX,
    DEFAULT_IDLE_TIMEOUT_SECS, DEFAULT_MAX_CONNS, DEFAULT_READ_TIMEOUT_SECS, DEFAULT_RPS,
    DEFAULT_WRITE_TIMEOUT_SECS,
};

use serde::Deserialize;
use std::net::SocketAddr;

#[derive(Debug, Clone, Deserialize)]
pub struct Config {
    pub server: Server,
    pub limits: Limits,
    pub drr: Drr,
    pub amnesia: Amnesia,
    pub pq: Pq,
    pub safety: Safety,
    pub log: Log,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Server {
    pub bind_addr: SocketAddr,
    pub metrics_addr: SocketAddr,
    pub max_conns: usize,
    pub read_timeout_secs: u64,
    pub write_timeout_secs: u64,
    pub idle_timeout_secs: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Limits {
    pub max_body_bytes: usize,
    pub decode_abs_cap_bytes: usize,
    pub decode_ratio_max: usize,
}

#[derive(Debug, Clone, Deserialize, Default)]
pub struct Drr {
    pub default_quantum: u32,
    pub rate_limit_rps: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Amnesia {
    pub enabled: bool,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Pq {
    pub mode: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Safety {
    pub danger_ok: bool,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Log {
    pub format: String,
    pub level: String,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            server: Server {
                bind_addr: "127.0.0.1:5304".parse().unwrap(),
                metrics_addr: "127.0.0.1:0".parse().unwrap(),
                max_conns: DEFAULT_MAX_CONNS,
                read_timeout_secs: DEFAULT_READ_TIMEOUT_SECS,
                write_timeout_secs: DEFAULT_WRITE_TIMEOUT_SECS,
                idle_timeout_secs: DEFAULT_IDLE_TIMEOUT_SECS,
            },
            limits: Limits {
                max_body_bytes: DEFAULT_BODY_CAP_BYTES,
                decode_abs_cap_bytes: DEFAULT_DECODE_ABS_CAP_BYTES,
                decode_ratio_max: DEFAULT_DECODE_RATIO_MAX,
            },
            drr: Drr {
                default_quantum: 1,
                rate_limit_rps: DEFAULT_RPS,
            },
            amnesia: Amnesia { enabled: false },
            pq: Pq { mode: "off".into() },
            safety: Safety { danger_ok: false },
            log: Log {
                format: "json".into(),
                level: "info".into(),
            },
        }
    }
}

impl Config {
    /// Load configuration.
    ///
    /// # Errors
    ///
    /// This stubbed loader cannot fail today; it will return `Ok(Self::default())`.
    /// When file/env loading is added later, this will surface parse/IO errors.
    pub fn load() -> anyhow::Result<Self> {
        Ok(Self::default())
    }
}

```

### crates/svc-gateway/src/config/safety.rs
<a id="crates-svc-gateway-src-config-safety-rs"></a>

```rust
//! Safety guard to prevent weakening defaults unless `danger_ok=true`.
//! Hardening checklist refs. :contentReference[oaicite:7]{index=7}

#[inline]
pub fn assert_safe(danger_ok: bool) {
    if !danger_ok { /* keep defaults enforced */ }
}

```

### crates/svc-gateway/src/consts.rs
<a id="crates-svc-gateway-src-consts-rs"></a>

```rust
// crates/svc-gateway/src/consts.rs
#![allow(clippy::module_name_repetitions)]

pub const DEFAULT_MAX_CONNS: usize = 2_048;

// 1 MiB (avoid `1 * 1024 * 1024` which trips clippy::identity_op)
pub const DEFAULT_BODY_CAP_BYTES: usize = 1_048_576;

// Decompression guard
pub const DEFAULT_DECODE_RATIO_MAX: usize = 10;
pub const DEFAULT_DECODE_ABS_CAP_BYTES: usize = 16 * 1_048_576; // 16 MiB

// Read timeouts
pub const DEFAULT_READ_TIMEOUT_SECS: u64 = 10;
pub const DEFAULT_WRITE_TIMEOUT_SECS: u64 = 10;
pub const DEFAULT_IDLE_TIMEOUT_SECS: u64 = 30;

// Rate limit (as u64 to match config field)
pub const DEFAULT_RPS: u64 = 500;

```

### crates/svc-gateway/src/errors.rs
<a id="crates-svc-gateway-src-errors-rs"></a>

```rust
//! Carry-over: `Problem{code,message,retryable,retry_after_ms?,reason?}`.

use axum::{
    http::{self, HeaderValue, StatusCode},
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;

#[derive(Serialize)]
pub struct Problem<'a> {
    pub code: &'a str,
    pub message: &'a str,
    pub retryable: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retry_after_ms: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<&'a str>,
}

impl Problem<'_> {
    #[must_use]
    pub fn into_response_with(self, status: StatusCode) -> Response {
        (status, Json(self)).into_response()
    }
}

/// 429 Too Many Requests with Retry-After (seconds). Never panics.
pub fn rate_limited_retry_after(ms: u64) -> Response {
    let mut resp = Problem {
        code: "rate_limited",
        message: "Too many requests",
        retryable: true,
        retry_after_ms: Some(ms),
        reason: None,
    }
    .into_response_with(StatusCode::TOO_MANY_REQUESTS);

    // Best-effort Retry-After header; if conversion fails, omit it.
    if let Ok(v) = HeaderValue::from_str(&(ms / 1000).to_string()) {
        let headers = resp.headers_mut();
        headers.insert(http::header::RETRY_AFTER, v);
    }
    resp
}

/// 503 Busy with Retry-After (seconds). Never panics.
pub fn too_busy_retry_after(ms: u64) -> Response {
    let mut resp = Problem {
        code: "too_busy",
        message: "Server busy",
        retryable: true,
        retry_after_ms: Some(ms),
        reason: None,
    }
    .into_response_with(StatusCode::SERVICE_UNAVAILABLE);

    if let Ok(v) = HeaderValue::from_str(&(ms / 1000).to_string()) {
        let headers = resp.headers_mut();
        headers.insert(http::header::RETRY_AFTER, v);
    }
    resp
}

```

### crates/svc-gateway/src/forward/index_client.rs
<a id="crates-svc-gateway-src-forward-indexclient-rs"></a>

```rust
//! Index client stub.

```

### crates/svc-gateway/src/forward/mod.rs
<a id="crates-svc-gateway-src-forward-mod-rs"></a>

```rust
//! Clients to overlay/index/storage (stubs).

pub mod index_client;
pub mod overlay_client;
pub mod storage_client;

```

### crates/svc-gateway/src/forward/overlay_client.rs
<a id="crates-svc-gateway-src-forward-overlayclient-rs"></a>

```rust
/// Fetch raw bytes from overlay given an address + relative path.
///
/// # Errors
///
/// As a stub this never errors and returns an empty vec. When implemented,
/// it will return I/O or protocol errors from the overlay client.
pub fn get_bytes(_addr: &str, _rel: &str) -> anyhow::Result<Vec<u8>> {
    Ok(Vec::new())
}

```

### crates/svc-gateway/src/forward/storage_client.rs
<a id="crates-svc-gateway-src-forward-storageclient-rs"></a>

```rust
//! `forward/storage_client.rs` — Optional: read-only media proxy; range-reads — placeholder.

/// Stubbed storage fetch.
///
/// # Errors
///
/// See `overlay_client` notes (not implemented here yet).
pub fn get_object(_key: &str) -> anyhow::Result<Vec<u8>> {
    Ok(Vec::new())
}

```

### crates/svc-gateway/src/headers/etag.rs
<a id="crates-svc-gateway-src-headers-etag-rs"></a>

```rust
//! Produce a quoted `ETag` value for a BLAKE3 address (e.g., `b3:abcd...`).

#[must_use]
pub fn etag_from_b3(addr: &str) -> String {
    // clippy(pedantic): prefer inline args over `"{}"`
    format!("\"{addr}\"")
}

```

### crates/svc-gateway/src/headers/mod.rs
<a id="crates-svc-gateway-src-headers-mod-rs"></a>

```rust
pub mod etag;

```

### crates/svc-gateway/src/layers/auth.rs
<a id="crates-svc-gateway-src-layers-auth-rs"></a>

```rust
#[must_use]
pub fn enabled() -> bool {
    false
}

```

### crates/svc-gateway/src/layers/body_caps.rs
<a id="crates-svc-gateway-src-layers-bodycaps-rs"></a>

```rust
use tower_http::limit::RequestBodyLimitLayer;

#[must_use]
pub fn layer(max_bytes: usize) -> RequestBodyLimitLayer {
    RequestBodyLimitLayer::new(max_bytes)
}

```

### crates/svc-gateway/src/layers/corr.rs
<a id="crates-svc-gateway-src-layers-corr-rs"></a>

```rust
//! RO:WHAT      Correlation-id layer (stub).
//! RO:WHY       No-op identity layer so the router can compile now; we’ll
//!              swap in real request-id middleware later.
//! RO:USE       Attach at route scope: `.route_layer(layers::corr::layer())`.

use tower::layer::util::Identity;

/// Return a no-op layer that leaves the inner service unchanged.
///
/// This avoids pulling in `tower-layer` directly and works with Axum 0.7’s
/// `Router::route_layer` bounds.
///
/// # Example
/// ```ignore
/// router
///   .route("/ping", get(ping))
///   .route_layer(layers::corr::layer());
/// ```
#[must_use = "attach with `.route_layer(layers::corr::layer())`"]
pub fn layer() -> Identity {
    Identity::new()
}

```

### crates/svc-gateway/src/layers/decode_guard.rs
<a id="crates-svc-gateway-src-layers-decodeguard-rs"></a>

```rust
//! STUB: decode guard (decompression ratio / absolute cap checks) temporarily disabled.
//! Returns an identity layer to unblock compilation; real logic will be restored later.

#![allow(clippy::unused_async)]

use tower::layer::util::Identity;

/// Stub that produces a `Layer` satisfying axum's `route_layer` bounds.
#[must_use]
pub fn layer(_ratio_max: usize, _abs_cap: usize) -> Identity {
    Identity::new()
}

```

### crates/svc-gateway/src/layers/drr.rs
<a id="crates-svc-gateway-src-layers-drr-rs"></a>

```rust
//! RO:WHAT   DRR/fair-queue placeholder layer.
//! RO:WHY    Slot-in for future dispatcher; currently pass-through.

use axum::http::Request;
use axum::response::Response;
use std::task::{Context, Poll};
use tower::{Layer, Service};

use crate::observability::metrics::MetricsHandles;

#[derive(Clone)]
pub struct DrrLayer {
    pub max_inflight: usize,
    pub metrics: MetricsHandles,
}

impl<S> Layer<S> for DrrLayer {
    type Service = Drr<S>;
    fn layer(&self, inner: S) -> Self::Service {
        Drr {
            inner,
            max_inflight: self.max_inflight,
            metrics: self.metrics.clone(),
        }
    }
}

#[derive(Clone)]
pub struct Drr<S> {
    inner: S,
    #[allow(dead_code)]
    max_inflight: usize,
    #[allow(dead_code)]
    metrics: MetricsHandles,
}

impl<S, B> Service<Request<B>> for Drr<S>
where
    S: Service<Request<B>, Response = Response> + Clone + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Send + 'static,
{
    type Response = Response;
    type Error = S::Error;
    type Future = S::Future;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        // TODO: implement fair queueing; for now pass-through.
        self.inner.call(req)
    }
}

```

### crates/svc-gateway/src/layers/mod.rs
<a id="crates-svc-gateway-src-layers-mod-rs"></a>

```rust
//! Order (inner→outer): timeouts → `body_caps` → `decode_guard` → `rate_limit` → drr → tarpit → auth → corr

pub mod corr;
pub mod decode_guard;
pub mod timeouts;

```

### crates/svc-gateway/src/layers/rate_limit.rs
<a id="crates-svc-gateway-src-layers-ratelimit-rs"></a>

```rust
//! RO:WHAT   RPS token-bucket placeholder layer.
//! RO:WHY    Slot-in for future limiter; currently pass-through.

use axum::http::Request;
use axum::response::Response;
use std::task::{Context, Poll};
use tower::{Layer, Service};

#[derive(Clone)]
pub struct RateLimitLayer {
    pub rps: usize,
}

impl<S> Layer<S> for RateLimitLayer {
    type Service = RateLimit<S>;
    fn layer(&self, inner: S) -> Self::Service {
        RateLimit {
            inner,
            rps: self.rps,
        }
    }
}

#[derive(Clone)]
pub struct RateLimit<S> {
    inner: S,
    #[allow(dead_code)]
    rps: usize,
}

impl<S, B> Service<Request<B>> for RateLimit<S>
where
    S: Service<Request<B>, Response = Response> + Clone + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Send + 'static,
{
    type Response = Response;
    type Error = S::Error;
    type Future = S::Future;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        // TODO: implement token bucket; for now pass-through.
        self.inner.call(req)
    }
}

```

### crates/svc-gateway/src/layers/tarpit.rs
<a id="crates-svc-gateway-src-layers-tarpit-rs"></a>

```rust
#[must_use]
pub fn enabled() -> bool {
    false
}

```

### crates/svc-gateway/src/layers/timeouts.rs
<a id="crates-svc-gateway-src-layers-timeouts-rs"></a>

```rust
//! STUB: per-route read timeout layer (temporarily disabled).
//! Returns an identity layer that compiles cleanly with axum 0.7's `route_layer` bounds.

#![allow(clippy::unused_async)]

use tower::layer::util::Identity;

/// Stub that produces a `Layer` satisfying:
/// `Service<Request<Body>> + Clone + Send + 'static`.
#[must_use]
pub fn layer(_read_s: u64) -> Identity {
    Identity::new()
}

```

### crates/svc-gateway/src/lib.rs
<a id="crates-svc-gateway-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]
#![deny(clippy::all, clippy::pedantic)]
#![allow(clippy::module_name_repetitions)]

pub mod consts;
pub mod errors;
pub mod result;
pub mod state;

pub mod config;
pub mod headers;
pub mod observability;
pub mod policy;
pub mod pq;
pub mod readiness;
pub mod tls;

pub mod admission;
pub mod forward;
pub mod layers;
pub mod routes;

```

### crates/svc-gateway/src/main.rs
<a id="crates-svc-gateway-src-main-rs"></a>

```rust
//! svc-gateway binary (stub bootstrap)

use axum::Router;
use svc_gateway::{config::Config, observability::metrics, routes, state::AppState};
use tokio::net::TcpListener;
use tracing::{info, Level};
use tracing_subscriber::EnvFilter;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Minimal tracing; respects RUST_LOG if set.
    let _ = tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env().add_directive(Level::INFO.into()))
        .with_target(false)
        .try_init();

    let cfg = Config::load()?;
    let metrics_handles = metrics::register()?;

    // App state requires both Config and MetricsHandles
    let state = AppState::new(cfg.clone(), metrics_handles.clone());

    // Build the router from crate routes
    let router: Router = routes::build_router(&state);

    // Bind and serve with graceful shutdown
    let listener = TcpListener::bind(cfg.server.bind_addr).await?;
    info!("svc-gateway listening on {}", cfg.server.bind_addr);

    axum::serve(listener, router)
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    Ok(())
}

async fn shutdown_signal() {
    // CTRL+C to stop
    let _ = tokio::signal::ctrl_c().await;
}

```

### crates/svc-gateway/src/observability/logging.rs
<a id="crates-svc-gateway-src-observability-logging-rs"></a>

```rust
use tracing_subscriber::{fmt::format::FmtSpan, EnvFilter};

pub fn init() {
    let filter =
        std::env::var("RUST_LOG").unwrap_or_else(|_| "info,axum=warn,tower_http=warn".into());
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::new(filter))
        .with_span_events(FmtSpan::CLOSE)
        .json()
        .flatten_event(true)
        .init();
}

```

### crates/svc-gateway/src/observability/metrics.rs
<a id="crates-svc-gateway-src-observability-metrics-rs"></a>

```rust
//! Prometheus registry + golden metrics wiring.
//! Dashboard hints & names aligned with docs. :contentReference[oaicite:9]{index=9}

use prometheus::{
    register_histogram_vec, register_int_counter_vec, register_int_gauge, HistogramVec,
    IntCounterVec, IntGauge,
};

/// Handles to all gateway metrics registered in the global Prometheus registry.
#[derive(Clone)]
pub struct MetricsHandles {
    /// Total HTTP requests, partitioned by `route`, `method`, and `status`.
    pub http_reqs: IntCounterVec,
    /// Request latency histogram (seconds), partitioned by `route` and `method`.
    pub http_lat: HistogramVec,
    /// Current number of in-flight requests across the gateway.
    pub inflight: IntGauge,
    /// Count of rejected requests by `reason` (e.g., `rate_limit`, `body_cap`, `timeout`).
    pub rejected: IntCounterVec,

    pub ready_inflight_current: IntGauge,
    pub ready_error_rate_pct: IntGauge,
    pub ready_queue_saturated: IntGauge,
}

/// Register metrics; returns handles.
///
/// # Errors
///
/// Returns an error if metrics of the same name are already registered.
pub fn register() -> anyhow::Result<MetricsHandles> {
    let http_reqs = register_int_counter_vec!(
        "http_requests_total",
        "HTTP requests",
        &["route", "method", "status"]
    )?;
    let http_lat = register_histogram_vec!(
        "request_latency_seconds",
        "Request latencies",
        &["route", "method"]
    )?;
    let inflight = register_int_gauge!("inflight_requests", "In-flight requests")?;
    let rejected = register_int_counter_vec!(
        "rejected_total",
        "Rejected by reason (e.g., rate_limit, body_cap, timeout)",
        &["reason"]
    )?;

    // Readiness gauges (carry-over names). :contentReference[oaicite:10]{index=10}
    let ready_inflight_current =
        register_int_gauge!("ready_inflight_current", "Current inflight across gateway")?;
    let ready_error_rate_pct =
        register_int_gauge!("ready_error_rate_pct", "Observed 429/503 % over window")?;
    let ready_queue_saturated =
        register_int_gauge!("ready_queue_saturated", "Queue saturated indicator")?;

    Ok(MetricsHandles {
        http_reqs,
        http_lat,
        inflight,
        rejected,
        ready_inflight_current,
        ready_error_rate_pct,
        ready_queue_saturated,
    })
}

```

### crates/svc-gateway/src/observability/mod.rs
<a id="crates-svc-gateway-src-observability-mod-rs"></a>

```rust
pub mod logging;
pub mod metrics;
pub mod tracing;

```

### crates/svc-gateway/src/observability/tracing.rs
<a id="crates-svc-gateway-src-observability-tracing-rs"></a>

```rust
//! observability/tracing.rs — Trace subscriber & context propagation — placeholder.

```

### crates/svc-gateway/src/policy/abuse.rs
<a id="crates-svc-gateway-src-policy-abuse-rs"></a>

```rust
#[derive(Clone, Default)]
pub struct AbusePolicy;

```

### crates/svc-gateway/src/policy/mod.rs
<a id="crates-svc-gateway-src-policy-mod-rs"></a>

```rust
//! Residency/abuse policy stubs; attach via Extension<> AFTER inner layers.
//! Carry-over: Extension order discipline. :contentReference[oaicite:13]{index=13}
pub mod abuse;
pub mod residency;

#[derive(Clone, Default)]
pub struct PolicyBundle;

```

### crates/svc-gateway/src/policy/residency.rs
<a id="crates-svc-gateway-src-policy-residency-rs"></a>

```rust
#[derive(Clone, Default)]
pub struct ResidencyPolicy;

```

### crates/svc-gateway/src/pq/mod.rs
<a id="crates-svc-gateway-src-pq-mod-rs"></a>

```rust
//! Post-quantum plumbing stub (hybrid later).
pub mod policy;

```

### crates/svc-gateway/src/pq/policy.rs
<a id="crates-svc-gateway-src-pq-policy-rs"></a>

```rust
//! PQ policy toggles (off|hybrid). Kept as stub for now.
#[derive(Clone, Copy, Debug)]
pub enum PqMode {
    Off,
    Hybrid,
}

```

### crates/svc-gateway/src/readiness/keys.rs
<a id="crates-svc-gateway-src-readiness-keys-rs"></a>

```rust
//! Names kept stable for dashboards/tests. :contentReference[oaicite:12]{index=12}
pub const READY_INFLIGHT_CURRENT: &str = "ready_inflight_current";
pub const READY_ERROR_RATE_PCT: &str = "ready_error_rate_pct";
pub const READY_QUEUE_SATURATED: &str = "ready_queue_saturated";

```

### crates/svc-gateway/src/readiness/mod.rs
<a id="crates-svc-gateway-src-readiness-mod-rs"></a>

```rust
//! Tiny readiness/degradation flag exposed to /readyz.

use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};

#[derive(Default)]
struct ReadyStateInner {
    degraded: AtomicBool,
}

#[derive(Clone)]
pub struct ReadyState(Arc<ReadyStateInner>);

impl Default for ReadyState {
    fn default() -> Self {
        Self::new()
    }
}

impl ReadyState {
    #[must_use]
    pub fn new() -> Self {
        Self(Arc::new(ReadyStateInner::default()))
    }

    pub fn set_degraded(&self, d: bool) {
        self.0.degraded.store(d, Ordering::Relaxed);
    }

    #[must_use]
    pub fn is_degraded(&self) -> bool {
        self.0.degraded.load(Ordering::Relaxed)
    }

    /// Consider "ready" when not degraded (you can enrich later with more gates).
    #[must_use]
    pub fn ready(&self) -> bool {
        !self.is_degraded()
    }
}

```

### crates/svc-gateway/src/result.rs
<a id="crates-svc-gateway-src-result-rs"></a>

```rust
pub type Result<T, E = anyhow::Error> = std::result::Result<T, E>;

```

### crates/svc-gateway/src/routes/health.rs
<a id="crates-svc-gateway-src-routes-health-rs"></a>

```rust
//! RO:WHAT  /healthz — liveness probe.
//! RO:WHY   Simple process up check. Always 200 "ok".

use axum::response::{IntoResponse, Response};

pub async fn handler() -> Response {
    "ok".into_response()
}

```

### crates/svc-gateway/src/routes/metrics.rs
<a id="crates-svc-gateway-src-routes-metrics-rs"></a>

```rust
//! RO:NOTE  We gather from the default registry to avoid coupling to `MetricsHandles` API.

use axum::{response::IntoResponse, Json};
use prometheus::{Encoder, TextEncoder};

pub async fn get_metrics() -> impl IntoResponse {
    let metric_families = prometheus::gather();
    let mut buf = Vec::new();
    let encoder = TextEncoder::new();
    let _ = encoder.encode(&metric_families, &mut buf);
    // Expose as text; callers should set content-type when wiring the route.
    Json(String::from_utf8_lossy(&buf).into_owned())
}

```

### crates/svc-gateway/src/routes/mod.rs
<a id="crates-svc-gateway-src-routes-mod-rs"></a>

```rust
use crate::state::AppState;
use axum::{routing::get, Router};

mod metrics;

pub fn build_router(_state: &AppState) -> Router {
    Router::new().route("/metrics", get(metrics::get_metrics))
}

```

### crates/svc-gateway/src/routes/objects.rs
<a id="crates-svc-gateway-src-routes-objects-rs"></a>

```rust
//! GET /o/{addr}

use crate::headers::etag::etag_from_b3;
use axum::{extract::Path, response::IntoResponse};

pub async fn get_object(Path(addr): Path<String>) -> impl IntoResponse {
    // MVP: echo stub (no overlay forwarding yet).
    (
        [(http::header::ETAG, etag_from_b3(&addr))],
        axum::body::Body::from(format!("object stub for {}", addr)),
    )
}

```

### crates/svc-gateway/src/routes/objects_range.rs
<a id="crates-svc-gateway-src-routes-objectsrange-rs"></a>

```rust
//! GET /o/{addr} with Range (separate route for clarity)

use axum::{extract::Path, response::IntoResponse};

pub async fn get_range(Path(addr): Path<String>) -> impl IntoResponse {
    // MVP: range not implemented yet
    (
        http::StatusCode::NOT_IMPLEMENTED,
        format!("range read stub for {}", addr),
    )
}

```

### crates/svc-gateway/src/routes/ready.rs
<a id="crates-svc-gateway-src-routes-ready-rs"></a>

```rust
//! /readyz — conservative stub (503) until the real sampler wires in.

use crate::state::AppState;
use axum::{extract::State, http::StatusCode, response::IntoResponse};

pub async fn handler(State(state): State<AppState>) -> impl IntoResponse {
    let _ = &state.readiness; // placeholder to show we touched it
    (StatusCode::SERVICE_UNAVAILABLE, "not ready")
}

```

### crates/svc-gateway/src/routes/version.rs
<a id="crates-svc-gateway-src-routes-version-rs"></a>

```rust
use axum::Json;
use serde_json::json;

// The router expects `version::handler`
pub async fn handler() -> Json<serde_json::Value> {
    Json(json!({
        "service": "svc-gateway",
        "version": env!("CARGO_PKG_VERSION"),
        "build": { "pkg": env!("CARGO_PKG_NAME") }
    }))
}

```

### crates/svc-gateway/src/state.rs
<a id="crates-svc-gateway-src-state-rs"></a>

```rust
//! RO:WHAT   Process state container passed to handlers and layers.
//! RO:WHY    Centralizes config, metrics handles, and readiness gate.
//! RO:INVARS Send + Sync; cheap to clone via Arcs.

use std::sync::Arc;

use crate::config::Config;
use crate::observability::metrics::{self, MetricsHandles};
use crate::readiness::ReadyState;

#[derive(Clone)]
pub struct AppState {
    pub cfg: Config,
    pub metrics: MetricsHandles,
    pub readiness: Arc<ReadyState>,
}

impl AppState {
    /// Build a new state from provided parts.
    #[must_use]
    pub fn new(cfg: Config, metrics: MetricsHandles) -> Self {
        Self {
            cfg,
            metrics,
            readiness: Arc::new(ReadyState::new()),
        }
    }

    /// Convenience ctor for early bring-up until real loaders are wired.
    ///
    /// # Panics
    /// Panics if metric registration fails (should not happen under normal conditions).
    #[must_use]
    pub fn new_default() -> Self {
        let cfg = Config::default();
        let metrics = metrics::register().expect("register metrics");
        Self::new(cfg, metrics)
    }
}

```

### crates/svc-gateway/src/tls/mod.rs
<a id="crates-svc-gateway-src-tls-mod-rs"></a>

```rust
//! TLS scaffolding (tokio-rustls) — enable with `--features tls`.

```

### crates/svc-gateway/tests/integration/caps_limits.rs
<a id="crates-svc-gateway-tests-integration-capslimits-rs"></a>

```rust
//! caps_limits.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/integration/interop_vectors.rs
<a id="crates-svc-gateway-tests-integration-interopvectors-rs"></a>

```rust
//! interop_vectors.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/integration/loom_readiness.rs
<a id="crates-svc-gateway-tests-integration-loomreadiness-rs"></a>

```rust
//! loom_readiness.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/integration/readyz_degrade.rs
<a id="crates-svc-gateway-tests-integration-readyzdegrade-rs"></a>

```rust
//! readyz_degrade.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/integration/taxonomy_stability.rs
<a id="crates-svc-gateway-tests-integration-taxonomystability-rs"></a>

```rust
//! taxonomy_stability.rs — integration test placeholder.
//! Role: prove invariants (shed writes first, caps, interop vectors, taxonomy freeze, loom interleavings).

```

### crates/svc-gateway/tests/vectors/error_taxonomy.json
<a id="crates-svc-gateway-tests-vectors-errortaxonomy-json"></a>

```json
{ "_comment": "Deterministic error taxonomy mapping placeholder." }

```

### crates/svc-gateway/tests/vectors/manifest_digest.json
<a id="crates-svc-gateway-tests-vectors-manifestdigest-json"></a>

```json
{ "_comment": "BLAKE3 manifest digest vector placeholder." }

```

### crates/svc-gateway/tests/vectors/oap1_frame_roundtrip.json
<a id="crates-svc-gateway-tests-vectors-oap1frameroundtrip-json"></a>

```json
{ "_comment": "OAP/1 frame roundtrip vector placeholder." }

```

