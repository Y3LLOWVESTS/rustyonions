<!-- Generated by scripts/make_crate_codex.sh on 2025-10-26T00:33:07Z -->
# Code Bundle â€” `ron-transport`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-transport/.cargo/config.toml](#crates-ron-transport--cargo-config-toml)
- [crates/ron-transport/.github/workflows/ci.yml](#crates-ron-transport--github-workflows-ci-yml)
- [crates/ron-transport/.github/workflows/perf.yml](#crates-ron-transport--github-workflows-perf-yml)
- [crates/ron-transport/.github/workflows/tla.yml](#crates-ron-transport--github-workflows-tla-yml)
- [crates/ron-transport/Cargo.toml](#crates-ron-transport-Cargo-toml)
- [crates/ron-transport/benches/bench_latency.rs](#crates-ron-transport-benches-benchlatency-rs)
- [crates/ron-transport/benches/bench_throughput.rs](#crates-ron-transport-benches-benchthroughput-rs)
- [crates/ron-transport/examples/bench_echo.rs](#crates-ron-transport-examples-benchecho-rs)
- [crates/ron-transport/examples/http_echo.rs](#crates-ron-transport-examples-httpecho-rs)
- [crates/ron-transport/examples/onion_echo.rs](#crates-ron-transport-examples-onionecho-rs)
- [crates/ron-transport/examples/quic_echo.rs](#crates-ron-transport-examples-quicecho-rs)
- [crates/ron-transport/examples/tcp_echo.rs](#crates-ron-transport-examples-tcpecho-rs)
- [crates/ron-transport/examples/tls_echo.rs](#crates-ron-transport-examples-tlsecho-rs)
- [crates/ron-transport/examples/tls_transport.rs](#crates-ron-transport-examples-tlstransport-rs)
- [crates/ron-transport/fuzz/fuzz_targets/frame_boundaries.rs](#crates-ron-transport-fuzz-fuzztargets-frameboundaries-rs)
- [crates/ron-transport/scripts/ci/env_sanitize.sh](#crates-ron-transport-scripts-ci-envsanitize-sh)
- [crates/ron-transport/scripts/ci/run_tlc.sh](#crates-ron-transport-scripts-ci-runtlc-sh)
- [crates/ron-transport/scripts/local/echo_smoke.sh](#crates-ron-transport-scripts-local-echosmoke-sh)
- [crates/ron-transport/scripts/local/http_echo_smoke.sh](#crates-ron-transport-scripts-local-httpechosmoke-sh)
- [crates/ron-transport/scripts/local/mk_self_signed.sh](#crates-ron-transport-scripts-local-mkselfsigned-sh)
- [crates/ron-transport/scripts/local/perf_repro.sh](#crates-ron-transport-scripts-local-perfrepro-sh)
- [crates/ron-transport/scripts/local/smoke_tls.sh](#crates-ron-transport-scripts-local-smoketls-sh)
- [crates/ron-transport/scripts/local/smoke_transport.sh](#crates-ron-transport-scripts-local-smoketransport-sh)
- [crates/ron-transport/src/arti/client.rs](#crates-ron-transport-src-arti-client-rs)
- [crates/ron-transport/src/arti/mod.rs](#crates-ron-transport-src-arti-mod-rs)
- [crates/ron-transport/src/arti/readiness.rs](#crates-ron-transport-src-arti-readiness-rs)
- [crates/ron-transport/src/arti/service.rs](#crates-ron-transport-src-arti-service-rs)
- [crates/ron-transport/src/config.rs](#crates-ron-transport-src-config-rs)
- [crates/ron-transport/src/conn/backpressure.rs](#crates-ron-transport-src-conn-backpressure-rs)
- [crates/ron-transport/src/conn/mod.rs](#crates-ron-transport-src-conn-mod-rs)
- [crates/ron-transport/src/conn/rate_limit.rs](#crates-ron-transport-src-conn-ratelimit-rs)
- [crates/ron-transport/src/conn/reader.rs](#crates-ron-transport-src-conn-reader-rs)
- [crates/ron-transport/src/conn/writer.rs](#crates-ron-transport-src-conn-writer-rs)
- [crates/ron-transport/src/error.rs](#crates-ron-transport-src-error-rs)
- [crates/ron-transport/src/lib.rs](#crates-ron-transport-src-lib-rs)
- [crates/ron-transport/src/limits.rs](#crates-ron-transport-src-limits-rs)
- [crates/ron-transport/src/metrics.rs](#crates-ron-transport-src-metrics-rs)
- [crates/ron-transport/src/quic/client.rs](#crates-ron-transport-src-quic-client-rs)
- [crates/ron-transport/src/quic/mod.rs](#crates-ron-transport-src-quic-mod-rs)
- [crates/ron-transport/src/quic/server.rs](#crates-ron-transport-src-quic-server-rs)
- [crates/ron-transport/src/readiness.rs](#crates-ron-transport-src-readiness-rs)
- [crates/ron-transport/src/reason.rs](#crates-ron-transport-src-reason-rs)
- [crates/ron-transport/src/tcp/dialer.rs](#crates-ron-transport-src-tcp-dialer-rs)
- [crates/ron-transport/src/tcp/listener.rs](#crates-ron-transport-src-tcp-listener-rs)
- [crates/ron-transport/src/tcp/mod.rs](#crates-ron-transport-src-tcp-mod-rs)
- [crates/ron-transport/src/tls/client.rs](#crates-ron-transport-src-tls-client-rs)
- [crates/ron-transport/src/tls/mod.rs](#crates-ron-transport-src-tls-mod-rs)
- [crates/ron-transport/src/tls/server.rs](#crates-ron-transport-src-tls-server-rs)
- [crates/ron-transport/src/tls_types.rs](#crates-ron-transport-src-tlstypes-rs)
- [crates/ron-transport/src/types.rs](#crates-ron-transport-src-types-rs)
- [crates/ron-transport/src/util/bytes.rs](#crates-ron-transport-src-util-bytes-rs)
- [crates/ron-transport/src/util/cancel.rs](#crates-ron-transport-src-util-cancel-rs)
- [crates/ron-transport/src/util/mod.rs](#crates-ron-transport-src-util-mod-rs)
- [crates/ron-transport/src/util/timeouts.rs](#crates-ron-transport-src-util-timeouts-rs)
- [crates/ron-transport/tests/amnesia/no_disk_touches.rs](#crates-ron-transport-tests-amnesia-nodisktouches-rs)
- [crates/ron-transport/tests/integration/arti_bootstrap_ready.rs](#crates-ron-transport-tests-integration-artibootstrapready-rs)
- [crates/ron-transport/tests/integration/idle_timeout.rs](#crates-ron-transport-tests-integration-idletimeout-rs)
- [crates/ron-transport/tests/integration/mod.rs](#crates-ron-transport-tests-integration-mod-rs)
- [crates/ron-transport/tests/integration/over_capacity.rs](#crates-ron-transport-tests-integration-overcapacity-rs)
- [crates/ron-transport/tests/integration/quic_parity.rs](#crates-ron-transport-tests-integration-quicparity-rs)
- [crates/ron-transport/tests/integration/tls_accept.rs](#crates-ron-transport-tests-integration-tlsaccept-rs)
- [crates/ron-transport/tests/integration/tls_handshake_limits.rs](#crates-ron-transport-tests-integration-tlshandshakelimits-rs)
- [crates/ron-transport/tests/intergration.rs](#crates-ron-transport-tests-intergration-rs)
- [crates/ron-transport/tests/loom/single_writer.rs](#crates-ron-transport-tests-loom-singlewriter-rs)
- [crates/ron-transport/tests/soak/loopback_1MiB.rs](#crates-ron-transport-tests-soak-loopback1MiB-rs)
- [crates/ron-transport/tests/vectors/comp_bounds.json](#crates-ron-transport-tests-vectors-compbounds-json)
- [crates/ron-transport/tests/vectors/oap_hello.json](#crates-ron-transport-tests-vectors-oaphello-json)
- [crates/ron-transport/tests/vectors/pq_hybrid_hello.json](#crates-ron-transport-tests-vectors-pqhybridhello-json)
- [crates/ron-transport/tests/vectors/tor_parity.json](#crates-ron-transport-tests-vectors-torparity-json)

### crates/ron-transport/.cargo/config.toml
<a id="crates-ron-transport--cargo-config-toml"></a>

```toml
[build]
# Local build/test knobs can live here (e.g., enabling loom via cfg)

```

### crates/ron-transport/.github/workflows/ci.yml
<a id="crates-ron-transport--github-workflows-ci-yml"></a>

```yaml
name: ron-transport2 CI
on:
  push:
  pull_request:
jobs:
  build-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        features: ["", "arti", "quic", "arti,quic"]
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Build
        run: cargo build -p ron-transport2 ${MATRIX:+--features ${{ matrix.features }}}
        env: { MATRIX: ${{ matrix.features }} }
      - name: Test
        run: cargo test -p ron-transport2 ${MATRIX:+--features ${{ matrix.features }}}
        env: { MATRIX: ${{ matrix.features }} }
      - name: Clippy (deny warnings)
        run: cargo clippy -p ron-transport2 ${MATRIX:+--features ${{ matrix.features }}} -- -D warnings
        env: { MATRIX: ${{ matrix.features }} }

```

### crates/ron-transport/.github/workflows/perf.yml
<a id="crates-ron-transport--github-workflows-perf-yml"></a>

```yaml
name: ron-transport2 Perf
on: { workflow_dispatch: {} }
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run benches (placeholder)
        run: cargo bench -p ron-transport2 || true
      - name: Archive Criterion artifacts
        uses: actions/upload-artifact@v4
        with:
          name: bench-artifacts
          path: target/criterion

```

### crates/ron-transport/.github/workflows/tla.yml
<a id="crates-ron-transport--github-workflows-tla-yml"></a>

```yaml
name: ron-transport2 TLA
on:
  push:
  pull_request:
jobs:
  tla:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run TLC (placeholder)
        run: bash crates/ron-transport2/scripts/ci/run_tlc.sh

```

### crates/ron-transport/Cargo.toml
<a id="crates-ron-transport-Cargo-toml"></a>

```toml
[package]
name = "ron-transport"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RustyOnions transport abstraction (TCP/TLS; Tor via arti feature; QUIC optional) for OAP/1 streams."
repository = "https://github.com/yourorg/RustyOnions"
readme = "README.md"

[lib]
name = "ron_transport"
path = "src/lib.rs"

[features]
default = ["tcp", "tls"]
tcp = []
tls = ["dep:tokio-rustls", "dep:rustls-pemfile"]
arti = []            # feature hook; code compiles without pulling arti deps yet
quic = []            # feature hook; add quinn later

[dependencies]
tokio = { version = "1.47.1", features = ["net", "rt-multi-thread", "sync", "time", "io-util", "macros"] }
bytes = "1.6"
futures = "0.3"
thiserror = "2"
anyhow = "1"
parking_lot = "0.12"
tracing = "0.1"
once_cell = "1.20"
rand = "0.9"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
prometheus = "0.14"
tokio-util = { version = "0.7", features = ["codec", "rt"] }  # rt => CancellationToken
pin-project-lite = "0.2"

# TLS (guarded)
tokio-rustls = { version = "0.26.2", optional = true }
rustls-pemfile = { version = "2.2", optional = true }

# Internal crates (kernel re-exports: Bus, HealthState, Metrics)
ron-kernel = { path = "../ron-kernel" }
ron-metrics = { path = "../ron-metrics" }

[dev-dependencies]
tokio = { version = "1.47.1", features = ["rt-multi-thread", "macros", "time", "io-util", "net"] }
criterion = "0.5"
tokio-rustls = { version = "0.26.2" }
rustls-pemfile = { version = "2.2" }

[package.metadata.docs.rs]
features = ["tcp", "tls"]

```

### crates/ron-transport/benches/bench_latency.rs
<a id="crates-ron-transport-benches-benchlatency-rs"></a>

```rust
#![allow(unused)]
fn main() {}
// Placeholder Criterion bench: connectâ†’first-byte latency per backend.

```

### crates/ron-transport/benches/bench_throughput.rs
<a id="crates-ron-transport-benches-benchthroughput-rs"></a>

```rust
#![allow(unused)]
fn main() {}
// Placeholder Criterion bench: 1 MiB frames, ~64 KiB streaming.

```

### crates/ron-transport/examples/bench_echo.rs
<a id="crates-ron-transport-examples-benchecho-rs"></a>

```rust
//! RO:WHAT â€” Minimal loopback listener smoke.
//! RO:WHY  â€” Verify spawn_transport() binds and runs without TLS.
//! RO:INTERACTS â€” TransportConfig, TransportMetrics, HealthState, Bus<TransportEvent>.

use ron_transport::{config::TransportConfig, metrics::TransportMetrics, spawn_transport, types::TransportEvent};
use ron_kernel::{HealthState, Bus};
use std::sync::Arc;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cfg = TransportConfig::default();
    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());

    // Event bus: we won't consume events here, but the type is now TransportEvent.
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, None).await?;
    println!("ron-transport listening on {}", addr);

    tokio::signal::ctrl_c().await.ok();
    Ok(())
}

```

### crates/ron-transport/examples/http_echo.rs
<a id="crates-ron-transport-examples-httpecho-rs"></a>

```rust
//! Minimal HTTP-ish echo over raw TCP (not using the library).
//! Purpose: easy curl checks that show a visible response.

use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpListener,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let listener = TcpListener::bind(("127.0.0.1", 0)).await?;
    let addr = listener.local_addr()?;
    println!("http-echo listening on {}", addr);

    loop {
        let (mut sock, _peer) = listener.accept().await?;
        tokio::spawn(async move {
            let mut buf = vec![0u8; 16 * 1024];

            // Read once (simple demo) â€” enough for small requests.
            let n = match sock.read(&mut buf).await {
                Ok(0) => return,
                Ok(m) => m,
                Err(_) => return,
            };

            // Craft a simple 200 OK with echoed body.
            let body = &buf[..n];
            let header = format!(
                "HTTP/1.1 200 OK\r\nContent-Length: {}\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n",
                body.len()
            );

            if sock.write_all(header.as_bytes()).await.is_err() { return; }
            let _ = sock.write_all(body).await;
            let _ = sock.flush().await;
        });
    }
}

```

### crates/ron-transport/examples/onion_echo.rs
<a id="crates-ron-transport-examples-onionecho-rs"></a>

```rust
fn main() { println!("onion_echo (Arti) placeholder"); }

```

### crates/ron-transport/examples/quic_echo.rs
<a id="crates-ron-transport-examples-quicecho-rs"></a>

```rust
fn main() { println!("quic_echo placeholder"); }

```

### crates/ron-transport/examples/tcp_echo.rs
<a id="crates-ron-transport-examples-tcpecho-rs"></a>

```rust
//! Minimal TCP echo (for human-visible round-trips with curl/nc).
//! NOTE: This is a standalone echo using Tokio, not the library accept loop.
//! Itâ€™s just for smoke-testing with tools that expect a response.

use tokio::{io::{AsyncReadExt, AsyncWriteExt}, net::TcpListener};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let listener = TcpListener::bind(("127.0.0.1", 0)).await?;
    let addr = listener.local_addr()?;
    println!("echo listening on {}", addr);

    loop {
        let (mut sock, _peer) = listener.accept().await?;
        tokio::spawn(async move {
            let mut buf = vec![0u8; 4096];
            loop {
                let n = match sock.read(&mut buf).await {
                    Ok(0) => return,              // closed
                    Ok(n) => n,
                    Err(_) => return,
                };
                if sock.write_all(&buf[..n]).await.is_err() {
                    return;
                }
            }
        });
    }
}

```

### crates/ron-transport/examples/tls_echo.rs
<a id="crates-ron-transport-examples-tlsecho-rs"></a>

```rust
fn main() { println!("tls_echo placeholder"); }

```

### crates/ron-transport/examples/tls_transport.rs
<a id="crates-ron-transport-examples-tlstransport-rs"></a>

```rust
//! TLS listener using the ron-transport library.
//! Loads cert+key, builds rustls::ServerConfig, and passes it to spawn_transport.

#![cfg(feature = "tls")]

use ron_transport::{
    config::TransportConfig,
    metrics::TransportMetrics,
    spawn_transport,
    TlsServerConfig, // re-export
    types::TransportEvent,
};
use ron_kernel::{Bus, HealthState};
use std::{fs::File, io::BufReader, path::Path, sync::Arc};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cert_path = std::env::args()
        .nth(1)
        .unwrap_or_else(|| "crates/ron-transport/scripts/local/certs/cert.pem".into());
    let key_path = std::env::args()
        .nth(2)
        .unwrap_or_else(|| "crates/ron-transport/scripts/local/certs/key.pem".into());

    let tls_cfg = Arc::new(load_rustls_server(&cert_path, &key_path)?);

    let mut cfg = TransportConfig::default();
    cfg.name = "tls";
    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, Some(tls_cfg)).await?;
    println!("tls-transport listening on {}", addr);
    tokio::signal::ctrl_c().await.ok();
    Ok(())
}

#[cfg(feature = "tls")]
fn load_rustls_server(cert_path: &str, key_path: &str) -> anyhow::Result<TlsServerConfig> {
    use rustls_pemfile::{certs, pkcs8_private_keys, rsa_private_keys};
    use tokio_rustls::rustls::{
        pki_types::{
            CertificateDer, PrivateKeyDer, PrivatePkcs1KeyDer, PrivatePkcs8KeyDer,
        },
        ServerConfig,
    };

    // Load cert chain
    let cert_file = File::open(Path::new(cert_path))?;
    let mut cert_rd = BufReader::new(cert_file);
    let certs: Vec<CertificateDer<'static>> = certs(&mut cert_rd).collect::<Result<_, _>>()?;

    // Load first available private key (PKCS#8 preferred, fall back to PKCS#1/RSA)
    let key: PrivateKeyDer<'static> = {
        // Try PKCS#8
        let key_file = File::open(Path::new(key_path))?;
        let mut key_rd = BufReader::new(key_file);
        let mut pkcs8: Vec<PrivateKeyDer<'static>> = pkcs8_private_keys(&mut key_rd)
            .map(|res: std::io::Result<PrivatePkcs8KeyDer<'static>>| res.map(Into::into))
            .collect::<Result<_, _>>()?;
        if let Some(k) = pkcs8.pop() {
            k
        } else {
            // Try PKCS#1 (RSA)
            let key_file = File::open(Path::new(key_path))?;
            let mut key_rd = BufReader::new(key_file);
            let mut rsa: Vec<PrivateKeyDer<'static>> = rsa_private_keys(&mut key_rd)
                .map(|res: std::io::Result<PrivatePkcs1KeyDer<'static>>| res.map(Into::into))
                .collect::<Result<_, _>>()?;
            rsa.pop()
                .ok_or_else(|| anyhow::anyhow!("no private key found in {}", key_path))?
        }
    };

    // rustls 0.22 API
    let cfg = ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)?;

    Ok(cfg)
}

```

### crates/ron-transport/fuzz/fuzz_targets/frame_boundaries.rs
<a id="crates-ron-transport-fuzz-fuzztargets-frameboundaries-rs"></a>

```rust
#![no_main]
// Placeholder fuzz target for frame boundaries.

```

### crates/ron-transport/scripts/ci/env_sanitize.sh
<a id="crates-ron-transport-scripts-ci-envsanitize-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT â€” sanitize env for hermetic CI runs
set -euo pipefail
unset RUST_LOG || true
unset RUST_BACKTRACE || true

```

### crates/ron-transport/scripts/ci/run_tlc.sh
<a id="crates-ron-transport-scripts-ci-runtlc-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT â€” placeholder TLA+ runner (specs compile later)
set -euo pipefail
echo "TLA+ specs not enabled yet for ron-transport MVP."

```

### crates/ron-transport/scripts/local/echo_smoke.sh
<a id="crates-ron-transport-scripts-local-echosmoke-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

LOG_FILE="$(mktemp -t ron_transport_echo.XXXXXX.log)"
RUST_LOG=info cargo run -q -p ron-transport --example tcp_echo >"$LOG_FILE" 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true; rm -f "$LOG_FILE"' EXIT

# Wait for "echo listening on ..."
for _ in {1..50}; do
  if grep -q "echo listening on" "$LOG_FILE"; then break; fi
  sleep 0.1
done

line="$(grep "echo listening on" "$LOG_FILE" | tail -n1)"
PORT="$(awk -F: '{print $NF}' <<<"$line" | tr -d '[:space:]')"
HOST="$(sed -E 's/.* on ([0-9\.]+):[0-9]+/\1/' <<<"$line")"

echo "[ OK ] echo server: ${HOST}:${PORT}"

# 1) curl round-trip allowing HTTP/0.9 (raw TCP echo)
if command -v curl >/dev/null 2>&1; then
  printf 'hello RON\n' | curl --http0.9 --no-progress-meter --data-binary @- "http://${HOST}:${PORT}/" || true
else
  echo "[WARN] curl not found; skipping curl test"
fi

# 2) nc round-trip
if command -v nc >/dev/null 2>&1; then
  printf 'hello RON\n' | nc -w 1 "${HOST}" "${PORT}" || true
else
  echo "[WARN] nc not found; skipping nc test"
fi

echo "[ OK ] probes done"

```

### crates/ron-transport/scripts/local/http_echo_smoke.sh
<a id="crates-ron-transport-scripts-local-httpechosmoke-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

LOG_FILE="$(mktemp -t ron_transport_http_echo.XXXXXX.log)"
RUST_LOG=info cargo run -q -p ron-transport --example http_echo >"$LOG_FILE" 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true; rm -f "$LOG_FILE"' EXIT

for _ in {1..50}; do
  if grep -q "http-echo listening on" "$LOG_FILE"; then break; fi
  sleep 0.1
done

line="$(grep "http-echo listening on" "$LOG_FILE" | tail -n1)"
PORT="$(awk -F: '{print $NF}' <<<"$line" | tr -d '[:space:]')"
HOST="$(sed -E 's/.* on ([0-9\.]+):[0-9]+/\1/' <<<"$line")"

echo "[ OK ] http-echo server: ${HOST}:${PORT}"
printf 'Hello via curl ðŸ§ª\n' | curl --no-progress-meter --data-binary @- "http://${HOST}:${PORT}/" || true
echo
echo "[ OK ] done"

```

### crates/ron-transport/scripts/local/mk_self_signed.sh
<a id="crates-ron-transport-scripts-local-mkselfsigned-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT â€” Generate a quick self-signed cert/key for local TLS smoke.
set -euo pipefail

DIR="${1:-crates/ron-transport/scripts/local/certs}"
mkdir -p "$DIR"

CERT="$DIR/cert.pem"
KEY="$DIR/key.pem"

# 365-day self-signed; CN=localhost
openssl req -x509 -newkey rsa:2048 -nodes -sha256 -days 365 \
  -subj "/CN=localhost" \
  -keyout "$KEY" -out "$CERT" >/dev/null 2>&1

echo "[ OK ] wrote $CERT and $KEY"

```

### crates/ron-transport/scripts/local/perf_repro.sh
<a id="crates-ron-transport-scripts-local-perfrepro-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT â€” local loopback perf smoke (placeholder)
set -euo pipefail
RUST_LOG=${RUST_LOG:-info} cargo run -p ron-transport --example bench_echo || true

```

### crates/ron-transport/scripts/local/smoke_tls.sh
<a id="crates-ron-transport-scripts-local-smoketls-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT â€” Build (--features tls), start tls_transport, and probe with openssl.
set -euo pipefail

# Ensure certs exist
bash crates/ron-transport/scripts/local/mk_self_signed.sh >/dev/null

CERT="crates/ron-transport/scripts/local/certs/cert.pem"
KEY="crates/ron-transport/scripts/local/certs/key.pem"

# Build with TLS
cargo build -q -p ron-transport --features tls

# Run tls_transport example
LOG_FILE="$(mktemp -t ron_transport_tls.XXXXXX.log)"
RUST_LOG=info cargo run -q -p ron-transport --features tls --example tls_transport -- "$CERT" "$KEY" >"$LOG_FILE" 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true; rm -f "$LOG_FILE"' EXIT

# Wait for it to start
for _ in {1..50}; do
  if grep -q "tls-transport listening on" "$LOG_FILE"; then break; fi
  sleep 0.1
done

line="$(grep "tls-transport listening on" "$LOG_FILE" | tail -n1)"
PORT="$(awk -F: '{print $NF}' <<<"$line" | tr -d '[:space:]')"
HOST="$(sed -E 's/.* on ([0-9\.]+):[0-9]+/\1/' <<<"$line")"
echo "[ OK ] tls server: ${HOST}:${PORT}"

# Probe with openssl s_client (TLS 1.3), send a line, and exit.
# Expect no HTTP response â€” this proves handshake success.
printf 'hello over TLS\n' | openssl s_client -quiet -connect "${HOST}:${PORT}" -tls1_3 -servername localhost >/dev/null 2>&1 || true
echo "[ OK ] openssl s_client connected + wrote bytes (no response expected)"

```

### crates/ron-transport/scripts/local/smoke_transport.sh
<a id="crates-ron-transport-scripts-local-smoketransport-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT  â€” End-to-end smoke for ron-transport loopback (robust macOS/Linux).
# RO:NOTE  â€” Uses Python socket send first (non-blocking), falls back to nc with safe flags.

set -euo pipefail

HOST_DEFAULT="127.0.0.1"
HOST="${HOST:-$HOST_DEFAULT}"
PORT="${PORT:-}"
LOG_FILE="$(mktemp -t ron_transport_smoke.XXXXXX.log)"
SERVER_PID=""
CLEANUP_DONE=0

cleanup() {
  if [[ $CLEANUP_DONE -eq 1 ]]; then return; fi
  CLEANUP_DONE=1
  if [[ -n "${SERVER_PID}" ]]; then
    kill "${SERVER_PID}" >/dev/null 2>&1 || true
    wait "${SERVER_PID}" >/dev/null 2>&1 || true
  fi
  rm -f "$LOG_FILE" || true
}
trap cleanup EXIT INT TERM

info()  { printf "[INFO] %s\n" "$*"; }
ok()    { printf "[ OK ] %s\n" "$*"; }
warn()  { printf "[WARN] %s\n" "$*"; }
fail()  { printf "[FAIL] %s\n" "$*"; }

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || { fail "missing '$1' in PATH"; exit 1; }
}

spawn_server_if_needed() {
  if [[ -n "${PORT}" ]]; then
    info "Using provided PORT=${PORT}, HOST=${HOST}; will not spawn server."
    return
  fi

  info "Starting bench_echo to auto-discover port (HOST=${HOST})â€¦"
  RUST_LOG=info cargo run -q -p ron-transport --example bench_echo >"$LOG_FILE" 2>&1 &
  SERVER_PID=$!

  # Wait until it prints the listening line (timeout ~5s).
  for _ in {1..50}; do
    if grep -q "ron-transport listening on" "$LOG_FILE"; then
      break
    fi
    sleep 0.1
  done
  if ! grep -q "ron-transport listening on" "$LOG_FILE"; then
    warn "Could not detect listener line; recent log:"
    tail -n +1 "$LOG_FILE" || true
    fail "Server failed to start or log was not captured."
    exit 1
  fi

  local line
  line="$(grep "ron-transport listening on" "$LOG_FILE" | tail -n1)"
  PORT="$(awk -F: '{print $NF}' <<<"$line" | tr -d '[:space:]')"
  HOST="$(sed -E 's/.* on ([0-9\.]+):[0-9]+/\1/' <<<"$line")"
  ok "Server is up: ${HOST}:${PORT} (pid ${SERVER_PID})"
}

nc_support_flags() {
  # Detect safe close flag for this nc variant.
  local help; help="$( (nc -h 2>&1 || true) )"
  if grep -q -- " -N" <<<"$help"; then
    echo "-N"           # OpenBSD/macOS: close on stdin EOF
  elif grep -q -- " -q " <<<"$help"; then
    echo "-q 1"         # GNU netcat: quit 1s after EOF on stdin
  else
    echo ""             # Unknown; weâ€™ll guard with timeout anyway
  fi
}

run_probes() {
  # 1) Quick TCP connect check with nc -vz (non-blocking)
  info "Probing with nc (TCP connect)â€¦"
  if command -v nc >/dev/null 2>&1; then
    if nc -vz -w 2 "${HOST}" "${PORT}" >/dev/null 2>&1; then
      ok "nc connect succeeded"
    else
      warn "nc connect failed (continuing)"
    fi
  else
    warn "nc not found; skipping"
  fi

  # 2) Send bytes via Python socket (preferred, never hangs)
  info "Python one-liner sendâ€¦"
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<PY || warn "python send failed (continuing)"
import socket
s=socket.create_connection(("${HOST}", int("${PORT}")), 2)
s.sendall(b"hello\\n")
s.close()
PY
    ok "python send completed"
  else
    warn "python3 not found; skipping python send"
  fi

  # 3) Optional: nc one-shot send with safe close (guarded)
  if command -v nc >/dev/null 2>&1; then
    local CLOSE_FLAGS; CLOSE_FLAGS="$(nc_support_flags)"
    info "Sending bytes via nc (one-shot, flags: ${CLOSE_FLAGS:-none})â€¦"
    # Run nc in the background with a hard kill after 3s as a final guard.
    ( printf 'hello ron-transport\n' | nc ${CLOSE_FLAGS} -w 2 "${HOST}" "${PORT}" ) >/dev/null 2>&1 & 
    local nc_pid=$!
    # Hard timeout guard:
    ( sleep 3; kill "$nc_pid" >/dev/null 2>&1 || true ) &
    wait "$nc_pid" >/dev/null 2>&1 || true
    ok "sent bytes with nc (no response expected)"
  fi

  # 4) curl proof (expect timeout; add connect-timeout)
  info "curl smoke (expect timeout, proves non-HTTP raw TCP)â€¦"
  if command -v curl >/dev/null 2>&1; then
    if echo -n 'hello' | curl --no-progress-meter --data-binary @- \
         --connect-timeout 1 --max-time 2 "http://${HOST}:${PORT}/" >/dev/null; then
      warn "curl returned success (unexpected for raw TCP), continuing"
    else
      ok "curl timed out as expected (raw TCP, no HTTP)"
    fi
  else
    warn "curl not found; skipping"
  fi

  info "All probes done."
}

main() {
  require_cmd cargo
  spawn_server_if_needed
  run_probes
}

main

```

### crates/ron-transport/src/arti/client.rs
<a id="crates-ron-transport-src-arti-client-rs"></a>

```rust
//! Arti outbound (placeholder).
pub struct ArtiClient;

```

### crates/ron-transport/src/arti/mod.rs
<a id="crates-ron-transport-src-arti-mod-rs"></a>

```rust
pub mod client;
pub mod service;
pub mod readiness;

```

### crates/ron-transport/src/arti/readiness.rs
<a id="crates-ron-transport-src-arti-readiness-rs"></a>

```rust
//! Arti readiness glue (placeholder).
pub struct ArtiReadiness;

```

### crates/ron-transport/src/arti/service.rs
<a id="crates-ron-transport-src-arti-service-rs"></a>

```rust
//! Arti onion service (placeholder).
pub struct ArtiService;

```

### crates/ron-transport/src/config.rs
<a id="crates-ron-transport-src-config-rs"></a>

```rust
//! RO:WHAT â€” Transport configuration (bind, ceilings, timeouts).
//! RO:WHY  â€” Hard caps & deadlines enforce SEC/RES.
//! RO:INTERACTS â€” limits, tcp::listener/dialer, tls::{server,client}.
//! RO:INVARIANTS â€” immutable at runtime; values bounded; amnesia-safe.
//! RO:CONFIG â€” From env or files (upstream); this struct is runtime snapshot.

use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
use std::time::Duration;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TransportConfig {
    /// Bind address for the listener (e.g., "127.0.0.1:9400").
    pub addr: SocketAddr,
    /// Human-readable transport name (for metrics labels).
    pub name: &'static str,
    /// Maximum concurrent connections allowed.
    pub max_conns: usize,
    /// Read timeout per I/O op.
    pub read_timeout: Duration,
    /// Write timeout per I/O op.
    pub write_timeout: Duration,
    /// Idle timeout (no traffic).
    pub idle_timeout: Duration,
}

impl Default for TransportConfig {
    fn default() -> Self {
        Self {
            addr: "127.0.0.1:0".parse().unwrap(),
            name: "tcp",
            max_conns: 1024,
            read_timeout: Duration::from_secs(5),
            write_timeout: Duration::from_secs(5),
            idle_timeout: Duration::from_secs(15),
        }
    }
}

```

### crates/ron-transport/src/conn/backpressure.rs
<a id="crates-ron-transport-src-conn-backpressure-rs"></a>

```rust
//! RO:WHAT â€” Simple per-conn inflight limiter (MVP).
use crate::limits::MAX_INFLIGHT_FRAMES;
use std::sync::atomic::{AtomicUsize, Ordering};

#[derive(Default)]
pub struct Inflight {
    n: AtomicUsize,
}
impl Inflight {
    pub fn new() -> Self { Self { n: AtomicUsize::new(0) } }
    pub fn try_inc(&self) -> bool {
        let cur = self.n.load(Ordering::Relaxed);
        if cur >= MAX_INFLIGHT_FRAMES { return false; }
        self.n.fetch_add(1, Ordering::Relaxed);
        true
    }
    pub fn dec(&self) {
        self.n.fetch_sub(1, Ordering::Relaxed);
    }
}

```

### crates/ron-transport/src/conn/mod.rs
<a id="crates-ron-transport-src-conn-mod-rs"></a>

```rust
//! RO:WHAT â€” Connection primitives (backpressure, reader, writer, rate limits).
//! RO:INVARIANTS â€” single-writer discipline; bounded inflight.

pub mod backpressure;
pub mod reader;
pub mod writer;
pub mod rate_limit;

```

### crates/ron-transport/src/conn/rate_limit.rs
<a id="crates-ron-transport-src-conn-ratelimit-rs"></a>

```rust
//! RO:WHAT â€” Placeholder for per-conn rate limiting (tokens).
#[derive(Clone, Default)]
pub struct RateLimit;
impl RateLimit {
    pub fn allow(&self, _bytes: usize) -> bool { true }
}

```

### crates/ron-transport/src/conn/reader.rs
<a id="crates-ron-transport-src-conn-reader-rs"></a>

```rust
//! RO:WHAT â€” Per-connection reader task (frame-capped, timed).
//! RO:INVARIANTS â€” cap before alloc; owned bytes; cancel-safe; idle/read timeouts.
//! RO:DESIGN â€” Generic over any AsyncRead, so it supports TcpStream and TlsStream.

use bytes::BytesMut;
use tokio::io::{AsyncRead, AsyncReadExt};
use tokio::time::{timeout, Duration, Instant};

use crate::limits::MAX_FRAME_BYTES;

#[derive(Debug, Default, Clone)]
pub struct ReaderStats {
    pub bytes_in: u64,
}

pub async fn run<R>(
    mut rd: R,
    read_timeout: Duration,
    idle_timeout: Duration,
) -> std::io::Result<ReaderStats>
where
    R: AsyncRead + Unpin,
{
    let mut buf = BytesMut::with_capacity(8 * 1024);
    let mut stats = ReaderStats::default();
    let mut last = Instant::now();

    loop {
        // Per-op read timeout.
        let n = match timeout(read_timeout, rd.read_buf(&mut buf)).await {
            Ok(Ok(0)) => return Ok(stats), // peer closed
            Ok(Ok(n)) => n,
            Ok(Err(e)) => return Err(e),
            Err(_elapsed) => {
                // If we've been entirely idle longer than idle_timeout, close.
                if last.elapsed() > idle_timeout {
                    return Ok(stats);
                }
                continue; // allow another attempt until idle threshold trips
            }
        };

        last = Instant::now();
        stats.bytes_in += n as u64;

        if buf.len() > MAX_FRAME_BYTES {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "frame too large",
            ));
        }

        // MVP: drain; upper layers will parse OAP frames.
        if !buf.is_empty() {
            buf.clear();
        }
    }
}

```

### crates/ron-transport/src/conn/writer.rs
<a id="crates-ron-transport-src-conn-writer-rs"></a>

```rust
//! RO:WHAT â€” Per-connection single-writer task with backpressure.
//! RO:WHY  â€” Enforce single-writer discipline; count bytes_out; await I/O for backpressure.
//! RO:DESIGN â€” Generic over any AsyncWrite so it works for TcpStream and TlsStream.

use bytes::Bytes;
use tokio::{
    io::AsyncWrite,
    io::AsyncWriteExt,
    sync::mpsc::{self, error::SendError, Sender},
};

/// Handle to enqueue bytes for the connection's writer task.
#[derive(Clone)]
pub struct WriterHandle {
    tx: Sender<Bytes>,
}

impl WriterHandle {
    pub async fn send(&self, b: Bytes) -> Result<(), SendError<Bytes>> {
        self.tx.send(b).await
    }
}

/// Spawn a writer task for any AsyncWrite (TcpStream, TlsStream, ...).
/// Returns a handle for sending bytes and the writer task JoinHandle.
///
/// The writer task:
/// - writes each chunk fully (`write_all`)
/// - flushes periodically (on every message in MVP)
/// - increments `bytes_out` metrics
/// - exits cleanly when channel closes
pub fn spawn_writer<W>(
    mut w: W,
    name: &'static str,
    metrics: crate::metrics::TransportMetrics,
) -> (WriterHandle, tokio::task::JoinHandle<()>)
where
    W: AsyncWrite + Unpin + Send + 'static,
{
    // Bounded queue prevents unbounded memory under slow receivers.
    let (tx, mut rx) = mpsc::channel::<Bytes>(64);
    let jh = tokio::spawn(async move {
        while let Some(chunk) = rx.recv().await {
            if chunk.is_empty() {
                continue;
            }
            if let Err(e) = w.write_all(&chunk).await {
                tracing::debug!(error=%e, "writer: write_all failed");
                break;
            }
            // Count bytes_out
            metrics
                .bytes_out
                .with_label_values(&[name])
                .inc_by(chunk.len() as u64);

            // Flush to minimize tail latency (can batch/tune later).
            if let Err(e) = w.flush().await {
                tracing::debug!(error=%e, "writer: flush failed");
                break;
            }
        }

        // Attempt graceful shutdown for protocols that support it (e.g., TLS close_notify).
        let _ = w.shutdown().await;
    });

    (WriterHandle { tx }, jh)
}

```

### crates/ron-transport/src/error.rs
<a id="crates-ron-transport-src-error-rs"></a>

```rust
//! RO:WHAT â€” Error types for ron-transport.
//! RO:WHY  â€” Stable taxonomy for callers (deterministic).
//! RO:INTERACTS â€” reason::RejectReason.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum TransportError {
    #[error("bind error: {0}")]
    Bind(std::io::Error),
    #[error("accept loop failed: {0}")]
    Accept(std::io::Error),
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
    #[error("limit exceeded: {0}")]
    Limit(&'static str),
    #[error("timeout")]
    Timeout,
    #[error("tls error")]
    Tls,
    #[error("closed")]
    Closed,
}

```

### crates/ron-transport/src/lib.rs
<a id="crates-ron-transport-src-lib-rs"></a>

```rust
//! RO:WHAT â€” Public entry for ron-transport: config/types and spawn helpers.
//! RO:WHY  â€” Pillar 10 transport; Concerns: SEC/RES/PERF.
//! RO:INTERACTS â€” tcp::{listener,dialer}, tls::{server,client}, limits, metrics; kernel Bus/Health.
//! RO:INVARIANTS â€” single writer per conn; no locks across .await; OAP max_frame=1MiB; chunkâ‰ˆ64KiB.

#![forbid(unsafe_code)]

pub mod config;
pub mod limits;
pub mod error;
pub mod reason;
pub mod readiness;
pub mod metrics;
pub mod types;
pub mod util;
pub mod conn;
pub mod tcp;
#[cfg(feature = "tls")]
pub mod tls;
#[cfg(feature = "arti")]
pub mod arti;
#[cfg(feature = "quic")]
pub mod quic;

// Always-present TLS type alias wrapper (feature-safe).
mod tls_types;
pub use tls_types::TlsServerConfig;

use crate::config::TransportConfig;
use crate::metrics::TransportMetrics;
use crate::readiness::ReadyGate;
use crate::types::TransportEvent;
use crate::util::cancel::Cancel;
use ron_kernel::{Bus, HealthState};
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::task::JoinHandle;

/// Public handle for a running transport listener.
pub struct TransportHandle {
    /// The accept-loop task.
    pub task: JoinHandle<()>,
    /// The bound socket address.
    pub addr: SocketAddr,
    /// Cancellation token â€” request graceful shutdown.
    pub cancel: Cancel,
}

/// Spawn a TCP (optionally TLS) listener and per-connection tasks, returning a shutdown handle.
///
/// Backward-compatible, high-level entry.
pub async fn spawn_transport_with_cancel(
    cfg: TransportConfig,
    metrics: TransportMetrics,
    health: Arc<HealthState>,
    _bus: Bus<TransportEvent>, // reserved; will publish Connected/Disconnected when Bus API is confirmed
    tls: Option<Arc<TlsServerConfig>>,
) -> anyhow::Result<TransportHandle> {
    let gate = ReadyGate::new();
    let cancel = Cancel::new();
    let (task, addr) =
        tcp::listener::spawn_listener_with_cancel(cfg, metrics, health, gate.clone(), tls, cancel.clone()).await?;
    gate.set_listeners_bound(true);
    Ok(TransportHandle { task, addr, cancel })
}

/// Legacy wrapper that preserves the original return type.
/// Use `spawn_transport_with_cancel` if you want a shutdown handle.
pub async fn spawn_transport(
    cfg: TransportConfig,
    metrics: TransportMetrics,
    health: Arc<HealthState>,
    bus: Bus<TransportEvent>,
    tls: Option<Arc<TlsServerConfig>>,
) -> anyhow::Result<(JoinHandle<()>, SocketAddr)> {
    let handle = spawn_transport_with_cancel(cfg, metrics, health, bus, tls).await?;
    Ok((handle.task, handle.addr))
}

```

### crates/ron-transport/src/limits.rs
<a id="crates-ron-transport-src-limits-rs"></a>

```rust
//! RO:WHAT â€” Hard transport limits aligned to OAP/1 & Hardening v2.
//! RO:WHY  â€” Prevent DoS/compression bombs; deterministic errors.
//! RO:INTERACTS â€” conn::{reader,writer}, reason::RejectReason.

/// OAP/1 protocol frame max (bytes).
pub const MAX_FRAME_BYTES: usize = 1 * 1024 * 1024; // 1 MiB

/// Typical streaming chunk size (~storage path guidance).
pub const STREAM_CHUNK_BYTES: usize = 64 * 1024; // 64 KiB

/// Maximum decompressed size multiplier (defense-in-depth).
pub const MAX_DECOMP_RATIO: u32 = 10;

/// Inflight per-connection frame bound (defensive default).
pub const MAX_INFLIGHT_FRAMES: usize = 64;

```

### crates/ron-transport/src/metrics.rs
<a id="crates-ron-transport-src-metrics-rs"></a>

```rust
//! RO:WHAT â€” Prometheus counters/histograms for transport.
//! RO:WHY  â€” Golden metrics surface; avoid duplicate registers.

use prometheus::{HistogramOpts, HistogramVec, IntCounterVec, Opts, Registry};

#[derive(Clone)]
pub struct TransportMetrics {
    pub registry: Registry,
    pub connections: IntCounterVec,
    pub bytes_in: IntCounterVec,
    pub bytes_out: IntCounterVec,
    pub rejected_total: IntCounterVec,
    pub latency_seconds: HistogramVec,
}

impl TransportMetrics {
    pub fn new(namespace: &str) -> Self {
        let registry = Registry::new();
        let connections = IntCounterVec::new(
            Opts::new("transport_connections_total", "Accepted connections").namespace(namespace),
            &["name"],
        )
        .unwrap();
        let bytes_in = IntCounterVec::new(
            Opts::new("transport_bytes_in_total", "Bytes received").namespace(namespace),
            &["name"],
        )
        .unwrap();
        let bytes_out = IntCounterVec::new(
            Opts::new("transport_bytes_out_total", "Bytes sent").namespace(namespace),
            &["name"],
        )
        .unwrap();
        let rejected_total = IntCounterVec::new(
            Opts::new("transport_rejected_total", "Rejected connections/frames")
                .namespace(namespace),
            &["name", "reason"],
        )
        .unwrap();
        let latency_seconds = HistogramVec::new(
            HistogramOpts::new("transport_latency_seconds", "End-to-end per-conn lifetime")
                .namespace(namespace),
            &["name"],
        )
        .unwrap();

        registry.register(Box::new(connections.clone())).ok();
        registry.register(Box::new(bytes_in.clone())).ok();
        registry.register(Box::new(bytes_out.clone())).ok();
        registry.register(Box::new(rejected_total.clone())).ok();
        registry.register(Box::new(latency_seconds.clone())).ok();

        Self {
            registry,
            connections,
            bytes_in,
            bytes_out,
            rejected_total,
            latency_seconds,
        }
    }
}

```

### crates/ron-transport/src/quic/client.rs
<a id="crates-ron-transport-src-quic-client-rs"></a>

```rust
//! QUIC client (placeholder).
pub struct QuicClient;

```

### crates/ron-transport/src/quic/mod.rs
<a id="crates-ron-transport-src-quic-mod-rs"></a>

```rust
pub mod client;
pub mod server;

```

### crates/ron-transport/src/quic/server.rs
<a id="crates-ron-transport-src-quic-server-rs"></a>

```rust
//! QUIC server (placeholder).
pub struct QuicServer;

```

### crates/ron-transport/src/readiness.rs
<a id="crates-ron-transport-src-readiness-rs"></a>

```rust
//! RO:WHAT â€” Minimal readiness gate for listeners.
//! RO:WHY  â€” Truthful /readyz for services consuming transport.

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

#[derive(Clone)]
pub struct ReadyGate {
    listeners_bound: Arc<AtomicBool>,
}

impl ReadyGate {
    pub fn new() -> Self {
        Self { listeners_bound: Arc::new(AtomicBool::new(false)) }
    }
    pub fn set_listeners_bound(&self, v: bool) {
        self.listeners_bound.store(v, Ordering::SeqCst);
    }
    pub fn listeners_bound(&self) -> bool {
        self.listeners_bound.load(Ordering::SeqCst)
    }
}

```

### crates/ron-transport/src/reason.rs
<a id="crates-ron-transport-src-reason-rs"></a>

```rust
//! RO:WHAT â€” Canonical reject reasons (metrics label-safe).
//! RO:WHY  â€” Consistent observability & tests.

#[derive(Debug, Clone, Copy)]
pub enum RejectReason {
    OverCapacity,
    BadFrame,
    TooLarge,
    Timeout,
    Io,
    Tls,
}

impl RejectReason {
    pub fn as_str(self) -> &'static str {
        match self {
            Self::OverCapacity => "over_capacity",
            Self::BadFrame => "bad_frame",
            Self::TooLarge => "too_large",
            Self::Timeout => "timeout",
            Self::Io => "io",
            Self::Tls => "tls",
        }
    }
}

```

### crates/ron-transport/src/tcp/dialer.rs
<a id="crates-ron-transport-src-tcp-dialer-rs"></a>

```rust
//! RO:WHAT â€” TCP dialer (MVP).
use std::net::SocketAddr;
use tokio::net::TcpStream;

pub async fn dial(addr: SocketAddr) -> std::io::Result<TcpStream> {
    TcpStream::connect(addr).await
}

```

### crates/ron-transport/src/tcp/listener.rs
<a id="crates-ron-transport-src-tcp-listener-rs"></a>

```rust
//! RO:WHAT â€” TCP accept loop with optional TLS, limits, metrics, cancel.
//! RO:INVARIANTS â€” readiness flips when bound; single writer; deadlines enforced.

use crate::config::TransportConfig;
use crate::conn::reader::{self, ReaderStats};
use crate::conn::writer;
use crate::metrics::TransportMetrics;
use crate::readiness::ReadyGate;
use crate::reason::RejectReason;
use crate::util::cancel::Cancel;
use crate::TlsServerConfig;

use std::net::SocketAddr;
use std::sync::Arc;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::{OwnedSemaphorePermit, Semaphore};
use tokio::task::JoinHandle;
use tokio::time::{sleep, Duration, Instant};

/// Back-compat API (no shutdown handle). Internally creates a cancel token and drops it.
pub async fn spawn_listener(
    cfg: TransportConfig,
    metrics: TransportMetrics,
    health: Arc<ron_kernel::HealthState>,
    gate: ReadyGate,
    tls: Option<Arc<TlsServerConfig>>,
) -> anyhow::Result<(JoinHandle<()>, SocketAddr)> {
    let cancel = Cancel::new();
    spawn_listener_with_cancel(cfg, metrics, health, gate, tls, cancel).await
}

/// New API that takes a `Cancel` token so callers can trigger graceful shutdown.
pub async fn spawn_listener_with_cancel(
    cfg: TransportConfig,
    metrics: TransportMetrics,
    _health: Arc<ron_kernel::HealthState>,
    _gate: ReadyGate,
    tls: Option<Arc<TlsServerConfig>>,
    cancel: Cancel,
) -> anyhow::Result<(JoinHandle<()>, SocketAddr)> {
    let listener =
        TcpListener::bind(cfg.addr).await.map_err(crate::error::TransportError::Bind)?;
    let addr = listener.local_addr().unwrap();
    let permits = Arc::new(Semaphore::new(cfg.max_conns));

    let jh = tokio::spawn(async move {
        tracing::info!(%addr, name=%cfg.name, "ron-transport listener bound");
        loop {
            tokio::select! {
                _ = cancel.cancelled() => {
                    tracing::info!(%addr, "listener shutdown requested");
                    break;
                }
                res = listener.accept() => {
                    match res {
                        Ok((stream, peer)) => {
                            let cfgc = cfg.clone();
                            let m = metrics.clone();
                            let tls_cfg = tls.clone();

                            // Connection limit: clone Arc before try_acquire_owned (it consumes its Arc).
                            match permits.clone().try_acquire_owned() {
                                Ok(permit) => {
                                    m.connections.with_label_values(&[cfg.name]).inc();
                                    tokio::spawn(handle_conn(stream, peer, cfgc, m, permit, tls_cfg));
                                }
                                Err(_) => {
                                    m.rejected_total
                                        .with_label_values(&[cfg.name, RejectReason::OverCapacity.as_str()])
                                        .inc();
                                    drop(stream);
                                }
                            }
                        }
                        Err(e) => {
                            metrics
                                .rejected_total
                                .with_label_values(&[cfg.name, RejectReason::Io.as_str()])
                                .inc();
                            tracing::warn!(error=%e, "accept failed; backing off");
                            sleep(Duration::from_millis(100)).await;
                        }
                    }
                }
            }
        }
        tracing::info!(%addr, "listener exited");
    });

    Ok((jh, addr))
}

async fn handle_conn(
    stream: TcpStream,
    peer: SocketAddr,
    cfg: TransportConfig,
    metrics: TransportMetrics,
    _permit: OwnedSemaphorePermit, // holds a slot until this task ends
    tls: Option<Arc<TlsServerConfig>>,
) {
    tracing::debug!(%peer, "accepted");
    let started = Instant::now();

    let result = match maybe_tls(stream, tls).await {
        Ok(IoUpgraded::Plain(s)) => run_plain(s, &cfg, &metrics).await,
        #[cfg(feature = "tls")]
        Ok(IoUpgraded::Tls(s)) => run_tls(s, &cfg, &metrics).await,
        Err(e) => Err(e),
    };
    let elapsed = started.elapsed().as_secs_f64();

    match result {
        Ok(stats) => {
            metrics
                .bytes_in
                .with_label_values(&[cfg.name])
                .inc_by(stats.bytes_in as u64);
            metrics
                .latency_seconds
                .with_label_values(&[cfg.name])
                .observe(elapsed);
            tracing::debug!(%peer, bytes_in=%stats.bytes_in, dur=%elapsed, "closed ok");
        }
        Err(e) => {
            metrics
                .rejected_total
                .with_label_values(&[cfg.name, RejectReason::Io.as_str()])
                .inc();
            tracing::debug!(%peer, error=%e, "closed with error");
        }
    }
}

async fn run_plain(
    stream: TcpStream,
    cfg: &TransportConfig,
    metrics: &TransportMetrics,
) -> std::io::Result<ReaderStats> {
    use tokio::io::split;
    let (rd, wr) = split(stream);

    // Spawn writer (currently unused by upper layers; metrics ready).
    let (_wh, writer_task) = writer::spawn_writer(wr, cfg.name, metrics.clone());

    // Run reader until EOF/timeout/error.
    let stats = reader::run(rd, cfg.read_timeout, cfg.idle_timeout).await;

    // Drop handle, await the task to flush+shutdown (sends FIN).
    drop(_wh);
    let _ = writer_task.await;

    stats
}

#[cfg(feature = "tls")]
async fn run_tls(
    stream: tokio_rustls::server::TlsStream<TcpStream>,
    cfg: &TransportConfig,
    metrics: &TransportMetrics,
) -> std::io::Result<ReaderStats> {
    use tokio::io::split;
    let (rd, wr) = split(stream);

    // Spawn writer (TLS): will send close_notify during shutdown().
    let (_wh, writer_task) = writer::spawn_writer(wr, cfg.name, metrics.clone());

    // Reader loop (generic over AsyncRead).
    let stats = reader::run(rd, cfg.read_timeout, cfg.idle_timeout).await;

    // Drop handle and wait for close_notify.
    drop(_wh);
    let _ = writer_task.await;

    stats
}

/// Unified return type for maybe_tls()
enum IoUpgraded {
    Plain(TcpStream),
    #[cfg(feature = "tls")]
    Tls(tokio_rustls::server::TlsStream<TcpStream>),
}

// Feature-safe TLS accept wrapper: if TLS feature disabled or None provided, pass-through.
async fn maybe_tls(
    stream: TcpStream,
    tls: Option<Arc<TlsServerConfig>>,
) -> std::io::Result<IoUpgraded> {
    match tls {
        #[cfg(feature = "tls")]
        Some(cfg) => {
            use tokio_rustls::TlsAcceptor;
            let acceptor = TlsAcceptor::from(cfg);
            let tls_stream = acceptor.accept(stream).await?;
            Ok(IoUpgraded::Tls(tls_stream))
        }
        _ => Ok(IoUpgraded::Plain(stream)),
    }
}

```

### crates/ron-transport/src/tcp/mod.rs
<a id="crates-ron-transport-src-tcp-mod-rs"></a>

```rust
//! RO:WHAT â€” TCP transport modules (listener/dialer).
pub mod listener;
pub mod dialer;

```

### crates/ron-transport/src/tls/client.rs
<a id="crates-ron-transport-src-tls-client-rs"></a>

```rust
//! RO:WHAT â€” TLS dial wrapper (placeholder).
#![cfg(feature = "tls")]
pub struct TlsClientConfig; // placeholder

```

### crates/ron-transport/src/tls/mod.rs
<a id="crates-ron-transport-src-tls-mod-rs"></a>

```rust
//! RO:WHAT â€” TLS wrappers (server/client) behind rustls.
//! RO:INVARIANTS â€” ServerConfig type = tokio_rustls::rustls::ServerConfig.
pub mod server;
pub mod client;

```

### crates/ron-transport/src/tls/server.rs
<a id="crates-ron-transport-src-tls-server-rs"></a>

```rust
//! RO:WHAT â€” TLS accept wrapper (placeholder).
#![cfg(feature = "tls")]
use tokio_rustls::rustls::ServerConfig;

pub type TlsServerConfig = ServerConfig;
// Integration will wrap TcpStream with TlsAcceptor::from(Arc<ServerConfig>) later.

```

### crates/ron-transport/src/tls_types.rs
<a id="crates-ron-transport-src-tlstypes-rs"></a>

```rust
//! RO:WHAT â€” Feature-safe TLS ServerConfig alias.
//! This lets the rest of the crate reference `TlsServerConfig` regardless of
//! whether `feature = "tls"` is enabled.

#[cfg(feature = "tls")]
pub type TlsServerConfig = tokio_rustls::rustls::ServerConfig;

#[cfg(not(feature = "tls"))]
pub struct TlsServerConfig;

```

### crates/ron-transport/src/types.rs
<a id="crates-ron-transport-src-types-rs"></a>

```rust
//! RO:WHAT â€” Common types/aliases for transport.
//! RO:WHY  â€” Keep the public surface small & stable; define bus events.

use bytes::Bytes;
use std::net::SocketAddr;

/// Owned frame bytes on hot paths (upper layers decode OAP/1).
pub type FrameBytes = Bytes;

/// Event type emitted on the kernel bus for observability/supervision.
#[derive(Debug, Clone)]
pub enum TransportEvent {
    Connected { peer: SocketAddr, name: &'static str },
    Disconnected { peer: SocketAddr, name: &'static str, reason: Option<String> },
}

```

### crates/ron-transport/src/util/bytes.rs
<a id="crates-ron-transport-src-util-bytes-rs"></a>

```rust
//! RO:WHAT â€” Byte helpers (cap checks).
//! RO:INVARIANTS â€” enforce MAX_FRAME_BYTES before alloc.

use bytes::BytesMut;

pub fn reserve_capped(buf: &mut BytesMut, want: usize, cap: usize) -> Result<(), &'static str> {
    if want > cap { return Err("cap_exceeded"); }
    buf.reserve(want);
    Ok(())
}

```

### crates/ron-transport/src/util/cancel.rs
<a id="crates-ron-transport-src-util-cancel-rs"></a>

```rust
//! RO:WHAT â€” Cancel tokens & helpers (async-drop friendly).
//! RO:WHY  â€” Crash-only supervision + graceful shutdown.

use tokio_util::sync::CancellationToken;

#[derive(Clone)]
pub struct Cancel {
    token: CancellationToken,
}
impl Cancel {
    pub fn new() -> Self { Self { token: CancellationToken::new() } }
    pub fn child(&self) -> Self { Self { token: self.token.child_token() } }
    pub fn cancel(&self) { self.token.cancel(); }
    pub async fn cancelled(&self) { self.token.cancelled().await; }
}

```

### crates/ron-transport/src/util/mod.rs
<a id="crates-ron-transport-src-util-mod-rs"></a>

```rust
pub mod cancel;
pub mod timeouts;
pub mod bytes;

```

### crates/ron-transport/src/util/timeouts.rs
<a id="crates-ron-transport-src-util-timeouts-rs"></a>

```rust
//! RO:WHAT â€” Timeout helpers (read/write/idle).
use std::time::Duration;
use tokio::time::{timeout, Instant};

pub async fn with_timeout<F, T>(dur: Duration, f: F) -> Result<T, tokio::time::error::Elapsed>
where
    F: std::future::Future<Output = T>,
{
    timeout(dur, f).await
}

pub struct IdleGuard {
    last: Instant,
    idle: Duration,
}
impl IdleGuard {
    pub fn new(idle: Duration) -> Self { Self { last: Instant::now(), idle } }
    pub fn bump(&mut self) { self.last = Instant::now(); }
    pub fn expired(&self) -> bool { self.last.elapsed() > self.idle }
}

```

### crates/ron-transport/tests/amnesia/no_disk_touches.rs
<a id="crates-ron-transport-tests-amnesia-nodisktouches-rs"></a>

```rust
#[test]
fn no_disk_touches_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/integration/arti_bootstrap_ready.rs
<a id="crates-ron-transport-tests-integration-artibootstrapready-rs"></a>

```rust
#[test]
fn arti_bootstrap_ready_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/integration/idle_timeout.rs
<a id="crates-ron-transport-tests-integration-idletimeout-rs"></a>

```rust
use ron_transport::{config::TransportConfig, metrics::TransportMetrics, spawn_transport, types::TransportEvent};
use ron_kernel::{Bus, HealthState};
use std::{io::Write, net::TcpStream as StdTcp, sync::Arc, time::Duration};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn idle_timeout_closes() -> anyhow::Result<()> {
    let mut cfg = TransportConfig::default();
    cfg.read_timeout = Duration::from_millis(50);
    cfg.idle_timeout = Duration::from_millis(100);
    cfg.name = "test";

    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, None).await?;

    // Connect and stay idle; server should close within ~idle_timeout.
    let mut s = StdTcp::connect(addr)?;
    tokio::time::sleep(Duration::from_millis(200)).await; // cross idle timeout

    // Poll for closure up to a small budget to avoid race with FIN propagation.
    let deadline = std::time::Instant::now() + Duration::from_millis(600);
    loop {
        match s.write(&[1, 2, 3]) {
            Ok(_) => {
                if std::time::Instant::now() >= deadline {
                    anyhow::bail!("expected write to fail after idle timeout (connection still open)");
                }
                // FIN may not have arrived yet; wait and retry.
                tokio::time::sleep(Duration::from_millis(50)).await;
            }
            Err(e) => {
                use std::io::ErrorKind::*;
                assert!(
                    matches!(e.kind(), BrokenPipe | ConnectionReset | NotConnected | UnexpectedEof),
                    "unexpected error kind: {e}"
                );
                break;
            }
        }
    }
    Ok(())
}

```

### crates/ron-transport/tests/integration/mod.rs
<a id="crates-ron-transport-tests-integration-mod-rs"></a>

```rust
mod idle_timeout;
mod over_capacity;
#[cfg(feature = "tls")]
mod tls_accept;

```

### crates/ron-transport/tests/integration/over_capacity.rs
<a id="crates-ron-transport-tests-integration-overcapacity-rs"></a>

```rust
use ron_transport::{config::TransportConfig, metrics::TransportMetrics, spawn_transport, types::TransportEvent};
use ron_kernel::{Bus, HealthState};
use std::{io::Write, net::TcpStream as StdTcp, sync::Arc, time::Duration};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn over_capacity_second_conn_dropped() -> anyhow::Result<()> {
    let mut cfg = TransportConfig::default();
    cfg.max_conns = 1;
    cfg.read_timeout = Duration::from_millis(200);
    cfg.idle_timeout = Duration::from_millis(500);
    cfg.name = "test";

    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, None).await?;

    // First connection holds the single permit.
    let _first = StdTcp::connect(addr)?;

    // Second connection should be dropped immediately by policy.
    let mut second = StdTcp::connect(addr)?;
    match second.write(&[9, 9, 9]) {
        Ok(_) => {
            tokio::time::sleep(Duration::from_millis(100)).await;
            match second.write(&[9, 9, 9]) {
                Ok(_) => anyhow::bail!("expected second connection to be dropped"),
                Err(_) => Ok(()),
            }
        }
        Err(_) => Ok(()),
    }
}

```

### crates/ron-transport/tests/integration/quic_parity.rs
<a id="crates-ron-transport-tests-integration-quicparity-rs"></a>

```rust
#[test]
fn quic_parity_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/integration/tls_accept.rs
<a id="crates-ron-transport-tests-integration-tlsaccept-rs"></a>

```rust
#![cfg(feature = "tls")]

use ron_transport::{config::TransportConfig, metrics::TransportMetrics, spawn_transport, TlsServerConfig, types::TransportEvent};
use ron_kernel::{Bus, HealthState};
use rustls_pemfile::{certs, pkcs8_private_keys, rsa_private_keys};
use std::{fs::File, io::BufReader, path::Path, sync::Arc};
use tokio_rustls::rustls::{
    ClientConfig, RootCertStore,
    pki_types::{CertificateDer, PrivatePkcs1KeyDer, PrivatePkcs8KeyDer, ServerName},
};
use tokio_rustls::TlsConnector;
use tokio::net::TcpStream;

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn tls_accepts_handshake() -> anyhow::Result<()> {
    let cert_path = "crates/ron-transport/scripts/local/certs/cert.pem";
    let key_path  = "crates/ron-transport/scripts/local/certs/key.pem";
    if !(Path::new(cert_path).exists() && Path::new(key_path).exists()) {
        eprintln!("(skipping tls_accepts_handshake: local certs not found)");
        return Ok(());
    }

    let server_cfg = Arc::new(load_rustls_server(cert_path, key_path)?);

    let mut cfg = TransportConfig::default();
    cfg.name = "tls-test";
    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, Some(server_cfg)).await?;

    let mut roots = RootCertStore::empty();
    let cert_file = File::open(Path::new(cert_path))?;
    let mut cert_rd = BufReader::new(cert_file);
    let certs: Vec<CertificateDer<'static>> = certs(&mut cert_rd).collect::<Result<_, _>>()?;
    for c in certs.into_iter() { roots.add(c)?; }

    let client = ClientConfig::builder().with_root_certificates(roots).with_no_client_auth();
    let connector = TlsConnector::from(Arc::new(client));
    let tcp = TcpStream::connect(addr).await?;
    let _tls = connector.connect(ServerName::try_from("localhost")?, tcp).await?;
    Ok(())
}

fn load_rustls_server(cert_path: &str, key_path: &str) -> anyhow::Result<TlsServerConfig> {
    use tokio_rustls::rustls::{ServerConfig, pki_types::{CertificateDer, PrivateKeyDer}};

    let cert_file = File::open(Path::new(cert_path))?;
    let mut cert_rd = BufReader::new(cert_file);
    let certs: Vec<CertificateDer<'static>> = certs(&mut cert_rd).collect::<Result<_, _>>()?;

    let key: PrivateKeyDer<'static> = {
        let key_file = File::open(Path::new(key_path))?;
        let mut key_rd = BufReader::new(key_file);
        let mut pkcs8: Vec<PrivateKeyDer<'static>> = pkcs8_private_keys(&mut key_rd)
            .map(|res: std::io::Result<PrivatePkcs8KeyDer<'static>>| res.map(Into::into))
            .collect::<Result<_, _>>()?;
        if let Some(k) = pkcs8.pop() {
            k
        } else {
            let key_file = File::open(Path::new(key_path))?;
            let mut key_rd = BufReader::new(key_file);
            let mut rsa: Vec<PrivateKeyDer<'static>> = rsa_private_keys(&mut key_rd)
                .map(|res: std::io::Result<PrivatePkcs1KeyDer<'static>>| res.map(Into::into))
                .collect::<Result<_, _>>()?;
            rsa.pop().ok_or_else(|| anyhow::anyhow!("no private key found in {}", key_path))?
        }
    };

    let cfg = ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)?;
    Ok(cfg)
}

```

### crates/ron-transport/tests/integration/tls_handshake_limits.rs
<a id="crates-ron-transport-tests-integration-tlshandshakelimits-rs"></a>

```rust
#[test]
fn tls_handshake_limits_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/intergration.rs
<a id="crates-ron-transport-tests-intergration-rs"></a>

```rust
mod integration;

```

### crates/ron-transport/tests/loom/single_writer.rs
<a id="crates-ron-transport-tests-loom-singlewriter-rs"></a>

```rust
#[test]
fn single_writer_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/soak/loopback_1MiB.rs
<a id="crates-ron-transport-tests-soak-loopback1MiB-rs"></a>

```rust
#[test]
fn soak_loopback_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/vectors/comp_bounds.json
<a id="crates-ron-transport-tests-vectors-compbounds-json"></a>

```json
{ "max_frame_bytes": 1048576, "inflate_cap": "8x", "notes": "placeholder" }

```

### crates/ron-transport/tests/vectors/oap_hello.json
<a id="crates-ron-transport-tests-vectors-oaphello-json"></a>

```json
{ "name": "oap_hello", "version": 1, "notes": "placeholder vector" }

```

### crates/ron-transport/tests/vectors/pq_hybrid_hello.json
<a id="crates-ron-transport-tests-vectors-pqhybridhello-json"></a>

```json
{ "kex": "hybrid_x25519_mlkem768", "sig": "ed25519", "notes": "placeholder" }

```

### crates/ron-transport/tests/vectors/tor_parity.json
<a id="crates-ron-transport-tests-vectors-torparity-json"></a>

```json
{ "backend": "arti", "parity": true, "notes": "placeholder" }

```

