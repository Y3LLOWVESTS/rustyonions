<!-- Generated by scripts/make_crate_codex.sh on 2025-11-09T18:46:47Z -->
# Code Bundle — `ron-auth`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-auth/.github/workflows/ci.yml](#crates-ron-auth--github-workflows-ci-yml)
- [crates/ron-auth/.github/workflows/pq-matrix.yml](#crates-ron-auth--github-workflows-pq-matrix-yml)
- [crates/ron-auth/Cargo.toml](#crates-ron-auth-Cargo-toml)
- [crates/ron-auth/benches/verify_bench.rs](#crates-ron-auth-benches-verifybench-rs)
- [crates/ron-auth/deny.toml](#crates-ron-auth-deny-toml)
- [crates/ron-auth/examples/verify.rs](#crates-ron-auth-examples-verify-rs)
- [crates/ron-auth/fuzz/fuzz_targets/token_parser_fuzz.rs](#crates-ron-auth-fuzz-fuzztargets-tokenparserfuzz-rs)
- [crates/ron-auth/rustfmt.toml](#crates-ron-auth-rustfmt-toml)
- [crates/ron-auth/scripts/smoke_auth.sh](#crates-ron-auth-scripts-smokeauth-sh)
- [crates/ron-auth/src/bounds.rs](#crates-ron-auth-src-bounds-rs)
- [crates/ron-auth/src/builder.rs](#crates-ron-auth-src-builder-rs)
- [crates/ron-auth/src/capability/caveat.rs](#crates-ron-auth-src-capability-caveat-rs)
- [crates/ron-auth/src/capability/encode.rs](#crates-ron-auth-src-capability-encode-rs)
- [crates/ron-auth/src/capability/mod.rs](#crates-ron-auth-src-capability-mod-rs)
- [crates/ron-auth/src/capability/scope.rs](#crates-ron-auth-src-capability-scope-rs)
- [crates/ron-auth/src/caveats/builtin.rs](#crates-ron-auth-src-caveats-builtin-rs)
- [crates/ron-auth/src/caveats/custom.rs](#crates-ron-auth-src-caveats-custom-rs)
- [crates/ron-auth/src/caveats/mod.rs](#crates-ron-auth-src-caveats-mod-rs)
- [crates/ron-auth/src/caveats/registry.rs](#crates-ron-auth-src-caveats-registry-rs)
- [crates/ron-auth/src/cbor.rs](#crates-ron-auth-src-cbor-rs)
- [crates/ron-auth/src/config/env.rs](#crates-ron-auth-src-config-env-rs)
- [crates/ron-auth/src/config/mod.rs](#crates-ron-auth-src-config-mod-rs)
- [crates/ron-auth/src/config/verifier_config.rs](#crates-ron-auth-src-config-verifierconfig-rs)
- [crates/ron-auth/src/ctx.rs](#crates-ron-auth-src-ctx-rs)
- [crates/ron-auth/src/errors.rs](#crates-ron-auth-src-errors-rs)
- [crates/ron-auth/src/keys/mac_handle.rs](#crates-ron-auth-src-keys-machandle-rs)
- [crates/ron-auth/src/keys/mod.rs](#crates-ron-auth-src-keys-mod-rs)
- [crates/ron-auth/src/keys/traits.rs](#crates-ron-auth-src-keys-traits-rs)
- [crates/ron-auth/src/lib.rs](#crates-ron-auth-src-lib-rs)
- [crates/ron-auth/src/mac.rs](#crates-ron-auth-src-mac-rs)
- [crates/ron-auth/src/metrics.rs](#crates-ron-auth-src-metrics-rs)
- [crates/ron-auth/src/pq/mod.rs](#crates-ron-auth-src-pq-mod-rs)
- [crates/ron-auth/src/pq/sig_adapter.rs](#crates-ron-auth-src-pq-sigadapter-rs)
- [crates/ron-auth/src/prelude.rs](#crates-ron-auth-src-prelude-rs)
- [crates/ron-auth/src/redact.rs](#crates-ron-auth-src-redact-rs)
- [crates/ron-auth/src/types.rs](#crates-ron-auth-src-types-rs)
- [crates/ron-auth/src/verify/checks.rs](#crates-ron-auth-src-verify-checks-rs)
- [crates/ron-auth/src/verify/decision.rs](#crates-ron-auth-src-verify-decision-rs)
- [crates/ron-auth/src/verify/error.rs](#crates-ron-auth-src-verify-error-rs)
- [crates/ron-auth/src/verify/eval.rs](#crates-ron-auth-src-verify-eval-rs)
- [crates/ron-auth/src/verify/mod.rs](#crates-ron-auth-src-verify-mod-rs)
- [crates/ron-auth/src/verify/parse.rs](#crates-ron-auth-src-verify-parse-rs)
- [crates/ron-auth/src/verify/pipeline.rs](#crates-ron-auth-src-verify-pipeline-rs)
- [crates/ron-auth/src/verify/soa.rs](#crates-ron-auth-src-verify-soa-rs)
- [crates/ron-auth/src/verify/soa_eval.rs](#crates-ron-auth-src-verify-soaeval-rs)
- [crates/ron-auth/src/verify/streaming.rs](#crates-ron-auth-src-verify-streaming-rs)
- [crates/ron-auth/src/zk/mod.rs](#crates-ron-auth-src-zk-mod-rs)
- [crates/ron-auth/testing/vectors/ron-auth/v1/allow_example.json](#crates-ron-auth-testing-vectors-ron-auth-v1-allowexample-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/custom_ns_examples.json](#crates-ron-auth-testing-vectors-ron-auth-v1-customnsexamples-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/deny_expired.json](#crates-ron-auth-testing-vectors-ron-auth-v1-denyexpired-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/deny_unknown_kid.json](#crates-ron-auth-testing-vectors-ron-auth-v1-denyunknownkid-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/pq_allow.json](#crates-ron-auth-testing-vectors-ron-auth-v1-pqallow-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/pq_deny_mismatch.json](#crates-ron-auth-testing-vectors-ron-auth-v1-pqdenymismatch-json)
- [crates/ron-auth/tests/allow_deny_vectors.rs](#crates-ron-auth-tests-allowdenyvectors-rs)
- [crates/ron-auth/tests/amnesia_mode.rs](#crates-ron-auth-tests-amnesiamode-rs)
- [crates/ron-auth/tests/attenuation_monotonicity.rs](#crates-ron-auth-tests-attenuationmonotonicity-rs)
- [crates/ron-auth/tests/compat_public_api.rs](#crates-ron-auth-tests-compatpublicapi-rs)
- [crates/ron-auth/tests/ip_cidr.rs](#crates-ron-auth-tests-ipcidr-rs)
- [crates/ron-auth/tests/loom_verify.rs](#crates-ron-auth-tests-loomverify-rs)
- [crates/ron-auth/tests/parser_fixtures.rs](#crates-ron-auth-tests-parserfixtures-rs)
- [crates/ron-auth/tests/verify_batch_order.rs](#crates-ron-auth-tests-verifybatchorder-rs)
- [crates/ron-auth/tests/verify_error_path.rs](#crates-ron-auth-tests-verifyerrorpath-rs)
- [crates/ron-auth/tests/verify_happy_path.rs](#crates-ron-auth-tests-verifyhappypath-rs)

### crates/ron-auth/.github/workflows/ci.yml
<a id="crates-ron-auth--github-workflows-ci-yml"></a>

```yaml
name: CI (ron-auth2)

on:
  push:
    paths:
      - "crates/ron-auth2/**"
  pull_request:
    paths:
      - "crates/ron-auth2/**"

jobs:
  build-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: crates/ron-auth2
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
      - run: cargo fmt --all -- --check
      - run: cargo clippy --all-targets -- -D warnings
      - run: cargo build --features ""
      - run: cargo test --features ""
      - run: echo "placeholder: cargo-deny/public-api checks wired later"
```

### crates/ron-auth/.github/workflows/pq-matrix.yml
<a id="crates-ron-auth--github-workflows-pq-matrix-yml"></a>

```yaml
name: PQ Matrix (ron-auth2)

on:
  push:
    paths:
      - "crates/ron-auth2/**"
  pull_request:
    paths:
      - "crates/ron-auth2/**"

jobs:
  matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        features: ["", "pq", "pq-hybrid", "pq-only"]
    defaults:
      run:
        working-directory: crates/ron-auth2
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
      - run: cargo build --features "${{ matrix.features }}"
      - run: cargo test --features "${{ matrix.features }}"
```

### crates/ron-auth/Cargo.toml
<a id="crates-ron-auth-Cargo-toml"></a>

```toml
[package]
name = "ron-auth"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Capability-based auth for RON-CORE"
readme = "README.md"
repository = "https://github.com/your-org/rusty-onions"
keywords = ["auth", "capability", "macaroon"]
categories = ["authentication", "cryptography"]

[features]
# Keep defaults minimal. Turn knobs on in benches or services.
default = ["std"]
std = []

# Perf toggles
bench-eval-modes = []
simd-b64 = ["base64-simd"]
fast-cbor = ["ciborium"]          # keep as-is (disabled by default)
parallel = ["rayon"]

# New: zero-copy CBOR scaffold (not enabled by default).
# First iteration keeps current serde encoding on the wire; we will
# A/B a borrowed decode path in a later patch behind this flag.
minicbor-zerocopy = ["minicbor"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_bytes = "0.11"
serde_cbor = "0.11"
ciborium = { version = "0.2", optional = true }
base64 = "0.22"
smallvec = "1.15"
blake3 = "1.5"
ipnet = "2.11"
thiserror = "1.0"

# Feature-gated perf deps
base64-simd = { version = "0.8", optional = true }
rayon = { version = "1.11", optional = true }
minicbor = { version = "0.25", optional = true, features = ["std", "alloc"] }

[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }
proptest = "1.4"
loom = "0.7"

# Tell Cargo this bench uses Criterion (not the default test harness)
[[bench]]
name = "verify_bench"
harness = false

```

### crates/ron-auth/benches/verify_bench.rs
<a id="crates-ron-auth-benches-verifybench-rs"></a>

```rust
// RO:WHAT   Criterion microbench for verify_token / verify_many (small + heavy tokens).
// RO:WHY    Show hybrid crossover; optionally compare streaming-only vs SoA-only.
// RO:INVARIANTS Pure; BLAKE3; deterministic; no I/O.

use criterion::{black_box, criterion_group, criterion_main, BatchSize, Criterion};
#[cfg(feature = "bench-eval-modes")]
use ron_auth::verify::{
    verify_many_soa_only, verify_many_streaming_only, verify_token_soa_only,
    verify_token_streaming_only,
};
use ron_auth::{
    sign_and_encode_b64url, verify_many, verify_token, CapabilityBuilder, Caveat, MacKey,
    MacKeyProvider, RequestCtx, Scope, VerifierConfig,
};
use serde_cbor::Value;
use std::net::IpAddr;
use std::str::FromStr;

#[derive(Clone)]
struct StaticKeys;
impl MacKeyProvider for StaticKeys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        if kid == "k1" && tid == "test" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn now() -> u64 {
    1_700_000_000
}
fn make_cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 128,
        clock_skew_secs: 60,
        // NEW knob in Perf Pack A (exported by ron-auth); keep default crossover.
        soa_threshold: 8,
    }
}

fn base_ctx() -> RequestCtx {
    // Method uppercased once; matches verifier’s fast path.
    RequestCtx {
        now_unix_s: now(),
        method: "GET".into(),
        path: "/index/1".into(),
        peer_ip: Some(IpAddr::from_str("127.0.0.1").unwrap()),
        object_addr: None,
        tenant: "test".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}

fn make_token_small(keys: &impl MacKeyProvider) -> String {
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::PathPrefix("/index/".into()))
        .caveat(Caveat::Method(vec!["GET".into()]))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::Exp(now() + 600))
        .build();
    sign_and_encode_b64url(&cap, keys).unwrap()
}

// Heavier capability: multi-methods, prefixes, CIDRs, and bounds (~24–32 caveats).
fn make_token_heavy(keys: &impl MacKeyProvider) -> String {
    let methods = vec![
        "GET", "HEAD", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "TRACE", "CONNECT", "PROPFIND",
        "SEARCH", "COPY",
    ]
    .into_iter()
    .map(|s| s.to_string())
    .collect::<Vec<_>>();

    let scope = Scope {
        prefix: Some("/api/v1/tenant/test/objects/".into()),
        methods: methods.clone(),
        max_bytes: None,
    };

    let mut builder = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::Exp(now() + 600))
        .caveat(Caveat::PathPrefix("/api/".into()))
        .caveat(Caveat::PathPrefix("/api/v1/".into()))
        .caveat(Caveat::PathPrefix("/api/v1/tenant/".into()))
        .caveat(Caveat::PathPrefix("/api/v1/tenant/test/".into()))
        .caveat(Caveat::Method(methods))
        .caveat(Caveat::IpCidr("127.0.0.0/8".into()))
        .caveat(Caveat::IpCidr("10.0.0.0/8".into()))
        .caveat(Caveat::IpCidr("192.168.0.0/16".into()))
        .caveat(Caveat::IpCidr("172.16.0.0/12".into()))
        .caveat(Caveat::BytesLe(1_048_576))
        .caveat(Caveat::Amnesia(false));

    // pad to ~30 caveats with no-op customs (ignored by evaluator)
    for i in 0..6 {
        builder = builder.caveat(Caveat::Custom {
            name: format!("x{}", i),
            ns: "demo".into(),
            cbor: Value::Null,
        });
    }

    let cap = builder.build();
    sign_and_encode_b64url(&cap, keys).unwrap()
}

fn benches_small(c: &mut Criterion) {
    let keys = StaticKeys;
    let token = make_token_small(&keys);
    let cfg_single = make_cfg();
    let ctx_single = base_ctx();

    c.bench_function("verify_single", |b| {
        b.iter(|| {
            let d = verify_token(&cfg_single, black_box(&token), &ctx_single, &keys).unwrap();
            black_box(d);
        })
    });

    c.bench_function("verify_batch_64_loop", |b| {
        b.iter_batched(
            || {
                let v: Vec<String> = vec![token.clone(); 64];
                (v, base_ctx(), make_cfg(), keys.clone())
            },
            |(tokens, ctx, cfg, keys)| {
                for t in tokens.iter() {
                    let d = verify_token(&cfg, t, &ctx, &keys).unwrap();
                    black_box(d);
                }
            },
            BatchSize::SmallInput,
        )
    });

    c.bench_function("verify_many_64", |b| {
        b.iter_batched(
            || {
                let v: Vec<String> = vec![token.clone(); 64];
                (v, base_ctx(), make_cfg(), keys.clone())
            },
            |(tokens, ctx, cfg, keys)| {
                let decisions = verify_many(&cfg, &tokens, &ctx, &keys).unwrap();
                black_box(decisions);
            },
            BatchSize::SmallInput,
        )
    });
}

fn benches_heavy(c: &mut Criterion) {
    let keys = StaticKeys;
    let token = make_token_heavy(&keys);

    c.bench_function("verify_single_heavy", |b| {
        b.iter(|| {
            let d = verify_token(&make_cfg(), black_box(&token), &base_ctx(), &keys).unwrap();
            black_box(d);
        })
    });

    c.bench_function("verify_many_64_heavy", |b| {
        b.iter_batched(
            || {
                let v: Vec<String> = vec![token.clone(); 64];
                (v, base_ctx(), make_cfg(), keys.clone())
            },
            |(tokens, ctx, cfg, keys)| {
                let decisions = verify_many(&cfg, &tokens, &ctx, &keys).unwrap();
                black_box(decisions);
            },
            BatchSize::SmallInput,
        )
    });

    // Optional: hard-toggle comparisons (requires `--features bench-eval-modes`)
    #[cfg(feature = "bench-eval-modes")]
    {
        c.bench_function("verify_single_heavy_streaming_only", |b| {
            b.iter(|| {
                let d =
                    verify_token_streaming_only(&make_cfg(), black_box(&token), &base_ctx(), &keys)
                        .unwrap();
                black_box(d);
            })
        });

        c.bench_function("verify_single_heavy_soa_only", |b| {
            b.iter(|| {
                let d = verify_token_soa_only(&make_cfg(), black_box(&token), &base_ctx(), &keys)
                    .unwrap();
                black_box(d);
            })
        });

        c.bench_function("verify_many_64_heavy_streaming_only", |b| {
            b.iter_batched(
                || {
                    let v: Vec<String> = vec![token.clone(); 64];
                    (v, base_ctx(), make_cfg(), keys.clone())
                },
                |(tokens, ctx, cfg, keys)| {
                    let decisions = verify_many_streaming_only(&cfg, &tokens, &ctx, &keys).unwrap();
                    black_box(decisions);
                },
                BatchSize::SmallInput,
            )
        });

        c.bench_function("verify_many_64_heavy_soa_only", |b| {
            b.iter_batched(
                || {
                    let v: Vec<String> = vec![token.clone(); 64];
                    (v, base_ctx(), make_cfg(), keys.clone())
                },
                |(tokens, ctx, cfg, keys)| {
                    let decisions = verify_many_soa_only(&cfg, &tokens, &ctx, &keys).unwrap();
                    black_box(decisions);
                },
                BatchSize::SmallInput,
            )
        });
    }
}

criterion_group!(benches, benches_small, benches_heavy);
criterion_main!(benches);

```

### crates/ron-auth/deny.toml
<a id="crates-ron-auth-deny-toml"></a>

```toml
[advisories]
yanked = "deny"
ignore = []

[bans]
multiple-versions = "warn"
wildcards = "deny"
deny = [
  { name = "tokio" },
  { name = "hyper" },
  { name = "reqwest" },
]

[sources]
unknown-registry = "deny"
unknown-git = "deny"
allow-registry = ["https://github.com/rust-lang/crates.io-index"]

[licenses]
unlicensed = "deny"
allow = [
  "MIT",
  "Apache-2.0",
  "Unicode-3.0",
  "Unicode-DFS-2016",
  "CC0-1.0",
  "CDLA-Permissive-2.0",
  "OpenSSL"
]
```

### crates/ron-auth/examples/verify.rs
<a id="crates-ron-auth-examples-verify-rs"></a>

```rust
//! Minimal end-to-end example: verify one token, then a batch.
use ron_auth::{
    verify_many, verify_token, Decision, MacKey, MacKeyProvider, RequestCtx, VerifierConfig,
};
use serde_cbor::Value;

#[derive(Clone)]
struct StaticKeys;
impl MacKeyProvider for StaticKeys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        if kid == "k1" && tid == "tenant-a" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn ctx() -> RequestCtx {
    RequestCtx {
        now_unix_s: 1_700_000_000,
        method: "GET".into(),
        path: "/index/abc".into(),
        peer_ip: None,
        object_addr: None,
        tenant: "tenant-a".into(),
        amnesia: false,
        policy_digest_hex: None,
        extras: Value::Null,
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cfg = VerifierConfig::with_defaults();

    // Single
    let token = std::env::args().nth(1).expect("pass b64 token");
    let d: Decision = verify_token(&cfg, &token, &ctx(), &StaticKeys)?;
    println!("single: {d:?}");

    // Batch
    let batch = vec![token.clone(), token.clone(), token];
    let out = verify_many(&cfg, &batch, &ctx(), &StaticKeys)?;
    println!("batch: {out:?}");

    Ok(())
}

```

### crates/ron-auth/fuzz/fuzz_targets/token_parser_fuzz.rs
<a id="crates-ron-auth-fuzz-fuzztargets-tokenparserfuzz-rs"></a>

```rust
// fuzz target: token parser placeholder
```

### crates/ron-auth/rustfmt.toml
<a id="crates-ron-auth-rustfmt-toml"></a>

```toml
max_width = 100
edition = "2021"
use_field_init_shorthand = true
newline_style = "Unix"
```

### crates/ron-auth/scripts/smoke_auth.sh
<a id="crates-ron-auth-scripts-smokeauth-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Simple smoke for ron-auth:
#  - fmt, clippy, tests
#  - builds the example
#  - runs the example with a provided or default b64url token
#
# Usage:
#   crates/ron-auth/scripts/smoke_auth.sh
#   crates/ron-auth/scripts/smoke_auth.sh "<base64url_token>"
#
# Env:
#   FEATURES   - Cargo features to use for build/test (default: "")
#   RUSTFLAGS  - Optional (e.g., -C target-cpu=native)
#   RAYON_NUM_THREADS - Optional for benches or future parallel runs

CRATE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$CRATE_DIR"

FEATURES="${FEATURES:-}"

echo "[INFO] crate dir = $CRATE_DIR"
echo "[INFO] features  = '${FEATURES}'"

echo "[STEP] cargo fmt"
cargo fmt -p ron-auth

echo "[STEP] cargo clippy (deny warnings)"
if [[ -n "$FEATURES" ]]; then
  cargo clippy -p ron-auth --features "$FEATURES" --all-targets -- -D warnings
else
  cargo clippy -p ron-auth --all-targets -- -D warnings
fi

echo "[STEP] cargo test"
if [[ -n "$FEATURES" ]]; then
  cargo test -p ron-auth --features "$FEATURES"
else
  cargo test -p ron-auth
fi

# Build the example (exists in examples/verify.rs)
echo "[STEP] build example: verify"
if [[ -n "$FEATURES" ]]; then
  cargo build -p ron-auth --features "$FEATURES" --example verify
else
  cargo build -p ron-auth --example verify
fi

# Default demo token: valid base64url JSON-ish payload; verification will likely return Deny
# unless it matches your StaticKeys/kid/tid and caveats.
DEFAULT_TOKEN='eyJkZW1vIjoidG9rZW4tZm9yLXJvbi1hdXRoLXNtb2tlIn0'

TOKEN="${1:-$DEFAULT_TOKEN}"

echo "[STEP] run example: verify (token length: ${#TOKEN})"
set +e
if [[ -n "$FEATURES" ]]; then
  cargo run -p ron-auth --features "$FEATURES" --example verify -- "$TOKEN"
else
  cargo run -p ron-auth --example verify -- "$TOKEN"
fi
STATUS=$?
set -e

# We don't fail the smoke if the example returns Deny/Err (non-zero). The goal is “it runs”.
if [[ $STATUS -ne 0 ]]; then
  echo "[WARN] example exited with status ${STATUS} (often OK if token doesn't match keys/caveats)"
else
  echo "[OK] example ran successfully"
fi

echo "[DONE] smoke_auth complete."

```

### crates/ron-auth/src/bounds.rs
<a id="crates-ron-auth-src-bounds-rs"></a>

```rust
//! RO:WHAT  Centralized bounds helpers.
//! RO:WHY   Enforce size/complexity limits consistently.

/// Rough upper bound for Base64URL (no padding) length for a given raw size.
pub fn max_b64url_chars_for(max_bytes: usize) -> usize {
    // ceiling((max_bytes * 4) / 3) without padding; use saturating math for safety.
    max_bytes.saturating_mul(4).div_ceil(3)
}

```

### crates/ron-auth/src/builder.rs
<a id="crates-ron-auth-src-builder-rs"></a>

```rust
//! RO:WHAT  Capability attenuation builder (pure); requires caller-provided signer.
//! RO:WHY   Build stricter children; never broaden scope.
//! RO:INVARIANTS No I/O; callers inject MacKeyProvider to sign.

use crate::types::MacKey;
use crate::{
    cbor::encode_b64url_cbor_capability,
    mac::compute_mac,
    types::{Capability, Caveat, MacKeyProvider, Scope},
};

#[derive(Debug, Clone)]
pub struct CapabilityBuilder {
    tid: String,
    kid: String,
    scope: Scope,
    caveats: Vec<Caveat>,
}

impl CapabilityBuilder {
    pub fn new(scope: Scope, tid: impl Into<String>, kid: impl Into<String>) -> Self {
        Self {
            tid: tid.into(),
            kid: kid.into(),
            scope,
            caveats: Vec::new(),
        }
    }

    pub fn caveat(mut self, c: Caveat) -> Self {
        self.caveats.push(c);
        self
    }

    pub fn build(self) -> Capability {
        // Unsigned until caller signs; mac is zeroed.
        Capability {
            tid: self.tid,
            kid: self.kid,
            scope: self.scope,
            caveats: self.caveats,
            mac: vec![0u8; 32],
        }
    }
}

/// Helper for hosts/tests to sign-and-encode using their key source.
/// Note: this is referenced primarily from integration tests and host crates.
#[allow(dead_code)]
pub fn sign_and_encode_b64url(
    cap: &mut Capability,
    keys: &impl MacKeyProvider,
) -> Result<String, &'static str> {
    let MacKey(k) = keys.key_for(&cap.kid, &cap.tid).ok_or("unknown kid")?;
    let tag = compute_mac(&MacKey(k), cap);
    cap.mac.clear();
    cap.mac.extend_from_slice(&tag);
    Ok(encode_b64url_cbor_capability(cap))
}

```

### crates/ron-auth/src/capability/caveat.rs
<a id="crates-ron-auth-src-capability-caveat-rs"></a>

```rust
// capability::caveat placeholder
```

### crates/ron-auth/src/capability/encode.rs
<a id="crates-ron-auth-src-capability-encode-rs"></a>

```rust
// capability::encode placeholder
```

### crates/ron-auth/src/capability/mod.rs
<a id="crates-ron-auth-src-capability-mod-rs"></a>

```rust
// capability::mod placeholder
```

### crates/ron-auth/src/capability/scope.rs
<a id="crates-ron-auth-src-capability-scope-rs"></a>

```rust
// capability::scope placeholder
```

### crates/ron-auth/src/caveats/builtin.rs
<a id="crates-ron-auth-src-caveats-builtin-rs"></a>

```rust
// caveats::builtin placeholder
```

### crates/ron-auth/src/caveats/custom.rs
<a id="crates-ron-auth-src-caveats-custom-rs"></a>

```rust
// caveats::custom placeholder
```

### crates/ron-auth/src/caveats/mod.rs
<a id="crates-ron-auth-src-caveats-mod-rs"></a>

```rust
// caveats::mod placeholder
```

### crates/ron-auth/src/caveats/registry.rs
<a id="crates-ron-auth-src-caveats-registry-rs"></a>

```rust
// caveats::registry placeholder
```

### crates/ron-auth/src/cbor.rs
<a id="crates-ron-auth-src-cbor-rs"></a>

```rust
//! RO:WHAT  CBOR (de)serialization + Base64URL helpers (no padding).
//! RO:WHY   Keep encoding deterministic; centralized parsing; low alloc.
//! RO:INVARIANTS Deterministic CBOR; URL_SAFE_NO_PAD; strict size checks; buffer reuse.

#![allow(clippy::needless_return)]

use crate::{errors::AuthError, types::Capability};
use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine;

#[cfg(feature = "fast-cbor")]
use ciborium::de::from_reader as cbor_from_reader;
#[cfg(not(feature = "fast-cbor"))]
use serde_cbor::from_slice as cbor_from_slice;

#[cfg(feature = "simd-b64")]
use base64_simd::URL_SAFE_NO_PAD as SIMD_URL_SAFE_NO_PAD;

/// Decode a Base64URL (no padding) CBOR-encoded Capability into `scratch` to minimize allocs.
pub fn decode_b64url_cbor_capability_with_buf(
    b64: &str,
    max_bytes: usize,
    scratch: &mut Vec<u8>,
) -> Result<Capability, AuthError> {
    // Decode Base64URL → bytes into `scratch`.
    #[cfg(feature = "simd-b64")]
    {
        // SIMD decode returns a fresh Vec; move it into `scratch` with no extra copy.
        let decoded = SIMD_URL_SAFE_NO_PAD
            .decode_to_vec(b64.as_bytes())
            .map_err(|_| AuthError::Malformed("base64url"))?;
        if decoded.len() > max_bytes {
            return Err(AuthError::Bounds);
        }
        *scratch = decoded;
    }

    #[cfg(not(feature = "simd-b64"))]
    {
        scratch.clear();
        URL_SAFE_NO_PAD
            .decode_vec(b64.as_bytes(), scratch)
            .map_err(|_| AuthError::Malformed("base64url"))?;
        if scratch.len() > max_bytes {
            return Err(AuthError::Bounds);
        }
    }

    // Decode CBOR → Capability (serde-compatible). `fast-cbor` uses a reader form.
    #[cfg(feature = "fast-cbor")]
    let cap: Capability =
        cbor_from_reader(scratch.as_slice()).map_err(|_| AuthError::Malformed("cbor"))?;

    #[cfg(not(feature = "fast-cbor"))]
    let cap: Capability = cbor_from_slice(scratch).map_err(|_| AuthError::Malformed("cbor"))?;

    // Basic MAC sanity: 32 bytes (BLAKE3 keyed).
    if cap.mac.len() != 32 {
        return Err(AuthError::Malformed("mac_len"));
    }
    Ok(cap)
}

/// Backwards-compatible wrapper (allocates) — prefer the `_with_buf` variant on hot paths.
#[allow(dead_code)]
pub fn decode_b64url_cbor_capability(b64: &str, max_bytes: usize) -> Result<Capability, AuthError> {
    let mut tmp = Vec::new();
    decode_b64url_cbor_capability_with_buf(b64, max_bytes, &mut tmp)
}

#[allow(dead_code)]
pub fn encode_b64url_cbor_capability(cap: &Capability) -> String {
    let bytes = serde_cbor::to_vec(cap).expect("capability to cbor");
    URL_SAFE_NO_PAD.encode(bytes)
}

/// Deterministic CBOR fragment encoder for MAC chaining (allocating version).
#[allow(dead_code)]
pub fn cbor_fragment<T: serde::Serialize>(t: &T) -> Vec<u8> {
    serde_cbor::to_vec(t).expect("cbor fragment")
}

/// Deterministic CBOR fragment encoder that writes into `buf` (reused across calls).
pub fn cbor_fragment_into<T: serde::Serialize>(t: &T, buf: &mut Vec<u8>) {
    buf.clear();
    // serde_cbor::to_writer keeps canonical ordering for our simple maps/seq usage.
    serde_cbor::to_writer(buf, t).expect("cbor fragment into buf");
}

```

### crates/ron-auth/src/config/env.rs
<a id="crates-ron-auth-src-config-env-rs"></a>

```rust
// config::env placeholder (feature: config-env)
```

### crates/ron-auth/src/config/mod.rs
<a id="crates-ron-auth-src-config-mod-rs"></a>

```rust
// config::mod placeholder
```

### crates/ron-auth/src/config/verifier_config.rs
<a id="crates-ron-auth-src-config-verifierconfig-rs"></a>

```rust
// config::verifier_config placeholder
```

### crates/ron-auth/src/ctx.rs
<a id="crates-ron-auth-src-ctx-rs"></a>

```rust
// ctx placeholder
```

### crates/ron-auth/src/errors.rs
<a id="crates-ron-auth-src-errors-rs"></a>

```rust
//! RO:WHAT  Public error/deny taxonomy (stable).
//! RO:WHY   Callers map to metrics and user-facing problem docs.
//! RO:INVARIANTS Codes/reasons are semver-stable.

use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum AuthError {
    #[error("malformed token: {0}")]
    Malformed(&'static str),
    #[error("bounds exceeded")]
    Bounds,
    #[error("unknown kid")]
    UnknownKid,
    #[error("mac mismatch")]
    MacMismatch,
    #[error("expired")]
    Expired,
    #[error("not yet valid")]
    NotYetValid,
    #[error("policy deny")]
    PolicyDeny, // Decision::Deny will contain reasons; this is for strict-mode callers.
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "reason", content = "detail")]
pub enum DenyReason {
    // Time
    Expired,
    NotYetValid,
    // Shape
    BadAudience,
    MethodNotAllowed,
    PathNotAllowed,
    IpNotAllowed,
    TenantMismatch,
    BytesExceed,
    RateExceeded, // placeholder for future rate caveat eval
    Custom(String),
}

```

### crates/ron-auth/src/keys/mac_handle.rs
<a id="crates-ron-auth-src-keys-machandle-rs"></a>

```rust
// keys::mac_handle placeholder
```

### crates/ron-auth/src/keys/mod.rs
<a id="crates-ron-auth-src-keys-mod-rs"></a>

```rust
// keys::mod placeholder
```

### crates/ron-auth/src/keys/traits.rs
<a id="crates-ron-auth-src-keys-traits-rs"></a>

```rust
// keys::traits placeholder
```

### crates/ron-auth/src/lib.rs
<a id="crates-ron-auth-src-lib-rs"></a>

```rust
//! RO:WHAT  Public crate façade for ron-auth.
//! RO:WHY   Stable, minimal surface; re-exports common types and verify APIs.
//! RO:INTERACTS  Delegates to `verify` module; no I/O or globals.
//! RO:INVARIANTS  No panics; propagate typed errors; keep generics simple and zero-IO.

pub mod cbor;
pub mod errors;
pub mod mac;
pub mod metrics;
pub mod types;
pub mod verify;

pub use errors::{AuthError, DenyReason};
pub use types::{
    Capability, Caveat, Decision, MacKey, MacKeyProvider, RequestCtx, Scope, VerifierConfig,
};

/// Verify a single Base64URL-encoded token.
#[inline]
pub fn verify_token<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Decision, AuthError> {
    verify::verify_token(cfg, token_b64url, ctx, keys)
}

/// Verify many tokens; amortizes internal buffers and may parallelize
/// when built with `--features parallel`.
#[inline]
pub fn verify_many<K: MacKeyProvider + Sync>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Vec<Decision>, AuthError> {
    verify::verify_many(cfg, tokens_b64url, ctx, keys)
}

/// Same as `verify_many` but writes into `out` (clears it first).
#[inline]
pub fn verify_many_into<K: MacKeyProvider + Sync>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
    out: &mut Vec<Decision>,
) -> Result<(), AuthError> {
    verify::verify_many_into(cfg, tokens_b64url, ctx, keys, out)
}

// ===== Bench/Test-friendly helpers (stable, zero I/O) ========================

/// Builder to assemble a Capability and sign/encode it for benches/tests.
///
/// NOTE: ctor order matches the bench: `new(scope, tid, kid)`.
#[derive(Debug, Clone)]
pub struct CapabilityBuilder {
    tid: String,
    kid: String,
    scope: Scope,
    caveats: Vec<Caveat>,
}

impl CapabilityBuilder {
    /// Create a new builder.
    pub fn new<T: Into<String>, K: Into<String>>(scope: Scope, tid: T, kid: K) -> Self {
        Self {
            tid: tid.into(),
            kid: kid.into(),
            scope,
            caveats: Vec::new(),
        }
    }

    /// Add a caveat (alias for `push` to match bench naming).
    #[inline]
    pub fn caveat(self, c: Caveat) -> Self {
        self.push(c)
    }

    #[inline]
    pub fn push(mut self, c: Caveat) -> Self {
        self.caveats.push(c);
        self
    }

    #[inline]
    pub fn extend<I: IntoIterator<Item = Caveat>>(mut self, it: I) -> Self {
        self.caveats.extend(it);
        self
    }

    /// Finalize into an unsigned Capability (MAC empty).
    pub fn build_unsigned(self) -> Capability {
        Capability {
            tid: self.tid,
            kid: self.kid,
            scope: self.scope,
            caveats: self.caveats,
            mac: Vec::new(),
        }
    }

    /// Alias expected by benches.
    #[inline]
    pub fn build(self) -> Capability {
        self.build_unsigned()
    }

    /// Build, sign with `key`, and return the finalized Capability.
    pub fn build_and_sign(self, key: &MacKey) -> Capability {
        let mut cap = self.build_unsigned();
        let tag = crate::mac::compute_mac(key, &cap);
        cap.mac = tag.to_vec();
        cap
    }

    /// Build, sign, and Base64URL-encode the CBOR token.
    pub fn build_sign_encode(self, key: &MacKey) -> String {
        let cap = self.build_and_sign(key);
        crate::cbor::encode_b64url_cbor_capability(&cap)
    }
}

/// Public so it can be used in a public function bound (fixes `private_bounds` warning).
pub trait KeyLookup {
    fn key_for_cap(&self, kid: &str, tid: &str) -> Option<MacKey>;
}

impl KeyLookup for &MacKey {
    #[inline]
    fn key_for_cap(&self, _kid: &str, _tid: &str) -> Option<MacKey> {
        Some((**self).clone())
    }
}

impl<K: MacKeyProvider> KeyLookup for &K {
    #[inline]
    fn key_for_cap(&self, kid: &str, tid: &str) -> Option<MacKey> {
        MacKeyProvider::key_for(*self, kid, tid)
    }
}

/// Sign the provided `Capability` using either a `&MacKey` or a `&impl MacKeyProvider`,
/// then return the Base64URL-encoded CBOR token.
///
/// - Accepts `&Capability`.
/// - Returns `Result<String, AuthError>` so benches can `.unwrap()`.
#[inline]
pub fn sign_and_encode_b64url<L: KeyLookup>(
    cap: &Capability,
    lookup: L,
) -> Result<String, AuthError> {
    let key = lookup
        .key_for_cap(&cap.kid, &cap.tid)
        .ok_or(AuthError::UnknownKid)?;

    let mut tmp = Capability {
        tid: cap.tid.clone(),
        kid: cap.kid.clone(),
        scope: cap.scope.clone(),
        caveats: cap.caveats.clone(),
        mac: Vec::new(),
    };
    let tag = mac::compute_mac(&key, &tmp);
    tmp.mac = tag.to_vec();
    Ok(cbor::encode_b64url_cbor_capability(&tmp))
}

```

### crates/ron-auth/src/mac.rs
<a id="crates-ron-auth-src-mac-rs"></a>

```rust
//! RO:WHAT  BLAKE3 keyed MAC chaining with domain separation (low-alloc path).
//! RO:WHY   Integrity over (tenant,kid,scope,caveats...) in strict order.
//! RO:INVARIANTS No SHA; constant-time compare; buffer reuse to cut allocs.

use crate::{
    cbor,
    types::{Capability, Caveat, MacKey, Scope},
};

const DOMAIN_SEP: &[u8] = b"RON-AUTHv1\0";

#[inline]
fn init_tag(key: &MacKey, tid: &str, kid: &str, scope: &Scope, buf: &mut Vec<u8>) -> [u8; 32] {
    // tag0 = BLAKE3(key, DOMAIN || CBOR{tid,kid,scope})
    buf.clear();
    buf.extend_from_slice(DOMAIN_SEP);
    cbor::cbor_fragment_into(&(tid, kid, scope), buf);
    *blake3::keyed_hash(&key.0, buf).as_bytes()
}

#[inline]
fn fold_caveats(
    key: &MacKey,
    mut tag: [u8; 32],
    caveats: &[Caveat],
    frag: &mut Vec<u8>,
    fold: &mut Vec<u8>,
) -> [u8; 32] {
    for c in caveats {
        // Serialize caveat into frag (reused)
        cbor::cbor_fragment_into(c, frag);

        // fold = tag || frag
        fold.clear();
        fold.extend_from_slice(&tag);
        fold.extend_from_slice(frag);

        tag = *blake3::keyed_hash(&key.0, fold).as_bytes();
    }
    tag
}

/// Compute MAC with minimal transient allocations by reusing small buffers.
#[inline]
pub fn compute_mac(key: &MacKey, cap: &Capability) -> [u8; 32] {
    let mut init_buf = Vec::with_capacity(128);
    let tag0 = init_tag(key, &cap.tid, &cap.kid, &cap.scope, &mut init_buf);

    let mut frag = Vec::with_capacity(128);
    let mut fold = Vec::with_capacity(160); // 32 + typical frag
    fold_caveats(key, tag0, &cap.caveats, &mut frag, &mut fold)
}

/// Constant-time MAC comparison (works for equal-length slices).
/// Runs in time proportional to length; no early-exit and no branching on secrets.
#[inline]
pub fn macs_equal(ct_a: &[u8], ct_b: &[u8]) -> bool {
    if ct_a.len() != ct_b.len() {
        return false;
    }
    let mut diff: u8 = 0;
    // Iterate over all bytes; XOR accumulates any difference.
    for i in 0..ct_a.len() {
        // SAFETY: bounds-checked by loop condition
        diff |= ct_a[i] ^ ct_b[i];
    }
    // `diff == 0` after the loop implies equality; single comparison independent of contents.
    diff == 0
}

```

### crates/ron-auth/src/metrics.rs
<a id="crates-ron-auth-src-metrics-rs"></a>

```rust
//! Minimal, zero-IO metrics hook for ron-auth.
//!
//! - Default is NO-OP (no allocations, no locks on hot path).
//! - Hosts may register a recorder once (e.g., Prometheus in svc-passport).
//! - This crate never depends on prometheus/tokio/etc.

use crate::errors::AuthError;
use std::sync::OnceLock;

pub trait MetricsRecorder: Send + Sync + 'static {
    /// Counter add (monotonic). Example: "ron_auth_verify_allow_total"
    fn counter_add(&self, name: &'static str, by: u64);
    /// Histogram observe (nanoseconds, counts, sizes, etc.).
    fn histogram_observe(&self, name: &'static str, value: u64);
    /// Gauge set (rarely used here).
    fn gauge_set(&self, _name: &'static str, _value: i64) {
        // optional to implement
    }
}

struct Nop;
impl MetricsRecorder for Nop {
    #[inline]
    fn counter_add(&self, _name: &'static str, _by: u64) {}
    #[inline]
    fn histogram_observe(&self, _name: &'static str, _value: u64) {}
    #[inline]
    fn gauge_set(&self, _name: &'static str, _value: i64) {}
}

static REC: OnceLock<&'static dyn MetricsRecorder> = OnceLock::new();
static NOP: Nop = Nop;

/// One-time hook called by hosts (e.g., svc-passport) to install a recorder.
/// Safe to call at startup; subsequent calls are ignored.
pub fn set_recorder(rec: &'static dyn MetricsRecorder) {
    let _ = REC.set(rec);
}

#[inline]
fn rec() -> &'static dyn MetricsRecorder {
    REC.get().copied().unwrap_or(&NOP)
}

// ---------- Convenience shims used by the pipeline ----------

#[inline]
pub fn counter_inc(name: &'static str) {
    rec().counter_add(name, 1);
}
#[inline]
pub fn counter_add(name: &'static str, by: u64) {
    rec().counter_add(name, by);
}
#[inline]
pub fn hist_ns(name: &'static str, v: u64) {
    rec().histogram_observe(name, v);
}
#[inline]
pub fn gauge(name: &'static str, v: i64) {
    rec().gauge_set(name, v);
}

// Grouped helpers used at error/decision sites:

pub const C_ALLOW: &'static str = "ron_auth_verify_allow_total";
pub const C_DENY: &'static str = "ron_auth_verify_deny_total";

pub const C_ERR_MALFORMED: &'static str = "ron_auth_err_malformed_total";
pub const C_ERR_BOUNDS: &'static str = "ron_auth_err_bounds_total";
pub const C_ERR_UNKNOWN_KID: &'static str = "ron_auth_err_unknown_kid_total";
pub const C_ERR_MAC: &'static str = "ron_auth_err_mac_mismatch_total";
pub const C_ERR_EXPIRED: &'static str = "ron_auth_err_expired_total";
pub const C_ERR_NOTYET: &'static str = "ron_auth_err_not_yet_valid_total";
pub const C_ERR_POLICY: &'static str = "ron_auth_err_policy_total";

pub const H_BATCH_SIZE: &'static str = "ron_auth_verify_batch_size";
pub const H_CAVEATS_PER_CAP: &'static str = "ron_auth_caveats_per_cap";

/// Increment a counter by error type (call *before* returning the error).
#[inline]
pub fn bump_error(e: &AuthError) {
    match e {
        AuthError::Malformed(_) => counter_inc(C_ERR_MALFORMED),
        AuthError::Bounds => counter_inc(C_ERR_BOUNDS),
        AuthError::UnknownKid => counter_inc(C_ERR_UNKNOWN_KID),
        AuthError::MacMismatch => counter_inc(C_ERR_MAC),
        AuthError::Expired => counter_inc(C_ERR_EXPIRED),
        AuthError::NotYetValid => counter_inc(C_ERR_NOTYET),
        AuthError::PolicyDeny => counter_inc(C_ERR_POLICY),
    }
}

/// Record per-capacity caveat count (cheap int, helps crossover tuning).
#[inline]
pub fn observe_caveats(n: usize) {
    rec().histogram_observe(H_CAVEATS_PER_CAP, n as u64);
}

```

### crates/ron-auth/src/pq/mod.rs
<a id="crates-ron-auth-src-pq-mod-rs"></a>

```rust
// pq::mod placeholder (feature-gated)
```

### crates/ron-auth/src/pq/sig_adapter.rs
<a id="crates-ron-auth-src-pq-sigadapter-rs"></a>

```rust
// pq::sig_adapter placeholder (feature-gated)
```

### crates/ron-auth/src/prelude.rs
<a id="crates-ron-auth-src-prelude-rs"></a>

```rust
//! RO:WHAT    Shared imports/types for crate-internal modules.
//! RO:WHY     Keep lib files concise and consistent (CODECOMMENTS.MD).
//! RO:INTERACTS  Used by most modules (types, errors, tools).
//! RO:INVARIANTS No I/O, no async, no SHA; BLAKE3 only.

pub use crate::errors::AuthError;
pub use serde::{Deserialize, Serialize};

```

### crates/ron-auth/src/redact.rs
<a id="crates-ron-auth-src-redact-rs"></a>

```rust
// redact helpers placeholder
```

### crates/ron-auth/src/types.rs
<a id="crates-ron-auth-src-types-rs"></a>

```rust
//! RO:WHAT  Public types: Capability, Scope, Caveat, Decision, VerifierConfig, RequestCtx.
//! RO:WHY   Stable, boring DTOs; serde/CBOR friendly; no alloc surprises.
//! RO:INVARIANTS Deterministic encoding; strict bounds; no I/O.

use crate::errors::DenyReason;
use serde::{Deserialize, Serialize};
use std::net::IpAddr;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Scope {
    /// Optional resource prefix (e.g., "/index/").
    pub prefix: Option<String>,
    /// Allowed HTTP-style methods (e.g., "GET","PUT").
    pub methods: Vec<String>,
    /// Max payload bytes permitted by this capability.
    pub max_bytes: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "t", content = "v")]
pub enum Caveat {
    Exp(u64),
    Nbf(u64),
    Aud(String),
    Method(Vec<String>),
    PathPrefix(String),
    IpCidr(String),
    BytesLe(u64),
    Rate {
        per_s: u32,
        burst: u32,
    },
    Tenant(String),
    Amnesia(bool),
    GovPolicyDigest(String),
    Custom {
        ns: String,
        name: String,
        cbor: serde_cbor::Value,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Capability {
    /// Tenant/domain namespace for multi-tenant safety.
    pub tid: String,
    /// Key identifier for MAC lookup.
    pub kid: String,
    pub scope: Scope,
    pub caveats: Vec<Caveat>,
    /// Final MAC (BLAKE3 keyed), 32 bytes.
    #[serde(with = "serde_bytes")]
    pub mac: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct VerifierConfig {
    /// Upper bound after Base64URL decode.
    pub max_token_bytes: usize,
    /// Max allowed caveats.
    pub max_caveats: usize,
    /// Clock skew in seconds for exp/nbf.
    pub clock_skew_secs: i64,
    /// Hybrid crossover: <= threshold → streaming; > threshold → SoA.
    pub soa_threshold: usize,
}

impl VerifierConfig {
    pub fn with_defaults() -> Self {
        Self {
            max_token_bytes: 4096,
            max_caveats: 64,
            clock_skew_secs: 60,
            // Mixed workloads on your laptop benefit from a slightly higher default.
            soa_threshold: 16,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct RequestCtx {
    pub now_unix_s: u64,
    pub method: String,
    pub path: String,
    pub peer_ip: Option<IpAddr>,
    pub object_addr: Option<String>,
    pub tenant: String,
    pub amnesia: bool,
    pub policy_digest_hex: Option<String>,
    pub extras: serde_cbor::Value,
}

/// Final decision.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum Decision {
    Allow { scope: Scope },
    Deny { reasons: Vec<DenyReason> },
}

/// Opaque MAC key (32 bytes for BLAKE3 keyed mode).
#[derive(Debug, Clone)]
pub struct MacKey(pub [u8; 32]);

/// Caller-provided keys (e.g., from ron-kms). No I/O here.
pub trait MacKeyProvider {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey>;
}

```

### crates/ron-auth/src/verify/checks.rs
<a id="crates-ron-auth-src-verify-checks-rs"></a>

```rust
//! RO:WHAT   Fast structural/limit checks executed before MAC work.
//! RO:WHY    Shed bad requests early; keep hot path predictable.
//! RO:INVARIANTS Pure; constant-time unrelated to secrets.

use crate::types::VerifierConfig;

#[allow(dead_code)]
#[inline]
pub fn check_size_cap(cfg: &VerifierConfig, token_len: usize) -> Result<(), &'static str> {
    if token_len > cfg.max_token_bytes {
        return Err("cap: token too large");
    }
    Ok(())
}

#[allow(dead_code)]
#[inline]
pub fn check_caveat_count(cfg: &VerifierConfig, count: usize) -> Result<(), &'static str> {
    if count > cfg.max_caveats {
        return Err("cap: too many caveats");
    }
    Ok(())
}

```

### crates/ron-auth/src/verify/decision.rs
<a id="crates-ron-auth-src-verify-decision-rs"></a>

```rust
// verify::decision placeholder

```

### crates/ron-auth/src/verify/error.rs
<a id="crates-ron-auth-src-verify-error-rs"></a>

```rust
// verify::error placeholder

```

### crates/ron-auth/src/verify/eval.rs
<a id="crates-ron-auth-src-verify-eval-rs"></a>

```rust
//! RO:WHAT  Streaming caveat evaluator with early short-circuit on Exp/Nbf.
//! RO:WHY   Fast path for small caveat sets; accumulates soft mismatches.

use crate::{
    errors::{AuthError, DenyReason},
    types::{Caveat, RequestCtx, VerifierConfig},
};
use ipnet::IpNet;
use serde_cbor::Value;
use std::str::FromStr;

#[inline]
pub fn eval_caveats_streaming(
    cfg: &VerifierConfig,
    ctx: &RequestCtx,
    caveats: &[Caveat],
    out: &mut Vec<DenyReason>,
) -> Result<(), AuthError> {
    let now = ctx.now_unix_s as i64;
    let mut need_len: Option<u64> = None;

    for c in caveats {
        match c {
            Caveat::Exp(v) => {
                if now > (*v as i64) + cfg.clock_skew_secs {
                    return Err(AuthError::Expired);
                }
            }
            Caveat::Nbf(v) => {
                if now + cfg.clock_skew_secs < *v as i64 {
                    return Err(AuthError::NotYetValid);
                }
            }
            Caveat::Aud(a) => {
                if ctx.policy_digest_hex.as_deref() != Some(a.as_str()) {
                    out.push(DenyReason::BadAudience);
                }
            }
            Caveat::Method(ms) => {
                if !ms.iter().any(|m| m.eq_ignore_ascii_case(&ctx.method)) {
                    out.push(DenyReason::MethodNotAllowed);
                }
            }
            Caveat::PathPrefix(pref) => {
                if !ctx.path.starts_with(pref) {
                    out.push(DenyReason::PathNotAllowed);
                }
            }
            Caveat::IpCidr(s) => match (&ctx.peer_ip, IpNet::from_str(s)) {
                (Some(ip), Ok(net)) if net.contains(ip) => {}
                _ => out.push(DenyReason::IpNotAllowed),
            },
            Caveat::BytesLe(max) => {
                if need_len.is_none() {
                    need_len = extract_len_from_extras(&ctx.extras);
                }
                if let Some(len) = need_len {
                    if len > *max {
                        out.push(DenyReason::BytesExceed);
                    }
                }
            }
            Caveat::Rate { .. } => {
                // informational placeholder
            }
            Caveat::Tenant(t) => {
                if t != &ctx.tenant {
                    out.push(DenyReason::TenantMismatch);
                }
            }
            Caveat::Amnesia(flag) => {
                if *flag != ctx.amnesia {
                    out.push(DenyReason::Custom("amnesia_mismatch".into()));
                }
            }
            Caveat::GovPolicyDigest(d) => {
                if ctx.policy_digest_hex.as_deref() != Some(d.as_str()) {
                    out.push(DenyReason::Custom("gov_policy_digest_mismatch".into()));
                }
            }
            Caveat::Custom { .. } => {
                // host-defined; no-op
            }
        }
    }
    Ok(())
}

#[inline]
pub fn extract_len_from_extras(v: &Value) -> Option<u64> {
    match v {
        Value::Map(m) => {
            for (k, val) in m {
                if let Value::Text(s) = k {
                    if s == "len" {
                        if let Value::Integer(i) = val {
                            if *i >= 0 {
                                return Some(*i as u64);
                            }
                        } else if let Value::Float(f) = val {
                            if *f >= 0.0 {
                                return Some(*f as u64);
                            }
                        }
                    }
                }
            }
            None
        }
        _ => None,
    }
}

```

### crates/ron-auth/src/verify/mod.rs
<a id="crates-ron-auth-src-verify-mod-rs"></a>

```rust
//! RO:WHAT    Verification module split into pipeline + evaluators.
//! RO:LAYOUT  pipeline (API) | streaming (small sets) | soa (columns) | soa_eval | parse tests.

pub mod parse; // tests/utilities (kept)
pub mod soa; // CaveatsSoA columnar representation
pub mod soa_eval;
pub mod streaming; // eval for small caveat sets (early short-circuit)

mod pipeline; // main API (private module)

pub use pipeline::{verify_many, verify_many_into, verify_token};

#[cfg(feature = "bench-eval-modes")]
pub use pipeline::{
    verify_many_soa_only, verify_many_streaming_only, verify_token_soa_only,
    verify_token_streaming_only,
};

```

### crates/ron-auth/src/verify/parse.rs
<a id="crates-ron-auth-src-verify-parse-rs"></a>

```rust
//! RO:WHAT   Token parsing helpers (base64url, CBOR).
//! RO:WHY    Keep low-level parsing separate from pipeline orchestration.
//! RO:INVARIANTS No I/O; deterministic; URL-safe base64 without padding.

use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine as _;
use serde::de::DeserializeOwned;

/// Decode URL-safe base64 (no padding) with a conservative early size cap.
/// `max_bytes` is the maximum allowed decoded length (post-base64).
#[allow(dead_code)]
#[inline]
pub fn b64url_decode(bytes_b64url: &str, max_bytes: usize) -> Result<Vec<u8>, &'static str> {
    // Early cap on input chars: ceil(max_bytes * 4 / 3)
    let max_in = max_bytes.saturating_mul(4).div_ceil(3);
    if bytes_b64url.len() > max_in {
        return Err("b64url: input too large");
    }
    URL_SAFE_NO_PAD
        .decode(bytes_b64url.as_bytes())
        .map_err(|_| "b64url: decode error")
}

/// Decode CBOR value from a slice using serde_cbor.
#[allow(dead_code)]
#[inline]
pub fn cbor_from_slice<T: DeserializeOwned>(buf: &[u8]) -> Result<T, &'static str> {
    serde_cbor::from_slice(buf).map_err(|_| "cbor: decode error")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn decode_roundtrip() {
        let payload = b"hello";
        let enc = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(payload);
        let out = b64url_decode(&enc, 1024).unwrap();
        assert_eq!(out, payload);
    }
}

```

### crates/ron-auth/src/verify/pipeline.rs
<a id="crates-ron-auth-src-verify-pipeline-rs"></a>

```rust
//! RO:WHAT  Token verification pipeline (pure, sync) with hybrid eval + optional parallel batch.
//! RO:WHY   Keep early short-circuit cost for common tiny tokens; SoA for larger sets;
//!          add feature-gated parallelism for big batches while preserving order.
//! RO:INVARIANTS No I/O; strict bounds; constant-time MAC compare; BLAKE3 only.

use super::{soa::CaveatsSoA, soa_eval::eval_caveats_soa, streaming::eval_caveats_streaming};
use crate::cbor::decode_b64url_cbor_capability_with_buf;
use crate::errors::{AuthError, DenyReason};
use crate::mac::{compute_mac, macs_equal};
use crate::metrics as m;
use crate::types::{Decision, MacKeyProvider, RequestCtx, VerifierConfig};

use smallvec::SmallVec;

#[cfg(feature = "parallel")]
use rayon::prelude::*;

/// Parallel shard kickoff threshold (avoid thread-pool overhead on small batches).
#[cfg(feature = "parallel")]
const PAR_MIN_BATCH: usize = 64;

/// Sample size used to estimate a per-batch effective threshold.
const THRESH_SAMPLE: usize = 6;

/// Heuristic: estimate an effective crossover threshold from a tiny sample of the batch.
///
/// Optimization: if we're going to take the parallel path (large batch), we avoid
/// double-decoding a sample and simply bias strongly toward the streaming evaluator,
/// which is what heavy caveat sets prefer on this machine.
fn estimate_effective_threshold(cfg: &VerifierConfig, tokens_b64url: &[String]) -> usize {
    #[cfg(feature = "parallel")]
    {
        if tokens_b64url.len() >= PAR_MIN_BATCH {
            return usize::MAX / 2; // bias to streaming, avoids extra sample decodes
        }
    }

    let sample_n = tokens_b64url.len().min(THRESH_SAMPLE);
    if sample_n == 0 {
        return cfg.soa_threshold;
    }

    let mut scratch = Vec::with_capacity(512);
    let mut lens: SmallVec<[usize; 8]> = SmallVec::new();

    for tok in &tokens_b64url[..sample_n] {
        match decode_b64url_cbor_capability_with_buf(tok, cfg.max_token_bytes, &mut scratch) {
            Ok(cap) => lens.push(cap.caveats.len()),
            Err(_) => return cfg.soa_threshold, // fall back if malformed appears in sample
        }
    }

    if lens.is_empty() {
        return cfg.soa_threshold;
    }
    lens.sort_unstable();
    let median = lens[lens.len() / 2];

    if median > 20 {
        usize::MAX / 2 // bias strongly toward streaming for heavy caveat sets
    } else {
        cfg.soa_threshold
    }
}

/// Verify a single Base64URL token.
pub fn verify_token<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Decision, AuthError> {
    let mut scratch = Vec::with_capacity(1024);
    verify_one_with_buf_thresh(
        cfg,
        cfg.soa_threshold,
        token_b64url,
        ctx,
        keys,
        &mut scratch,
    )
}

/// Verify many Base64URL tokens with amortized buffer reuse; returns a Vec.
/// See `verify_many_into` to reuse the output buffer.
pub fn verify_many<K: MacKeyProvider + Sync>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Vec<Decision>, AuthError> {
    let mut out = Vec::with_capacity(tokens_b64url.len());
    verify_many_into(cfg, tokens_b64url, ctx, keys, &mut out)?;
    Ok(out)
}

/// Same as `verify_many` but writes decisions into `out` (clears it first).
///
/// When built with `--features parallel` and the batch size is large enough,
/// this will shard across the Rayon pool while preserving output order.
/// Otherwise it falls back to the sequential pipeline.
pub fn verify_many_into<K: MacKeyProvider + Sync>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
    out: &mut Vec<Decision>,
) -> Result<(), AuthError> {
    out.clear();
    out.reserve(tokens_b64url.len());

    // empty
    if tokens_b64url.is_empty() {
        return Ok(());
    }

    // Record the batch size (cheap, one point per call).
    m::hist_ns(m::H_BATCH_SIZE, tokens_b64url.len() as u64);

    // Decide an effective threshold from a tiny sample of the batch (or skip on big batches).
    let effective_threshold = estimate_effective_threshold(cfg, tokens_b64url);

    // Parallel order-preserving path (feature-gated + threshold)
    #[cfg(feature = "parallel")]
    {
        if tokens_b64url.len() >= PAR_MIN_BATCH {
            let decisions: Result<Vec<Decision>, AuthError> = tokens_b64url
                .par_iter()
                .map(|tok| {
                    let mut scratch = Vec::with_capacity(2048);
                    verify_one_with_buf_thresh(
                        cfg,
                        effective_threshold,
                        tok,
                        ctx,
                        keys,
                        &mut scratch,
                    )
                })
                .collect();
            out.extend(decisions?);
            return Ok(());
        }
    }

    // Sequential fallback (and default when `parallel` feature is off).
    let mut scratch = Vec::with_capacity(1024);
    let mut reasons: Vec<DenyReason> = Vec::new();

    for tok in tokens_b64url {
        let cap =
            match decode_b64url_cbor_capability_with_buf(tok, cfg.max_token_bytes, &mut scratch) {
                Ok(c) => c,
                Err(e) => {
                    m::bump_error(&e);
                    return Err(e);
                }
            };

        if cap.caveats.len() > cfg.max_caveats {
            let e = AuthError::Bounds;
            m::bump_error(&e);
            return Err(e);
        }

        // tiny per-cap stat to help crossover tuning
        m::observe_caveats(cap.caveats.len());

        let key = match keys.key_for(&cap.kid, &cap.tid) {
            Some(k) => k,
            None => {
                let e = AuthError::UnknownKid;
                m::bump_error(&e);
                return Err(e);
            }
        };

        // MAC over original caveat order (domain fixed)
        let expect = compute_mac(&key, &cap);
        if !macs_equal(&expect, &cap.mac) {
            let e = AuthError::MacMismatch;
            m::bump_error(&e);
            return Err(e);
        }

        reasons.clear();

        // Evaluator may return Expired / NotYetValid (hard errors) or push soft reasons.
        let eval_res = if cap.caveats.len() <= effective_threshold {
            eval_caveats_streaming(cfg, ctx, &cap.caveats, &mut reasons)
        } else {
            eval_caveats_soa(cfg, ctx, CaveatsSoA::from_slice(&cap.caveats), &mut reasons)
        };

        if let Err(e @ (AuthError::Expired | AuthError::NotYetValid | AuthError::PolicyDeny)) =
            eval_res
        {
            m::bump_error(&e);
            return Err(e);
        }

        if reasons.is_empty() {
            m::counter_inc(m::C_ALLOW);
            out.push(Decision::Allow { scope: cap.scope });
        } else {
            m::counter_inc(m::C_DENY);
            out.push(Decision::Deny {
                reasons: core::mem::take(&mut reasons),
            });
        }
    }

    Ok(())
}

fn verify_one_with_buf_thresh<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    threshold: usize,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &K,
    scratch: &mut Vec<u8>,
) -> Result<Decision, AuthError> {
    let cap =
        match decode_b64url_cbor_capability_with_buf(token_b64url, cfg.max_token_bytes, scratch) {
            Ok(c) => c,
            Err(e) => {
                m::bump_error(&e);
                return Err(e);
            }
        };

    if cap.caveats.len() > cfg.max_caveats {
        let e = AuthError::Bounds;
        m::bump_error(&e);
        return Err(e);
    }

    m::observe_caveats(cap.caveats.len());

    let key = match keys.key_for(&cap.kid, &cap.tid) {
        Some(k) => k,
        None => {
            let e = AuthError::UnknownKid;
            m::bump_error(&e);
            return Err(e);
        }
    };

    // MAC over original caveat order
    let expect = compute_mac(&key, &cap);
    if !macs_equal(&expect, &cap.mac) {
        let e = AuthError::MacMismatch;
        m::bump_error(&e);
        return Err(e);
    }

    let mut reasons: Vec<DenyReason> = Vec::new();
    let eval_res = if cap.caveats.len() <= threshold {
        eval_caveats_streaming(cfg, ctx, &cap.caveats, &mut reasons)
    } else {
        eval_caveats_soa(cfg, ctx, CaveatsSoA::from_slice(&cap.caveats), &mut reasons)
    };

    if let Err(e @ (AuthError::Expired | AuthError::NotYetValid | AuthError::PolicyDeny)) = eval_res
    {
        m::bump_error(&e);
        return Err(e);
    }

    if reasons.is_empty() {
        m::counter_inc(m::C_ALLOW);
        Ok(Decision::Allow { scope: cap.scope })
    } else {
        m::counter_inc(m::C_DENY);
        Ok(Decision::Deny { reasons })
    }
}

#[cfg(feature = "bench-eval-modes")]
#[allow(dead_code)]
pub fn verify_token_streaming_only<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Decision, AuthError> {
    let mut scratch = Vec::with_capacity(1024);
    let cap =
        decode_b64url_cbor_capability_with_buf(token_b64url, cfg.max_token_bytes, &mut scratch)
            .map_err(|e| {
                m::bump_error(&e);
                e
            })?;
    if cap.caveats.len() > cfg.max_caveats {
        let e = AuthError::Bounds;
        m::bump_error(&e);
        return Err(e);
    }
    let key = keys.key_for(&cap.kid, &cap.tid).ok_or_else(|| {
        let e = AuthError::UnknownKid;
        m::bump_error(&e);
        e
    })?;
    let expect = compute_mac(&key, &cap);
    if !macs_equal(&expect, &cap.mac) {
        let e = AuthError::MacMismatch;
        m::bump_error(&e);
        return Err(e);
    }
    let mut reasons = Vec::new();
    if let Err(e @ (AuthError::Expired | AuthError::NotYetValid | AuthError::PolicyDeny)) =
        eval_caveats_streaming(cfg, ctx, &cap.caveats, &mut reasons)
    {
        m::bump_error(&e);
        return Err(e);
    }
    if reasons.is_empty() {
        m::counter_inc(m::C_ALLOW);
        Ok(Decision::Allow { scope: cap.scope })
    } else {
        m::counter_inc(m::C_DENY);
        Ok(Decision::Deny { reasons })
    }
}

#[cfg(feature = "bench-eval-modes")]
#[allow(dead_code)]
pub fn verify_token_soa_only<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Decision, AuthError> {
    let mut scratch = Vec::with_capacity(1024);
    let cap =
        decode_b64url_cbor_capability_with_buf(token_b64url, cfg.max_token_bytes, &mut scratch)
            .map_err(|e| {
                m::bump_error(&e);
                e
            })?;
    if cap.caveats.len() > cfg.max_caveats {
        let e = AuthError::Bounds;
        m::bump_error(&e);
        return Err(e);
    }
    let key = keys.key_for(&cap.kid, &cap.tid).ok_or_else(|| {
        let e = AuthError::UnknownKid;
        m::bump_error(&e);
        e
    })?;
    let expect = compute_mac(&key, &cap);
    if !macs_equal(&expect, &cap.mac) {
        let e = AuthError::MacMismatch;
        m::bump_error(&e);
        return Err(e);
    }
    let mut reasons = Vec::new();
    if let Err(e @ (AuthError::Expired | AuthError::NotYetValid | AuthError::PolicyDeny)) =
        eval_caveats_soa(cfg, ctx, CaveatsSoA::from_slice(&cap.caveats), &mut reasons)
    {
        m::bump_error(&e);
        return Err(e);
    }
    if reasons.is_empty() {
        m::counter_inc(m::C_ALLOW);
        Ok(Decision::Allow { scope: cap.scope })
    } else {
        m::counter_inc(m::C_DENY);
        Ok(Decision::Deny { reasons })
    }
}

#[cfg(feature = "bench-eval-modes")]
#[allow(dead_code)]
pub fn verify_many_streaming_only<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Vec<Decision>, AuthError> {
    let mut out = Vec::with_capacity(tokens_b64url.len());
    let mut scratch = Vec::with_capacity(1024);
    let mut reasons = Vec::<DenyReason>::new();

    if !tokens_b64url.is_empty() {
        m::hist_ns(m::H_BATCH_SIZE, tokens_b64url.len() as u64);
    }

    for tok in tokens_b64url {
        let cap = decode_b64url_cbor_capability_with_buf(tok, cfg.max_token_bytes, &mut scratch)
            .map_err(|e| {
                m::bump_error(&e);
                e
            })?;
        if cap.caveats.len() > cfg.max_caveats {
            let e = AuthError::Bounds;
            m::bump_error(&e);
            return Err(e);
        }
        m::observe_caveats(cap.caveats.len());
        let key = keys.key_for(&cap.kid, &cap.tid).ok_or_else(|| {
            let e = AuthError::UnknownKid;
            m::bump_error(&e);
            e
        })?;
        let expect = compute_mac(&key, &cap);
        if !macs_equal(&expect, &cap.mac) {
            let e = AuthError::MacMismatch;
            m::bump_error(&e);
            return Err(e);
        }
        reasons.clear();
        if let Err(e @ (AuthError::Expired | AuthError::NotYetValid | AuthError::PolicyDeny)) =
            eval_caveats_streaming(cfg, ctx, &cap.caveats, &mut reasons)
        {
            m::bump_error(&e);
            return Err(e);
        }
        if reasons.is_empty() {
            m::counter_inc(m::C_ALLOW);
            out.push(Decision::Allow { scope: cap.scope });
        } else {
            m::counter_inc(m::C_DENY);
            out.push(Decision::Deny {
                reasons: core::mem::take(&mut reasons),
            });
        }
    }
    Ok(out)
}

#[cfg(feature = "bench-eval-modes")]
#[allow(dead_code)]
pub fn verify_many_soa_only<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Vec<Decision>, AuthError> {
    let mut out = Vec::with_capacity(tokens_b64url.len());
    let mut scratch = Vec::with_capacity(1024);
    let mut reasons = Vec::<DenyReason>::new();

    if !tokens_b64url.is_empty() {
        m::hist_ns(m::H_BATCH_SIZE, tokens_b64url.len() as u64);
    }

    for tok in tokens_b64url {
        let cap = decode_b64url_cbor_capability_with_buf(tok, cfg.max_token_bytes, &mut scratch)
            .map_err(|e| {
                m::bump_error(&e);
                e
            })?;
        if cap.caveats.len() > cfg.max_caveats {
            let e = AuthError::Bounds;
            m::bump_error(&e);
            return Err(e);
        }
        m::observe_caveats(cap.caveats.len());
        let key = keys.key_for(&cap.kid, &cap.tid).ok_or_else(|| {
            let e = AuthError::UnknownKid;
            m::bump_error(&e);
            e
        })?;
        let expect = compute_mac(&key, &cap);
        if !macs_equal(&expect, &cap.mac) {
            let e = AuthError::MacMismatch;
            m::bump_error(&e);
            return Err(e);
        }
        reasons.clear();
        if let Err(e @ (AuthError::Expired | AuthError::NotYetValid | AuthError::PolicyDeny)) =
            eval_caveats_soa(cfg, ctx, CaveatsSoA::from_slice(&cap.caveats), &mut reasons)
        {
            m::bump_error(&e);
            return Err(e);
        }
        if reasons.is_empty() {
            m::counter_inc(m::C_ALLOW);
            out.push(Decision::Allow { scope: cap.scope });
        } else {
            m::counter_inc(m::C_DENY);
            out.push(Decision::Deny {
                reasons: core::mem::take(&mut reasons),
            });
        }
    }
    Ok(out)
}

```

### crates/ron-auth/src/verify/soa.rs
<a id="crates-ron-auth-src-verify-soa-rs"></a>

```rust
//! SoA (struct-of-arrays) view over a slice of Caveat.

use crate::types::Caveat;
use ipnet::IpNet;
use serde_cbor::Value;
use std::str::FromStr;

pub struct CaveatsSoA<'a> {
    pub exp: Vec<u64>,
    pub nbf: Vec<u64>,
    pub aud: Vec<&'a str>,
    pub method: Vec<&'a Vec<String>>,
    pub path_prefix: Vec<&'a str>,
    pub ip_cidr: Vec<Option<IpNet>>,
    pub bytes_le: Vec<u64>,
    pub rate: Vec<(u64, u32)>,
    pub tenant: Vec<&'a str>,
    pub amnesia: Vec<bool>,
    pub gov_policy_digest: Vec<&'a str>,
    pub custom: Vec<(&'a str, &'a str, &'a Value)>, // (ns, name, cbor)
}

impl<'a> CaveatsSoA<'a> {
    pub fn from_slice(caveats: &'a [Caveat]) -> Self {
        let mut out = Self {
            exp: Vec::new(),
            nbf: Vec::new(),
            aud: Vec::new(),
            method: Vec::new(),
            path_prefix: Vec::new(),
            ip_cidr: Vec::new(),
            bytes_le: Vec::new(),
            rate: Vec::new(),
            tenant: Vec::new(),
            amnesia: Vec::new(),
            gov_policy_digest: Vec::new(),
            custom: Vec::new(),
        };

        for c in caveats {
            match c {
                Caveat::Exp(v) => out.exp.push(*v),
                Caveat::Nbf(v) => out.nbf.push(*v),
                Caveat::Aud(a) => out.aud.push(a.as_str()),
                Caveat::Method(ms) => out.method.push(ms),
                Caveat::PathPrefix(p) => out.path_prefix.push(p.as_str()),
                Caveat::IpCidr(s) => {
                    out.ip_cidr.push(IpNet::from_str(s).ok());
                }
                Caveat::BytesLe(n) => out.bytes_le.push(*n),
                Caveat::Rate { burst, per_s } => out.rate.push((*burst as u64, *per_s)),
                Caveat::Tenant(t) => out.tenant.push(t.as_str()),
                Caveat::Amnesia(b) => out.amnesia.push(*b),
                Caveat::GovPolicyDigest(d) => out.gov_policy_digest.push(d.as_str()),
                Caveat::Custom { ns, name, cbor } => {
                    out.custom.push((ns.as_str(), name.as_str(), cbor))
                }
            }
        }

        out
    }
}

```

### crates/ron-auth/src/verify/soa_eval.rs
<a id="crates-ron-auth-src-verify-soaeval-rs"></a>

```rust
//! Evaluator over SoA columns.

use super::soa::CaveatsSoA;
use crate::errors::{AuthError, DenyReason};
use crate::types::{RequestCtx, VerifierConfig};

pub fn eval_caveats_soa<'a>(
    cfg: &VerifierConfig,
    ctx: &RequestCtx,
    soa: CaveatsSoA<'a>,
    out: &mut Vec<DenyReason>,
) -> Result<(), AuthError> {
    let now = ctx.now_unix_s as i64;

    // Hard errors first.
    for exp in soa.exp.iter() {
        if now > (*exp as i64) + cfg.clock_skew_secs {
            return Err(AuthError::Expired);
        }
    }
    for nbf in soa.nbf.iter() {
        if now + cfg.clock_skew_secs < *nbf as i64 {
            return Err(AuthError::NotYetValid);
        }
    }

    // Audience
    for a in soa.aud.iter() {
        match &ctx.policy_digest_hex {
            Some(pd) if pd == a => {}
            _ => out.push(DenyReason::BadAudience),
        }
    }

    // Method (borrowed slice of Strings; compare as &str)
    for methods in soa.method.iter() {
        if !methods
            .iter()
            .any(|m| m.as_str().eq_ignore_ascii_case(&ctx.method))
        {
            out.push(DenyReason::MethodNotAllowed);
        }
    }

    // PathPrefix
    for pref in soa.path_prefix.iter() {
        if !ctx.path.starts_with(pref) {
            out.push(DenyReason::PathNotAllowed);
        }
    }

    // IpCidr (already parsed)
    for net in soa.ip_cidr.iter() {
        match (&ctx.peer_ip, net) {
            (Some(ip), Some(n)) if n.contains(ip) => {}
            _ => out.push(DenyReason::IpNotAllowed),
        }
    }

    // BytesLe
    if let Some(len) = extract_len_from_extras_for_soa(&ctx.extras) {
        for max in soa.bytes_le.iter() {
            if len > *max {
                out.push(DenyReason::BytesExceed);
            }
        }
    }

    // Rate (placeholder)
    for (_burst, _per_s) in soa.rate.iter() {
        // host policy may enforce elsewhere
    }

    // Tenant
    for t in soa.tenant.iter() {
        if *t != ctx.tenant {
            out.push(DenyReason::TenantMismatch);
        }
    }

    // Amnesia flag
    for flag in soa.amnesia.iter() {
        if *flag != ctx.amnesia {
            out.push(DenyReason::Custom("amnesia_mismatch".into()));
        }
    }

    // Governance policy digest
    for d in soa.gov_policy_digest.iter() {
        if ctx.policy_digest_hex.as_deref() != Some(*d) {
            out.push(DenyReason::Custom("gov_policy_digest_mismatch".into()));
        }
    }

    // Custom caveats are host-defined; keep informational
    let _ = soa.custom;

    Ok(())
}

// Small helper to reuse the same len-extractor without exposing internals widely.
pub(crate) fn extract_len_from_extras_for_soa(v: &serde_cbor::Value) -> Option<u64> {
    use serde_cbor::Value;
    match v {
        Value::Map(m) => {
            for (k, val) in m {
                if let Value::Text(s) = k {
                    if s == "len" {
                        if let Value::Integer(i) = val {
                            if *i >= 0 {
                                return Some(*i as u64);
                            }
                        } else if let Value::Float(f) = val {
                            if *f >= 0.0 {
                                return Some(*f as u64);
                            }
                        }
                    }
                }
            }
            None
        }
        _ => None,
    }
}

```

### crates/ron-auth/src/verify/streaming.rs
<a id="crates-ron-auth-src-verify-streaming-rs"></a>

```rust
//! Streaming evaluator with early short-circuit for Exp/Nbf.

use crate::errors::{AuthError, DenyReason};
use crate::types::{Caveat, RequestCtx, VerifierConfig};
use ipnet::IpNet;
use serde_cbor::Value;
use std::str::FromStr;

pub fn eval_caveats_streaming(
    cfg: &VerifierConfig,
    ctx: &RequestCtx,
    caveats: &[Caveat],
    out: &mut Vec<DenyReason>,
) -> Result<(), AuthError> {
    let now = ctx.now_unix_s as i64;
    let mut need_len: Option<u64> = None;

    for c in caveats {
        match c {
            Caveat::Exp(v) => {
                if now > (*v as i64) + cfg.clock_skew_secs {
                    return Err(AuthError::Expired);
                }
            }
            Caveat::Nbf(v) => {
                if now + cfg.clock_skew_secs < *v as i64 {
                    return Err(AuthError::NotYetValid);
                }
            }
            Caveat::Aud(a) => {
                if ctx.policy_digest_hex.as_deref() != Some(a.as_str()) {
                    out.push(DenyReason::BadAudience);
                }
            }
            Caveat::Method(ms) => {
                if !ms.iter().any(|m| m.eq_ignore_ascii_case(&ctx.method)) {
                    out.push(DenyReason::MethodNotAllowed);
                }
            }
            Caveat::PathPrefix(pref) => {
                if !ctx.path.starts_with(pref) {
                    out.push(DenyReason::PathNotAllowed);
                }
            }
            Caveat::IpCidr(s) => match (&ctx.peer_ip, IpNet::from_str(s)) {
                (Some(ip), Ok(net)) if net.contains(ip) => {}
                _ => out.push(DenyReason::IpNotAllowed),
            },
            Caveat::BytesLe(max) => {
                if need_len.is_none() {
                    need_len = extract_len_from_extras(&ctx.extras);
                }
                if let Some(len) = need_len {
                    if len > *max {
                        out.push(DenyReason::BytesExceed);
                    }
                }
            }
            Caveat::Rate { .. } => {} // informational
            Caveat::Tenant(t) => {
                if t != &ctx.tenant {
                    out.push(DenyReason::TenantMismatch);
                }
            }
            Caveat::Amnesia(flag) => {
                if *flag != ctx.amnesia {
                    out.push(DenyReason::Custom("amnesia_mismatch".into()));
                }
            }
            Caveat::GovPolicyDigest(d) => {
                if ctx.policy_digest_hex.as_deref() != Some(d.as_str()) {
                    out.push(DenyReason::Custom("gov_policy_digest_mismatch".into()));
                }
            }
            Caveat::Custom { .. } => {}
        }
    }
    Ok(())
}

fn extract_len_from_extras(v: &Value) -> Option<u64> {
    match v {
        Value::Map(m) => {
            for (k, val) in m {
                if let Value::Text(s) = k {
                    if s == "len" {
                        if let Value::Integer(i) = val {
                            if *i >= 0 {
                                return Some(*i as u64);
                            }
                        } else if let Value::Float(f) = val {
                            if *f >= 0.0 {
                                return Some(*f as u64);
                            }
                        }
                    }
                }
            }
            None
        }
        _ => None,
    }
}

```

### crates/ron-auth/src/zk/mod.rs
<a id="crates-ron-auth-src-zk-mod-rs"></a>

```rust
// zk::mod placeholder (feature-gated)
```

### crates/ron-auth/testing/vectors/ron-auth/v1/allow_example.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-allowexample-json"></a>

```json
{ "placeholder": "allow_example" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/custom_ns_examples.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-customnsexamples-json"></a>

```json
{ "placeholder": "custom_ns_examples" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/deny_expired.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-denyexpired-json"></a>

```json
{ "placeholder": "deny_expired" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/deny_unknown_kid.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-denyunknownkid-json"></a>

```json
{ "placeholder": "deny_unknown_kid" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/pq_allow.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-pqallow-json"></a>

```json
{ "placeholder": "pq_allow" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/pq_deny_mismatch.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-pqdenymismatch-json"></a>

```json
{ "placeholder": "pq_deny_mismatch" }
```

### crates/ron-auth/tests/allow_deny_vectors.rs
<a id="crates-ron-auth-tests-allowdenyvectors-rs"></a>

```rust
// RO:WHAT   Minimal allow/deny sanity for ron-auth core.
// RO:WHY    Catch regressions fast: MAC path, bounds, caveats.
// RO:INVARIANTS BLAKE3 only; no I/O; deterministic CBOR+Base64URL.

use ron_auth::{
    sign_and_encode_b64url, verify_token, AuthError, CapabilityBuilder, Caveat, Decision,
    DenyReason, MacKey, MacKeyProvider, RequestCtx, Scope, VerifierConfig,
};
use serde_cbor::Value;
use std::net::IpAddr;
use std::str::FromStr;

#[derive(Clone)]
struct StaticKeys;
impl MacKeyProvider for StaticKeys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        // One fixed 32B key for (tid="test", kid="k1")
        if kid == "k1" && tid == "test" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn now() -> u64 {
    // Stable-ish test timestamp
    1_700_000_000
}

fn base_cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 64,
        clock_skew_secs: 60,
        soa_threshold: 8, // crossover for streaming vs SoA
    }
}

fn base_ctx() -> RequestCtx {
    RequestCtx {
        now_unix_s: now(),
        method: "GET".into(),
        path: "/index/items/42".into(),
        peer_ip: Some(IpAddr::from_str("127.0.0.1").unwrap()),
        object_addr: None,
        tenant: "test".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}

#[test]
fn allow_happy_path() {
    // Scope allows GET under /index/
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };

    // Build a capability with audience + path prefix + method + tenant + exp
    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::PathPrefix("/index/".into()))
        .caveat(Caveat::Method(vec!["GET".into()]))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::Exp(now() + 300))
        .build();

    // Sign + encode
    let tok = sign_and_encode_b64url(&cap, &StaticKeys).expect("sign");

    // Verify
    let decision = verify_token(&base_cfg(), &tok, &base_ctx(), &StaticKeys).expect("verify ok");
    match decision {
        Decision::Allow { scope } => {
            assert_eq!(scope.prefix.as_deref(), Some("/index/"));
        }
        _ => panic!("expected Allow"),
    }
}

#[test]
fn deny_method_not_allowed() {
    // Scope allows GET under /index/
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };

    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::PathPrefix("/index/".into()))
        .caveat(Caveat::Method(vec!["GET".into()]))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::Exp(now() + 300))
        .build();

    let tok = sign_and_encode_b64url(&cap, &StaticKeys).expect("sign");

    // Change method in context to POST to trigger deny
    let mut ctx = base_ctx();
    ctx.method = "POST".into();

    let decision = verify_token(&base_cfg(), &tok, &ctx, &StaticKeys).expect("verify ok");
    match decision {
        Decision::Deny { reasons } => {
            assert!(reasons.contains(&DenyReason::MethodNotAllowed));
        }
        _ => panic!("expected Deny"),
    }
}

#[test]
fn error_mac_mismatch() {
    // Tamper with token bytes after signing to ensure MAC mismatch is caught.
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Exp(now() + 60))
        .build();
    let tok = sign_and_encode_b64url(&cap, &StaticKeys).expect("sign");

    // Flip one character safely within base64url alphabet
    let mut chars: Vec<u8> = tok.as_bytes().to_vec();
    // Find a position that is not '-' or '_' and flip it.
    let pos = chars
        .iter()
        .position(|&c| c != b'-' && c != b'_')
        .unwrap_or(0);
    chars[pos] = if chars[pos] != b'A' { b'A' } else { b'B' };
    let tampered = String::from_utf8(chars).unwrap();

    let err = verify_token(&base_cfg(), &tampered, &base_ctx(), &StaticKeys).unwrap_err();
    match err {
        AuthError::Malformed(_) | AuthError::MacMismatch => {} // either decode fails or MAC fails
        other => panic!("unexpected error: {:?}", other),
    }
}

#[test]
fn error_expired() {
    // Exp in the past triggers AuthError::Expired (hard error).
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Exp(now() - 3600))
        .build();
    let tok = sign_and_encode_b64url(&cap, &StaticKeys).expect("sign");

    let err = verify_token(&base_cfg(), &tok, &base_ctx(), &StaticKeys).unwrap_err();
    assert!(matches!(err, AuthError::Expired));
}

```

### crates/ron-auth/tests/amnesia_mode.rs
<a id="crates-ron-auth-tests-amnesiamode-rs"></a>

```rust
// test: amnesia mode placeholder

```

### crates/ron-auth/tests/attenuation_monotonicity.rs
<a id="crates-ron-auth-tests-attenuationmonotonicity-rs"></a>

```rust
//! Property: Adding extra caveats never *widens* access.
//! We approximate by holding scope fixed and adding either Exp tightening or PathPrefix tightening.
use proptest::prelude::*;
use ron_auth::{
    verify_token, CapabilityBuilder, Caveat, Decision, MacKey, MacKeyProvider, RequestCtx, Scope,
    VerifierConfig,
};
use serde_cbor::Value;

#[derive(Clone)]
struct Keys;
impl MacKeyProvider for Keys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        if kid == "k1" && tid == "tenant-a" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn ctx(now: u64, path: &str) -> RequestCtx {
    RequestCtx {
        now_unix_s: now,
        method: "GET".into(),
        path: path.into(),
        peer_ip: None,
        object_addr: None,
        tenant: "tenant-a".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}
fn cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 128,
        clock_skew_secs: 60,
        soa_threshold: 8,
    }
}

proptest! {
    #[test]
    fn adding_stricter_caveats_does_not_turn_deny_into_allow(
        now in 1_699_999_500u64..=1_700_000_500u64,
        suffix in "[a-z]{0,8}"
    ) {
        let scope = Scope { prefix: Some("/index/".into()), methods: vec!["GET".into()], max_bytes: None };

        // Parent: exp near future; GET /index/*
        let parent = CapabilityBuilder::new(scope.clone(), "tenant-a", "k1")
            .caveat(Caveat::Aud("aud-demo".into()))
            .caveat(Caveat::Tenant("tenant-a".into()))
            .caveat(Caveat::Method(vec!["GET".into()]))
            .caveat(Caveat::PathPrefix("/index/".into()))
            .caveat(Caveat::Exp(now + 300))
            .build();
        let parent_b64 = ron_auth::sign_and_encode_b64url(&parent, &Keys).unwrap();

        // Child: add tighter expiry and tighter path
        let child = CapabilityBuilder::new(scope, "tenant-a", "k1")
            .caveat(Caveat::Aud("aud-demo".into()))
            .caveat(Caveat::Tenant("tenant-a".into()))
            .caveat(Caveat::Method(vec!["GET".into()]))
            .caveat(Caveat::PathPrefix(format!("/index/{suffix}")))
            .caveat(Caveat::Exp(now + 60))
            .build();
        let child_b64 = ron_auth::sign_and_encode_b64url(&child, &Keys).unwrap();

        // Pick a path potentially inside or outside child prefix.
        let path = format!("/index/{suffix}/item");
        let parent_dec = verify_token(&cfg(), &parent_b64, &ctx(now, &path), &Keys).unwrap();
        let child_dec = verify_token(&cfg(), &child_b64, &ctx(now, &path), &Keys).unwrap();

        // If parent denied, child must NOT become Allow.
        if matches!(parent_dec, Decision::Deny { .. }) {
            assert!(matches!(child_dec, Decision::Deny { .. }));
        }
    }
}

```

### crates/ron-auth/tests/compat_public_api.rs
<a id="crates-ron-auth-tests-compatpublicapi-rs"></a>

```rust
// test: public API stability placeholder

```

### crates/ron-auth/tests/ip_cidr.rs
<a id="crates-ron-auth-tests-ipcidr-rs"></a>

```rust
// RO:WHAT   IpCidr caveat sanity (allow/deny).
// RO:WHY    Lock CIDR parsing and membership semantics.
// RO:INVARIANTS Pure; BLAKE3; deterministic; no I/O.

use ron_auth::{
    sign_and_encode_b64url, verify_token, CapabilityBuilder, Caveat, Decision, DenyReason, MacKey,
    MacKeyProvider, RequestCtx, Scope, VerifierConfig,
};
use serde_cbor::Value;
use std::net::IpAddr;
use std::str::FromStr;

#[derive(Clone)]
struct StaticKeys;
impl MacKeyProvider for StaticKeys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        if kid == "k1" && tid == "test" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn now() -> u64 {
    1_700_000_000
}

fn cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 64,
        clock_skew_secs: 60,
        soa_threshold: 8, // crossover for streaming vs SoA
    }
}

fn ctx_with_ip(ip: &str) -> RequestCtx {
    RequestCtx {
        now_unix_s: now(),
        method: "GET".into(),
        path: "/".into(),
        peer_ip: Some(IpAddr::from_str(ip).unwrap()),
        object_addr: None,
        tenant: "test".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}

#[test]
fn ip_cidr_allow_ipv4() {
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::IpCidr("192.168.1.0/24".into()))
        .caveat(Caveat::Exp(now() + 60))
        .build();
    let tok = sign_and_encode_b64url(&cap, &StaticKeys).unwrap();

    let dec = verify_token(&cfg(), &tok, &ctx_with_ip("192.168.1.42"), &StaticKeys).unwrap();
    assert!(matches!(dec, Decision::Allow { .. }));
}

#[test]
fn ip_cidr_deny_outside() {
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::IpCidr("10.0.0.0/8".into()))
        .caveat(Caveat::Exp(now() + 60))
        .build();
    let tok = sign_and_encode_b64url(&cap, &StaticKeys).unwrap();

    let dec = verify_token(&cfg(), &tok, &ctx_with_ip("192.168.1.42"), &StaticKeys).unwrap();
    match dec {
        Decision::Deny { reasons } => assert!(reasons.contains(&DenyReason::IpNotAllowed)),
        _ => panic!("expected Deny"),
    }
}

#[test]
fn ip_cidr_deny_malformed() {
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::IpCidr("not-a-cidr".into()))
        .caveat(Caveat::Exp(now() + 60))
        .build();
    let tok = sign_and_encode_b64url(&cap, &StaticKeys).unwrap();

    let dec = verify_token(&cfg(), &tok, &ctx_with_ip("127.0.0.1"), &StaticKeys).unwrap();
    match dec {
        Decision::Deny { reasons } => assert!(reasons.contains(&DenyReason::IpNotAllowed)),
        _ => panic!("expected Deny"),
    }
}

```

### crates/ron-auth/tests/loom_verify.rs
<a id="crates-ron-auth-tests-loomverify-rs"></a>

```rust
// test: loom concurrency model placeholder

```

### crates/ron-auth/tests/parser_fixtures.rs
<a id="crates-ron-auth-tests-parserfixtures-rs"></a>

```rust
// test: parser fixtures placeholder

```

### crates/ron-auth/tests/verify_batch_order.rs
<a id="crates-ron-auth-tests-verifybatchorder-rs"></a>

```rust
// RO:WHAT   Batch verify order preservation on mixed good/bad tokens.
// RO:WHY    Ensure verify_many returns decisions in input order.
// RO:INVARIANTS No I/O; deterministic; avoid hard errors (Malformed/UnknownKid) in this test.

use ron_auth::{
    sign_and_encode_b64url, verify_many, CapabilityBuilder, Caveat, Decision, MacKey,
    MacKeyProvider, RequestCtx, Scope, VerifierConfig,
};
use serde_cbor::Value;
use std::net::IpAddr;
use std::str::FromStr;

#[derive(Clone)]
struct StaticKeys;
impl MacKeyProvider for StaticKeys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        // Known good pair for tests
        if kid == "k1" && tid == "test" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn now() -> u64 {
    1_700_000_000
}

fn cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 64,
        clock_skew_secs: 60,
        soa_threshold: 8,
    }
}

fn ctx() -> RequestCtx {
    RequestCtx {
        now_unix_s: now(),
        method: "GET".into(),
        path: "/index/items/42".into(),
        peer_ip: Some(IpAddr::from_str("127.0.0.1").unwrap()),
        object_addr: None,
        tenant: "test".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}

fn tok_allow() -> String {
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::PathPrefix("/index/".into()))
        .caveat(Caveat::Method(vec!["GET".into()]))
        .caveat(Caveat::Exp(now() + 300))
        .build();
    sign_and_encode_b64url(&cap, &StaticKeys).unwrap()
}

// Valid token that will evaluate to Deny (path/method mismatch) — NOT malformed, NOT unknown kid.
fn tok_deny() -> String {
    let scope = Scope {
        prefix: Some("/admin/".into()),
        methods: vec!["POST".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::PathPrefix("/admin/".into()))
        .caveat(Caveat::Method(vec!["POST".into()]))
        .caveat(Caveat::Exp(now() + 300))
        .build();
    sign_and_encode_b64url(&cap, &StaticKeys).unwrap()
}

#[test]
fn order_preserved_mixed() {
    // Mixed batch: Allow, Deny(valid), Allow, Allow
    let batch = vec![tok_allow(), tok_deny(), tok_allow(), tok_allow()];

    let decisions = verify_many(&cfg(), &batch, &ctx(), &StaticKeys).unwrap();
    assert_eq!(decisions.len(), 4);

    assert!(matches!(decisions[0], Decision::Allow { .. }));
    assert!(matches!(decisions[1], Decision::Deny { .. }));
    assert!(matches!(decisions[2], Decision::Allow { .. }));
    assert!(matches!(decisions[3], Decision::Allow { .. }));
}

```

### crates/ron-auth/tests/verify_error_path.rs
<a id="crates-ron-auth-tests-verifyerrorpath-rs"></a>

```rust
//! Error-path sanity: UnknownKid, Expired, Malformed (tuple variant), and basic shape.
use ron_auth::{
    verify_token, AuthError, CapabilityBuilder, MacKey, MacKeyProvider, RequestCtx, Scope,
    VerifierConfig,
};
use serde_cbor::Value;

#[derive(Clone)]
struct KeysOk;
impl MacKeyProvider for KeysOk {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        if kid == "k1" && tid == "tenant-a" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

#[derive(Clone)]
struct KeysEmpty;
impl MacKeyProvider for KeysEmpty {
    fn key_for(&self, _kid: &str, _tid: &str) -> Option<MacKey> {
        None
    }
}

fn base_ctx() -> RequestCtx {
    RequestCtx {
        now_unix_s: 1_700_000_000,
        method: "GET".into(),
        path: "/index/abc".into(),
        peer_ip: None,
        object_addr: None,
        tenant: "tenant-a".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}

fn cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 128,
        clock_skew_secs: 60,
        soa_threshold: 8,
    }
}

fn signed_ok() -> String {
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "tenant-a", "k1")
        .caveat(ron_auth::Caveat::Aud("aud-demo".into()))
        .caveat(ron_auth::Caveat::Tenant("tenant-a".into()))
        .caveat(ron_auth::Caveat::PathPrefix("/index/".into()))
        .caveat(ron_auth::Caveat::Method(vec!["GET".into()]))
        .caveat(ron_auth::Caveat::Exp(base_ctx().now_unix_s + 60))
        .build();
    ron_auth::sign_and_encode_b64url(&cap, &KeysOk).unwrap()
}

#[test]
fn unknown_kid() {
    let tok = signed_ok();
    let err = verify_token(&cfg(), &tok, &base_ctx(), &KeysEmpty).unwrap_err();
    // tuple variant carries a &'static str
    assert!(matches!(err, AuthError::UnknownKid));
}

#[test]
fn expired() {
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "tenant-a", "k1")
        .caveat(ron_auth::Caveat::Aud("aud-demo".into()))
        .caveat(ron_auth::Caveat::Tenant("tenant-a".into()))
        .caveat(ron_auth::Caveat::Exp(base_ctx().now_unix_s - 61))
        .build();
    let tok = ron_auth::sign_and_encode_b64url(&cap, &KeysOk).unwrap();
    let err = verify_token(&cfg(), &tok, &base_ctx(), &KeysOk).unwrap_err();
    assert!(matches!(err, AuthError::Expired));
}

#[test]
fn malformed_base64() {
    let bad = "!!!this-is-not-base64url!!!";
    let err = verify_token(&cfg(), bad, &base_ctx(), &KeysOk).unwrap_err();
    // tuple variant requires payload pattern
    assert!(matches!(err, AuthError::Malformed(_)));
}

```

### crates/ron-auth/tests/verify_happy_path.rs
<a id="crates-ron-auth-tests-verifyhappypath-rs"></a>

```rust
//! Happy-path verification: small token that should ALLOW.
use ron_auth::{
    verify_token, CapabilityBuilder, Caveat, Decision, MacKey, MacKeyProvider, RequestCtx, Scope,
    VerifierConfig,
};
use serde_cbor::Value;

#[derive(Clone)]
struct StaticKeys;
impl MacKeyProvider for StaticKeys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        if kid == "k1" && tid == "tenant-a" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn ctx() -> RequestCtx {
    RequestCtx {
        now_unix_s: 1_700_000_000,
        method: "GET".into(),
        path: "/index/abc".into(),
        peer_ip: None,
        object_addr: None,
        tenant: "tenant-a".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}

fn cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 128,
        clock_skew_secs: 60,
        // keep your hybrid crossover knob (as in benches)
        soa_threshold: 8,
    }
}

#[test]
fn allow_small_token() {
    // Build a minimal “allow GET /index/*” token for tenant-a, kid k1
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let cap = CapabilityBuilder::new(scope, "tenant-a", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::Tenant("tenant-a".into()))
        .caveat(Caveat::PathPrefix("/index/".into()))
        .caveat(Caveat::Method(vec!["GET".into()]))
        .caveat(Caveat::Exp(ctx().now_unix_s + 600))
        .build();

    // Use the same signing helper your benches use.
    let token_b64 = ron_auth::sign_and_encode_b64url(&cap, &StaticKeys).expect("sign");

    let d = verify_token(&cfg(), &token_b64, &ctx(), &StaticKeys).expect("verify");
    match d {
        Decision::Allow { scope } => {
            assert_eq!(scope.prefix.as_deref(), Some("/index/"));
            assert!(scope.methods.iter().any(|m| m == "GET"));
        }
        _ => panic!("expected Allow, got {d:?}"),
    }
}

```

