<!-- Generated by scripts/make_crate_codex.sh on 2025-11-09T01:45:55Z -->
# Code Bundle — `ron-auth`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-auth/.github/workflows/ci.yml](#crates-ron-auth--github-workflows-ci-yml)
- [crates/ron-auth/.github/workflows/pq-matrix.yml](#crates-ron-auth--github-workflows-pq-matrix-yml)
- [crates/ron-auth/Cargo.toml](#crates-ron-auth-Cargo-toml)
- [crates/ron-auth/benches/verify_bench.rs](#crates-ron-auth-benches-verifybench-rs)
- [crates/ron-auth/deny.toml](#crates-ron-auth-deny-toml)
- [crates/ron-auth/fuzz/fuzz_targets/token_parser_fuzz.rs](#crates-ron-auth-fuzz-fuzztargets-tokenparserfuzz-rs)
- [crates/ron-auth/rustfmt.toml](#crates-ron-auth-rustfmt-toml)
- [crates/ron-auth/src/bounds.rs](#crates-ron-auth-src-bounds-rs)
- [crates/ron-auth/src/builder.rs](#crates-ron-auth-src-builder-rs)
- [crates/ron-auth/src/capability/caveat.rs](#crates-ron-auth-src-capability-caveat-rs)
- [crates/ron-auth/src/capability/encode.rs](#crates-ron-auth-src-capability-encode-rs)
- [crates/ron-auth/src/capability/mod.rs](#crates-ron-auth-src-capability-mod-rs)
- [crates/ron-auth/src/capability/scope.rs](#crates-ron-auth-src-capability-scope-rs)
- [crates/ron-auth/src/caveats/builtin.rs](#crates-ron-auth-src-caveats-builtin-rs)
- [crates/ron-auth/src/caveats/custom.rs](#crates-ron-auth-src-caveats-custom-rs)
- [crates/ron-auth/src/caveats/mod.rs](#crates-ron-auth-src-caveats-mod-rs)
- [crates/ron-auth/src/caveats/registry.rs](#crates-ron-auth-src-caveats-registry-rs)
- [crates/ron-auth/src/cbor.rs](#crates-ron-auth-src-cbor-rs)
- [crates/ron-auth/src/config/env.rs](#crates-ron-auth-src-config-env-rs)
- [crates/ron-auth/src/config/mod.rs](#crates-ron-auth-src-config-mod-rs)
- [crates/ron-auth/src/config/verifier_config.rs](#crates-ron-auth-src-config-verifierconfig-rs)
- [crates/ron-auth/src/ctx.rs](#crates-ron-auth-src-ctx-rs)
- [crates/ron-auth/src/errors.rs](#crates-ron-auth-src-errors-rs)
- [crates/ron-auth/src/keys/mac_handle.rs](#crates-ron-auth-src-keys-machandle-rs)
- [crates/ron-auth/src/keys/mod.rs](#crates-ron-auth-src-keys-mod-rs)
- [crates/ron-auth/src/keys/traits.rs](#crates-ron-auth-src-keys-traits-rs)
- [crates/ron-auth/src/lib.rs](#crates-ron-auth-src-lib-rs)
- [crates/ron-auth/src/mac.rs](#crates-ron-auth-src-mac-rs)
- [crates/ron-auth/src/metrics.rs](#crates-ron-auth-src-metrics-rs)
- [crates/ron-auth/src/pq/mod.rs](#crates-ron-auth-src-pq-mod-rs)
- [crates/ron-auth/src/pq/sig_adapter.rs](#crates-ron-auth-src-pq-sigadapter-rs)
- [crates/ron-auth/src/prelude.rs](#crates-ron-auth-src-prelude-rs)
- [crates/ron-auth/src/redact.rs](#crates-ron-auth-src-redact-rs)
- [crates/ron-auth/src/types.rs](#crates-ron-auth-src-types-rs)
- [crates/ron-auth/src/verify/checks.rs](#crates-ron-auth-src-verify-checks-rs)
- [crates/ron-auth/src/verify/decision.rs](#crates-ron-auth-src-verify-decision-rs)
- [crates/ron-auth/src/verify/error.rs](#crates-ron-auth-src-verify-error-rs)
- [crates/ron-auth/src/verify/eval.rs](#crates-ron-auth-src-verify-eval-rs)
- [crates/ron-auth/src/verify/mod.rs](#crates-ron-auth-src-verify-mod-rs)
- [crates/ron-auth/src/verify/parse.rs](#crates-ron-auth-src-verify-parse-rs)
- [crates/ron-auth/src/verify/pipeline.rs](#crates-ron-auth-src-verify-pipeline-rs)
- [crates/ron-auth/src/verify/soa.rs](#crates-ron-auth-src-verify-soa-rs)
- [crates/ron-auth/src/verify/soa_eval.rs](#crates-ron-auth-src-verify-soaeval-rs)
- [crates/ron-auth/src/verify/streaming.rs](#crates-ron-auth-src-verify-streaming-rs)
- [crates/ron-auth/src/zk/mod.rs](#crates-ron-auth-src-zk-mod-rs)
- [crates/ron-auth/testing/vectors/ron-auth/v1/allow_example.json](#crates-ron-auth-testing-vectors-ron-auth-v1-allowexample-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/custom_ns_examples.json](#crates-ron-auth-testing-vectors-ron-auth-v1-customnsexamples-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/deny_expired.json](#crates-ron-auth-testing-vectors-ron-auth-v1-denyexpired-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/deny_unknown_kid.json](#crates-ron-auth-testing-vectors-ron-auth-v1-denyunknownkid-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/pq_allow.json](#crates-ron-auth-testing-vectors-ron-auth-v1-pqallow-json)
- [crates/ron-auth/testing/vectors/ron-auth/v1/pq_deny_mismatch.json](#crates-ron-auth-testing-vectors-ron-auth-v1-pqdenymismatch-json)
- [crates/ron-auth/tests/allow_deny_vectors.rs](#crates-ron-auth-tests-allowdenyvectors-rs)
- [crates/ron-auth/tests/amnesia_mode.rs](#crates-ron-auth-tests-amnesiamode-rs)
- [crates/ron-auth/tests/attenuation_monotonicity.rs](#crates-ron-auth-tests-attenuationmonotonicity-rs)
- [crates/ron-auth/tests/compat_public_api.rs](#crates-ron-auth-tests-compatpublicapi-rs)
- [crates/ron-auth/tests/ip_cidr.rs](#crates-ron-auth-tests-ipcidr-rs)
- [crates/ron-auth/tests/loom_verify.rs](#crates-ron-auth-tests-loomverify-rs)
- [crates/ron-auth/tests/parser_fixtures.rs](#crates-ron-auth-tests-parserfixtures-rs)

### crates/ron-auth/.github/workflows/ci.yml
<a id="crates-ron-auth--github-workflows-ci-yml"></a>

```yaml
name: CI (ron-auth2)

on:
  push:
    paths:
      - "crates/ron-auth2/**"
  pull_request:
    paths:
      - "crates/ron-auth2/**"

jobs:
  build-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: crates/ron-auth2
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
      - run: cargo fmt --all -- --check
      - run: cargo clippy --all-targets -- -D warnings
      - run: cargo build --features ""
      - run: cargo test --features ""
      - run: echo "placeholder: cargo-deny/public-api checks wired later"
```

### crates/ron-auth/.github/workflows/pq-matrix.yml
<a id="crates-ron-auth--github-workflows-pq-matrix-yml"></a>

```yaml
name: PQ Matrix (ron-auth2)

on:
  push:
    paths:
      - "crates/ron-auth2/**"
  pull_request:
    paths:
      - "crates/ron-auth2/**"

jobs:
  matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        features: ["", "pq", "pq-hybrid", "pq-only"]
    defaults:
      run:
        working-directory: crates/ron-auth2
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
      - run: cargo build --features "${{ matrix.features }}"
      - run: cargo test --features "${{ matrix.features }}"
```

### crates/ron-auth/Cargo.toml
<a id="crates-ron-auth-Cargo-toml"></a>

```toml
[package]
name = "ron-auth"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Capability-based auth for RON-CORE"
readme = "README.md"
repository = "https://github.com/your-org/rusty-onions"
keywords = ["auth", "capability", "macaroon"]
categories = ["authentication", "cryptography"]

[features]
# Keep defaults minimal. Turn knobs on in benches or services.
default = ["std"]
std = []

# Perf toggles
bench-eval-modes = []
simd-b64 = ["base64-simd"]
fast-cbor = ["ciborium"]
parallel = ["rayon"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_bytes = "0.11"
serde_cbor = "0.11"
ciborium = { version = "0.2", optional = true }
base64 = "0.22"
smallvec = "1.15"
blake3 = "1.5"
ipnet = "2.11"
thiserror = "1.0"
subtle = "2.6"

# Feature-gated perf deps
base64-simd = { version = "0.8", optional = true }
rayon = { version = "1.11", optional = true }

[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }
proptest = "1.4"
loom = "0.7"

# Tell Cargo this bench uses Criterion (not the default test harness)
[[bench]]
name = "verify_bench"
harness = false

```

### crates/ron-auth/benches/verify_bench.rs
<a id="crates-ron-auth-benches-verifybench-rs"></a>

```rust
// RO:WHAT   Criterion microbench for verify_token / verify_many (small + heavy tokens).
// RO:WHY    Show hybrid crossover; optionally compare streaming-only vs SoA-only.
// RO:INVARIANTS Pure; BLAKE3; deterministic; no I/O.

use criterion::{black_box, criterion_group, criterion_main, BatchSize, Criterion};
#[cfg(feature = "bench-eval-modes")]
use ron_auth::verify::{
    verify_many_soa_only, verify_many_streaming_only, verify_token_soa_only,
    verify_token_streaming_only,
};
use ron_auth::{
    sign_and_encode_b64url, verify_many, verify_token, CapabilityBuilder, Caveat, MacKey,
    MacKeyProvider, RequestCtx, Scope, VerifierConfig,
};
use serde_cbor::Value;
use std::net::IpAddr;
use std::str::FromStr;

#[derive(Clone)]
struct StaticKeys;
impl MacKeyProvider for StaticKeys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        if kid == "k1" && tid == "test" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn now() -> u64 {
    1_700_000_000
}
fn make_cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 128,
        clock_skew_secs: 60,
        // NEW knob in Perf Pack A (exported by ron-auth); keep default crossover.
        soa_threshold: 8,
    }
}

fn base_ctx() -> RequestCtx {
    // Method uppercased once; matches verifier’s fast path.
    RequestCtx {
        now_unix_s: now(),
        method: "GET".into(),
        path: "/index/1".into(),
        peer_ip: Some(IpAddr::from_str("127.0.0.1").unwrap()),
        object_addr: None,
        tenant: "test".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}

fn make_token_small(keys: &impl MacKeyProvider) -> String {
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let mut cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::PathPrefix("/index/".into()))
        .caveat(Caveat::Method(vec!["GET".into()]))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::Exp(now() + 600))
        .build();
    sign_and_encode_b64url(&mut cap, keys).unwrap()
}

// Heavier capability: multi-methods, prefixes, CIDRs, and bounds (~24–32 caveats).
fn make_token_heavy(keys: &impl MacKeyProvider) -> String {
    let methods = vec![
        "GET", "HEAD", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "TRACE", "CONNECT", "PROPFIND",
        "SEARCH", "COPY",
    ]
    .into_iter()
    .map(|s| s.to_string())
    .collect::<Vec<_>>();

    let scope = Scope {
        prefix: Some("/api/v1/tenant/test/objects/".into()),
        methods: methods.clone(),
        max_bytes: None,
    };

    let mut builder = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::Exp(now() + 600))
        .caveat(Caveat::PathPrefix("/api/".into()))
        .caveat(Caveat::PathPrefix("/api/v1/".into()))
        .caveat(Caveat::PathPrefix("/api/v1/tenant/".into()))
        .caveat(Caveat::PathPrefix("/api/v1/tenant/test/".into()))
        .caveat(Caveat::Method(methods))
        .caveat(Caveat::IpCidr("127.0.0.0/8".into()))
        .caveat(Caveat::IpCidr("10.0.0.0/8".into()))
        .caveat(Caveat::IpCidr("192.168.0.0/16".into()))
        .caveat(Caveat::IpCidr("172.16.0.0/12".into()))
        .caveat(Caveat::BytesLe(1_048_576))
        .caveat(Caveat::Amnesia(false));

    // pad to ~30 caveats with no-op customs (ignored by evaluator)
    for i in 0..6 {
        builder = builder.caveat(Caveat::Custom {
            name: format!("x{}", i),
            ns: "demo".into(),
            cbor: Value::Null,
        });
    }

    let mut cap = builder.build();
    sign_and_encode_b64url(&mut cap, keys).unwrap()
}

fn benches_small(c: &mut Criterion) {
    let keys = StaticKeys;
    let token = make_token_small(&keys);
    let cfg_single = make_cfg();
    let ctx_single = base_ctx();

    c.bench_function("verify_single", |b| {
        b.iter(|| {
            let d = verify_token(&cfg_single, black_box(&token), &ctx_single, &keys).unwrap();
            black_box(d);
        })
    });

    c.bench_function("verify_batch_64_loop", |b| {
        b.iter_batched(
            || {
                let v: Vec<String> = std::iter::repeat(token.clone()).take(64).collect();
                (v, base_ctx(), make_cfg(), keys.clone())
            },
            |(tokens, ctx, cfg, keys)| {
                for t in tokens.iter() {
                    let d = verify_token(&cfg, t, &ctx, &keys).unwrap();
                    black_box(d);
                }
            },
            BatchSize::SmallInput,
        )
    });

    c.bench_function("verify_many_64", |b| {
        b.iter_batched(
            || {
                let v: Vec<String> = std::iter::repeat(token.clone()).take(64).collect();
                (v, base_ctx(), make_cfg(), keys.clone())
            },
            |(tokens, ctx, cfg, keys)| {
                let decisions = verify_many(&cfg, &tokens, &ctx, &keys).unwrap();
                black_box(decisions);
            },
            BatchSize::SmallInput,
        )
    });
}

fn benches_heavy(c: &mut Criterion) {
    let keys = StaticKeys;
    let token = make_token_heavy(&keys);

    c.bench_function("verify_single_heavy", |b| {
        b.iter(|| {
            let d = verify_token(&make_cfg(), black_box(&token), &base_ctx(), &keys).unwrap();
            black_box(d);
        })
    });

    c.bench_function("verify_many_64_heavy", |b| {
        b.iter_batched(
            || {
                let v: Vec<String> = std::iter::repeat(token.clone()).take(64).collect();
                (v, base_ctx(), make_cfg(), keys.clone())
            },
            |(tokens, ctx, cfg, keys)| {
                let decisions = verify_many(&cfg, &tokens, &ctx, &keys).unwrap();
                black_box(decisions);
            },
            BatchSize::SmallInput,
        )
    });

    // Optional: hard-toggle comparisons (requires `--features bench-eval-modes`)
    #[cfg(feature = "bench-eval-modes")]
    {
        c.bench_function("verify_single_heavy_streaming_only", |b| {
            b.iter(|| {
                let d =
                    verify_token_streaming_only(&make_cfg(), black_box(&token), &base_ctx(), &keys)
                        .unwrap();
                black_box(d);
            })
        });

        c.bench_function("verify_single_heavy_soa_only", |b| {
            b.iter(|| {
                let d = verify_token_soa_only(&make_cfg(), black_box(&token), &base_ctx(), &keys)
                    .unwrap();
                black_box(d);
            })
        });

        c.bench_function("verify_many_64_heavy_streaming_only", |b| {
            b.iter_batched(
                || {
                    let v: Vec<String> = std::iter::repeat(token.clone()).take(64).collect();
                    (v, base_ctx(), make_cfg(), keys.clone())
                },
                |(tokens, ctx, cfg, keys)| {
                    let decisions = verify_many_streaming_only(&cfg, &tokens, &ctx, &keys).unwrap();
                    black_box(decisions);
                },
                BatchSize::SmallInput,
            )
        });

        c.bench_function("verify_many_64_heavy_soa_only", |b| {
            b.iter_batched(
                || {
                    let v: Vec<String> = std::iter::repeat(token.clone()).take(64).collect();
                    (v, base_ctx(), make_cfg(), keys.clone())
                },
                |(tokens, ctx, cfg, keys)| {
                    let decisions = verify_many_soa_only(&cfg, &tokens, &ctx, &keys).unwrap();
                    black_box(decisions);
                },
                BatchSize::SmallInput,
            )
        });
    }
}

criterion_group!(benches, benches_small, benches_heavy);
criterion_main!(benches);

```

### crates/ron-auth/deny.toml
<a id="crates-ron-auth-deny-toml"></a>

```toml
[advisories]
yanked = "deny"
ignore = []

[bans]
multiple-versions = "warn"
wildcards = "deny"
deny = [
  { name = "tokio" },
  { name = "hyper" },
  { name = "reqwest" },
]

[sources]
unknown-registry = "deny"
unknown-git = "deny"
allow-registry = ["https://github.com/rust-lang/crates.io-index"]

[licenses]
unlicensed = "deny"
allow = [
  "MIT",
  "Apache-2.0",
  "Unicode-3.0",
  "Unicode-DFS-2016",
  "CC0-1.0",
  "CDLA-Permissive-2.0",
  "OpenSSL"
]
```

### crates/ron-auth/fuzz/fuzz_targets/token_parser_fuzz.rs
<a id="crates-ron-auth-fuzz-fuzztargets-tokenparserfuzz-rs"></a>

```rust
// fuzz target: token parser placeholder
```

### crates/ron-auth/rustfmt.toml
<a id="crates-ron-auth-rustfmt-toml"></a>

```toml
max_width = 100
edition = "2021"
use_field_init_shorthand = true
newline_style = "Unix"
```

### crates/ron-auth/src/bounds.rs
<a id="crates-ron-auth-src-bounds-rs"></a>

```rust
//! RO:WHAT  Centralized bounds helpers.
//! RO:WHY   Enforce size/complexity limits consistently.

/// Rough upper bound for Base64URL (no padding) length for a given raw size.
pub fn max_b64url_chars_for(max_bytes: usize) -> usize {
    // ceiling((max_bytes * 4) / 3) without padding; use saturating math for safety.
    max_bytes.saturating_mul(4).div_ceil(3)
}

```

### crates/ron-auth/src/builder.rs
<a id="crates-ron-auth-src-builder-rs"></a>

```rust
//! RO:WHAT  Capability attenuation builder (pure); requires caller-provided signer.
//! RO:WHY   Build stricter children; never broaden scope.
//! RO:INVARIANTS No I/O; callers inject MacKeyProvider to sign.

use crate::types::MacKey;
use crate::{
    cbor::encode_b64url_cbor_capability,
    mac::compute_mac,
    types::{Capability, Caveat, MacKeyProvider, Scope},
};

#[derive(Debug, Clone)]
pub struct CapabilityBuilder {
    tid: String,
    kid: String,
    scope: Scope,
    caveats: Vec<Caveat>,
}

impl CapabilityBuilder {
    pub fn new(scope: Scope, tid: impl Into<String>, kid: impl Into<String>) -> Self {
        Self {
            tid: tid.into(),
            kid: kid.into(),
            scope,
            caveats: Vec::new(),
        }
    }

    pub fn caveat(mut self, c: Caveat) -> Self {
        self.caveats.push(c);
        self
    }

    pub fn build(self) -> Capability {
        // Unsigned until caller signs; mac is zeroed.
        Capability {
            tid: self.tid,
            kid: self.kid,
            scope: self.scope,
            caveats: self.caveats,
            mac: vec![0u8; 32],
        }
    }
}

/// Helper for hosts/tests to sign-and-encode using their key source.
/// Note: this is referenced primarily from integration tests and host crates.
#[allow(dead_code)]
pub fn sign_and_encode_b64url(
    cap: &mut Capability,
    keys: &impl MacKeyProvider,
) -> Result<String, &'static str> {
    let MacKey(k) = keys.key_for(&cap.kid, &cap.tid).ok_or("unknown kid")?;
    let tag = compute_mac(&MacKey(k), cap);
    cap.mac.clear();
    cap.mac.extend_from_slice(&tag);
    Ok(encode_b64url_cbor_capability(cap))
}

```

### crates/ron-auth/src/capability/caveat.rs
<a id="crates-ron-auth-src-capability-caveat-rs"></a>

```rust
// capability::caveat placeholder
```

### crates/ron-auth/src/capability/encode.rs
<a id="crates-ron-auth-src-capability-encode-rs"></a>

```rust
// capability::encode placeholder
```

### crates/ron-auth/src/capability/mod.rs
<a id="crates-ron-auth-src-capability-mod-rs"></a>

```rust
// capability::mod placeholder
```

### crates/ron-auth/src/capability/scope.rs
<a id="crates-ron-auth-src-capability-scope-rs"></a>

```rust
// capability::scope placeholder
```

### crates/ron-auth/src/caveats/builtin.rs
<a id="crates-ron-auth-src-caveats-builtin-rs"></a>

```rust
// caveats::builtin placeholder
```

### crates/ron-auth/src/caveats/custom.rs
<a id="crates-ron-auth-src-caveats-custom-rs"></a>

```rust
// caveats::custom placeholder
```

### crates/ron-auth/src/caveats/mod.rs
<a id="crates-ron-auth-src-caveats-mod-rs"></a>

```rust
// caveats::mod placeholder
```

### crates/ron-auth/src/caveats/registry.rs
<a id="crates-ron-auth-src-caveats-registry-rs"></a>

```rust
// caveats::registry placeholder
```

### crates/ron-auth/src/cbor.rs
<a id="crates-ron-auth-src-cbor-rs"></a>

```rust
//! RO:WHAT  CBOR (de)serialization + Base64URL helpers (no padding).
//! RO:WHY   Keep encoding deterministic; centralized parsing; low alloc.
//! RO:INVARIANTS Deterministic CBOR; URL_SAFE_NO_PAD; strict size checks; buffer reuse.

#![allow(clippy::needless_return)]

use crate::{bounds, errors::AuthError, types::Capability};
use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine;

#[cfg(feature = "fast-cbor")]
use ciborium::de::from_reader as cbor_from_reader;
#[cfg(not(feature = "fast-cbor"))]
use serde_cbor::from_slice as cbor_from_slice;

#[cfg(feature = "simd-b64")]
use base64_simd::URL_SAFE_NO_PAD as SIMD_URL_SAFE_NO_PAD;

/// Decode a Base64URL (no padding) CBOR-encoded Capability into `scratch` to minimize allocs.
pub fn decode_b64url_cbor_capability_with_buf(
    b64: &str,
    max_bytes: usize,
    scratch: &mut Vec<u8>,
) -> Result<Capability, AuthError> {
    // Bound the encoded length up front.
    if b64.len() > bounds::max_b64url_chars_for(max_bytes) {
        return Err(AuthError::Bounds);
    }

    // Decode Base64URL → bytes into `scratch`.
    #[cfg(feature = "simd-b64")]
    {
        // SIMD decode returns a fresh Vec; move it into `scratch` with no copy.
        let decoded = SIMD_URL_SAFE_NO_PAD
            .decode_to_vec(b64.as_bytes())
            .map_err(|_| AuthError::Malformed("base64url"))?;
        if decoded.len() > max_bytes {
            return Err(AuthError::Bounds);
        }
        *scratch = decoded;
    }

    #[cfg(not(feature = "simd-b64"))]
    {
        scratch.clear();
        URL_SAFE_NO_PAD
            .decode_vec(b64.as_bytes(), scratch)
            .map_err(|_| AuthError::Malformed("base64url"))?;
        if scratch.len() > max_bytes {
            return Err(AuthError::Bounds);
        }
    }

    // Decode CBOR → Capability (serde-compatible). `fast-cbor` is slightly leaner.
    #[cfg(feature = "fast-cbor")]
    let cap: Capability =
        cbor_from_reader(scratch.as_slice()).map_err(|_| AuthError::Malformed("cbor"))?;

    #[cfg(not(feature = "fast-cbor"))]
    let cap: Capability = cbor_from_slice(scratch).map_err(|_| AuthError::Malformed("cbor"))?;

    // Basic MAC sanity: 32 bytes BLAKE3 keyed.
    if cap.mac.len() != 32 {
        return Err(AuthError::Malformed("mac_len"));
    }
    Ok(cap)
}

/// Backwards-compatible wrapper (allocates) — prefer the `_with_buf` variant on hot paths.
#[allow(dead_code)]
pub fn decode_b64url_cbor_capability(b64: &str, max_bytes: usize) -> Result<Capability, AuthError> {
    let mut tmp = Vec::new();
    decode_b64url_cbor_capability_with_buf(b64, max_bytes, &mut tmp)
}

#[allow(dead_code)]
pub fn encode_b64url_cbor_capability(cap: &Capability) -> String {
    let bytes = serde_cbor::to_vec(cap).expect("capability to cbor");
    URL_SAFE_NO_PAD.encode(bytes)
}

/// Deterministic CBOR fragment encoder for MAC chaining (allocating version).
#[allow(dead_code)]
pub fn cbor_fragment<T: serde::Serialize>(t: &T) -> Vec<u8> {
    serde_cbor::to_vec(t).expect("cbor fragment")
}

/// Deterministic CBOR fragment encoder that writes into `buf` (reused across calls).
pub fn cbor_fragment_into<T: serde::Serialize>(t: &T, buf: &mut Vec<u8>) {
    buf.clear();
    // serde_cbor::to_writer keeps canonical ordering for our simple maps/seq usage.
    serde_cbor::to_writer(buf, t).expect("cbor fragment into buf");
}

```

### crates/ron-auth/src/config/env.rs
<a id="crates-ron-auth-src-config-env-rs"></a>

```rust
// config::env placeholder (feature: config-env)
```

### crates/ron-auth/src/config/mod.rs
<a id="crates-ron-auth-src-config-mod-rs"></a>

```rust
// config::mod placeholder
```

### crates/ron-auth/src/config/verifier_config.rs
<a id="crates-ron-auth-src-config-verifierconfig-rs"></a>

```rust
// config::verifier_config placeholder
```

### crates/ron-auth/src/ctx.rs
<a id="crates-ron-auth-src-ctx-rs"></a>

```rust
// ctx placeholder
```

### crates/ron-auth/src/errors.rs
<a id="crates-ron-auth-src-errors-rs"></a>

```rust
//! RO:WHAT  Public error/deny taxonomy (stable).
//! RO:WHY   Callers map to metrics and user-facing problem docs.
//! RO:INVARIANTS Codes/reasons are semver-stable.

use crate::prelude::*;

#[derive(Debug, thiserror::Error)]
pub enum AuthError {
    #[error("malformed token: {0}")]
    Malformed(&'static str),
    #[error("bounds exceeded")]
    Bounds,
    #[error("unknown kid")]
    UnknownKid,
    #[error("mac mismatch")]
    MacMismatch,
    #[error("expired")]
    Expired,
    #[error("not yet valid")]
    NotYetValid,
    #[error("policy deny")]
    PolicyDeny, // Decision::Deny will contain reasons; this is for strict-mode callers.
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "reason", content = "detail")]
pub enum DenyReason {
    // Time
    Expired,
    NotYetValid,
    // Shape
    BadAudience,
    MethodNotAllowed,
    PathNotAllowed,
    IpNotAllowed,
    TenantMismatch,
    BytesExceed,
    RateExceeded, // placeholder for future rate caveat eval
    Custom(String),
}

```

### crates/ron-auth/src/keys/mac_handle.rs
<a id="crates-ron-auth-src-keys-machandle-rs"></a>

```rust
// keys::mac_handle placeholder
```

### crates/ron-auth/src/keys/mod.rs
<a id="crates-ron-auth-src-keys-mod-rs"></a>

```rust
// keys::mod placeholder
```

### crates/ron-auth/src/keys/traits.rs
<a id="crates-ron-auth-src-keys-traits-rs"></a>

```rust
// keys::traits placeholder
```

### crates/ron-auth/src/lib.rs
<a id="crates-ron-auth-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]
//! RO:WHAT   ron-auth core — capability verification & attenuation (pure library).
//! RO:WHY    Deterministic, offline decisions; callers inject keys/clock/context.
//! RO:INTERACTS  KMS via MacKeyProvider; service crates call verify_token()/verify_many().
//! RO:INVARIANTS No network/disk I/O; BLAKE3 keyed MAC; CBOR canonical; URL-safe Base64 (no pad).

pub mod prelude;
pub mod verify;

mod bounds;
mod builder;
mod cbor;
mod errors;
mod mac;
mod types;

pub use builder::{sign_and_encode_b64url, CapabilityBuilder};
pub use errors::{AuthError, DenyReason};
pub use types::{
    Capability, Caveat, Decision, MacKey, MacKeyProvider, RequestCtx, Scope, VerifierConfig,
};

// Public entrypoints (forward to verify module).
pub fn verify_token(
    cfg: &VerifierConfig,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &impl MacKeyProvider,
) -> Result<Decision, AuthError> {
    crate::verify::verify_token(cfg, token_b64url, ctx, keys)
}

pub fn verify_many(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &impl MacKeyProvider,
) -> Result<Vec<Decision>, AuthError> {
    crate::verify::verify_many(cfg, tokens_b64url, ctx, keys)
}

/// Amortized batch into caller-provided buffer (no per-call Vec alloc).
pub fn verify_many_into(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &impl MacKeyProvider,
    out: &mut Vec<Decision>,
) -> Result<(), AuthError> {
    crate::verify::verify_many_into(cfg, tokens_b64url, ctx, keys, out)
}

```

### crates/ron-auth/src/mac.rs
<a id="crates-ron-auth-src-mac-rs"></a>

```rust
//! RO:WHAT  BLAKE3 keyed MAC chaining with domain separation (low-alloc path).
//! RO:WHY   Integrity over (tenant,kid,scope,caveats...) in strict order.
//! RO:INVARIANTS No SHA; constant-time compare; buffer reuse to cut allocs.

use crate::{
    cbor,
    types::{Capability, Caveat, MacKey, Scope},
};
use subtle::ConstantTimeEq;

const DOMAIN_SEP: &[u8] = b"RON-AUTHv1\0";

#[inline]
fn init_tag(key: &MacKey, tid: &str, kid: &str, scope: &Scope, buf: &mut Vec<u8>) -> [u8; 32] {
    // tag0 = BLAKE3(key, DOMAIN || CBOR{tid,kid,scope})
    buf.clear();
    buf.extend_from_slice(DOMAIN_SEP);
    cbor::cbor_fragment_into(&(tid, kid, scope), buf);
    *blake3::keyed_hash(&key.0, buf).as_bytes()
}

#[inline]
fn fold_caveats(
    key: &MacKey,
    mut tag: [u8; 32],
    caveats: &[Caveat],
    frag: &mut Vec<u8>,
    fold: &mut Vec<u8>,
) -> [u8; 32] {
    for c in caveats {
        // Serialize caveat into frag (reused)
        cbor::cbor_fragment_into(c, frag);

        // fold = tag || frag
        fold.clear();
        fold.extend_from_slice(&tag);
        fold.extend_from_slice(frag);

        tag = *blake3::keyed_hash(&key.0, fold).as_bytes();
    }
    tag
}

/// Compute MAC with minimal transient allocations by reusing small buffers.
#[inline]
pub fn compute_mac(key: &MacKey, cap: &Capability) -> [u8; 32] {
    let mut init_buf = Vec::with_capacity(128);
    let tag0 = init_tag(key, &cap.tid, &cap.kid, &cap.scope, &mut init_buf);

    let mut frag = Vec::with_capacity(128);
    let mut fold = Vec::with_capacity(160); // 32 + typical frag
    fold_caveats(key, tag0, &cap.caveats, &mut frag, &mut fold)
}

/// Constant-time MAC comparison (only if lengths match).
#[inline]
pub fn macs_equal(ct_a: &[u8], ct_b: &[u8]) -> bool {
    // Length mismatch ⇒ definitely not equal; we still avoid branching into a partial compare.
    if ct_a.len() != ct_b.len() {
        return false;
    }
    ct_a.ct_eq(ct_b).into()
}

```

### crates/ron-auth/src/metrics.rs
<a id="crates-ron-auth-src-metrics-rs"></a>

```rust
// metrics hook trait placeholder
```

### crates/ron-auth/src/pq/mod.rs
<a id="crates-ron-auth-src-pq-mod-rs"></a>

```rust
// pq::mod placeholder (feature-gated)
```

### crates/ron-auth/src/pq/sig_adapter.rs
<a id="crates-ron-auth-src-pq-sigadapter-rs"></a>

```rust
// pq::sig_adapter placeholder (feature-gated)
```

### crates/ron-auth/src/prelude.rs
<a id="crates-ron-auth-src-prelude-rs"></a>

```rust
//! RO:WHAT    Shared imports/types for crate-internal modules.
//! RO:WHY     Keep lib files concise and consistent (CODECOMMENTS.MD).
//! RO:INTERACTS  Used by most modules (types, errors, tools).
//! RO:INVARIANTS No I/O, no async, no SHA; BLAKE3 only.

pub use crate::errors::AuthError;
pub use serde::{Deserialize, Serialize};

```

### crates/ron-auth/src/redact.rs
<a id="crates-ron-auth-src-redact-rs"></a>

```rust
// redact helpers placeholder
```

### crates/ron-auth/src/types.rs
<a id="crates-ron-auth-src-types-rs"></a>

```rust
//! RO:WHAT  Public types: Capability, Scope, Caveat, Decision, VerifierConfig, RequestCtx.
//! RO:WHY   Stable, boring DTOs; serde/CBOR friendly; no alloc surprises.
//! RO:INVARIANTS Deterministic encoding; strict bounds; no I/O.

use crate::prelude::*;
use std::net::IpAddr;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Scope {
    /// Optional resource prefix (e.g., "/index/").
    pub prefix: Option<String>,
    /// Allowed HTTP-style methods (e.g., "GET","PUT").
    pub methods: Vec<String>,
    /// Max payload bytes permitted by this capability.
    pub max_bytes: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "t", content = "v")]
pub enum Caveat {
    Exp(u64),
    Nbf(u64),
    Aud(String),
    Method(Vec<String>),
    PathPrefix(String),
    IpCidr(String),
    BytesLe(u64),
    Rate {
        per_s: u32,
        burst: u32,
    },
    Tenant(String),
    Amnesia(bool),
    GovPolicyDigest(String),
    Custom {
        ns: String,
        name: String,
        cbor: serde_cbor::Value,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Capability {
    /// Tenant/domain namespace for multi-tenant safety.
    pub tid: String,
    /// Key identifier for MAC lookup.
    pub kid: String,
    pub scope: Scope,
    pub caveats: Vec<Caveat>,
    /// Final MAC (BLAKE3 keyed), 32 bytes.
    #[serde(with = "serde_bytes")]
    pub mac: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct VerifierConfig {
    /// Upper bound after Base64URL decode.
    pub max_token_bytes: usize,
    /// Max allowed caveats.
    pub max_caveats: usize,
    /// Clock skew in seconds for exp/nbf.
    pub clock_skew_secs: i64,
    /// Hybrid crossover: <= threshold → streaming; > threshold → SoA.
    pub soa_threshold: usize,
}

impl VerifierConfig {
    pub fn with_defaults() -> Self {
        Self {
            max_token_bytes: 4096,
            max_caveats: 64,
            clock_skew_secs: 60,
            // Your heavy fixtures (~30 caveats) consistently favor streaming; raise default.
            soa_threshold: 24,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct RequestCtx {
    pub now_unix_s: u64,
    pub method: String,
    pub path: String,
    pub peer_ip: Option<IpAddr>,
    pub object_addr: Option<String>,
    pub tenant: String,
    pub amnesia: bool,
    pub policy_digest_hex: Option<String>,
    pub extras: serde_cbor::Value,
}

/// Final decision.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum Decision {
    Allow {
        scope: Scope,
    },
    Deny {
        reasons: Vec<crate::errors::DenyReason>,
    },
}

/// Opaque MAC key (32 bytes for BLAKE3 keyed mode).
#[derive(Debug, Clone)]
pub struct MacKey(pub [u8; 32]);

/// Caller-provided keys (e.g., from ron-kms). No I/O here.
pub trait MacKeyProvider {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey>;
}

```

### crates/ron-auth/src/verify/checks.rs
<a id="crates-ron-auth-src-verify-checks-rs"></a>

```rust
//! RO:WHAT   Fast structural/limit checks executed before MAC work.
//! RO:WHY    Shed bad requests early; keep hot path predictable.
//! RO:INVARIANTS Pure; constant-time unrelated to secrets.

use crate::types::VerifierConfig;

#[allow(dead_code)]
#[inline]
pub fn check_size_cap(cfg: &VerifierConfig, token_len: usize) -> Result<(), &'static str> {
    if token_len > cfg.max_token_bytes {
        return Err("cap: token too large");
    }
    Ok(())
}

#[allow(dead_code)]
#[inline]
pub fn check_caveat_count(cfg: &VerifierConfig, count: usize) -> Result<(), &'static str> {
    if count > cfg.max_caveats {
        return Err("cap: too many caveats");
    }
    Ok(())
}

```

### crates/ron-auth/src/verify/decision.rs
<a id="crates-ron-auth-src-verify-decision-rs"></a>

```rust
// verify::decision placeholder

```

### crates/ron-auth/src/verify/error.rs
<a id="crates-ron-auth-src-verify-error-rs"></a>

```rust
// verify::error placeholder

```

### crates/ron-auth/src/verify/eval.rs
<a id="crates-ron-auth-src-verify-eval-rs"></a>

```rust
//! RO:WHAT  Streaming caveat evaluator with early short-circuit on Exp/Nbf.
//! RO:WHY   Fast path for small caveat sets; accumulates soft mismatches.

use crate::{
    errors::{AuthError, DenyReason},
    types::{Caveat, RequestCtx, VerifierConfig},
};
use ipnet::IpNet;
use serde_cbor::Value;
use std::str::FromStr;

#[inline]
pub fn eval_caveats_streaming(
    cfg: &VerifierConfig,
    ctx: &RequestCtx,
    caveats: &[Caveat],
    out: &mut Vec<DenyReason>,
) -> Result<(), AuthError> {
    let now = ctx.now_unix_s as i64;
    let mut need_len: Option<u64> = None;

    for c in caveats {
        match c {
            Caveat::Exp(v) => {
                if now > (*v as i64) + cfg.clock_skew_secs {
                    return Err(AuthError::Expired);
                }
            }
            Caveat::Nbf(v) => {
                if now + cfg.clock_skew_secs < *v as i64 {
                    return Err(AuthError::NotYetValid);
                }
            }
            Caveat::Aud(a) => {
                if ctx.policy_digest_hex.as_deref() != Some(a.as_str()) {
                    out.push(DenyReason::BadAudience);
                }
            }
            Caveat::Method(ms) => {
                if !ms.iter().any(|m| m.eq_ignore_ascii_case(&ctx.method)) {
                    out.push(DenyReason::MethodNotAllowed);
                }
            }
            Caveat::PathPrefix(pref) => {
                if !ctx.path.starts_with(pref) {
                    out.push(DenyReason::PathNotAllowed);
                }
            }
            Caveat::IpCidr(s) => match (&ctx.peer_ip, IpNet::from_str(s)) {
                (Some(ip), Ok(net)) if net.contains(ip) => {}
                _ => out.push(DenyReason::IpNotAllowed),
            },
            Caveat::BytesLe(max) => {
                if need_len.is_none() {
                    need_len = extract_len_from_extras(&ctx.extras);
                }
                if let Some(len) = need_len {
                    if len > *max {
                        out.push(DenyReason::BytesExceed);
                    }
                }
            }
            Caveat::Rate { .. } => {
                // informational placeholder
            }
            Caveat::Tenant(t) => {
                if t != &ctx.tenant {
                    out.push(DenyReason::TenantMismatch);
                }
            }
            Caveat::Amnesia(flag) => {
                if *flag != ctx.amnesia {
                    out.push(DenyReason::Custom("amnesia_mismatch".into()));
                }
            }
            Caveat::GovPolicyDigest(d) => {
                if ctx.policy_digest_hex.as_deref() != Some(d.as_str()) {
                    out.push(DenyReason::Custom("gov_policy_digest_mismatch".into()));
                }
            }
            Caveat::Custom { .. } => {
                // host-defined; no-op
            }
        }
    }
    Ok(())
}

#[inline]
pub fn extract_len_from_extras(v: &Value) -> Option<u64> {
    match v {
        Value::Map(m) => {
            for (k, val) in m {
                if let Value::Text(s) = k {
                    if s == "len" {
                        if let Value::Integer(i) = val {
                            if *i >= 0 {
                                return Some(*i as u64);
                            }
                        } else if let Value::Float(f) = val {
                            if *f >= 0.0 {
                                return Some(*f as u64);
                            }
                        }
                    }
                }
            }
            None
        }
        _ => None,
    }
}

```

### crates/ron-auth/src/verify/mod.rs
<a id="crates-ron-auth-src-verify-mod-rs"></a>

```rust
//! RO:WHAT    Verification module split into pipeline + evaluators.
//! RO:LAYOUT  pipeline (API) | streaming (small sets) | soa (columns) | soa_eval | parse tests.

pub mod parse; // tests/utilities (kept)
pub mod soa; // CaveatsSoA columnar representation
pub mod soa_eval;
pub mod streaming; // eval for small caveat sets (early short-circuit)

mod pipeline; // main API (private module)

pub use pipeline::{verify_many, verify_many_into, verify_token};

#[cfg(feature = "bench-eval-modes")]
pub use pipeline::{
    verify_many_soa_only, verify_many_streaming_only, verify_token_soa_only,
    verify_token_streaming_only,
};

```

### crates/ron-auth/src/verify/parse.rs
<a id="crates-ron-auth-src-verify-parse-rs"></a>

```rust
//! RO:WHAT   Token parsing helpers (base64url, CBOR).
//! RO:WHY    Keep low-level parsing separate from pipeline orchestration.
//! RO:INVARIANTS No I/O; deterministic; URL-safe base64 without padding.

use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine as _;
use serde::de::DeserializeOwned;

/// Decode URL-safe base64 (no padding) with a conservative early size cap.
/// `max_bytes` is the maximum allowed decoded length (post-base64).
#[allow(dead_code)]
#[inline]
pub fn b64url_decode(bytes_b64url: &str, max_bytes: usize) -> Result<Vec<u8>, &'static str> {
    // Early cap on input chars: ceil(max_bytes * 4 / 3)
    let max_in = max_bytes.saturating_mul(4).div_ceil(3);
    if bytes_b64url.len() > max_in {
        return Err("b64url: input too large");
    }
    URL_SAFE_NO_PAD
        .decode(bytes_b64url.as_bytes())
        .map_err(|_| "b64url: decode error")
}

/// Decode CBOR value from a slice using serde_cbor.
#[allow(dead_code)]
#[inline]
pub fn cbor_from_slice<T: DeserializeOwned>(buf: &[u8]) -> Result<T, &'static str> {
    serde_cbor::from_slice(buf).map_err(|_| "cbor: decode error")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn decode_roundtrip() {
        let payload = b"hello";
        let enc = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(payload);
        let out = b64url_decode(&enc, 1024).unwrap();
        assert_eq!(out, payload);
    }
}

```

### crates/ron-auth/src/verify/pipeline.rs
<a id="crates-ron-auth-src-verify-pipeline-rs"></a>

```rust
//! RO:WHAT  Token verification pipeline (pure, sync) with hybrid eval + optional parallel batch.
//! RO:WHY   Keep early short-circuit cost for common tiny tokens; SoA for larger sets;
//!          add feature-gated parallelism for big batches while preserving order.
//! RO:INVARS No I/O; strict bounds; constant-time MAC compare; BLAKE3 only.

use super::{soa::CaveatsSoA, soa_eval::eval_caveats_soa, streaming::eval_caveats_streaming};
use crate::cbor::decode_b64url_cbor_capability_with_buf;
use crate::errors::{AuthError, DenyReason};
use crate::mac::{compute_mac, macs_equal};
use crate::types::{Decision, MacKeyProvider, RequestCtx, VerifierConfig};
use core::mem;

#[cfg(feature = "parallel")]
use rayon::prelude::*;

/// Streaming/SoA crossover (kept local here; you already carry `soa_threshold` in cfg for future tuning).
const SOA_THRESHOLD: usize = 8;

/// Parallel shard kickoff threshold (avoid thread-pool overhead on small batches).
#[cfg(feature = "parallel")]
const PAR_MIN_BATCH: usize = 128;

/// Verify a single Base64URL token.
pub fn verify_token<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Decision, AuthError> {
    let mut scratch = Vec::with_capacity(1024);
    verify_one_with_buf(cfg, token_b64url, ctx, keys, &mut scratch)
}

/// Verify many Base64URL tokens with amortized buffer reuse; returns a Vec.
/// See `verify_many_into` to reuse the output buffer.
pub fn verify_many<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Vec<Decision>, AuthError> {
    let mut out = Vec::with_capacity(tokens_b64url.len());
    verify_many_into(cfg, tokens_b64url, ctx, keys, &mut out)?;
    Ok(out)
}

/// Same as `verify_many` but writes decisions into `out` (clears it first).
///
/// When built with `--features parallel` and the batch size is large enough,
/// this will shard across the Rayon pool while preserving output order.
/// Otherwise it falls back to the sequential pipeline.
pub fn verify_many_into<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
    out: &mut Vec<Decision>,
) -> Result<(), AuthError> {
    out.clear();
    out.reserve(tokens_b64url.len());

    // Fast-path: empty
    if tokens_b64url.is_empty() {
        return Ok(());
    }

    // Parallel order-preserving path (feature-gated + threshold)
    #[cfg(feature = "parallel")]
    {
        if tokens_b64url.len() >= PAR_MIN_BATCH {
            // Map each token to a Result<Decision, AuthError> in parallel.
            // `par_iter()` over a slice is an IndexedParallelIterator → collected Vec preserves order.
            let results: Vec<Result<Decision, AuthError>> = tokens_b64url
                .par_iter()
                .map(|tok| {
                    let mut scratch = Vec::with_capacity(1024);
                    verify_one_with_buf(cfg, tok, ctx, keys, &mut scratch)
                })
                .collect();

            // Propagate the first error (if any), otherwise extend `out` with the decisions.
            for r in results {
                match r {
                    Ok(d) => out.push(d),
                    Err(e) => return Err(e),
                }
            }
            return Ok(());
        }
    }

    // Sequential fallback (and default when `parallel` feature is off).
    let mut scratch = Vec::with_capacity(1024);
    let mut reasons: Vec<DenyReason> = Vec::new();

    for tok in tokens_b64url {
        let cap = decode_b64url_cbor_capability_with_buf(tok, cfg.max_token_bytes, &mut scratch)?;
        if cap.caveats.len() > cfg.max_caveats {
            return Err(AuthError::Bounds);
        }

        let key = keys
            .key_for(&cap.kid, &cap.tid)
            .ok_or(AuthError::UnknownKid)?;

        // MAC over original caveat order (domain fixed)
        let expect = compute_mac(&key, &cap);
        if !macs_equal(&expect, &cap.mac) {
            return Err(AuthError::MacMismatch);
        }

        reasons.clear();

        if cap.caveats.len() <= SOA_THRESHOLD {
            eval_caveats_streaming(cfg, ctx, &cap.caveats, &mut reasons)?;
        } else {
            eval_caveats_soa(cfg, ctx, CaveatsSoA::from_slice(&cap.caveats), &mut reasons)?;
        }

        if reasons.is_empty() {
            out.push(Decision::Allow { scope: cap.scope });
        } else {
            let taken = mem::take(&mut reasons);
            out.push(Decision::Deny { reasons: taken });
        }
    }

    Ok(())
}

fn verify_one_with_buf<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &K,
    scratch: &mut Vec<u8>,
) -> Result<Decision, AuthError> {
    let cap = decode_b64url_cbor_capability_with_buf(token_b64url, cfg.max_token_bytes, scratch)?;
    if cap.caveats.len() > cfg.max_caveats {
        return Err(AuthError::Bounds);
    }

    let key = keys
        .key_for(&cap.kid, &cap.tid)
        .ok_or(AuthError::UnknownKid)?;

    // MAC over original caveat order
    let expect = compute_mac(&key, &cap);
    if !macs_equal(&expect, &cap.mac) {
        return Err(AuthError::MacMismatch);
    }

    let mut reasons: Vec<DenyReason> = Vec::new();
    if cap.caveats.len() <= SOA_THRESHOLD {
        eval_caveats_streaming(cfg, ctx, &cap.caveats, &mut reasons)?;
    } else {
        eval_caveats_soa(cfg, ctx, CaveatsSoA::from_slice(&cap.caveats), &mut reasons)?;
    }

    if reasons.is_empty() {
        Ok(Decision::Allow { scope: cap.scope })
    } else {
        Ok(Decision::Deny { reasons })
    }
}

/* -------- Benchmark-only hard toggles (opt-in from benches) -------- */

#[allow(dead_code)]
pub fn verify_token_streaming_only<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Decision, AuthError> {
    let mut scratch = Vec::with_capacity(1024);
    let cap =
        decode_b64url_cbor_capability_with_buf(token_b64url, cfg.max_token_bytes, &mut scratch)?;
    if cap.caveats.len() > cfg.max_caveats {
        return Err(AuthError::Bounds);
    }
    let key = keys
        .key_for(&cap.kid, &cap.tid)
        .ok_or(AuthError::UnknownKid)?;
    let expect = compute_mac(&key, &cap);
    if !macs_equal(&expect, &cap.mac) {
        return Err(AuthError::MacMismatch);
    }
    let mut reasons = Vec::new();
    eval_caveats_streaming(cfg, ctx, &cap.caveats, &mut reasons)?;
    if reasons.is_empty() {
        Ok(Decision::Allow { scope: cap.scope })
    } else {
        Ok(Decision::Deny { reasons })
    }
}

#[allow(dead_code)]
pub fn verify_token_soa_only<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    token_b64url: &str,
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Decision, AuthError> {
    let mut scratch = Vec::with_capacity(1024);
    let cap =
        decode_b64url_cbor_capability_with_buf(token_b64url, cfg.max_token_bytes, &mut scratch)?;
    if cap.caveats.len() > cfg.max_caveats {
        return Err(AuthError::Bounds);
    }
    let key = keys
        .key_for(&cap.kid, &cap.tid)
        .ok_or(AuthError::UnknownKid)?;
    let expect = compute_mac(&key, &cap);
    if !macs_equal(&expect, &cap.mac) {
        return Err(AuthError::MacMismatch);
    }
    let mut reasons = Vec::new();
    eval_caveats_soa(cfg, ctx, CaveatsSoA::from_slice(&cap.caveats), &mut reasons)?;
    if reasons.is_empty() {
        Ok(Decision::Allow { scope: cap.scope })
    } else {
        Ok(Decision::Deny { reasons })
    }
}

#[allow(dead_code)]
pub fn verify_many_streaming_only<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Vec<Decision>, AuthError> {
    let mut out = Vec::with_capacity(tokens_b64url.len());
    let mut scratch = Vec::with_capacity(1024);
    let mut reasons = Vec::<DenyReason>::new();

    for tok in tokens_b64url {
        let cap = decode_b64url_cbor_capability_with_buf(tok, cfg.max_token_bytes, &mut scratch)?;
        if cap.caveats.len() > cfg.max_caveats {
            return Err(AuthError::Bounds);
        }
        let key = keys
            .key_for(&cap.kid, &cap.tid)
            .ok_or(AuthError::UnknownKid)?;
        let expect = compute_mac(&key, &cap);
        if !macs_equal(&expect, &cap.mac) {
            return Err(AuthError::MacMismatch);
        }
        reasons.clear();
        eval_caveats_streaming(cfg, ctx, &cap.caveats, &mut reasons)?;
        if reasons.is_empty() {
            out.push(Decision::Allow { scope: cap.scope });
        } else {
            let taken = mem::take(&mut reasons);
            out.push(Decision::Deny { reasons: taken });
        }
    }
    Ok(out)
}

#[allow(dead_code)]
pub fn verify_many_soa_only<K: MacKeyProvider>(
    cfg: &VerifierConfig,
    tokens_b64url: &[String],
    ctx: &RequestCtx,
    keys: &K,
) -> Result<Vec<Decision>, AuthError> {
    let mut out = Vec::with_capacity(tokens_b64url.len());
    let mut scratch = Vec::with_capacity(1024);
    let mut reasons = Vec::<DenyReason>::new();

    for tok in tokens_b64url {
        let cap = decode_b64url_cbor_capability_with_buf(tok, cfg.max_token_bytes, &mut scratch)?;
        if cap.caveats.len() > cfg.max_caveats {
            return Err(AuthError::Bounds);
        }
        let key = keys
            .key_for(&cap.kid, &cap.tid)
            .ok_or(AuthError::UnknownKid)?;
        let expect = compute_mac(&key, &cap);
        if !macs_equal(&expect, &cap.mac) {
            return Err(AuthError::MacMismatch);
        }
        reasons.clear();
        eval_caveats_soa(cfg, ctx, CaveatsSoA::from_slice(&cap.caveats), &mut reasons)?;
        if reasons.is_empty() {
            out.push(Decision::Allow { scope: cap.scope });
        } else {
            let taken = mem::take(&mut reasons);
            out.push(Decision::Deny { reasons: taken });
        }
    }
    Ok(out)
}

```

### crates/ron-auth/src/verify/soa.rs
<a id="crates-ron-auth-src-verify-soa-rs"></a>

```rust
//! SoA (struct-of-arrays) view over a slice of Caveat.

use crate::types::Caveat;
use ipnet::IpNet;
use serde_cbor::Value;
use std::str::FromStr;

pub struct CaveatsSoA<'a> {
    pub exp: Vec<u64>,
    pub nbf: Vec<u64>,
    pub aud: Vec<&'a str>,
    pub method: Vec<&'a Vec<String>>,
    pub path_prefix: Vec<&'a str>,
    pub ip_cidr: Vec<Option<IpNet>>,
    pub bytes_le: Vec<u64>,
    pub rate: Vec<(u64, u32)>,
    pub tenant: Vec<&'a str>,
    pub amnesia: Vec<bool>,
    pub gov_policy_digest: Vec<&'a str>,
    pub custom: Vec<(&'a str, &'a str, &'a Value)>, // (ns, name, cbor)
}

impl<'a> CaveatsSoA<'a> {
    pub fn from_slice(caveats: &'a [Caveat]) -> Self {
        let mut out = Self {
            exp: Vec::new(),
            nbf: Vec::new(),
            aud: Vec::new(),
            method: Vec::new(),
            path_prefix: Vec::new(),
            ip_cidr: Vec::new(),
            bytes_le: Vec::new(),
            rate: Vec::new(),
            tenant: Vec::new(),
            amnesia: Vec::new(),
            gov_policy_digest: Vec::new(),
            custom: Vec::new(),
        };

        for c in caveats {
            match c {
                Caveat::Exp(v) => out.exp.push(*v),
                Caveat::Nbf(v) => out.nbf.push(*v),
                Caveat::Aud(a) => out.aud.push(a.as_str()),
                Caveat::Method(ms) => out.method.push(ms),
                Caveat::PathPrefix(p) => out.path_prefix.push(p.as_str()),
                Caveat::IpCidr(s) => {
                    out.ip_cidr.push(IpNet::from_str(s).ok());
                }
                Caveat::BytesLe(n) => out.bytes_le.push(*n),
                Caveat::Rate { burst, per_s } => out.rate.push((*burst as u64, *per_s)),
                Caveat::Tenant(t) => out.tenant.push(t.as_str()),
                Caveat::Amnesia(b) => out.amnesia.push(*b),
                Caveat::GovPolicyDigest(d) => out.gov_policy_digest.push(d.as_str()),
                Caveat::Custom { ns, name, cbor } => {
                    out.custom.push((ns.as_str(), name.as_str(), cbor))
                }
            }
        }

        out
    }
}

```

### crates/ron-auth/src/verify/soa_eval.rs
<a id="crates-ron-auth-src-verify-soaeval-rs"></a>

```rust
//! Evaluator over SoA columns.

use super::soa::CaveatsSoA;
use crate::errors::{AuthError, DenyReason};
use crate::types::{RequestCtx, VerifierConfig};

pub fn eval_caveats_soa<'a>(
    cfg: &VerifierConfig,
    ctx: &RequestCtx,
    soa: CaveatsSoA<'a>,
    out: &mut Vec<DenyReason>,
) -> Result<(), AuthError> {
    let now = ctx.now_unix_s as i64;

    // Hard errors first.
    for exp in soa.exp.iter() {
        if now > (*exp as i64) + cfg.clock_skew_secs {
            return Err(AuthError::Expired);
        }
    }
    for nbf in soa.nbf.iter() {
        if now + cfg.clock_skew_secs < *nbf as i64 {
            return Err(AuthError::NotYetValid);
        }
    }

    // Audience
    for a in soa.aud.iter() {
        match &ctx.policy_digest_hex {
            Some(pd) if pd == a => {}
            _ => out.push(DenyReason::BadAudience),
        }
    }

    // Method (borrowed slice of Strings; compare as &str)
    for methods in soa.method.iter() {
        if !methods
            .iter()
            .any(|m| m.as_str().eq_ignore_ascii_case(&ctx.method))
        {
            out.push(DenyReason::MethodNotAllowed);
        }
    }

    // PathPrefix
    for pref in soa.path_prefix.iter() {
        if !ctx.path.starts_with(pref) {
            out.push(DenyReason::PathNotAllowed);
        }
    }

    // IpCidr (already parsed)
    for net in soa.ip_cidr.iter() {
        match (&ctx.peer_ip, net) {
            (Some(ip), Some(n)) if n.contains(ip) => {}
            _ => out.push(DenyReason::IpNotAllowed),
        }
    }

    // BytesLe
    if let Some(len) = extract_len_from_extras_for_soa(&ctx.extras) {
        for max in soa.bytes_le.iter() {
            if len > *max {
                out.push(DenyReason::BytesExceed);
            }
        }
    }

    // Rate (placeholder)
    for (_burst, _per_s) in soa.rate.iter() {
        // host policy may enforce elsewhere
    }

    // Tenant
    for t in soa.tenant.iter() {
        if *t != ctx.tenant {
            out.push(DenyReason::TenantMismatch);
        }
    }

    // Amnesia flag
    for flag in soa.amnesia.iter() {
        if *flag != ctx.amnesia {
            out.push(DenyReason::Custom("amnesia_mismatch".into()));
        }
    }

    // Governance policy digest
    for d in soa.gov_policy_digest.iter() {
        if ctx.policy_digest_hex.as_deref() != Some(*d) {
            out.push(DenyReason::Custom("gov_policy_digest_mismatch".into()));
        }
    }

    // Custom caveats are host-defined; keep informational
    let _ = soa.custom;

    Ok(())
}

// Small helper to reuse the same len-extractor without exposing internals widely.
pub(crate) fn extract_len_from_extras_for_soa(v: &serde_cbor::Value) -> Option<u64> {
    use serde_cbor::Value;
    match v {
        Value::Map(m) => {
            for (k, val) in m {
                if let Value::Text(s) = k {
                    if s == "len" {
                        if let Value::Integer(i) = val {
                            if *i >= 0 {
                                return Some(*i as u64);
                            }
                        } else if let Value::Float(f) = val {
                            if *f >= 0.0 {
                                return Some(*f as u64);
                            }
                        }
                    }
                }
            }
            None
        }
        _ => None,
    }
}

```

### crates/ron-auth/src/verify/streaming.rs
<a id="crates-ron-auth-src-verify-streaming-rs"></a>

```rust
//! Streaming evaluator with early short-circuit for Exp/Nbf.

use crate::errors::{AuthError, DenyReason};
use crate::types::{Caveat, RequestCtx, VerifierConfig};
use ipnet::IpNet;
use serde_cbor::Value;
use std::str::FromStr;

pub fn eval_caveats_streaming(
    cfg: &VerifierConfig,
    ctx: &RequestCtx,
    caveats: &[Caveat],
    out: &mut Vec<DenyReason>,
) -> Result<(), AuthError> {
    let now = ctx.now_unix_s as i64;
    let mut need_len: Option<u64> = None;

    for c in caveats {
        match c {
            Caveat::Exp(v) => {
                if now > (*v as i64) + cfg.clock_skew_secs {
                    return Err(AuthError::Expired);
                }
            }
            Caveat::Nbf(v) => {
                if now + cfg.clock_skew_secs < *v as i64 {
                    return Err(AuthError::NotYetValid);
                }
            }
            Caveat::Aud(a) => {
                if ctx.policy_digest_hex.as_deref() != Some(a.as_str()) {
                    out.push(DenyReason::BadAudience);
                }
            }
            Caveat::Method(ms) => {
                if !ms.iter().any(|m| m.eq_ignore_ascii_case(&ctx.method)) {
                    out.push(DenyReason::MethodNotAllowed);
                }
            }
            Caveat::PathPrefix(pref) => {
                if !ctx.path.starts_with(pref) {
                    out.push(DenyReason::PathNotAllowed);
                }
            }
            Caveat::IpCidr(s) => match (&ctx.peer_ip, IpNet::from_str(s)) {
                (Some(ip), Ok(net)) if net.contains(ip) => {}
                _ => out.push(DenyReason::IpNotAllowed),
            },
            Caveat::BytesLe(max) => {
                if need_len.is_none() {
                    need_len = extract_len_from_extras(&ctx.extras);
                }
                if let Some(len) = need_len {
                    if len > *max {
                        out.push(DenyReason::BytesExceed);
                    }
                }
            }
            Caveat::Rate { .. } => {} // informational
            Caveat::Tenant(t) => {
                if t != &ctx.tenant {
                    out.push(DenyReason::TenantMismatch);
                }
            }
            Caveat::Amnesia(flag) => {
                if *flag != ctx.amnesia {
                    out.push(DenyReason::Custom("amnesia_mismatch".into()));
                }
            }
            Caveat::GovPolicyDigest(d) => {
                if ctx.policy_digest_hex.as_deref() != Some(d.as_str()) {
                    out.push(DenyReason::Custom("gov_policy_digest_mismatch".into()));
                }
            }
            Caveat::Custom { .. } => {}
        }
    }
    Ok(())
}

fn extract_len_from_extras(v: &Value) -> Option<u64> {
    match v {
        Value::Map(m) => {
            for (k, val) in m {
                if let Value::Text(s) = k {
                    if s == "len" {
                        if let Value::Integer(i) = val {
                            if *i >= 0 {
                                return Some(*i as u64);
                            }
                        } else if let Value::Float(f) = val {
                            if *f >= 0.0 {
                                return Some(*f as u64);
                            }
                        }
                    }
                }
            }
            None
        }
        _ => None,
    }
}

```

### crates/ron-auth/src/zk/mod.rs
<a id="crates-ron-auth-src-zk-mod-rs"></a>

```rust
// zk::mod placeholder (feature-gated)
```

### crates/ron-auth/testing/vectors/ron-auth/v1/allow_example.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-allowexample-json"></a>

```json
{ "placeholder": "allow_example" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/custom_ns_examples.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-customnsexamples-json"></a>

```json
{ "placeholder": "custom_ns_examples" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/deny_expired.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-denyexpired-json"></a>

```json
{ "placeholder": "deny_expired" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/deny_unknown_kid.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-denyunknownkid-json"></a>

```json
{ "placeholder": "deny_unknown_kid" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/pq_allow.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-pqallow-json"></a>

```json
{ "placeholder": "pq_allow" }
```

### crates/ron-auth/testing/vectors/ron-auth/v1/pq_deny_mismatch.json
<a id="crates-ron-auth-testing-vectors-ron-auth-v1-pqdenymismatch-json"></a>

```json
{ "placeholder": "pq_deny_mismatch" }
```

### crates/ron-auth/tests/allow_deny_vectors.rs
<a id="crates-ron-auth-tests-allowdenyvectors-rs"></a>

```rust
// RO:WHAT   Minimal allow/deny sanity for ron-auth core.
// RO:WHY    Catch regressions fast: MAC path, bounds, caveats.
// RO:INVARIANTS BLAKE3 only; no I/O; deterministic CBOR+Base64URL.

use ron_auth::{
    sign_and_encode_b64url, verify_token, AuthError, CapabilityBuilder, Caveat, Decision,
    DenyReason, MacKey, MacKeyProvider, RequestCtx, Scope, VerifierConfig,
};
use serde_cbor::Value;
use std::net::IpAddr;
use std::str::FromStr;

#[derive(Clone)]
struct StaticKeys;
impl MacKeyProvider for StaticKeys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        // One fixed 32B key for (tid="test", kid="k1")
        if kid == "k1" && tid == "test" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn now() -> u64 {
    // Stable-ish test timestamp
    1_700_000_000
}

fn base_cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 64,
        clock_skew_secs: 60,
        soa_threshold: 8, // NEW: crossover for streaming vs SoA
    }
}

fn base_ctx() -> RequestCtx {
    RequestCtx {
        now_unix_s: now(),
        method: "GET".into(),
        path: "/index/items/42".into(),
        peer_ip: Some(IpAddr::from_str("127.0.0.1").unwrap()),
        object_addr: None,
        tenant: "test".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}

#[test]
fn allow_happy_path() {
    // Scope allows GET under /index/
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };

    // Build a capability with audience + path prefix + method + tenant + exp
    let mut cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::PathPrefix("/index/".into()))
        .caveat(Caveat::Method(vec!["GET".into()]))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::Exp(now() + 300))
        .build();

    // Sign + encode
    let tok = sign_and_encode_b64url(&mut cap, &StaticKeys).expect("sign");

    // Verify
    let decision = verify_token(&base_cfg(), &tok, &base_ctx(), &StaticKeys).expect("verify ok");
    match decision {
        Decision::Allow { scope } => {
            assert_eq!(scope.prefix.as_deref(), Some("/index/"));
        }
        _ => panic!("expected Allow"),
    }
}

#[test]
fn deny_method_not_allowed() {
    // Scope allows GET under /index/
    let scope = Scope {
        prefix: Some("/index/".into()),
        methods: vec!["GET".into()],
        max_bytes: None,
    };

    let mut cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::PathPrefix("/index/".into()))
        .caveat(Caveat::Method(vec!["GET".into()]))
        .caveat(Caveat::Tenant("test".into()))
        .caveat(Caveat::Exp(now() + 300))
        .build();

    let tok = sign_and_encode_b64url(&mut cap, &StaticKeys).expect("sign");

    // Change method in context to POST to trigger deny
    let mut ctx = base_ctx();
    ctx.method = "POST".into();

    let decision = verify_token(&base_cfg(), &tok, &ctx, &StaticKeys).expect("verify ok");
    match decision {
        Decision::Deny { reasons } => {
            assert!(reasons.contains(&DenyReason::MethodNotAllowed));
        }
        _ => panic!("expected Deny"),
    }
}

#[test]
fn error_mac_mismatch() {
    // Tamper with token bytes after signing to ensure MAC mismatch is caught.
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let mut cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Exp(now() + 60))
        .build();
    let tok = sign_and_encode_b64url(&mut cap, &StaticKeys).expect("sign");

    // Flip one character safely within base64url alphabet
    let mut chars: Vec<u8> = tok.as_bytes().to_vec();
    // Find a position that is not '-' or '_' and flip it.
    let pos = chars
        .iter()
        .position(|&c| c != b'-' && c != b'_')
        .unwrap_or(0);
    chars[pos] = if chars[pos] != b'A' { b'A' } else { b'B' };
    let tampered = String::from_utf8(chars).unwrap();

    let err = verify_token(&base_cfg(), &tampered, &base_ctx(), &StaticKeys).unwrap_err();
    match err {
        AuthError::Malformed(_) | AuthError::MacMismatch => {} // either decode fails or MAC fails
        other => panic!("unexpected error: {:?}", other),
    }
}

#[test]
fn error_expired() {
    // Exp in the past triggers AuthError::Expired (hard error).
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let mut cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Exp(now() - 3600))
        .build();
    let tok = sign_and_encode_b64url(&mut cap, &StaticKeys).expect("sign");

    let err = verify_token(&base_cfg(), &tok, &base_ctx(), &StaticKeys).unwrap_err();
    matches!(err, AuthError::Expired);
}

```

### crates/ron-auth/tests/amnesia_mode.rs
<a id="crates-ron-auth-tests-amnesiamode-rs"></a>

```rust
// test: amnesia mode placeholder

```

### crates/ron-auth/tests/attenuation_monotonicity.rs
<a id="crates-ron-auth-tests-attenuationmonotonicity-rs"></a>

```rust
// test: attenuation monotonicity placeholder

```

### crates/ron-auth/tests/compat_public_api.rs
<a id="crates-ron-auth-tests-compatpublicapi-rs"></a>

```rust
// test: public API stability placeholder

```

### crates/ron-auth/tests/ip_cidr.rs
<a id="crates-ron-auth-tests-ipcidr-rs"></a>

```rust
// RO:WHAT   IpCidr caveat sanity (allow/deny).
// RO:WHY    Lock CIDR parsing and membership semantics.
// RO:INVARIANTS Pure; BLAKE3; deterministic; no I/O.

use ron_auth::{
    sign_and_encode_b64url, verify_token, CapabilityBuilder, Caveat, Decision, DenyReason, MacKey,
    MacKeyProvider, RequestCtx, Scope, VerifierConfig,
};
use serde_cbor::Value;
use std::net::IpAddr;
use std::str::FromStr;

#[derive(Clone)]
struct StaticKeys;
impl MacKeyProvider for StaticKeys {
    fn key_for(&self, kid: &str, tid: &str) -> Option<MacKey> {
        if kid == "k1" && tid == "test" {
            Some(MacKey(*b"0123456789abcdef0123456789abcdef"))
        } else {
            None
        }
    }
}

fn now() -> u64 {
    1_700_000_000
}

fn cfg() -> VerifierConfig {
    VerifierConfig {
        max_token_bytes: 4096,
        max_caveats: 64,
        clock_skew_secs: 60,
        soa_threshold: 8, // NEW: crossover for streaming vs SoA
    }
}

fn ctx_with_ip(ip: &str) -> RequestCtx {
    RequestCtx {
        now_unix_s: now(),
        method: "GET".into(),
        path: "/".into(),
        peer_ip: Some(IpAddr::from_str(ip).unwrap()),
        object_addr: None,
        tenant: "test".into(),
        amnesia: false,
        policy_digest_hex: Some("aud-demo".into()),
        extras: Value::Null,
    }
}

#[test]
fn ip_cidr_allow_ipv4() {
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let mut cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::IpCidr("192.168.1.0/24".into()))
        .caveat(Caveat::Exp(now() + 60))
        .build();
    let tok = sign_and_encode_b64url(&mut cap, &StaticKeys).unwrap();

    let dec = verify_token(&cfg(), &tok, &ctx_with_ip("192.168.1.42"), &StaticKeys).unwrap();
    matches!(dec, Decision::Allow { .. });
}

#[test]
fn ip_cidr_deny_outside() {
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let mut cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::IpCidr("10.0.0.0/8".into()))
        .caveat(Caveat::Exp(now() + 60))
        .build();
    let tok = sign_and_encode_b64url(&mut cap, &StaticKeys).unwrap();

    let dec = verify_token(&cfg(), &tok, &ctx_with_ip("192.168.1.42"), &StaticKeys).unwrap();
    match dec {
        Decision::Deny { reasons } => assert!(reasons.contains(&DenyReason::IpNotAllowed)),
        _ => panic!("expected Deny"),
    }
}

#[test]
fn ip_cidr_deny_malformed() {
    let scope = Scope {
        prefix: None,
        methods: vec!["GET".into()],
        max_bytes: None,
    };
    let mut cap = CapabilityBuilder::new(scope, "test", "k1")
        .caveat(Caveat::Aud("aud-demo".into()))
        .caveat(Caveat::IpCidr("not-a-cidr".into()))
        .caveat(Caveat::Exp(now() + 60))
        .build();
    let tok = sign_and_encode_b64url(&mut cap, &StaticKeys).unwrap();

    let dec = verify_token(&cfg(), &tok, &ctx_with_ip("127.0.0.1"), &StaticKeys).unwrap();
    match dec {
        Decision::Deny { reasons } => assert!(reasons.contains(&DenyReason::IpNotAllowed)),
        _ => panic!("expected Deny"),
    }
}

```

### crates/ron-auth/tests/loom_verify.rs
<a id="crates-ron-auth-tests-loomverify-rs"></a>

```rust
// test: loom concurrency model placeholder

```

### crates/ron-auth/tests/parser_fixtures.rs
<a id="crates-ron-auth-tests-parserfixtures-rs"></a>

```rust
// test: parser fixtures placeholder

```

