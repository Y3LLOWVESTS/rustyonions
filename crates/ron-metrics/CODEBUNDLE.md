<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:47:02Z -->
# Code Bundle â€” `ron-metrics`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-metrics/.cargo/config.toml](#crates-ron-metrics--cargo-config-toml)
- [crates/ron-metrics/.github/workflows/ci.yml](#crates-ron-metrics--github-workflows-ci-yml)
- [crates/ron-metrics/.github/workflows/coverage.yml](#crates-ron-metrics--github-workflows-coverage-yml)
- [crates/ron-metrics/.github/workflows/mermaid.yml](#crates-ron-metrics--github-workflows-mermaid-yml)
- [crates/ron-metrics/.github/workflows/perf-smoke.yml](#crates-ron-metrics--github-workflows-perf-smoke-yml)
- [crates/ron-metrics/.github/workflows/public-api.yml](#crates-ron-metrics--github-workflows-public-api-yml)
- [crates/ron-metrics/.github/workflows/sanitizer.yml](#crates-ron-metrics--github-workflows-sanitizer-yml)
- [crates/ron-metrics/Cargo.toml](#crates-ron-metrics-Cargo-toml)
- [crates/ron-metrics/benches/exposer_bench.rs](#crates-ron-metrics-benches-exposerbench-rs)
- [crates/ron-metrics/benches/hotpath_bench.rs](#crates-ron-metrics-benches-hotpathbench-rs)
- [crates/ron-metrics/deny.toml](#crates-ron-metrics-deny-toml)
- [crates/ron-metrics/examples/axum_api.rs](#crates-ron-metrics-examples-axumapi-rs)
- [crates/ron-metrics/examples/exposer.rs](#crates-ron-metrics-examples-exposer-rs)
- [crates/ron-metrics/examples/pump.rs](#crates-ron-metrics-examples-pump-rs)
- [crates/ron-metrics/examples/watch_bus.rs](#crates-ron-metrics-examples-watchbus-rs)
- [crates/ron-metrics/rust-toolchain.toml](#crates-ron-metrics-rust-toolchain-toml)
- [crates/ron-metrics/scripts/check-taxonomy.sh](#crates-ron-metrics-scripts-check-taxonomy-sh)
- [crates/ron-metrics/scripts/render-mermaid.sh](#crates-ron-metrics-scripts-render-mermaid-sh)
- [crates/ron-metrics/src/axum_latency.rs](#crates-ron-metrics-src-axumlatency-rs)
- [crates/ron-metrics/src/axum_status.rs](#crates-ron-metrics-src-axumstatus-rs)
- [crates/ron-metrics/src/build_info.rs](#crates-ron-metrics-src-buildinfo-rs)
- [crates/ron-metrics/src/bus_watcher.rs](#crates-ron-metrics-src-buswatcher-rs)
- [crates/ron-metrics/src/config.rs](#crates-ron-metrics-src-config-rs)
- [crates/ron-metrics/src/errors.rs](#crates-ron-metrics-src-errors-rs)
- [crates/ron-metrics/src/exporters/mod.rs](#crates-ron-metrics-src-exporters-mod-rs)
- [crates/ron-metrics/src/exporters/otel.rs](#crates-ron-metrics-src-exporters-otel-rs)
- [crates/ron-metrics/src/exposer/http.rs](#crates-ron-metrics-src-exposer-http-rs)
- [crates/ron-metrics/src/exposer/middleware.rs](#crates-ron-metrics-src-exposer-middleware-rs)
- [crates/ron-metrics/src/exposer/mod.rs](#crates-ron-metrics-src-exposer-mod-rs)
- [crates/ron-metrics/src/exposer/tls.rs](#crates-ron-metrics-src-exposer-tls-rs)
- [crates/ron-metrics/src/exposer/uds.rs](#crates-ron-metrics-src-exposer-uds-rs)
- [crates/ron-metrics/src/health.rs](#crates-ron-metrics-src-health-rs)
- [crates/ron-metrics/src/labels.rs](#crates-ron-metrics-src-labels-rs)
- [crates/ron-metrics/src/lib.rs](#crates-ron-metrics-src-lib-rs)
- [crates/ron-metrics/src/metrics.rs](#crates-ron-metrics-src-metrics-rs)
- [crates/ron-metrics/src/pq.rs](#crates-ron-metrics-src-pq-rs)
- [crates/ron-metrics/src/readiness.rs](#crates-ron-metrics-src-readiness-rs)
- [crates/ron-metrics/src/registry.rs](#crates-ron-metrics-src-registry-rs)
- [crates/ron-metrics/src/zk.rs](#crates-ron-metrics-src-zk-rs)
- [crates/ron-metrics/tests/bus_watcher.rs](#crates-ron-metrics-tests-buswatcher-rs)
- [crates/ron-metrics/tests/health_ready.rs](#crates-ron-metrics-tests-healthready-rs)
- [crates/ron-metrics/tests/http_endpoints.rs](#crates-ron-metrics-tests-httpendpoints-rs)
- [crates/ron-metrics/tests/http_status_counter.rs](#crates-ron-metrics-tests-httpstatuscounter-rs)
- [crates/ron-metrics/tests/integration_http_endpoints.rs](#crates-ron-metrics-tests-integrationhttpendpoints-rs)
- [crates/ron-metrics/tests/loom_shutdown.rs](#crates-ron-metrics-tests-loomshutdown-rs)
- [crates/ron-metrics/tests/metrics_encode_ok.rs](#crates-ron-metrics-tests-metricsencodeok-rs)
- [crates/ron-metrics/tests/public_api.rs](#crates-ron-metrics-tests-publicapi-rs)
- [crates/ron-metrics/tests/readiness_semantics.rs](#crates-ron-metrics-tests-readinesssemantics-rs)
- [crates/ron-metrics/tests/taxonomy_labels.rs](#crates-ron-metrics-tests-taxonomylabels-rs)
- [crates/ron-metrics/tests/vectors/interop/ron-metrics/readyz-degraded.json](#crates-ron-metrics-tests-vectors-interop-ron-metrics-readyz-degraded-json)
- [crates/ron-metrics/tests/vectors/interop/ron-metrics/readyz-ready.json](#crates-ron-metrics-tests-vectors-interop-ron-metrics-readyz-ready-json)

### crates/ron-metrics/.cargo/config.toml
<a id="crates-ron-metrics--cargo-config-toml"></a>

```toml
# Minimal, portable Cargo config for CI parity
[build]
rustflags = []

[env]
RUSTFLAGS = "-Dwarnings"

```

### crates/ron-metrics/.github/workflows/ci.yml
<a id="crates-ron-metrics--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: rustup toolchain install 1.80.0 --profile minimal --component rustfmt clippy
      - run: cargo fmt --all -- --check
      - run: cargo clippy -p ron-metrics2 -- -D warnings
      - run: cargo test -p ron-metrics2
      - run: cargo deny check

```

### crates/ron-metrics/.github/workflows/coverage.yml
<a id="crates-ron-metrics--github-workflows-coverage-yml"></a>

```yaml
name: coverage
on: [push, pull_request]
jobs:
  cov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: taiki-e/install-action@cargo-llvm-cov
      - run: cargo llvm-cov --workspace --lcov --output-path lcov.info
      - run: cargo llvm-cov report --json | jq -e '.data[0].totals.branches.percent >= 80'

```

### crates/ron-metrics/.github/workflows/mermaid.yml
<a id="crates-ron-metrics--github-workflows-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          mkdir -p docs
          for f in $(git ls-files 'docs/mmd/*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out"
          done

```

### crates/ron-metrics/.github/workflows/perf-smoke.yml
<a id="crates-ron-metrics--github-workflows-perf-smoke-yml"></a>

```yaml
name: perf-smoke
on:
  workflow_dispatch:
jobs:
  bombardier:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "perf smoke placeholder (would hammer /metrics and record p95)"

```

### crates/ron-metrics/.github/workflows/public-api.yml
<a id="crates-ron-metrics--github-workflows-public-api-yml"></a>

```yaml
name: public-api
on: [push, pull_request]
jobs:
  api:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: cargo install cargo-public-api
      # Allow first run to pass before snapshots exist; tighten later.
      - run: cargo public-api --crate ron-metrics2 --deny changed || true

```

### crates/ron-metrics/.github/workflows/sanitizer.yml
<a id="crates-ron-metrics--github-workflows-sanitizer-yml"></a>

```yaml
name: sanitizer
on:
  schedule:
    - cron: "0 4 * * *"
jobs:
  tsan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: rustup toolchain install nightly --profile minimal
      - run: rustup default nightly
      - run: RUSTFLAGS="-Z sanitizer=thread" RUSTDOCFLAGS="-Z sanitizer=thread" cargo test -p ron-metrics2 --target x86_64-unknown-linux-gnu || true

```

### crates/ron-metrics/Cargo.toml
<a id="crates-ron-metrics-Cargo-toml"></a>

```toml
[package]
name = "ron-metrics"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
rust-version = "1.80.0"
description = "RustyOnions observability library (+ tiny HTTP exposer)"

[features]
default = []
bus = ["dep:ron-bus"]                      # bridge ron-bus events -> metrics/health (optional)
otel = ["dep:opentelemetry", "dep:opentelemetry-otlp"]
tls = ["dep:tokio-rustls"]
uds = []

[dependencies]
axum = { version = "0.7.9", default-features = false, features = ["tokio", "http1", "http2", "json"] }
prometheus = "0.14"
tokio = { version = "1.47.1", features = ["rt-multi-thread","macros","net","signal","time","io-util"] }
parking_lot = "0.12"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
once_cell = "1.19"
tracing = "0.1"
http = "1.1"
tower = "0.4"


# optional
tokio-rustls = { version = "0.26.2", optional = true }
opentelemetry = { version = "0.23", optional = true }
opentelemetry-otlp = { version = "0.16", optional = true }
ron-bus = { path = "../ron-bus", optional = true }   # adjust path if your workspace differs

[dev-dependencies]
anyhow = "1.0"
# Hyper core + client
hyper = { version = "1.4", features = ["client", "http1", "http2"] }
hyper-util = { version = "0.1", features = ["client", "http1", "http2", "tokio", "client-legacy"] }
http-body-util = "0.1"
tracing-subscriber = "0.3"
rand = "0.9"
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls"] }

```

### crates/ron-metrics/benches/exposer_bench.rs
<a id="crates-ron-metrics-benches-exposerbench-rs"></a>

```rust
// Criterion bench placeholder for exposition latency across registry sizes.
fn main() {}

```

### crates/ron-metrics/benches/hotpath_bench.rs
<a id="crates-ron-metrics-benches-hotpathbench-rs"></a>

```rust
// Measures counter/histogram hot path (scaffold placeholder).
fn main() {}

```

### crates/ron-metrics/deny.toml
<a id="crates-ron-metrics-deny-toml"></a>

```toml
# cargo-deny baseline (licenses, advisories, bans)
[advisories]
vulnerability = "deny"
yanked = "deny"

[licenses]
confidence-threshold = 0.8
allow = [
  "MIT", "Apache-2.0", "Unicode-DFS-2016", "BSD-3-Clause",
  "ISC", "CC0-1.0", "OpenSSL"
]

```

### crates/ron-metrics/examples/axum_api.rs
<a id="crates-ron-metrics-examples-axumapi-rs"></a>

```rust
//! RO:WHAT â€” Example Axum API instrumented with ron-metrics middleware (latency + status-class).
//! RO:WHY  â€” Zero-touch HTTP visibility: /metrics + automatic histograms/counters.
//! Run: RON_METRICS_METRICS_ADDR=127.0.0.1:0 cargo run -p ron-metrics --example axum_api

use axum::{routing::get, Router};
use std::{env, net::SocketAddr, time::Duration};
use tokio::time::sleep;

use ron_metrics::{
    axum_latency, // latency histogram middleware (request_latency_seconds)
    axum_status,  // status-class counter middleware (request_status_total)
    build_info::build_version,
    exposer::http::make_router as make_metrics_router,
    BaseLabels,
    HealthState,
    Metrics,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();

    // Base labels
    let base = BaseLabels {
        service: env::var("RON_SERVICE").unwrap_or_else(|_| "demo-api".into()),
        instance: env::var("RON_INSTANCE").unwrap_or_else(|_| "local-1".into()),
        build_version: build_version(),
        amnesia: env::var("RON_AMNESIA").unwrap_or_else(|_| "off".into()),
    };

    // Health state
    let health = HealthState::new();
    health.set("config_loaded".into(), true);
    health.set("db".into(), true);

    // Metrics
    let metrics = Metrics::new(base, health)?;

    // App routes (business endpoints)
    let app = Router::new()
        .route("/ping", get(|| async { "pong" }))
        .route(
            "/sleep",
            get(|| async {
                // Simulate work
                sleep(Duration::from_millis(12)).await;
                "ok"
            }),
        );

    // Expose /metrics, /healthz, /readyz on same server
    let app = app.merge(make_metrics_router(metrics.clone()));

    // Attach middlewares (order is fine either way; both apply to all routes)
    let app = axum_latency::attach(app, metrics.clone());
    let app = axum_status::attach(app, metrics.clone());

    // Bind & serve
    let bind: SocketAddr = env::var("RON_METRICS_METRICS_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:0".into())
        .parse()?;
    let listener = tokio::net::TcpListener::bind(bind).await?;
    let addr = listener.local_addr()?;
    println!("api     :  http://{}/ping", addr);
    println!("sleep   :  http://{}/sleep", addr);
    println!("metrics :  http://{}/metrics", addr);
    println!("healthz :  http://{}/healthz", addr);
    println!("readyz  :  http://{}/readyz", addr);

    axum::serve(listener, app).await?;
    Ok(())
}

```

### crates/ron-metrics/examples/exposer.rs
<a id="crates-ron-metrics-examples-exposer-rs"></a>

```rust
//! RO:WHAT â€” Tiny demo: start the exposer and print bound addr.

use ron_metrics::build_info::build_version;
use ron_metrics::{BaseLabels, HealthState, Metrics};
use std::env;
use std::net::SocketAddr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();

    let service = env::var("RON_SERVICE").unwrap_or_else(|_| "demo".into());
    let instance = env::var("RON_INSTANCE").unwrap_or_else(|_| "local-1".into());
    let amnesia = match env::var("RON_AMNESIA").ok().as_deref() {
        Some("on") | Some("1") | Some("true") => "on".to_string(),
        _ => "off".to_string(),
    };

    let base = BaseLabels {
        service,
        instance,
        build_version: build_version(),
        amnesia,
    };

    let health = HealthState::new();
    // Declare one dependency and mark ready
    health.set("config_loaded".to_string(), true);

    let metrics = Metrics::new(base, health)?;
    let bind: SocketAddr = env::var("RON_METRICS_METRICS_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:9100".into())
        .parse()?;

    let (_jh, addr) = metrics.serve(bind).await?;
    println!("metrics:  http://{addr}/metrics");
    println!("healthz:  http://{addr}/healthz");
    println!("readyz :  http://{addr}/readyz");
    tokio::signal::ctrl_c().await?;
    Ok(())
}

```

### crates/ron-metrics/examples/pump.rs
<a id="crates-ron-metrics-examples-pump-rs"></a>

```rust
//! RO:WHAT â€” Simulate activity against Metrics so /metrics moves live.
//! Run: RON_METRICS_METRICS_ADDR=127.0.0.1:0 cargo run -p ron-metrics --example pump

use rand::{rng, Rng}; // rand 0.9 API
use ron_metrics::{build_info::build_version, BaseLabels, HealthState, Metrics};
use std::{env, net::SocketAddr, time::Duration};
use tokio::time::sleep;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();

    let service = env::var("RON_SERVICE").unwrap_or_else(|_| "demo".into());
    let instance = env::var("RON_INSTANCE").unwrap_or_else(|_| "local-1".into());
    let amnesia = match env::var("RON_AMNESIA").ok().as_deref() {
        Some("on") | Some("1") | Some("true") => "on".to_string(),
        _ => "off".to_string(),
    };

    let base = BaseLabels {
        service,
        instance,
        build_version: build_version(),
        amnesia,
    };

    let health = HealthState::new();
    health.set("config_loaded".to_string(), true);
    health.set("db".to_string(), false);
    health.set("cache".to_string(), false);

    let metrics = Metrics::new(base, health)?;
    let bind: SocketAddr = env::var("RON_METRICS_METRICS_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:0".into())
        .parse()?;

    let (_jh, addr) = metrics.clone().serve(bind).await?;
    println!("metrics:  http://{addr}/metrics");
    println!("healthz:  http://{addr}/healthz");
    println!("readyz :  http://{addr}/readyz");

    // Simulate activity forever
    let mut tick: u64 = 0;
    loop {
        let mut r = rng();

        // Simulate a request with 0.3â€“20 ms latency
        let lat_ms: f64 = r.random_range(0.3..20.0);
        metrics.observe_request(lat_ms / 1000.0);

        // Pretend a service restarted every ~15s
        if tick % 15 == 0 {
            metrics.inc_service_restart("worker-A");
        }

        // Pretend the bus overwrote some lagged messages sporadically
        if tick % 7 == 0 {
            let overwrites: u64 = r.random_range(1..5);
            metrics.add_bus_lag("kernel", overwrites);
        }

        // Flip readiness of db/cache occasionally to show /readyz truth
        if tick % 9 == 0 {
            let ok = r.random::<bool>();
            metrics.set_ready("db", ok);
        }
        if tick % 11 == 0 {
            let ok = r.random::<bool>();
            metrics.set_ready("cache", ok);
        }

        tick += 1;
        sleep(Duration::from_millis(1000)).await;
    }
}

```

### crates/ron-metrics/examples/watch_bus.rs
<a id="crates-ron-metrics-examples-watchbus-rs"></a>

```rust
//! RO:WHAT â€” Demo: bridge ron-bus events into ron-metrics endpoints.
//! Run: cargo run -p ron-metrics --features bus --example watch_bus

use ron_metrics::{build_info::build_version, BaseLabels, HealthState, Metrics};
use std::{env, net::SocketAddr, time::Duration};

#[cfg(feature = "bus")]
use {
    ron_bus::{Bus, BusConfig, Event},
    ron_metrics::bus_watcher::start_bus_watcher,
    tokio::time::sleep,
};

/// When `bus` feature is OFF, provide a tiny placeholder main so examples still build under `cargo test`.
#[cfg(not(feature = "bus"))]
fn main() {
    eprintln!("watch_bus example requires `--features bus`");
}

/// Real example when `bus` feature is ON.
#[cfg(feature = "bus")]
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();

    let base = BaseLabels {
        service: env::var("RON_SERVICE").unwrap_or_else(|_| "demo".into()),
        instance: env::var("RON_INSTANCE").unwrap_or_else(|_| "local-1".into()),
        build_version: build_version(),
        amnesia: env::var("RON_AMNESIA").unwrap_or_else(|_| "off".into()),
    };

    let cfg = BusConfig::default().with_capacity(256);
    let bus = Bus::new(cfg).expect("bus");

    let health = HealthState::new();
    health.set("config_loaded".into(), false);

    let metrics = Metrics::new(base, health)?;
    let bind: SocketAddr = env::var("RON_METRICS_METRICS_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:0".into())
        .parse()?;

    let (_jh, addr) = metrics.clone().serve(bind).await?;
    println!("metrics:  http://{addr}/metrics");
    println!("healthz:  http://{addr}/healthz");
    println!("readyz :  http://{addr}/readyz");

    let _watcher = start_bus_watcher(metrics.clone(), &bus, "demo-watcher");

    let tx = bus.sender();
    tx.send(Event::Health {
        service: "config_loaded".into(),
        ok: false,
    })
    .expect("send");
    sleep(Duration::from_millis(250)).await;
    tx.send(Event::Health {
        service: "config_loaded".into(),
        ok: true,
    })
    .expect("send");

    println!("curl the endpoints now. shutting down in ~3sâ€¦");
    sleep(Duration::from_secs(3)).await;
    tx.send(Event::Shutdown).expect("send");

    Ok(())
}

```

### crates/ron-metrics/rust-toolchain.toml
<a id="crates-ron-metrics-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/ron-metrics/scripts/check-taxonomy.sh
<a id="crates-ron-metrics-scripts-check-taxonomy-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Placeholder: fetch /metrics and assert suffix and base labels (scaffold).
echo "check-taxonomy: placeholder"

```

### crates/ron-metrics/scripts/render-mermaid.sh
<a id="crates-ron-metrics-scripts-render-mermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Renders all docs/mmd/*.mmd to .svg (requires mmdc).
echo "render-mermaid: placeholder"

```

### crates/ron-metrics/src/axum_latency.rs
<a id="crates-ron-metrics-src-axumlatency-rs"></a>

```rust
//! RO:WHAT â€” Axum middleware to observe request latency into ron-metrics.
//! RO:WHY  â€” Zero-touch per-request timing for Axum apps.
//! RO:INVARIANTS â€” no locks across .await; low overhead.
//! RO:USAGE â€” let app = axum_latency::attach(router, metrics.clone());

use std::time::Instant;

use crate::Metrics;
use axum::{
    body::Body,
    extract::State,
    http::Request,
    middleware::{self, Next},
    response::Response,
    Router,
};

/// Attach a latency middleware to the given Router that records per-request
/// latency into `request_latency_seconds`.
///
/// ```ignore
/// let router = Router::new()
///     .route("/ping", get(|| async { "pong" }));
/// let router = ron_metrics::axum_latency::attach(router, metrics.clone());
/// ```
pub fn attach(router: Router, metrics: Metrics) -> Router {
    router.layer(middleware::from_fn_with_state(metrics, track_latency))
}

async fn track_latency(State(metrics): State<Metrics>, req: Request<Body>, next: Next) -> Response {
    let started = Instant::now();
    let resp = next.run(req).await;
    metrics.observe_request(started.elapsed().as_secs_f64());
    resp
}

```

### crates/ron-metrics/src/axum_status.rs
<a id="crates-ron-metrics-src-axumstatus-rs"></a>

```rust
//! RO:WHAT â€” Axum middleware to count responses by status class (1xx..5xx).
//! RO:WHY  â€” Low-cardinality error-rate signal for SRE/alerts.
//! RO:USAGE â€” let app = axum_status::attach(router, metrics.clone());

use crate::Metrics;
use axum::{
    body::Body,
    http::Request,
    middleware::{self, Next},
    response::Response,
    Router,
};

pub fn attach(router: Router, metrics: Metrics) -> Router {
    router.layer(middleware::from_fn_with_state(metrics, count_status))
}

async fn count_status(
    axum::extract::State(metrics): axum::extract::State<Metrics>,
    req: Request<Body>,
    next: Next,
) -> Response {
    let resp = next.run(req).await;
    let code = resp.status().as_u16();
    let class = match code {
        100..=199 => "1xx",
        200..=299 => "2xx",
        300..=399 => "3xx",
        400..=499 => "4xx",
        500..=599 => "5xx",
        _ => "other",
    };
    metrics.observe_status_class(class);
    resp
}

```

### crates/ron-metrics/src/build_info.rs
<a id="crates-ron-metrics-src-buildinfo-rs"></a>

```rust
//! RO:WHAT â€” Build/version helpers for base labels.

pub fn build_version() -> String {
    // Package version + short git if provided by outer build
    let ver = env!("CARGO_PKG_VERSION");
    match option_env!("GIT_SHA_SHORT") {
        Some(sha) if !sha.is_empty() => format!("{ver}+{sha}"),
        _ => ver.to_string(),
    }
}

```

### crates/ron-metrics/src/bus_watcher.rs
<a id="crates-ron-metrics-src-buswatcher-rs"></a>

```rust
//! RO:WHAT â€” Translate ron-bus events into metrics + health updates.
//! RO:WHY  â€” Unified observability; keep ron-bus lean, exporter lives here.
//! RO:INTERACTS â€” ron_bus::{Bus, Event}; Metrics; HealthState.
//! RO:INVARIANTS â€” single subscriber; bounded; no lock across .await.
//! RO:TODO â€” If ron-bus later emits lag/overwrite events, extend the match arms here behind the same feature.

#![allow(dead_code)]

#[cfg(feature = "bus")]
mod impls {
    use crate::Metrics;
    use ron_bus::{Bus, Event};
    use tokio::task::JoinHandle;
    use tokio::time::{sleep, Duration};
    use tracing::{info, warn};

    /// Start a watcher that consumes events from the shared bus and updates metrics/health.
    /// We only borrow the `Bus` to create a subscriber; the subscriber is moved into the task.
    pub fn start_bus_watcher(
        metrics: Metrics,
        bus: &Bus,
        watcher_name: &'static str,
    ) -> JoinHandle<()> {
        // Each subscriber has its own cursor by design.
        let mut sub = bus.subscribe();

        tokio::spawn(async move {
            info!(watcher=%watcher_name, "ron-metrics: bus watcher started");
            loop {
                match sub.recv().await {
                    Ok(ev) => match ev {
                        Event::Health { service, ok } => {
                            metrics.set_ready(&service, ok);
                        }
                        Event::Shutdown => {
                            info!(watcher=%watcher_name, "ron-metrics: bus watcher received Shutdown; exiting");
                            break;
                        }
                        // Extend here when new events are added (e.g., ConfigUpdated, BusLag, etc.)
                        _ => {}
                    },
                    Err(e) => {
                        // Channel closed or transient error â€” back off a hair to avoid hot loop.
                        warn!(watcher=%watcher_name, error=?e, "bus watcher recv error; backing off");
                        sleep(Duration::from_millis(5)).await;
                    }
                }
            }
        })
    }
}

#[cfg(feature = "bus")]
pub use impls::start_bus_watcher;

// If the feature is off, expose a stub so callsites can compile behind cfg.
#[cfg(not(feature = "bus"))]
pub fn start_bus_watcher(_: crate::Metrics, _: (), _: &'static str) -> () {
    ()
}

```

### crates/ron-metrics/src/config.rs
<a id="crates-ron-metrics-src-config-rs"></a>

```rust
// Typed configuration placeholder for ron-metrics2.
// Defines TCP addr vs UDS, timeouts, TLS paths, OTLP endpoint (env-first).
// Implementation intentionally omitted in scaffold.

```

### crates/ron-metrics/src/errors.rs
<a id="crates-ron-metrics-src-errors-rs"></a>

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum MetricsError {
    #[error("prometheus error: {0}")]
    Prometheus(#[from] prometheus::Error),

    #[error("io error: {0}")]
    Io(#[from] std::io::Error),

    #[error("other: {0}")]
    Other(String),
}

```

### crates/ron-metrics/src/exporters/mod.rs
<a id="crates-ron-metrics-src-exporters-mod-rs"></a>

```rust
//! RO:WHAT â€” Optional exporters (OTLP), feature-gated.

#[cfg(feature = "otel")]
pub mod otel;

```

### crates/ron-metrics/src/exporters/otel.rs
<a id="crates-ron-metrics-src-exporters-otel-rs"></a>

```rust
//! RO:WHAT â€” Minimal OTLP exporter wiring (feature gated).

#[allow(dead_code)]
pub fn init_otel() -> Result<(), Box<dyn std::error::Error>> {
    // Stub for future: map families to OTLP if desired.
    Ok(())
}

```

### crates/ron-metrics/src/exposer/http.rs
<a id="crates-ron-metrics-src-exposer-http-rs"></a>

```rust
//! RO:WHAT â€” Axum router + handlers for /metrics, /healthz, /readyz.

use crate::{
    metrics::Metrics,
    readiness::{make_ready_json, ReadyJson, ReadyPolicy},
};
use axum::{
    extract::State,
    http::{header, StatusCode},
    response::{IntoResponse, Response},
    routing::get,
    Json, Router,
};
use prometheus::{Encoder, TextEncoder}; // <-- Encoder trait needed
use std::time::{Instant, SystemTime};

#[derive(Clone)]
pub struct AppState {
    pub metrics: Metrics,
    pub ready_since: SystemTime,
}

pub fn make_router(metrics: Metrics) -> Router {
    let state = AppState {
        metrics,
        ready_since: SystemTime::now(),
    };

    Router::new()
        .route("/metrics", get(get_metrics))
        .route("/healthz", get(get_healthz))
        .route("/readyz", get(get_readyz))
        .with_state(state)
}

async fn get_metrics(State(st): State<AppState>) -> impl IntoResponse {
    let t0 = Instant::now();
    let mf = st.metrics.registry().gather();

    let mut buf = Vec::with_capacity(64 * 1024);
    let enc = TextEncoder::new();

    if let Err(e) = enc.encode(&mf, &mut buf) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("encode failed: {e}"),
        )
            .into_response();
    }

    let secs = t0.elapsed().as_secs_f64();
    st.metrics.observe_exposition(secs, "/metrics");

    Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, enc.format_type())
        .body(axum::body::Body::from(buf))
        .unwrap()
}

async fn get_healthz() -> impl IntoResponse {
    (StatusCode::OK, "ok")
}

async fn get_readyz(State(st): State<AppState>) -> impl IntoResponse {
    let health = st.metrics.health();
    let snap = health.snapshot();
    let all_ready = snap.values().all(|v| *v);
    let missing: Vec<String> = snap
        .into_iter()
        .filter_map(|(svc, ok)| if ok { None } else { Some(svc) })
        .collect();

    let policy: ReadyPolicy = st.metrics.ready_policy();
    let body: ReadyJson = make_ready_json(all_ready, missing, policy, st.ready_since);

    if all_ready {
        (StatusCode::OK, Json(body)).into_response()
    } else {
        let mut resp = (StatusCode::SERVICE_UNAVAILABLE, Json(body)).into_response();
        let retry_after = policy.retry_after_secs.to_string();
        resp.headers_mut()
            .insert(header::RETRY_AFTER, retry_after.parse().unwrap());
        resp
    }
}

```

### crates/ron-metrics/src/exposer/middleware.rs
<a id="crates-ron-metrics-src-exposer-middleware-rs"></a>

```rust
// Middleware placeholder: timeouts, concurrency caps, inflight gauge hooks.

```

### crates/ron-metrics/src/exposer/mod.rs
<a id="crates-ron-metrics-src-exposer-mod-rs"></a>

```rust
//! RO:WHAT â€” HTTP exposer surface (router + helpers).

pub mod http;
// Future: pub mod tls; pub mod uds;

```

### crates/ron-metrics/src/exposer/tls.rs
<a id="crates-ron-metrics-src-exposer-tls-rs"></a>

```rust
// TLS wiring placeholder (tokio_rustls::rustls::ServerConfig only).

```

### crates/ron-metrics/src/exposer/uds.rs
<a id="crates-ron-metrics-src-exposer-uds-rs"></a>

```rust
// UDS bind placeholder with secure modes (0700 dir / 0600 socket), no symlinks.

```

### crates/ron-metrics/src/health.rs
<a id="crates-ron-metrics-src-health-rs"></a>

```rust
//! RO:WHAT â€” In-memory readiness map with snapshot semantics.

use parking_lot::RwLock;
use std::{collections::BTreeMap, sync::Arc};

pub type ServiceName = String;

#[derive(Clone)]
pub struct HealthState {
    inner: Arc<RwLock<BTreeMap<ServiceName, bool>>>,
}

impl HealthState {
    pub fn new() -> Self {
        Self {
            inner: Arc::new(RwLock::new(BTreeMap::new())),
        }
    }
    pub fn set(&self, service: ServiceName, ok: bool) {
        let mut w = self.inner.write();
        w.insert(service, ok);
    }
    pub fn snapshot(&self) -> BTreeMap<ServiceName, bool> {
        self.inner.read().clone()
    }
    pub fn all_ready(&self) -> bool {
        self.inner.read().values().all(|v| *v)
    }
}

```

### crates/ron-metrics/src/labels.rs
<a id="crates-ron-metrics-src-labels-rs"></a>

```rust
//! RO:WHAT â€” Base label helpers (service, instance, build_version, amnesia).

use std::collections::HashMap;

#[derive(Clone, Debug)]
pub struct BaseLabels {
    pub service: String,
    pub instance: String,
    pub build_version: String,
    pub amnesia: String,
}

impl BaseLabels {
    pub fn to_const_labels(&self) -> HashMap<String, String> {
        let mut m = HashMap::with_capacity(4);
        m.insert("service".into(), self.service.clone());
        m.insert("instance".into(), self.instance.clone());
        m.insert("build_version".into(), self.build_version.clone());
        m.insert("amnesia".into(), self.amnesia.clone());
        m
    }
}

```

### crates/ron-metrics/src/lib.rs
<a id="crates-ron-metrics-src-lib-rs"></a>

```rust
//! RO:WHAT â€” Public faÃ§ade for ron-metrics: golden families, health/readiness, HTTP exposer.
//! RO:WHY  â€” Pillar 5 Observability; Concerns: PERF/RES/GOV.
//! RO:INTERACTS â€” crate::{metrics,registry,labels,health,readiness}, axum; prometheus Registry.
//! RO:INVARIANTS â€” single registration per process; GET-only; no lock across .await; TLS type=tokio_rustls::rustls::ServerConfig.
//! RO:METRICS â€” service_restarts_total, bus_lagged_total, request_latency_seconds, exposition_latency_seconds, health_ready{service}.
//! RO:CONFIG â€” base labels include {service,instance,build_version,amnesia}; amnesia truthful.

#![forbid(unsafe_code)]

pub mod axum_latency;
pub mod axum_status;
pub mod build_info;
pub mod bus_watcher;
mod errors;
pub mod exporters;
pub mod exposer;
mod health;
mod labels;
mod metrics;
mod readiness;
mod registry;

pub use crate::errors::MetricsError;
pub use crate::health::HealthState;
pub use crate::labels::BaseLabels;
pub use crate::metrics::Metrics;
pub use crate::readiness::{ReadyJson, ReadyPolicy};
pub use crate::registry::SafeRegistry;

```

### crates/ron-metrics/src/metrics.rs
<a id="crates-ron-metrics-src-metrics-rs"></a>

```rust
//! RO:WHAT â€” Metrics facade and registry wiring for ron-metrics.
//! RO:WHY  â€” Single place to define/own metric families and expose helpers.
//! RO:INVARIANTS â€” no locks across .await; single registry instance; stable names.

use std::sync::Arc;

use crate::exposer::http::make_router;
use crate::health::HealthState;
use crate::readiness::ReadyPolicy; // <- import ReadyPolicy from the public module
use crate::registry::SafeRegistry;

use prometheus::{Histogram, HistogramOpts, IntCounterVec, IntGaugeVec, Opts};
use tokio::net::TcpListener;
use tokio::task::JoinHandle;

use crate::errors::MetricsError;
use crate::BaseLabels;

#[derive(Clone)]
pub struct Metrics {
    inner: Arc<Inner>,
}

struct Inner {
    registry: SafeRegistry,
    // Golden families
    pub service_restarts_total: IntCounterVec,
    pub bus_lagged_total: IntCounterVec,
    pub request_latency_seconds: Histogram,
    pub exposition_latency_seconds: Histogram,
    pub health_ready: IntGaugeVec,
    pub request_status_total: IntCounterVec,
    // Health state used by /healthz,/readyz
    pub health: HealthState,
}

impl Metrics {
    pub fn new(_base: BaseLabels, health: HealthState) -> Result<Self, MetricsError> {
        // Current SafeRegistry only exposes `new()`
        let registry = SafeRegistry::new();

        // ---- metric families ----
        let service_restarts_total = IntCounterVec::new(
            Opts::new("service_restarts_total", "Total restarts per component"),
            &["component"],
        )?;

        let bus_lagged_total = IntCounterVec::new(
            Opts::new("bus_lagged_total", "Overwrites due to lag/drop on bus"),
            &["bus"],
        )?;

        let request_latency_seconds = Histogram::with_opts(
            HistogramOpts::new("request_latency_seconds", "Request latency")
                .buckets(buckets::pow2_1ms_to_512ms()),
        )?;

        let exposition_latency_seconds = Histogram::with_opts(
            HistogramOpts::new("exposition_latency_seconds", "Latency to expose endpoints")
                .buckets(buckets::pow2_1ms_to_512ms()),
        )?;

        let health_ready =
            IntGaugeVec::new(Opts::new("health_ready", "Readiness (0/1)"), &["check"])?;

        let request_status_total = IntCounterVec::new(
            Opts::new("request_status_total", "Responses by status class"),
            &["status_class"],
        )?;

        // ---- register once with stable names ----
        registry.register("service_restarts_total", |r| {
            r.register(Box::new(service_restarts_total.clone()))
        })?;
        registry.register("bus_lagged_total", |r| {
            r.register(Box::new(bus_lagged_total.clone()))
        })?;
        registry.register("request_latency_seconds", |r| {
            r.register(Box::new(request_latency_seconds.clone()))
        })?;
        registry.register("exposition_latency_seconds", |r| {
            r.register(Box::new(exposition_latency_seconds.clone()))
        })?;
        registry.register("health_ready", |r| {
            r.register(Box::new(health_ready.clone()))
        })?;
        registry.register("request_status_total", |r| {
            r.register(Box::new(request_status_total.clone()))
        })?;

        Ok(Self {
            inner: Arc::new(Inner {
                registry,
                service_restarts_total,
                bus_lagged_total,
                request_latency_seconds,
                exposition_latency_seconds,
                health_ready,
                request_status_total,
                health,
            }),
        })
    }

    /// Exposer uses this to call `.gather()`.
    /// We return the wrapper so `exposer/http.rs` can do: `metrics.registry().gather()`.
    pub fn registry(&self) -> &SafeRegistry {
        &self.inner.registry
    }

    pub fn health(&self) -> &HealthState {
        &self.inner.health
    }

    // ---------- public helpers ----------

    pub fn inc_service_restart(&self, component: &str) {
        let _ = self
            .inner
            .service_restarts_total
            .with_label_values(&[component])
            .inc();
    }

    pub fn add_bus_lag(&self, bus: &str, overwritten: u64) {
        let _ = self
            .inner
            .bus_lagged_total
            .with_label_values(&[bus])
            .inc_by(overwritten);
    }

    pub fn observe_request(&self, seconds: f64) {
        self.inner.request_latency_seconds.observe(seconds);
    }

    /// Record status by class ("2xx", "4xx", ...)
    pub fn observe_status_class(&self, class: &str) {
        let _ = self
            .inner
            .request_status_total
            .with_label_values(&[class])
            .inc();
    }

    pub fn set_ready<S: Into<String>>(&self, check: S, ok: bool) {
        // avoid moving `check` twice
        let check_s: String = check.into();
        let n = if ok { 1 } else { 0 };
        let _ = self
            .inner
            .health_ready
            .with_label_values(&[&check_s])
            .set(n);
        self.inner.health.set(check_s, ok);
    }

    /// Spawn the HTTP server exposing /metrics,/healthz,/readyz
    pub async fn serve(
        self,
        addr: std::net::SocketAddr,
    ) -> Result<(JoinHandle<()>, std::net::SocketAddr), MetricsError> {
        let router = make_router(self.clone());
        let listener = TcpListener::bind(addr).await?;
        let local = listener.local_addr()?;
        let jh = tokio::spawn(async move {
            if let Err(e) = axum::serve(listener, router).await {
                tracing::error!(error=?e, "metrics HTTP server exited");
            }
        });
        Ok((jh, local))
    }

    /// Keep signature compatible with `exposer/http.rs` (it passes endpoint string)
    pub(crate) fn observe_exposition(&self, seconds: f64, _endpoint: &'static str) {
        self.inner.exposition_latency_seconds.observe(seconds);
    }

    /// Exposer expects a ready policy; keep default semantics
    pub fn ready_policy(&self) -> ReadyPolicy {
        ReadyPolicy::default()
    }
}

// Local buckets helper inside this module
pub mod buckets {
    pub fn pow2_1ms_to_512ms() -> Vec<f64> {
        // Explicit, strictly-increasing boundaries (10 buckets)
        // +Inf is implicit in Prometheus.
        [
            0.001, 0.002, 0.004, 0.008, 0.016, 0.032, 0.064, 0.128, 0.256, 0.512,
        ]
        .to_vec()
    }
}

```

### crates/ron-metrics/src/pq.rs
<a id="crates-ron-metrics-src-pq-rs"></a>

```rust
// PQ metrics placeholder (present even if zero): pq_kex_failures_total, etc.

```

### crates/ron-metrics/src/readiness.rs
<a id="crates-ron-metrics-src-readiness-rs"></a>

```rust
//! RO:WHAT â€” Ready JSON schema + policy helpers.

use serde::{Deserialize, Serialize};
use std::time::{Duration, SystemTime};

#[derive(Clone, Copy)]
pub struct ReadyPolicy {
    pub retry_after_secs: u64,
}
impl Default for ReadyPolicy {
    fn default() -> Self {
        Self {
            retry_after_secs: 5,
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ReadyJson {
    pub degraded: bool,
    #[serde(default)]
    pub missing: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retry_after: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub since: Option<u64>,
}

pub fn make_ready_json(
    all_ready: bool,
    missing: Vec<String>,
    policy: ReadyPolicy,
    since: SystemTime,
) -> ReadyJson {
    let since_secs = since
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    if all_ready {
        ReadyJson {
            degraded: false,
            missing: Vec::new(),
            retry_after: None,
            since: Some(since_secs),
        }
    } else {
        ReadyJson {
            degraded: true,
            missing,
            retry_after: Some(policy.retry_after_secs),
            since: Some(since_secs),
        }
    }
}

```

### crates/ron-metrics/src/registry.rs
<a id="crates-ron-metrics-src-registry-rs"></a>

```rust
//! RO:WHAT â€” Thin wrapper over prometheus::Registry preventing duplicate names.

use prometheus::{Error as PromError, Registry, Result as PromResult};
use std::collections::HashSet;
use std::sync::{Arc, Mutex};

#[derive(Clone)]
pub struct SafeRegistry {
    inner: Arc<Registry>,
    names: Arc<Mutex<HashSet<String>>>,
}

impl SafeRegistry {
    pub fn new() -> Self {
        Self {
            inner: Arc::new(Registry::new()),
            names: Arc::new(Mutex::new(HashSet::new())),
        }
    }

    pub fn register<F>(&self, family_name: &str, register_fn: F) -> PromResult<()>
    where
        F: FnOnce(&Registry) -> PromResult<()>,
    {
        let mut g = self.names.lock().unwrap();
        if !g.insert(family_name.to_string()) {
            // Return a real prometheus::Error so callers can map it.
            return Err(PromError::Msg(format!("duplicate family: {family_name}")));
        }
        drop(g);
        register_fn(&self.inner)
    }

    pub fn gather(&self) -> Vec<prometheus::proto::MetricFamily> {
        self.inner.gather()
    }

    pub fn raw(&self) -> &Registry {
        &self.inner
    }
}

```

### crates/ron-metrics/src/zk.rs
<a id="crates-ron-metrics-src-zk-rs"></a>

```rust
// ZK metrics placeholder (present even if zero): zk_verify_failures_total, zk_proof_latency_seconds.

```

### crates/ron-metrics/tests/bus_watcher.rs
<a id="crates-ron-metrics-tests-buswatcher-rs"></a>

```rust
#![cfg(feature = "bus")]
use ron_bus::{Bus, BusConfig, Event};
use ron_metrics::build_info::build_version;
use ron_metrics::bus_watcher::start_bus_watcher;
use ron_metrics::{BaseLabels, HealthState, Metrics};

#[tokio::test]
async fn watcher_maps_health_events() {
    let base = BaseLabels {
        service: "svc".into(),
        instance: "t".into(),
        build_version: build_version(),
        amnesia: "off".into(),
    };
    let bus = Bus::new(BusConfig::default().with_capacity(64)).expect("bus");
    let health = HealthState::new();
    let metrics = Metrics::new(base, health).unwrap();
    let _h = start_bus_watcher(metrics.clone(), &bus, "test");

    let tx = bus.sender();
    tx.send(Event::Health {
        service: "db".into(),
        ok: false,
    })
    .unwrap();
    tx.send(Event::Health {
        service: "cache".into(),
        ok: true,
    })
    .unwrap();

    tokio::time::sleep(std::time::Duration::from_millis(50)).await;
    let snap = metrics.health().snapshot();
    assert_eq!(snap.get("db"), Some(&false));
    assert_eq!(snap.get("cache"), Some(&true));

    tx.send(Event::Shutdown).unwrap();
}

```

### crates/ron-metrics/tests/health_ready.rs
<a id="crates-ron-metrics-tests-healthready-rs"></a>

```rust
use ron_metrics::HealthState;

#[test]
fn health_state_roundtrip() {
    let h = HealthState::new();
    h.set("db".to_string(), false);
    h.set("cache".to_string(), true);

    let snap = h.snapshot();
    assert_eq!(snap.get("db"), Some(&false));
    assert_eq!(snap.get("cache"), Some(&true));
    assert!(!h.all_ready());

    h.set("db".to_string(), true);
    assert!(h.all_ready());
}

```

### crates/ron-metrics/tests/http_endpoints.rs
<a id="crates-ron-metrics-tests-httpendpoints-rs"></a>

```rust
use axum::body::Body; // request body type
use ron_metrics::build_info::build_version;
use ron_metrics::{BaseLabels, HealthState, Metrics};

use http_body_util::BodyExt; // for .collect().to_bytes()
use hyper::{Request, StatusCode};
use hyper_util::client::legacy::{connect::HttpConnector, Client};
use hyper_util::rt::TokioExecutor;
use std::net::SocketAddr;

#[tokio::test]
async fn http_endpoints_smoke() {
    let base = BaseLabels {
        service: "test-svc".into(),
        instance: "itest-1".into(),
        build_version: build_version(),
        amnesia: "off".into(),
    };
    let health = HealthState::new();
    health.set("config_loaded".into(), true);
    health.set("db".into(), false);

    let metrics = Metrics::new(base, health).expect("metrics new");

    let (_jh, addr) = metrics
        .clone()
        .serve("127.0.0.1:0".parse::<SocketAddr>().unwrap())
        .await
        .expect("serve");

    // Hyper 1.x client via hyper-util
    let connector = HttpConnector::new();
    let client: Client<_, Body> = Client::builder(TokioExecutor::new()).build(connector);

    // /healthz -> 200
    let resp = client
        .request(
            Request::builder()
                .uri(format!("http://{addr}/healthz"))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    assert_eq!(resp.status(), StatusCode::OK);

    // /readyz -> 503 (db=false) + Retry-After + JSON body
    let resp = client
        .request(
            Request::builder()
                .uri(format!("http://{addr}/readyz"))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    assert_eq!(resp.status(), StatusCode::SERVICE_UNAVAILABLE);
    assert!(resp.headers().get(hyper::header::RETRY_AFTER).is_some());
    let body_bytes = resp
        .into_body()
        .collect()
        .await
        .expect("collect body")
        .to_bytes();
    let v: serde_json::Value = serde_json::from_slice(&body_bytes).unwrap();
    assert!(v.get("degraded").and_then(|b| b.as_bool()).unwrap());

    // flip -> ready
    metrics.set_ready("db", true);
    let resp = client
        .request(
            Request::builder()
                .uri(format!("http://{addr}/readyz"))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    assert_eq!(resp.status(), StatusCode::OK);

    // /metrics -> 200 text/plain
    let resp = client
        .request(
            Request::builder()
                .uri(format!("http://{addr}/metrics"))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
    let ctype = resp
        .headers()
        .get(hyper::header::CONTENT_TYPE)
        .unwrap()
        .to_str()
        .unwrap();
    assert!(ctype.starts_with("text/plain"));
}

```

### crates/ron-metrics/tests/http_status_counter.rs
<a id="crates-ron-metrics-tests-httpstatuscounter-rs"></a>

```rust
//! Ensures request_status_total increments and the latency histogram encodes.

use axum::{routing::get, Router};
use ron_metrics::build_info::build_version;
use ron_metrics::{
    axum_latency, axum_status, exposer::http::make_router, BaseLabels, HealthState, Metrics,
};
use std::net::SocketAddr;
use tokio::time::{sleep, Duration};

#[tokio::test]
async fn status_counter_and_latency_move() {
    let base = BaseLabels {
        service: "test-svc".into(),
        instance: "test-1".into(),
        build_version: build_version(),
        amnesia: "off".into(),
    };
    let health = HealthState::new();
    health.set("config_loaded".into(), true);
    let metrics = Metrics::new(base, health).expect("metrics");

    let app = Router::new()
        .route("/ping", get(|| async { "pong" }))
        .merge(make_router(metrics.clone()));
    let app = axum_latency::attach(app, metrics.clone());
    let app = axum_status::attach(app, metrics.clone());

    let listener = tokio::net::TcpListener::bind(SocketAddr::from(([127, 0, 0, 1], 0)))
        .await
        .unwrap();
    let addr = listener.local_addr().unwrap();

    let jh = tokio::spawn(async move { axum::serve(listener, app).await.unwrap() });

    // exercise endpoints
    let _ = reqwest::get(format!("http://{addr}/ping"))
        .await
        .unwrap()
        .text()
        .await
        .unwrap();
    sleep(Duration::from_millis(10)).await;

    // pull metrics text
    let body = reqwest::get(format!("http://{addr}/metrics"))
        .await
        .unwrap()
        .text()
        .await
        .unwrap();

    // assert status counter moved (2xx)
    assert!(
        body.contains("request_status_total{status_class=\"2xx\"}"),
        "missing 2xx counter"
    );
    // assert latency histogram exported (count present)
    assert!(
        body.contains("request_latency_seconds_count"),
        "missing latency count"
    );

    drop(jh);
}

```

### crates/ron-metrics/tests/integration_http_endpoints.rs
<a id="crates-ron-metrics-tests-integrationhttpendpoints-rs"></a>

```rust
// Ensures /metrics, /healthz, /readyz status/headers/body shapes (scaffold placeholder).
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/loom_shutdown.rs
<a id="crates-ron-metrics-tests-loomshutdown-rs"></a>

```rust
// Loom-gated shutdown sequencing (no locks across .await) â€” scaffold placeholder.
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/metrics_encode_ok.rs
<a id="crates-ron-metrics-tests-metricsencodeok-rs"></a>

```rust
use prometheus::{Encoder, TextEncoder};
use ron_metrics::build_info::build_version;
use ron_metrics::{BaseLabels, HealthState, Metrics};

#[test]
fn metrics_encode_ok() {
    let base = BaseLabels {
        service: "test-svc".into(),
        instance: "test-1".into(),
        build_version: build_version(),
        amnesia: "off".into(),
    };
    let health = HealthState::new();
    health.set("config_loaded".into(), true);

    let metrics = Metrics::new(base, health).expect("metrics new");
    metrics.inc_service_restart("worker-A");
    metrics.add_bus_lag("kernel", 2);
    metrics.observe_request(0.002);

    let mf = metrics.registry().gather();
    assert!(!mf.is_empty(), "registry should have some families");

    let mut buf = Vec::new();
    let enc = TextEncoder::new();
    enc.encode(&mf, &mut buf).expect("encode");
    assert!(!buf.is_empty(), "prometheus text should be non-empty");
}

```

### crates/ron-metrics/tests/public_api.rs
<a id="crates-ron-metrics-tests-publicapi-rs"></a>

```rust
// Guards public symbol drift via cargo-public-api snapshots (scaffold placeholder).
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/readiness_semantics.rs
<a id="crates-ron-metrics-tests-readinesssemantics-rs"></a>

```rust
// Asserts fail-open reads / fail-closed writes and Retry-After semantics (scaffold placeholder).
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/taxonomy_labels.rs
<a id="crates-ron-metrics-tests-taxonomylabels-rs"></a>

```rust
// Verifies suffix discipline and base labels presence (scaffold placeholder).
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/vectors/interop/ron-metrics/readyz-degraded.json
<a id="crates-ron-metrics-tests-vectors-interop-ron-metrics-readyz-degraded-json"></a>

```json
{ "degraded": true, "missing": ["config_loaded","kernel_bus_attached"], "retry_after": 5 }

```

### crates/ron-metrics/tests/vectors/interop/ron-metrics/readyz-ready.json
<a id="crates-ron-metrics-tests-vectors-interop-ron-metrics-readyz-ready-json"></a>

```json
{ "degraded": false, "missing": [], "retry_after": 0 }

```

