<!-- Generated by scripts/make_crate_codex.sh on 2025-11-07T19:33:57Z -->
# Code Bundle — `svc-passport`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-passport/.github/workflows/ci.yml](#crates-svc-passport--github-workflows-ci-yml)
- [crates/svc-passport/.github/workflows/obs.yml](#crates-svc-passport--github-workflows-obs-yml)
- [crates/svc-passport/.github/workflows/render-mermaid.yml](#crates-svc-passport--github-workflows-render-mermaid-yml)
- [crates/svc-passport/Cargo.toml](#crates-svc-passport-Cargo-toml)
- [crates/svc-passport/benches/issue_bench.rs](#crates-svc-passport-benches-issuebench-rs)
- [crates/svc-passport/config/default.toml](#crates-svc-passport-config-default-toml)
- [crates/svc-passport/docker/docker-compose.yml](#crates-svc-passport-docker-docker-compose-yml)
- [crates/svc-passport/examples/issue_cli.rs](#crates-svc-passport-examples-issuecli-rs)
- [crates/svc-passport/fuzz/fuzz_targets/caveat_mutation.rs](#crates-svc-passport-fuzz-fuzztargets-caveatmutation-rs)
- [crates/svc-passport/fuzz/fuzz_targets/envelope_parse.rs](#crates-svc-passport-fuzz-fuzztargets-envelopeparse-rs)
- [crates/svc-passport/loom/rotation_loom.rs](#crates-svc-passport-loom-rotationloom-rs)
- [crates/svc-passport/rust-toolchain.toml](#crates-svc-passport-rust-toolchain-toml)
- [crates/svc-passport/scripts/inject_kms_latency.sh](#crates-svc-passport-scripts-injectkmslatency-sh)
- [crates/svc-passport/scripts/load_issue_profile.sh](#crates-svc-passport-scripts-loadissueprofile-sh)
- [crates/svc-passport/scripts/rotate_under_load.sh](#crates-svc-passport-scripts-rotateunderload-sh)
- [crates/svc-passport/src/bootstrap.rs](#crates-svc-passport-src-bootstrap-rs)
- [crates/svc-passport/src/bus/mod.rs](#crates-svc-passport-src-bus-mod-rs)
- [crates/svc-passport/src/bus/rpc.rs](#crates-svc-passport-src-bus-rpc-rs)
- [crates/svc-passport/src/config.rs](#crates-svc-passport-src-config-rs)
- [crates/svc-passport/src/dto/issue.rs](#crates-svc-passport-src-dto-issue-rs)
- [crates/svc-passport/src/dto/mod.rs](#crates-svc-passport-src-dto-mod-rs)
- [crates/svc-passport/src/dto/revoke.rs](#crates-svc-passport-src-dto-revoke-rs)
- [crates/svc-passport/src/dto/verify.rs](#crates-svc-passport-src-dto-verify-rs)
- [crates/svc-passport/src/error.rs](#crates-svc-passport-src-error-rs)
- [crates/svc-passport/src/health.rs](#crates-svc-passport-src-health-rs)
- [crates/svc-passport/src/http/handlers/healthz.rs](#crates-svc-passport-src-http-handlers-healthz-rs)
- [crates/svc-passport/src/http/handlers/issue.rs](#crates-svc-passport-src-http-handlers-issue-rs)
- [crates/svc-passport/src/http/handlers/mod.rs](#crates-svc-passport-src-http-handlers-mod-rs)
- [crates/svc-passport/src/http/handlers/readyz.rs](#crates-svc-passport-src-http-handlers-readyz-rs)
- [crates/svc-passport/src/http/handlers/revoke.rs](#crates-svc-passport-src-http-handlers-revoke-rs)
- [crates/svc-passport/src/http/handlers/verify.rs](#crates-svc-passport-src-http-handlers-verify-rs)
- [crates/svc-passport/src/http/middleware.rs](#crates-svc-passport-src-http-middleware-rs)
- [crates/svc-passport/src/http/mod.rs](#crates-svc-passport-src-http-mod-rs)
- [crates/svc-passport/src/http/router.rs](#crates-svc-passport-src-http-router-rs)
- [crates/svc-passport/src/kms/client.rs](#crates-svc-passport-src-kms-client-rs)
- [crates/svc-passport/src/kms/keyslot.rs](#crates-svc-passport-src-kms-keyslot-rs)
- [crates/svc-passport/src/kms/mod.rs](#crates-svc-passport-src-kms-mod-rs)
- [crates/svc-passport/src/kms/rotation.rs](#crates-svc-passport-src-kms-rotation-rs)
- [crates/svc-passport/src/lib.rs](#crates-svc-passport-src-lib-rs)
- [crates/svc-passport/src/main.rs](#crates-svc-passport-src-main-rs)
- [crates/svc-passport/src/metrics.rs](#crates-svc-passport-src-metrics-rs)
- [crates/svc-passport/src/policy/eval.rs](#crates-svc-passport-src-policy-eval-rs)
- [crates/svc-passport/src/policy/mod.rs](#crates-svc-passport-src-policy-mod-rs)
- [crates/svc-passport/src/state/audit.rs](#crates-svc-passport-src-state-audit-rs)
- [crates/svc-passport/src/state/issuer.rs](#crates-svc-passport-src-state-issuer-rs)
- [crates/svc-passport/src/state/mod.rs](#crates-svc-passport-src-state-mod-rs)
- [crates/svc-passport/src/telemetry/mod.rs](#crates-svc-passport-src-telemetry-mod-rs)
- [crates/svc-passport/src/telemetry/prometheus.rs](#crates-svc-passport-src-telemetry-prometheus-rs)
- [crates/svc-passport/src/telemetry/tracing_init.rs](#crates-svc-passport-src-telemetry-tracinginit-rs)
- [crates/svc-passport/src/token/attenuate.rs](#crates-svc-passport-src-token-attenuate-rs)
- [crates/svc-passport/src/token/caveat.rs](#crates-svc-passport-src-token-caveat-rs)
- [crates/svc-passport/src/token/encode.rs](#crates-svc-passport-src-token-encode-rs)
- [crates/svc-passport/src/token/macaroon.rs](#crates-svc-passport-src-token-macaroon-rs)
- [crates/svc-passport/src/token/mod.rs](#crates-svc-passport-src-token-mod-rs)
- [crates/svc-passport/src/util/hashing.rs](#crates-svc-passport-src-util-hashing-rs)
- [crates/svc-passport/src/util/id.rs](#crates-svc-passport-src-util-id-rs)
- [crates/svc-passport/src/util/mod.rs](#crates-svc-passport-src-util-mod-rs)
- [crates/svc-passport/src/util/time.rs](#crates-svc-passport-src-util-time-rs)
- [crates/svc-passport/src/verify/mod.rs](#crates-svc-passport-src-verify-mod-rs)
- [crates/svc-passport/src/verify/preflight.rs](#crates-svc-passport-src-verify-preflight-rs)
- [crates/svc-passport/testing/profiles/issue_80_20_local.json](#crates-svc-passport-testing-profiles-issue8020local-json)
- [crates/svc-passport/tests/api_issue.rs](#crates-svc-passport-tests-apiissue-rs)
- [crates/svc-passport/tests/api_revoke.rs](#crates-svc-passport-tests-apirevoke-rs)
- [crates/svc-passport/tests/api_verify.rs](#crates-svc-passport-tests-apiverify-rs)
- [crates/svc-passport/tests/invariants.rs](#crates-svc-passport-tests-invariants-rs)
- [crates/svc-passport/tests/readiness.rs](#crates-svc-passport-tests-readiness-rs)

### crates/svc-passport/.github/workflows/ci.yml
<a id="crates-svc-passport--github-workflows-ci-yml"></a>

```yaml
name: ci-scaffold
on: [push, pull_request]
jobs:
  noop:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "ci scaffold"

```

### crates/svc-passport/.github/workflows/obs.yml
<a id="crates-svc-passport--github-workflows-obs-yml"></a>

```yaml
name: obs-scaffold
on: [push, pull_request]
jobs:
  noop:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "obs scaffold"

```

### crates/svc-passport/.github/workflows/render-mermaid.yml
<a id="crates-svc-passport--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid-scaffold
on: [push, pull_request]
jobs:
  noop:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "render scaffold"

```

### crates/svc-passport/Cargo.toml
<a id="crates-svc-passport-Cargo-toml"></a>

```toml
[package]
name = "svc-passport"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[lib]
name = "svc_passport"
path = "src/lib.rs"

[[bin]]
name = "svc-passport"
path = "src/main.rs"

[features]
# Enable dev-kms by default so the crate runs out-of-the-box.
default = ["with-metrics", "dev-kms"]
dalek-batch = []
parallel-batch = []
with-metrics = []
bus-rpc = []
dev-kms = ["dep:ed25519-dalek", "dep:rand_core"]

[dependencies]
# RON workspace crates
ron-kernel = { path = "../ron-kernel" }
ron-policy = { path = "../ron-policy" }

# Async/HTTP stack (match workspace pins explicitly)
tokio = { workspace = true, features = ["macros","rt-multi-thread","signal","time","io-util","sync","net","fs"] }
axum  = { workspace = true, default-features = false, features = ["tokio","http1","http2","json"] }
# IMPORTANT: explicitly mirror workspace tower settings to avoid 0.4/0.5 splits
tower = { workspace = true, default-features = false, features = ["util"] }
tower-http = { workspace = true, features = ["trace"] }
http  = { workspace = true }
# hyper/hyper-util are fine to keep local
hyper = { version = "1", features = ["http1","http2","server"] }
hyper-util = "0.1"

# Metrics/obs
prometheus = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true, features = ["fmt","env-filter"] }

# Serde / JSON / config / time
serde      = { workspace = true, features = ["derive"] }
serde_json = { workspace = true }
toml       = { workspace = true }
time       = { version = "0.3", features = ["formatting","parsing","macros"] }
uuid       = { version = "1", features = ["v4"] }
base64     = "0.22"

# Concurrency / utils
parking_lot = { workspace = true }
once_cell   = { workspace = true }

# Errors
thiserror = { workspace = true }   # aligns to workspace (v1) to avoid dupes
anyhow    = { workspace = true }

# Async trait for dyn-safe async methods
async-trait = "0.1"

# Zeroization
zeroize = "1"

# Dev KMS (optional; enabled by dev-kms feature)
ed25519-dalek = { version = "2", features = ["rand_core","serde"], optional = true }
rand_core     = { version = "0.6", features = ["getrandom"], optional = true }

[dev-dependencies]
reqwest = { workspace = true, features = ["rustls-tls-native-roots","json"] }
tokio   = { workspace = true, features = ["macros","rt-multi-thread","time"] }

```

### crates/svc-passport/benches/issue_bench.rs
<a id="crates-svc-passport-benches-issuebench-rs"></a>

```rust
// Criterion bench scaffold: /issue path
fn main() { /* bench placeholder */
}

```

### crates/svc-passport/config/default.toml
<a id="crates-svc-passport-config-default-toml"></a>

```toml
# RO:WHAT — Default config for svc-passport (dev-friendly)
[server]
bind = "127.0.0.1:5307"
admin_bind = "127.0.0.1:5308"

[passport]
issuer = "svc-passport"
default_ttl_s = 3600
max_ttl_s = 86400
clock_skew_s = 120

[verify]
target_batch = 64
max_batch = 256
max_wait_us = 500

[cache]
vk_ttl_s = 60
jwks_ttl_s = 60

[limits]
max_msg_bytes = 4096
max_batch = 512

[security]
require_aud = true

```

### crates/svc-passport/docker/docker-compose.yml
<a id="crates-svc-passport-docker-docker-compose-yml"></a>

```yaml
version: "3.9"
services:
  svc-passport2:
    image: svcpassport2:scaffold
    build:
      context: ..
      dockerfile: docker/Dockerfile

```

### crates/svc-passport/examples/issue_cli.rs
<a id="crates-svc-passport-examples-issuecli-rs"></a>

```rust
// Minimal example scaffold: issues a passport via HTTP (to be implemented)
fn main() {
    println!("issue_cli scaffold");
}

```

### crates/svc-passport/fuzz/fuzz_targets/caveat_mutation.rs
<a id="crates-svc-passport-fuzz-fuzztargets-caveatmutation-rs"></a>

```rust
#![no_main]
// Fuzz target scaffold: caveat_mutation
use libfuzzer_sys::fuzz_target;
fuzz_target!(|_data: &[u8]| {
    // TODO
});

```

### crates/svc-passport/fuzz/fuzz_targets/envelope_parse.rs
<a id="crates-svc-passport-fuzz-fuzztargets-envelopeparse-rs"></a>

```rust
#![no_main]
// Fuzz target scaffold: envelope_parse
use libfuzzer_sys::fuzz_target;
fuzz_target!(|_data: &[u8]| {
    // TODO
});

```

### crates/svc-passport/loom/rotation_loom.rs
<a id="crates-svc-passport-loom-rotationloom-rs"></a>

```rust
// Loom model scaffold for rotation/mint interleavings
#[test] fn loom_rotation_scaffold() { assert!(true); }

```

### crates/svc-passport/rust-toolchain.toml
<a id="crates-svc-passport-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/svc-passport/scripts/inject_kms_latency.sh
<a id="crates-svc-passport-scripts-injectkmslatency-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "[scaffold] inject_kms_latency.sh <latency>" >&2

```

### crates/svc-passport/scripts/load_issue_profile.sh
<a id="crates-svc-passport-scripts-loadissueprofile-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "[scaffold] load_issue_profile.sh <profile.json>" >&2

```

### crates/svc-passport/scripts/rotate_under_load.sh
<a id="crates-svc-passport-scripts-rotateunderload-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "[scaffold] rotate_under_load.sh" >&2

```

### crates/svc-passport/src/bootstrap.rs
<a id="crates-svc-passport-src-bootstrap-rs"></a>

```rust
//! Boot the svc-passport HTTP server.

use std::net::SocketAddr;

use axum::Router;
use tokio::net::TcpListener;

use crate::{
    config::Config, health::Health, http::router::build_router, state::issuer::IssuerState,
};

/// Start the HTTP server. Binds, builds router+state, and serves until Ctrl-C.
pub async fn run(cfg: Config, issuer: IssuerState) -> anyhow::Result<()> {
    // Bind listener
    let addr: SocketAddr = cfg.server.bind.parse()?;
    let listener = TcpListener::bind(addr).await?;

    // Health (use Default or adjust to Health::new() if that's your ctor)
    let health: Health = Default::default();

    // Build the app with state
    let app: Router<IssuerState> = build_router(cfg.clone(), health).with_state(issuer);

    // Axum 0.7: pass the Router directly; no into_make_service()
    let server = axum::serve(listener, app).with_graceful_shutdown(shutdown_signal());

    // Await and map error cleanly
    if let Err(e) = server.await {
        return Err(anyhow::Error::new(e));
    }
    Ok(())
}

async fn shutdown_signal() {
    let _ = tokio::signal::ctrl_c().await;
}

```

### crates/svc-passport/src/bus/mod.rs
<a id="crates-svc-passport-src-bus-mod-rs"></a>

```rust
//! Experimental Bus RPC surface (scaffold). HTTP remains canonical.
pub mod rpc;

```

### crates/svc-passport/src/bus/rpc.rs
<a id="crates-svc-passport-src-bus-rpc-rs"></a>

```rust
//! mint_cap RPC handler stubs (scaffold).

```

### crates/svc-passport/src/config.rs
<a id="crates-svc-passport-src-config-rs"></a>

```rust
//! RO:WHAT — Service configuration model + loader (env/file), with sane defaults.

use serde::Deserialize;
use std::{env, fs, path::Path};

#[derive(Debug, Clone, Deserialize)]
pub struct Config {
    pub server: Server,
    pub passport: Passport,
    pub verify: VerifyPolicy,
    pub cache: Cache,
    pub limits: Limits,
    pub security: Security,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Server {
    pub bind: String,
    pub admin_bind: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Passport {
    pub issuer: String,
    pub default_ttl_s: u64,
    pub max_ttl_s: u64,
    pub clock_skew_s: i64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct VerifyPolicy {
    pub target_batch: usize,
    pub max_batch: usize,
    pub max_wait_us: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Cache {
    pub vk_ttl_s: u64,
    pub jwks_ttl_s: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Limits {
    pub max_msg_bytes: usize,
    pub max_batch: usize,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Security {
    pub require_aud: bool,
}

impl Config {
    pub fn load() -> anyhow::Result<Self> {
        if let Ok(s) = env::var("PASSPORT_CONFIG") {
            return Ok(toml::from_str(&s)?);
        }
        let path = env::var("PASSPORT_CONFIG_FILE")
            .unwrap_or_else(|_| "crates/svc-passport/config/default.toml".to_string());
        let text = fs::read_to_string(Path::new(&path))?;
        Ok(toml::from_str(&text)?)
    }
}

```

### crates/svc-passport/src/dto/issue.rs
<a id="crates-svc-passport-src-dto-issue-rs"></a>

```rust
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct IssueRequest {
    pub sub: String,
    pub aud: Vec<String>,
    pub scopes: Vec<String>,
    #[serde(default)]
    pub ctx: Option<Value>,
    #[serde(default)]
    pub ttl_s: Option<u64>,
    #[serde(default)]
    pub nbf: Option<i64>,
    #[serde(default)]
    pub nonce: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct IssueResponse {
    pub envelope: super::verify::Envelope,
}

```

### crates/svc-passport/src/dto/mod.rs
<a id="crates-svc-passport-src-dto-mod-rs"></a>

```rust
//! RO:WHAT — Stable JSON DTOs for issue/verify/revoke (deny unknown fields).
pub mod issue;
pub mod revoke;
pub mod verify;

```

### crates/svc-passport/src/dto/revoke.rs
<a id="crates-svc-passport-src-dto-revoke-rs"></a>

```rust
#![allow(dead_code)]
use serde::Deserialize;

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct RevokeRequest {
    pub jti: String,
}

```

### crates/svc-passport/src/dto/verify.rs
<a id="crates-svc-passport-src-dto-verify-rs"></a>

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Envelope {
    pub alg: String,
    pub kid: String,
    pub sig_b64: String,
    pub msg_b64: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct VerifyRequest {
    pub envelope: Envelope,
}

#[derive(Debug, Serialize)]
pub struct VerifyResponse {
    pub ok: bool,
    pub reason: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct VerifyBatchRequest {
    pub envelopes: Vec<Envelope>,
}

#[derive(Debug, Serialize)]
pub struct VerifyBatchResponse {
    pub results: Vec<VerifyResult>,
}

#[derive(Debug, Serialize)]
pub struct VerifyResult {
    pub ok: bool,
    pub reason: Option<String>,
}

```

### crates/svc-passport/src/error.rs
<a id="crates-svc-passport-src-error-rs"></a>

```rust
//! RO:WHAT — Error taxonomy (stable, machine-parseable) and IntoResponse mapping.
//! RO:WHY  — Deterministic client behavior, SDK-friendly.
//! RO:INVARIANTS — No secrets in messages; stable codes.

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("malformed")]
    Malformed,
    #[error("verify_failed")]
    VerifyFailed,
    #[error("expired")]
    Expired,
    #[error("nbf")]
    NotBefore,
    #[error("bad_aud")]
    BadAudience,
    #[error("unknown_kid")]
    UnknownKid,
    #[error("scope_denied")]
    ScopeDenied,
    #[error("internal")]
    Internal(anyhow::Error),
}

#[derive(Serialize)]
pub struct Problem<'a> {
    code: &'a str,
    message: &'a str,
    retryable: bool,
}

impl IntoResponse for Error {
    fn into_response(self) -> Response {
        let (code, msg, status, retryable) = match &self {
            Error::Malformed => (
                "malformed",
                "bad request body",
                StatusCode::BAD_REQUEST,
                false,
            ),
            Error::VerifyFailed => (
                "verify_failed",
                "signature did not verify",
                StatusCode::UNAUTHORIZED,
                false,
            ),
            Error::Expired => ("expired", "token expired", StatusCode::UNAUTHORIZED, false),
            Error::NotBefore => ("nbf", "token not valid yet", StatusCode::UNAUTHORIZED, true),
            Error::BadAudience => ("bad_aud", "audience denied", StatusCode::FORBIDDEN, false),
            Error::UnknownKid => (
                "unknown_kid",
                "unknown verifying key",
                StatusCode::UNAUTHORIZED,
                true,
            ),
            Error::ScopeDenied => (
                "scope_denied",
                "capability denied",
                StatusCode::FORBIDDEN,
                false,
            ),
            Error::Internal(_) => (
                "internal",
                "internal error",
                StatusCode::INTERNAL_SERVER_ERROR,
                true,
            ),
        };
        let body = Json(Problem {
            code,
            message: msg,
            retryable,
        });
        (status, body).into_response()
    }
}

impl From<anyhow::Error> for Error {
    fn from(e: anyhow::Error) -> Self {
        Error::Internal(e)
    }
}

```

### crates/svc-passport/src/health.rs
<a id="crates-svc-passport-src-health-rs"></a>

```rust
//! Health/Readiness wrappers.

use ron_kernel::metrics::{health::HealthState, readiness::Readiness};

#[derive(Clone)]
pub struct Health {
    pub health: HealthState,
    pub ready: Readiness,
}

impl Health {
    pub fn new() -> Self {
        let health = HealthState::new();
        let ready = Readiness::new(health.clone());
        Self { health, ready }
    }
}

// Clippy asked for this; also makes it easy to construct.
impl Default for Health {
    fn default() -> Self {
        Self::new()
    }
}

```

### crates/svc-passport/src/http/handlers/healthz.rs
<a id="crates-svc-passport-src-http-handlers-healthz-rs"></a>

```rust
//! RO:WHAT — GET /healthz (passthrough to ron-kernel health).
use axum::response::IntoResponse;
use ron_kernel::metrics::health::HealthState;

pub async fn healthz(h: HealthState) -> impl IntoResponse {
    if h.all_ready() {
        "ok"
    } else {
        "degraded"
    }
}

```

### crates/svc-passport/src/http/handlers/issue.rs
<a id="crates-svc-passport-src-http-handlers-issue-rs"></a>

```rust
// RO:WHAT   Issue endpoints: sign payload -> envelope; jwks; rotate; attest.

use crate::{error::Error, state::issuer::IssuerState};
use axum::{extract::State, http::StatusCode, Json};
use serde_json::Value;

/// POST /v1/passport/issue  { ...arbitrary JSON payload... }
/// Returns: Envelope { alg,kid,msg_b64,sig_b64 }
pub async fn issue(
    State(issuer): State<IssuerState>,
    Json(payload): Json<Value>,
) -> Result<(StatusCode, Json<crate::dto::verify::Envelope>), Error> {
    let bytes = serde_json::to_vec(&payload).map_err(|_| Error::Malformed)?;
    let (kid, sig) = issuer.sign(&bytes).await?;
    let env = issuer.build_envelope(kid, bytes, sig);
    Ok((StatusCode::OK, Json(env)))
}

/// GET /v1/keys  -> JWKS/keys doc
pub async fn keys(
    State(issuer): State<IssuerState>,
) -> Result<(StatusCode, Json<serde_json::Value>), Error> {
    let jwks = issuer.jwks().await?;
    Ok((StatusCode::OK, Json(jwks)))
}

/// POST /admin/rotate  -> { kid }
pub async fn rotate(
    State(issuer): State<IssuerState>,
) -> Result<(StatusCode, Json<serde_json::Value>), Error> {
    let kid = issuer.rotate().await?;
    Ok((StatusCode::OK, Json(serde_json::json!({ "kid": kid }))))
}

/// GET /admin/attest  -> attestation doc
pub async fn attest(
    State(issuer): State<IssuerState>,
) -> Result<(StatusCode, Json<serde_json::Value>), Error> {
    let doc = issuer.attest().await?;
    Ok((StatusCode::OK, Json(doc)))
}

```

### crates/svc-passport/src/http/handlers/mod.rs
<a id="crates-svc-passport-src-http-handlers-mod-rs"></a>

```rust
pub mod healthz;
pub mod issue;
pub mod readyz;
pub mod revoke;
pub mod verify;

```

### crates/svc-passport/src/http/handlers/readyz.rs
<a id="crates-svc-passport-src-http-handlers-readyz-rs"></a>

```rust
//! RO:WHAT — GET /readyz handled in bootstrap via ron-kernel readiness handler.
//! RO:WHY  — Keep handler here for symmetry if needed later.
#![allow(dead_code)]

```

### crates/svc-passport/src/http/handlers/revoke.rs
<a id="crates-svc-passport-src-http-handlers-revoke-rs"></a>

```rust
//! RO:WHAT — (stub) Revocation endpoint; Bronze stores nonce/jti in-memory with TTL.
//! RO:WHY  — Demonstrate shape; Silver will back by CAS/index if needed.
#![allow(dead_code)]

```

### crates/svc-passport/src/http/handlers/verify.rs
<a id="crates-svc-passport-src-http-handlers-verify-rs"></a>

```rust
// RO:WHAT   Verify endpoints: single and batch.

use crate::{dto::verify::Envelope, error::Error, state::issuer::IssuerState};
use axum::{extract::State, http::StatusCode, Json};

/// POST /v1/passport/verify  Envelope -> bool
pub async fn verify_one(
    State(issuer): State<IssuerState>,
    Json(env): Json<Envelope>,
) -> Result<(StatusCode, Json<bool>), Error> {
    let ok = issuer.verify_envelope(&env).await?;
    Ok((StatusCode::OK, Json(ok)))
}

/// POST /v1/passport/verify_batch  [Envelope] -> [bool]
pub async fn verify_batch(
    State(issuer): State<IssuerState>,
    Json(envs): Json<Vec<Envelope>>,
) -> Result<(StatusCode, Json<Vec<bool>>), Error> {
    let mut out = Vec::with_capacity(envs.len());
    for env in &envs {
        out.push(issuer.verify_envelope(env).await?);
    }
    Ok((StatusCode::OK, Json(out)))
}

```

### crates/svc-passport/src/http/middleware.rs
<a id="crates-svc-passport-src-http-middleware-rs"></a>

```rust
//! RO:WHAT — (stub) room for quotas/fair-queue/body caps if we front-door here.
//! RO:WHY  — Hardening blueprint hooks.
//! RO:INVARIANTS — keep simple for Bronze; svc-gateway can apply global guards.

#![allow(dead_code)]

```

### crates/svc-passport/src/http/mod.rs
<a id="crates-svc-passport-src-http-mod-rs"></a>

```rust
//! RO:WHAT — HTTP layer: router, middleware, and handlers.
//! RO:WHY  — Surface area kept small/boring; DTO hygiene.
//! RO:INVARIANTS — body caps, timeouts, deterministic errors.

pub mod handlers;
pub mod middleware;
pub mod router;

```

### crates/svc-passport/src/http/router.rs
<a id="crates-svc-passport-src-http-router-rs"></a>

```rust
// RO:WHAT   HTTP router assembly.
// RO:WHY    Use existing handlers in http/handlers; keep Router state as IssuerState only.

use crate::{
    config::Config,
    health::Health,
    kms::client::{DevKms, KmsClient},
    state::issuer::IssuerState,
};
use axum::{
    routing::{get, post},
    Router,
};
use std::sync::Arc;

// Import handlers directly from http/handlers
use crate::http::handlers::{issue, verify};

pub fn build_router(cfg: Config, _health: Health) -> Router<IssuerState> {
    // KMS client (dev by default)
    let kms: Arc<dyn KmsClient> = Arc::new(DevKms::new());
    let issuer = IssuerState::new(cfg.clone(), kms);

    Router::new()
        .route("/v1/passport/issue", post(issue::issue))
        .route("/v1/passport/verify", post(verify::verify_one))
        .route("/v1/passport/verify_batch", post(verify::verify_batch))
        .route("/v1/keys", get(issue::keys))
        .route("/admin/rotate", post(issue::rotate))
        .route("/admin/attest", get(issue::attest))
        .with_state(issuer)
}

```

### crates/svc-passport/src/kms/client.rs
<a id="crates-svc-passport-src-kms-client-rs"></a>

```rust
//! RO:WHAT — KmsClient trait; DevKms (ed25519-dalek) for dev/tests.
//! RO:INVARIANTS — versioned KID "ed25519/default/v{n}"
//! RO:NOTES — DevKms is feature-gated behind `dev-kms` and uses rand_core::OsRng.

use async_trait::async_trait;

#[async_trait]
pub trait KmsClient: Send + Sync {
    async fn sign(&self, msg: &[u8]) -> anyhow::Result<(String, Vec<u8>)>;
    async fn verify(&self, kid: &str, msg: &[u8], sig: &[u8]) -> anyhow::Result<bool>;
    async fn public_keys(&self) -> anyhow::Result<serde_json::Value>;
    async fn rotate(&self) -> anyhow::Result<String>;
    async fn attest(&self) -> anyhow::Result<serde_json::Value>;
}

#[cfg(feature = "dev-kms")]
mod dev {
    use super::*;
    use base64::engine::general_purpose::URL_SAFE_NO_PAD;
    use base64::Engine;
    use ed25519_dalek::{Signer, SigningKey, VerifyingKey};
    use parking_lot::RwLock;
    use rand_core::OsRng; // rand_core 0.6 — CSPRNG compatible with dalek v2
    use serde_json::json;
    use std::sync::atomic::{AtomicU64, Ordering};

    /// Simple in-proc KMS for dev/tests.
    pub struct DevKms {
        version: AtomicU64,
        head: RwLock<(SigningKey, VerifyingKey)>,
        history: RwLock<Vec<(String, VerifyingKey)>>, // (kid, vk)
    }

    impl Default for DevKms {
        fn default() -> Self {
            Self::new()
        }
    }

    impl DevKms {
        pub fn new() -> Self {
            // Use OsRng (rand_core 0.6) to satisfy dalek's CryptoRngCore bound.
            let mut csprng = OsRng;
            let sk = SigningKey::generate(&mut csprng);
            let vk = sk.verifying_key();
            let kid = "ed25519/default/v1".to_string();
            Self {
                version: AtomicU64::new(1),
                head: RwLock::new((sk, vk)),
                history: RwLock::new(vec![(kid, vk)]),
            }
        }

        fn current_kid(&self) -> String {
            format!("ed25519/default/v{}", self.version.load(Ordering::SeqCst))
        }
    }

    #[async_trait]
    impl KmsClient for DevKms {
        async fn sign(&self, msg: &[u8]) -> anyhow::Result<(String, Vec<u8>)> {
            let (sk, _vk) = &*self.head.read();
            let sig = sk.sign(msg).to_bytes().to_vec();
            Ok((self.current_kid(), sig))
        }

        async fn verify(&self, kid: &str, msg: &[u8], sig: &[u8]) -> anyhow::Result<bool> {
            // find vk by kid
            let vk = {
                let hist = self.history.read();
                hist.iter().find(|(k, _)| k == kid).map(|(_, v)| *v)
            }
            .ok_or_else(|| anyhow::anyhow!("unknown kid"))?;

            let Ok(sig) = ed25519_dalek::Signature::from_slice(sig) else {
                return Ok(false);
            };
            Ok(vk.verify_strict(msg, &sig).is_ok())
        }

        async fn public_keys(&self) -> anyhow::Result<serde_json::Value> {
            let keys: Vec<_> = {
                let hist = self.history.read();
                hist.iter()
                    .map(|(kid, vk)| {
                        json!({"kid": kid, "vk_b64": URL_SAFE_NO_PAD.encode(vk.to_bytes()), "alg":"Ed25519"})
                    })
                    .collect()
            };
            Ok(json!({"alg":"Ed25519","current": self.current_kid(), "keys": keys }))
        }

        async fn rotate(&self) -> anyhow::Result<String> {
            // Bump to a new key/version using OsRng again.
            let mut csprng = OsRng;
            let sk = SigningKey::generate(&mut csprng);
            let vk = sk.verifying_key();

            {
                let mut head = self.head.write();
                *head = (sk, vk);
            }
            let next = self.version.load(Ordering::SeqCst) + 1;
            self.version.store(next, Ordering::SeqCst);
            let kid = self.current_kid();
            self.history.write().push((kid.clone(), vk));
            Ok(kid)
        }

        async fn attest(&self) -> anyhow::Result<serde_json::Value> {
            self.public_keys().await
        }
    }
}

#[cfg(feature = "dev-kms")]
pub use dev::DevKms;

#[cfg(not(feature = "dev-kms"))]
compile_error!("Enable feature `dev-kms` or wire a real ron-kms client here.");

```

### crates/svc-passport/src/kms/keyslot.rs
<a id="crates-svc-passport-src-kms-keyslot-rs"></a>

```rust
//! RO:WHAT — Keyslot types (versioned KID newtype).
#[derive(Debug, Clone)]
pub struct KeyId(pub String);
impl std::fmt::Display for KeyId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

```

### crates/svc-passport/src/kms/mod.rs
<a id="crates-svc-passport-src-kms-mod-rs"></a>

```rust
//! RO:WHAT — KMS boundary (trait) + local dev implementation.
//! RO:WHY  — Swap to ron-kms without touching service code.

pub mod client;
pub mod keyslot;
pub mod rotation;

```

### crates/svc-passport/src/kms/rotation.rs
<a id="crates-svc-passport-src-kms-rotation-rs"></a>

```rust
//! RO:WHAT — Rotation helpers (admin plane).
#![allow(dead_code)]

```

### crates/svc-passport/src/lib.rs
<a id="crates-svc-passport-src-lib-rs"></a>

```rust
//! RO:WHAT — Library root for svc-passport: issue/verify Ed25519 "passports" with versioned KID.
//! RO:WHY  — P3 Identity & Keys; Concerns: SEC/RES/PERF. Short-TTL capability tokens with batch verify.
//! RO:INTERACTS — http::handlers, token::{encode,macaroon}, kms::client, state::issuer, policy::eval
//! RO:INVARIANTS — strict Ed25519 only; deterministic envelopes; no locks across .await
//! RO:METRICS — passport_ops_total, passport_failures_total, passport_op_latency_seconds, passport_batch_len
//! RO:CONFIG — see config.rs (ttl, batch, caps); /metrics + /healthz + /readyz via ron-kernel surfaces
//! RO:SECURITY — no ambient authority; admin routes gated; zeroize ephemeral secrets
//! RO:TEST — tests/* (API smoke), fuzz/* (envelope/caveat), loom/* (rotation under races)
#![forbid(unsafe_code)]

pub mod bootstrap;
pub mod config;
pub mod dto;
pub mod error;
pub mod health;
pub mod http;
pub mod kms;
pub mod metrics;
pub mod policy;
pub mod state;
pub mod telemetry;
pub mod token;
pub mod util;
pub mod verify;

pub use crate::config::Config;

```

### crates/svc-passport/src/main.rs
<a id="crates-svc-passport-src-main-rs"></a>

```rust
//! RO:WHAT — Binary entrypoint: loads config, boots HTTP, exposes /metrics,/healthz,/readyz.
//! RO:WHY  — Service wrapper around library surfaces.
//! RO:INTERACTS — bootstrap::run, telemetry::tracing_init
//! RO:INVARIANTS — truthful readiness; graceful shutdown; no locks across .await

use std::net::SocketAddr;
use svc_passport::{bootstrap, telemetry::tracing_init, Config};
use tracing::info;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_init::init();
    let cfg = Config::load()?;
    let bind: SocketAddr = cfg.server.bind.parse()?;
    let admin: SocketAddr = cfg.server.admin_bind.parse()?;

    let (_http, http_addr) = bootstrap::run(bind, admin, cfg).await?;
    info!(%http_addr, "svc-passport: listening");
    // Block until Ctrl-C
    tokio::signal::ctrl_c().await?;
    Ok(())
}

```

### crates/svc-passport/src/metrics.rs
<a id="crates-svc-passport-src-metrics-rs"></a>

```rust
//! RO:WHAT — Prometheus counters/histograms for passport ops.
//! RO:WHY  — Golden metrics & perf gates.
//! RO:INVARIANTS — Default registry; labels kept low-cardinality.

use once_cell::sync::Lazy;
use prometheus::{
    register_histogram, register_int_counter_vec, Histogram, HistogramOpts, IntCounterVec, Opts,
};

pub static OPS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        Opts::new("passport_ops_total", "passport operations total"),
        &["op", "result", "alg"]
    )
    .unwrap()
});

pub static FAILURES_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        Opts::new("passport_failures_total", "passport failures by reason"),
        &["reason"]
    )
    .unwrap()
});

pub static OP_LATENCY: Lazy<Histogram> = Lazy::new(|| {
    register_histogram!(
        HistogramOpts::new("passport_op_latency_seconds", "op latency").buckets(vec![
            0.0002, 0.0005, 0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1
        ])
    )
    .unwrap()
});

pub static BATCH_LEN: Lazy<Histogram> = Lazy::new(|| {
    register_histogram!(
        HistogramOpts::new("passport_batch_len", "verify batch length")
            .buckets(vec![1.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0])
    )
    .unwrap()
});

```

### crates/svc-passport/src/policy/eval.rs
<a id="crates-svc-passport-src-policy-eval-rs"></a>

```rust
#![allow(dead_code)]
//! RO:WHAT — (stub) Evaluate scopes/caveats vs requested operation; default allow.
pub fn allow() -> bool {
    true
}

```

### crates/svc-passport/src/policy/mod.rs
<a id="crates-svc-passport-src-policy-mod-rs"></a>

```rust
//! RO:WHAT — Policy adapter (deny-by-default); Bronze: allow all.
pub mod eval;

```

### crates/svc-passport/src/state/audit.rs
<a id="crates-svc-passport-src-state-audit-rs"></a>

```rust
#![allow(dead_code)]
//! RO:WHAT — (stub) Audit sink for issue/verify/revoke events; Bronze: no-op.

```

### crates/svc-passport/src/state/issuer.rs
<a id="crates-svc-passport-src-state-issuer-rs"></a>

```rust
// RO:WHAT   IssuerState: thin service state around a KMS client + helpers.
// RO:WHY    Handlers expect helpers: build_envelope, jwks, rotate, attest, verify_envelope.

use crate::{config::Config, dto::verify::Envelope, error::Error, kms::client::KmsClient};
use base64::{engine::general_purpose::STANDARD, Engine as _};
use parking_lot::RwLock;
use serde_json::Value;
use std::{collections::HashMap, sync::Arc};

#[derive(Clone)]
pub struct IssuerState {
    pub cfg: Config,
    pub kms: Arc<dyn KmsClient>,
    pub cache: Arc<RwLock<HashMap<String, ()>>>,
}

impl IssuerState {
    pub fn new(cfg: Config, kms: Arc<dyn KmsClient>) -> Self {
        Self {
            cfg,
            kms,
            cache: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Sign raw message bytes; returns (kid, signature).
    pub async fn sign(&self, msg: &[u8]) -> Result<(String, Vec<u8>), Error> {
        self.kms.sign(msg).await.map_err(Error::Internal)
    }

    /// Verify signature with kid; returns true/false.
    pub async fn verify(&self, kid: &str, msg: &[u8], sig: &[u8]) -> Result<bool, Error> {
        self.kms
            .verify(kid, msg, sig)
            .await
            .map_err(Error::Internal)
    }

    /// Build a transport envelope from parts.
    pub fn build_envelope(&self, kid: String, msg: Vec<u8>, sig: Vec<u8>) -> Envelope {
        Envelope {
            alg: "Ed25519".to_string(),
            kid,
            msg_b64: STANDARD.encode(msg),
            sig_b64: STANDARD.encode(sig),
        }
    }

    /// Public JWKS (placeholder until KMS exposes a real JWKS).
    pub async fn jwks(&self) -> Result<Value, Error> {
        Ok(serde_json::json!({ "keys": [] }))
    }

    /// Rotate active signing key; returns new kid.
    pub async fn rotate(&self) -> Result<String, Error> {
        self.kms.rotate().await.map_err(Error::Internal)
    }

    /// Attestation / device report passthrough.
    pub async fn attest(&self) -> Result<Value, Error> {
        self.kms.attest().await.map_err(Error::Internal)
    }

    /// Verify an Envelope payload by decoding b64 then consulting the KMS.
    pub async fn verify_envelope(&self, env: &Envelope) -> Result<bool, Error> {
        let msg = STANDARD
            .decode(&env.msg_b64)
            .map_err(|_| Error::Malformed)?;
        let sig = STANDARD
            .decode(&env.sig_b64)
            .map_err(|_| Error::Malformed)?;
        self.kms
            .verify(&env.kid, &msg, &sig)
            .await
            .map_err(Error::Internal)
    }
}

```

### crates/svc-passport/src/state/mod.rs
<a id="crates-svc-passport-src-state-mod-rs"></a>

```rust
//! RO:WHAT — Service state (issuer, audit).
pub mod audit;
pub mod issuer;

```

### crates/svc-passport/src/telemetry/mod.rs
<a id="crates-svc-passport-src-telemetry-mod-rs"></a>

```rust
pub mod prometheus;
pub mod tracing_init;

```

### crates/svc-passport/src/telemetry/prometheus.rs
<a id="crates-svc-passport-src-telemetry-prometheus-rs"></a>

```rust
use axum::{http::StatusCode, response::IntoResponse};
use prometheus::{Encoder, TextEncoder};
use ron_kernel::metrics::health::HealthState;

pub async fn metrics_handler() -> impl IntoResponse {
    let mf = prometheus::default_registry().gather();
    let mut buf = Vec::new();
    TextEncoder::new().encode(&mf, &mut buf).unwrap();
    (StatusCode::OK, buf)
}

pub async fn healthz_handler(h: HealthState) -> impl IntoResponse {
    if h.all_ready() {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    }
}

```

### crates/svc-passport/src/telemetry/tracing_init.rs
<a id="crates-svc-passport-src-telemetry-tracinginit-rs"></a>

```rust
//! RO:WHAT — Init tracing subscriber with env filter.
use tracing_subscriber::{fmt, EnvFilter};

pub fn init() {
    let _ = fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .with_target(false)
        .try_init();
}

```

### crates/svc-passport/src/token/attenuate.rs
<a id="crates-svc-passport-src-token-attenuate-rs"></a>

```rust
#![allow(dead_code)]
//! Placeholder helpers to attenuate scopes/caveats deterministically.

```

### crates/svc-passport/src/token/caveat.rs
<a id="crates-svc-passport-src-token-caveat-rs"></a>

```rust
#![allow(dead_code)]
//! Placeholder for caveat definitions & serialization rules.

```

### crates/svc-passport/src/token/encode.rs
<a id="crates-svc-passport-src-token-encode-rs"></a>

```rust
//! RO:WHAT — Canonical JSON payload + envelope (base64url, no pad).
//! RO:INVARIANTS — sorted keys; UTF-8 bytes; stable across languages.

use crate::{
    dto::{issue::IssueRequest, verify::Envelope},
    Config,
};
use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine;
use serde_json::{json, Value};
use time::OffsetDateTime;

pub fn canonical_payload(cfg: &Config, req: &IssueRequest) -> anyhow::Result<Value> {
    let now = OffsetDateTime::now_utc().unix_timestamp();
    let ttl = req
        .ttl_s
        .unwrap_or(cfg.passport.default_ttl_s)
        .min(cfg.passport.max_ttl_s);
    let iat = now;
    let exp = now + ttl as i64;
    let nbf = req.nbf.unwrap_or(iat);

    // Basic payload; kid is stamped after sign via IssuerState (KMS head)
    let payload = json!({
        "iss": cfg.passport.issuer,
        "sub": req.sub,
        "aud": req.aud,
        "iat": iat,
        "exp": exp,
        "nbf": nbf,
        "scopes": req.scopes,
        "nonce": req.nonce,
        "ctx": req.ctx
    });

    Ok(payload)
}

pub fn envelope(payload: &Value, kid: &str, sig: &[u8]) -> anyhow::Result<Envelope> {
    let msg = serde_json::to_vec(payload)?;
    Ok(Envelope {
        alg: "Ed25519".into(),
        kid: kid.to_string(),
        sig_b64: URL_SAFE_NO_PAD.encode(sig),
        msg_b64: URL_SAFE_NO_PAD.encode(&msg),
    })
}

pub fn decode_envelope(env: &Envelope) -> anyhow::Result<(Vec<u8>, Vec<u8>)> {
    let msg = URL_SAFE_NO_PAD.decode(&env.msg_b64)?;
    let sig = URL_SAFE_NO_PAD.decode(&env.sig_b64)?;
    Ok((msg, sig))
}

```

### crates/svc-passport/src/token/macaroon.rs
<a id="crates-svc-passport-src-token-macaroon-rs"></a>

```rust
//! RO:WHAT — (stub) Macaroon-like caveats; keep deterministic JSON for signing.
//! RO:NOTE — Silver+: add first-class caveat evaluation and attenuation.

#![allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Caveat {
    pub kind: String,
    pub value: String,
}

```

### crates/svc-passport/src/token/mod.rs
<a id="crates-svc-passport-src-token-mod-rs"></a>

```rust
//! RO:WHAT — Token primitives: canonical payload + envelope helpers.
pub mod attenuate;
pub mod caveat;
pub mod encode;
pub mod macaroon;

```

### crates/svc-passport/src/util/hashing.rs
<a id="crates-svc-passport-src-util-hashing-rs"></a>

```rust
//! RO:WHAT — (stub) Hash helpers if needed later.
#![allow(dead_code)]

```

### crates/svc-passport/src/util/id.rs
<a id="crates-svc-passport-src-util-id-rs"></a>

```rust
//! RO:WHAT — ID helpers (nonce/jti).
pub fn rand_nonce() -> String {
    uuid::Uuid::new_v4().to_string()
}

```

### crates/svc-passport/src/util/mod.rs
<a id="crates-svc-passport-src-util-mod-rs"></a>

```rust
pub mod hashing;
pub mod id;
pub mod time;

```

### crates/svc-passport/src/util/time.rs
<a id="crates-svc-passport-src-util-time-rs"></a>

```rust
//! RO:WHAT — Time helpers (UTC seconds).
pub fn now_s() -> i64 {
    time::OffsetDateTime::now_utc().unix_timestamp()
}

```

### crates/svc-passport/src/verify/mod.rs
<a id="crates-svc-passport-src-verify-mod-rs"></a>

```rust
//! RO:WHAT — Verify pipeline: preflight + crypto calls.
pub mod preflight;

```

### crates/svc-passport/src/verify/preflight.rs
<a id="crates-svc-passport-src-verify-preflight-rs"></a>

```rust
//! RO:WHAT — Cheap checks (iat/nbf/exp/aud size) before crypto.
//! RO:INVARIANTS — bounded skew; msg bytes parsed once.

use crate::{dto::verify::Envelope, error::Error, token::encode::decode_envelope, Config};
use serde_json::Value;
use time::OffsetDateTime;

pub fn time_window(cfg: &Config, env: &Envelope) -> Result<(), Error> {
    let (msg, _sig) = decode_envelope(env).map_err(|_| Error::Malformed)?;
    let v: Value = serde_json::from_slice(&msg).map_err(|_| Error::Malformed)?;
    let now = OffsetDateTime::now_utc().unix_timestamp();
    let skew = cfg.passport.clock_skew_s;

    let iat = v
        .get("iat")
        .and_then(|x| x.as_i64())
        .ok_or(Error::Malformed)?;
    let exp = v
        .get("exp")
        .and_then(|x| x.as_i64())
        .ok_or(Error::Malformed)?;
    let nbf = v.get("nbf").and_then(|x| x.as_i64()).unwrap_or(iat);

    if now + skew < nbf {
        return Err(Error::NotBefore);
    }
    if now - skew > exp {
        return Err(Error::Expired);
    }
    Ok(())
}

```

### crates/svc-passport/testing/profiles/issue_80_20_local.json
<a id="crates-svc-passport-testing-profiles-issue8020local-json"></a>

```json
{
  "description": "80% issue, 15% verify, 5% revoke (local)",
  "rps": 100,
  "duration_s": 60
}

```

### crates/svc-passport/tests/api_issue.rs
<a id="crates-svc-passport-tests-apiissue-rs"></a>

```rust
// Black-box test scaffold for /v1/passport/issue
#[test]
fn issue_scaffold() {
    assert!(true);
}

```

### crates/svc-passport/tests/api_revoke.rs
<a id="crates-svc-passport-tests-apirevoke-rs"></a>

```rust
// Black-box test scaffold for /v1/passport/revoke
#[test]
fn revoke_scaffold() {
    assert!(true);
}

```

### crates/svc-passport/tests/api_verify.rs
<a id="crates-svc-passport-tests-apiverify-rs"></a>

```rust
// Black-box test scaffold for /v1/passport/verify
#[test]
fn verify_scaffold() {
    assert!(true);
}

```

### crates/svc-passport/tests/invariants.rs
<a id="crates-svc-passport-tests-invariants-rs"></a>

```rust
// Property/invariant test scaffold: attenuation never widens authority.
#[test]
fn invariants_scaffold() {
    assert!(true);
}

```

### crates/svc-passport/tests/readiness.rs
<a id="crates-svc-passport-tests-readiness-rs"></a>

```rust
// Readiness gate scaffold
#[test]
fn readiness_scaffold() {
    assert!(true);
}

```

