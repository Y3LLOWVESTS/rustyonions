<!-- Generated by scripts/make_crate_codex.sh on 2025-11-08T15:20:29Z -->
# Code Bundle — `svc-passport`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-passport/.github/workflows/ci.yml](#crates-svc-passport--github-workflows-ci-yml)
- [crates/svc-passport/.github/workflows/obs.yml](#crates-svc-passport--github-workflows-obs-yml)
- [crates/svc-passport/.github/workflows/render-mermaid.yml](#crates-svc-passport--github-workflows-render-mermaid-yml)
- [crates/svc-passport/Cargo.toml](#crates-svc-passport-Cargo-toml)
- [crates/svc-passport/benches/issue_bench.rs](#crates-svc-passport-benches-issuebench-rs)
- [crates/svc-passport/benches/verify.rs](#crates-svc-passport-benches-verify-rs)
- [crates/svc-passport/config/default.toml](#crates-svc-passport-config-default-toml)
- [crates/svc-passport/docker/docker-compose.yml](#crates-svc-passport-docker-docker-compose-yml)
- [crates/svc-passport/examples/issue_cli.rs](#crates-svc-passport-examples-issuecli-rs)
- [crates/svc-passport/fuzz/fuzz_targets/caveat_mutation.rs](#crates-svc-passport-fuzz-fuzztargets-caveatmutation-rs)
- [crates/svc-passport/fuzz/fuzz_targets/envelope_parse.rs](#crates-svc-passport-fuzz-fuzztargets-envelopeparse-rs)
- [crates/svc-passport/loom/rotation_loom.rs](#crates-svc-passport-loom-rotationloom-rs)
- [crates/svc-passport/rust-toolchain.toml](#crates-svc-passport-rust-toolchain-toml)
- [crates/svc-passport/scripts/inject_kms_latency.sh](#crates-svc-passport-scripts-injectkmslatency-sh)
- [crates/svc-passport/scripts/load_issue_profile.sh](#crates-svc-passport-scripts-loadissueprofile-sh)
- [crates/svc-passport/scripts/rotate_under_load.sh](#crates-svc-passport-scripts-rotateunderload-sh)
- [crates/svc-passport/scripts/smoke_passport.sh](#crates-svc-passport-scripts-smokepassport-sh)
- [crates/svc-passport/src/bootstrap.rs](#crates-svc-passport-src-bootstrap-rs)
- [crates/svc-passport/src/bus/mod.rs](#crates-svc-passport-src-bus-mod-rs)
- [crates/svc-passport/src/bus/rpc.rs](#crates-svc-passport-src-bus-rpc-rs)
- [crates/svc-passport/src/config.rs](#crates-svc-passport-src-config-rs)
- [crates/svc-passport/src/dto/issue.rs](#crates-svc-passport-src-dto-issue-rs)
- [crates/svc-passport/src/dto/mod.rs](#crates-svc-passport-src-dto-mod-rs)
- [crates/svc-passport/src/dto/revoke.rs](#crates-svc-passport-src-dto-revoke-rs)
- [crates/svc-passport/src/dto/verify.rs](#crates-svc-passport-src-dto-verify-rs)
- [crates/svc-passport/src/error.rs](#crates-svc-passport-src-error-rs)
- [crates/svc-passport/src/health.rs](#crates-svc-passport-src-health-rs)
- [crates/svc-passport/src/http/handlers/healthz.rs](#crates-svc-passport-src-http-handlers-healthz-rs)
- [crates/svc-passport/src/http/handlers/issue.rs](#crates-svc-passport-src-http-handlers-issue-rs)
- [crates/svc-passport/src/http/handlers/mod.rs](#crates-svc-passport-src-http-handlers-mod-rs)
- [crates/svc-passport/src/http/handlers/readyz.rs](#crates-svc-passport-src-http-handlers-readyz-rs)
- [crates/svc-passport/src/http/handlers/revoke.rs](#crates-svc-passport-src-http-handlers-revoke-rs)
- [crates/svc-passport/src/http/handlers/verify.rs](#crates-svc-passport-src-http-handlers-verify-rs)
- [crates/svc-passport/src/http/middleware.rs](#crates-svc-passport-src-http-middleware-rs)
- [crates/svc-passport/src/http/mod.rs](#crates-svc-passport-src-http-mod-rs)
- [crates/svc-passport/src/http/router.rs](#crates-svc-passport-src-http-router-rs)
- [crates/svc-passport/src/kms/client.rs](#crates-svc-passport-src-kms-client-rs)
- [crates/svc-passport/src/kms/keyslot.rs](#crates-svc-passport-src-kms-keyslot-rs)
- [crates/svc-passport/src/kms/mod.rs](#crates-svc-passport-src-kms-mod-rs)
- [crates/svc-passport/src/kms/rotation.rs](#crates-svc-passport-src-kms-rotation-rs)
- [crates/svc-passport/src/lib.rs](#crates-svc-passport-src-lib-rs)
- [crates/svc-passport/src/main.rs](#crates-svc-passport-src-main-rs)
- [crates/svc-passport/src/metrics.rs](#crates-svc-passport-src-metrics-rs)
- [crates/svc-passport/src/policy/eval.rs](#crates-svc-passport-src-policy-eval-rs)
- [crates/svc-passport/src/policy/mod.rs](#crates-svc-passport-src-policy-mod-rs)
- [crates/svc-passport/src/state/audit.rs](#crates-svc-passport-src-state-audit-rs)
- [crates/svc-passport/src/state/issuer.rs](#crates-svc-passport-src-state-issuer-rs)
- [crates/svc-passport/src/state/mod.rs](#crates-svc-passport-src-state-mod-rs)
- [crates/svc-passport/src/telemetry/mod.rs](#crates-svc-passport-src-telemetry-mod-rs)
- [crates/svc-passport/src/telemetry/prometheus.rs](#crates-svc-passport-src-telemetry-prometheus-rs)
- [crates/svc-passport/src/telemetry/tracing_init.rs](#crates-svc-passport-src-telemetry-tracinginit-rs)
- [crates/svc-passport/src/test_support.rs](#crates-svc-passport-src-testsupport-rs)
- [crates/svc-passport/src/token/attenuate.rs](#crates-svc-passport-src-token-attenuate-rs)
- [crates/svc-passport/src/token/caveat.rs](#crates-svc-passport-src-token-caveat-rs)
- [crates/svc-passport/src/token/encode.rs](#crates-svc-passport-src-token-encode-rs)
- [crates/svc-passport/src/token/macaroon.rs](#crates-svc-passport-src-token-macaroon-rs)
- [crates/svc-passport/src/token/mod.rs](#crates-svc-passport-src-token-mod-rs)
- [crates/svc-passport/src/util/hashing.rs](#crates-svc-passport-src-util-hashing-rs)
- [crates/svc-passport/src/util/id.rs](#crates-svc-passport-src-util-id-rs)
- [crates/svc-passport/src/util/mod.rs](#crates-svc-passport-src-util-mod-rs)
- [crates/svc-passport/src/util/time.rs](#crates-svc-passport-src-util-time-rs)
- [crates/svc-passport/src/verify/mod.rs](#crates-svc-passport-src-verify-mod-rs)
- [crates/svc-passport/src/verify/preflight.rs](#crates-svc-passport-src-verify-preflight-rs)
- [crates/svc-passport/testing/profiles/issue_80_20_local.json](#crates-svc-passport-testing-profiles-issue8020local-json)
- [crates/svc-passport/tests/api_issue.rs](#crates-svc-passport-tests-apiissue-rs)
- [crates/svc-passport/tests/api_revoke.rs](#crates-svc-passport-tests-apirevoke-rs)
- [crates/svc-passport/tests/api_verify.rs](#crates-svc-passport-tests-apiverify-rs)
- [crates/svc-passport/tests/handlers.rs](#crates-svc-passport-tests-handlers-rs)
- [crates/svc-passport/tests/invariants.rs](#crates-svc-passport-tests-invariants-rs)
- [crates/svc-passport/tests/issuer.rs](#crates-svc-passport-tests-issuer-rs)
- [crates/svc-passport/tests/readiness.rs](#crates-svc-passport-tests-readiness-rs)

### crates/svc-passport/.github/workflows/ci.yml
<a id="crates-svc-passport--github-workflows-ci-yml"></a>

```yaml
name: ci-scaffold
on: [push, pull_request]
jobs:
  noop:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "ci scaffold"

```

### crates/svc-passport/.github/workflows/obs.yml
<a id="crates-svc-passport--github-workflows-obs-yml"></a>

```yaml
name: obs-scaffold
on: [push, pull_request]
jobs:
  noop:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "obs scaffold"

```

### crates/svc-passport/.github/workflows/render-mermaid.yml
<a id="crates-svc-passport--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid-scaffold
on: [push, pull_request]
jobs:
  noop:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "render scaffold"

```

### crates/svc-passport/Cargo.toml
<a id="crates-svc-passport-Cargo-toml"></a>

```toml
[package]
name = "svc-passport"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[lib]
name = "svc_passport"
path = "src/lib.rs"
bench = false          # avoid running the lib test harness as a bench

[[bin]]
name = "svc-passport"
path = "src/main.rs"

[features]
# Enable dev-kms by default so the crate runs out-of-the-box.
default = ["with-metrics", "dev-kms"]
dalek-batch = []
parallel-batch = []
with-metrics = []
bus-rpc = []
dev-kms = ["dep:ed25519-dalek", "dep:rand_core"]

[dependencies]
# RON workspace crates
ron-kernel = { path = "../ron-kernel" }
ron-policy = { path = "../ron-policy" }

# Async/HTTP stack (match workspace pins explicitly)
tokio = { workspace = true, features = ["macros","rt-multi-thread","signal","time","io-util","sync","net","fs"] }
axum  = { workspace = true, default-features = false, features = ["tokio","http1","http2","json"] }
# IMPORTANT: explicitly mirror workspace tower settings to avoid 0.4/0.5 splits
tower = { workspace = true, default-features = false, features = ["util","limit"] }
tower-http = { workspace = true, features = ["trace"] }
http  = { workspace = true }
# hyper/hyper-util local
hyper = { version = "1", features = ["http1","http2","server"] }
hyper-util = "0.1"

# Metrics/obs
prometheus = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true, features = ["fmt","env-filter"] }

# Serde / JSON / config / time
serde      = { workspace = true, features = ["derive"] }
serde_json = { workspace = true }
toml       = { workspace = true }
time       = { version = "0.3", features = ["formatting","parsing","macros"] }
uuid       = { version = "1", features = ["v4"] }
base64     = "0.22"

# Concurrency / utils
parking_lot = { workspace = true }
once_cell   = { workspace = true }

# Errors
thiserror = { workspace = true }   # aligns to workspace (v1) to avoid dupes
anyhow    = { workspace = true }

# Async trait for dyn-safe async methods
async-trait = "0.1"

# Zeroization
zeroize = "1"

# Dev KMS (optional; enabled by dev-kms feature)
ed25519-dalek = { version = "2", features = ["rand_core","serde"], optional = true }
rand_core     = { version = "0.6", features = ["getrandom"], optional = true }

[dev-dependencies]
# HTTP client for any future integration tests (we already have a Router-based test path)
reqwest  = { workspace = true, features = ["rustls-tls-native-roots","json"] }
tokio    = { workspace = true, features = ["macros","rt-multi-thread","time"] }
# Benches + helpers (Criterion enables --save-baseline)
criterion = "0.5"
futures   = "0.3"

[[bench]]
name = "verify"
harness = false

[profile.bench]
opt-level = 3
codegen-units = 1
lto = "thin"        # thin-LTO avoids the embed-bitcode=no conflict
panic = "abort"

[profile.release]
opt-level = 3
codegen-units = 1
lto = "thin"
panic = "abort"


```

### crates/svc-passport/benches/issue_bench.rs
<a id="crates-svc-passport-benches-issuebench-rs"></a>

```rust
// Criterion bench scaffold: /issue path
fn main() { /* bench placeholder */
}

```

### crates/svc-passport/benches/verify.rs
<a id="crates-svc-passport-benches-verify-rs"></a>

```rust
// crates/svc-passport/benches/verify.rs
use std::sync::Arc;

use base64::{engine::general_purpose::STANDARD, Engine as _};
use criterion::{black_box, criterion_group, criterion_main, BatchSize, Criterion};
use futures::executor;
use svc_passport::{
    config::Config,
    kms::client::{DevKms, KmsClient},
    state::issuer::IssuerState,
};

// Embed default config so benches don't rely on filesystem layout.
const EMBEDDED_DEFAULT_TOML: &str = include_str!("../config/default.toml");

fn ensure_bench_config() {
    // Only set if caller didn't provide something explicit.
    if std::env::var("PASSPORT_CONFIG").is_err() && std::env::var("PASSPORT_CONFIG_FILE").is_err() {
        std::env::set_var("PASSPORT_CONFIG", EMBEDDED_DEFAULT_TOML);
    }
}

fn make_issuer() -> IssuerState {
    ensure_bench_config();
    let kms: Arc<dyn KmsClient> = Arc::new(DevKms::new());
    let cfg = Config::load().expect("Config::load() in benches");
    IssuerState::new(cfg, kms)
}

pub fn bench_verify_single(c: &mut Criterion) {
    c.bench_function("verify_single", |b| {
        b.iter_batched(
            || {
                let issuer = make_issuer();
                let msg = br#"{"hello":"world"}"#.to_vec();
                let (kid, sig) = executor::block_on(issuer.sign(&msg)).unwrap();
                (issuer, kid, msg, sig)
            },
            |(issuer, kid, msg, sig)| {
                let ok = executor::block_on(issuer.verify(&kid, &msg, &sig)).unwrap();
                black_box(ok);
            },
            BatchSize::SmallInput,
        )
    });
}

pub fn bench_verify_batch_64(c: &mut Criterion) {
    c.bench_function("verify_batch_64", |b| {
        b.iter_batched(
            || {
                let issuer = make_issuer();
                let msg = br#"{"hello":"world"}"#.to_vec();
                let mut envs = Vec::with_capacity(64);
                for _ in 0..64 {
                    let (kid, sig) = executor::block_on(issuer.sign(&msg)).unwrap();
                    let env = serde_json::json!({
                        "kid": kid,
                        "msg_b64": STANDARD.encode(&msg),
                        "sig_b64": STANDARD.encode(&sig),
                        "alg": "Ed25519"
                    });
                    envs.push(env);
                }
                (issuer, envs)
            },
            |(issuer, envs)| {
                for env in &envs {
                    let kid = env["kid"].as_str().unwrap();
                    let msg = STANDARD.decode(env["msg_b64"].as_str().unwrap()).unwrap();
                    let sig = STANDARD.decode(env["sig_b64"].as_str().unwrap()).unwrap();
                    let ok = futures::executor::block_on(issuer.verify(kid, &msg, &sig)).unwrap();
                    black_box(ok);
                }
            },
            BatchSize::SmallInput,
        )
    });
}

criterion_group!(benches, bench_verify_single, bench_verify_batch_64);
criterion_main!(benches);

```

### crates/svc-passport/config/default.toml
<a id="crates-svc-passport-config-default-toml"></a>

```toml
# RO:WHAT — Default config for svc-passport (dev-friendly)
[server]
bind = "127.0.0.1:5307"
admin_bind = "127.0.0.1:5308"

[passport]
issuer = "svc-passport"
default_ttl_s = 3600
max_ttl_s = 86400
clock_skew_s = 120

[verify]
target_batch = 64
max_batch = 256
max_wait_us = 500

[cache]
vk_ttl_s = 60
jwks_ttl_s = 60

[limits]
max_msg_bytes = 4096
max_batch = 512

[security]
require_aud = true

```

### crates/svc-passport/docker/docker-compose.yml
<a id="crates-svc-passport-docker-docker-compose-yml"></a>

```yaml
version: "3.9"
services:
  svc-passport2:
    image: svcpassport2:scaffold
    build:
      context: ..
      dockerfile: docker/Dockerfile

```

### crates/svc-passport/examples/issue_cli.rs
<a id="crates-svc-passport-examples-issuecli-rs"></a>

```rust
// Minimal example scaffold: issues a passport via HTTP (to be implemented)
fn main() {
    println!("issue_cli scaffold");
}

```

### crates/svc-passport/fuzz/fuzz_targets/caveat_mutation.rs
<a id="crates-svc-passport-fuzz-fuzztargets-caveatmutation-rs"></a>

```rust
#![no_main]
// Fuzz target scaffold: caveat_mutation
use libfuzzer_sys::fuzz_target;
fuzz_target!(|_data: &[u8]| {
    // TODO
});

```

### crates/svc-passport/fuzz/fuzz_targets/envelope_parse.rs
<a id="crates-svc-passport-fuzz-fuzztargets-envelopeparse-rs"></a>

```rust
#![no_main]
// Fuzz target scaffold: envelope_parse
use libfuzzer_sys::fuzz_target;
fuzz_target!(|_data: &[u8]| {
    // TODO
});

```

### crates/svc-passport/loom/rotation_loom.rs
<a id="crates-svc-passport-loom-rotationloom-rs"></a>

```rust
// Loom model scaffold for rotation/mint interleavings
#[test] fn loom_rotation_scaffold() { assert!(true); }

```

### crates/svc-passport/rust-toolchain.toml
<a id="crates-svc-passport-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/svc-passport/scripts/inject_kms_latency.sh
<a id="crates-svc-passport-scripts-injectkmslatency-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "[scaffold] inject_kms_latency.sh <latency>" >&2

```

### crates/svc-passport/scripts/load_issue_profile.sh
<a id="crates-svc-passport-scripts-loadissueprofile-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "[scaffold] load_issue_profile.sh <profile.json>" >&2

```

### crates/svc-passport/scripts/rotate_under_load.sh
<a id="crates-svc-passport-scripts-rotateunderload-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "[scaffold] rotate_under_load.sh" >&2

```

### crates/svc-passport/scripts/smoke_passport.sh
<a id="crates-svc-passport-scripts-smokepassport-sh"></a>

```bash
#!/usr/bin/env bash
# Smoke test for svc-passport (portable, macOS-safe, self-tracing)
# - Auto-spawns server if not healthy; reuses existing
# - Discovers actual bound URL from logs; falls back to host:port if absent
# - Checks aligned with current router: /healthz, /metrics, issue/verify/verify_batch
# - TRACE=1 enables bash -x and error context dump
# - All logs go to stderr so stdout is reserved for function returns (e.g., URL)

set -euo pipefail

# -------------------- knobs --------------------
PASSPORT_HOST="${PASSPORT_HOST:-127.0.0.1}"
PASSPORT_PORT="${PASSPORT_PORT:-5307}"             # fallback only; discovery preferred
STARTUP_TIMEOUT_SECS="${STARTUP_TIMEOUT_SECS:-25}"
DISABLE_AUTO_SPAWN="${DISABLE_AUTO_SPAWN:-0}"
LOGFILE="${LOGFILE:-/tmp/svc-passport.log}"
RUST_LOG="${RUST_LOG:-info}"
TRACE="${TRACE:-0}"
# ------------------------------------------------

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"   # -> crates/svc-passport
CFG_FILE_DEFAULT="$ROOT/config/default.toml"

SERVER_PID=""
: > "$LOGFILE"

# ---- tracing helpers ----
if [[ "$TRACE" == "1" ]]; then
  set -x
fi
on_err() {
  local code=$?
  echo "=== ERROR: script aborted (exit=$code) at line ${BASH_LINENO[0]} in ${BASH_SOURCE[1]-main} ===" >&2
  echo "--- Last 60 lines of ${LOGFILE} ---" >&2
  tail -n 60 "$LOGFILE" 2>/dev/null || true
  exit "$code"
}
trap on_err ERR

# log helpers -> stderr (so stdout can carry function return values)
log()  { printf "\033[1;34m[INFO]\033[0m %s\n" "$*" >&2; }
ok()   { printf "\033[1;32m[ OK ]\033[0m %s\n" "$*" >&2; }
warn() { printf "\033[1;33m[WARN]\033[0m %s\n" "$*" >&2; }
err()  { printf "\033[1;31m[FAIL]\033[0m %s\n" "$*" >&2; }

need() { command -v "$1" >/dev/null 2>&1 || { err "Missing tool: $1"; exit 1; }; }
need curl
need jq
need awk
need grep
need sed
command -v lsof >/dev/null 2>&1 || warn "lsof not found; port freeing limited"

cleanup() {
  if [[ -n "${SERVER_PID}" ]]; then
    log "Stopping spawned svc-passport (pid=${SERVER_PID})"
    kill "${SERVER_PID}" 2>/dev/null || true
    wait "${SERVER_PID}" 2>/dev/null || true
  fi
}
trap cleanup EXIT INT TERM

# -------------------- config --------------------
prepare_config_env() {
  # Respect caller-supplied config if present
  if [[ -n "${PASSPORT_CONFIG_FILE:-}" || -n "${PASSPORT_CONFIG:-}" ]]; then
    return
  fi
  if [[ -f "$CFG_FILE_DEFAULT" ]]; then
    export PASSPORT_CONFIG_FILE="$CFG_FILE_DEFAULT"
    return
  fi
  err "No config provided and default missing: $CFG_FILE_DEFAULT"
  exit 1
}

# -------------------- ports --------------------
port_bound() {
  local port="$1"
  if command -v lsof >/dev/null 2>&1; then
    lsof -iTCP:"$port" -sTCP:LISTEN -n -P >/dev/null 2>&1
  else
    (exec 3<>/dev/tcp/"$PASSPORT_HOST"/"$port") >/dev/null 2>&1 || return 1
    exec 3>&- || true
    return 0
  fi
}

free_fixed_ports_if_needed() {
  # Best-effort only; defensive for macOS (no xargs -r)
  for PORT in "$PASSPORT_PORT" 5308; do
    if port_bound "$PORT"; then
      warn "Port $PORT busy. Killing holder(s)…"
      if command -v lsof >/dev/null 2>&1; then
        PIDS="$(lsof -tiTCP:"$PORT" -sTCP:LISTEN -n -P 2>/dev/null || true)"
        if [[ -n "${PIDS:-}" ]]; then
          # shellcheck disable=SC2086
          kill -9 $PIDS 2>/dev/null || true
        fi
      fi
      sleep 0.2
    fi
  done
}

# -------------------- URL discovery --------------------
discover_url_from_logs() {
  # Expect startup to log e.g. "svc-passport: listening on http://127.0.0.1:5307"
  # Extract the last http://IP:PORT seen
  local found
  found="$(grep -Eo 'http://[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+' "$LOGFILE" | tail -n1 || true)"
  printf "%s" "${found}"
}
fallback_url() { echo "http://${PASSPORT_HOST}:${PASSPORT_PORT}"; }

is_healthy() {
  local base="$1"
  [[ -z "$base" ]] && return 1
  curl -sSf "$base/healthz" >/dev/null 2>&1
}

# -------------------- spawn & wait --------------------
spawn() {
  log "Spawning svc-passport (cargo run -p svc-passport)"
  : > "$LOGFILE"

  # If PASSPORT_CONFIG exists but is empty, unset it so file mode is used.
  if [[ "${PASSPORT_CONFIG+x}" == "x" && -z "${PASSPORT_CONFIG:-}" ]]; then
    unset PASSPORT_CONFIG
  fi

  # Build an env block that only includes non-empty config vars
  (
    export RUST_LOG="$RUST_LOG"
    if [[ -n "${PASSPORT_CONFIG_FILE:-}" ]]; then
      export PASSPORT_CONFIG_FILE
    fi
    if [[ -n "${PASSPORT_CONFIG:-}" ]]; then
      export PASSPORT_CONFIG
    fi
    cargo run -p svc-passport --quiet
  ) >"$LOGFILE" 2>&1 &
  SERVER_PID=$!
  log "svc-passport spawned (pid=${SERVER_PID}); logs at ${LOGFILE}"
}

maybe_spawn() {
  if [[ "${DISABLE_AUTO_SPAWN}" == "1" ]]; then
    warn "Auto-spawn disabled; expecting service to be up."
    return 1
  fi
  local try_url; try_url="$(fallback_url)"
  if is_healthy "$try_url"; then
    log "Target already healthy at ${try_url}; not spawning."
    return 1
  fi
  if port_bound "${PASSPORT_PORT}"; then
    log "Port ${PASSPORT_PORT} bound; reusing existing process (will wait for health)."
    return 1
  fi
  spawn
  return 0
}

wait_for_up() {
  log "Waiting for service…"
  local url=""
  local deadline=$((SECONDS + STARTUP_TIMEOUT_SECS))
  while [[ $SECONDS -lt $deadline ]]; do
    url="$(discover_url_from_logs || true)"
    if [[ -z "$url" ]]; then
      url="$(fallback_url)"
    fi
    if is_healthy "$url"; then
      ok "Service is up at ${url}"
      # IMPORTANT: stdout returns ONLY the URL
      echo "$url"
      return 0
    fi
    if [[ -n "$SERVER_PID" ]] && ! kill -0 "$SERVER_PID" 2>/dev/null; then
      err "Process exited before becoming healthy. Last 200 log lines:"
      tail -n 200 "$LOGFILE" >&2 || true
      exit 1
    fi
    sleep 0.2
  done
  err "Timed out waiting for /healthz"
  warn "Last 200 lines of ${LOGFILE}:"
  tail -n 200 "$LOGFILE" >&2 || true
  exit 1
}

# -------------------- HTTP helpers --------------------
curl_save() {
  local url="$1" method="$2" path="$3" body="${4:-}" out="${5:-/dev/null}"
  if [[ -n "$body" ]]; then
    curl -sS -X "$method" -H 'content-type: application/json' -d "$body" -o "$out" -w '%{http_code}' "${url}${path}"
  else
    curl -sS -X "$method" -o "$out" -w '%{http_code}' "${url}${path}"
  fi
}

run_checks() {
  local url="$1" spawned="$2"
  local code failures=0 tmp body ENV ENV_FILE

  # Basics (aligned with current router)
  code=$(curl -s -o /dev/null -w '%{http_code}' "${url}/healthz") && [[ "$code" == "200" ]] \
    && ok "/healthz" || { err "/healthz (code=$code)"; failures=$((failures+1)); }

  if curl -sSf "${url}/metrics" >/dev/null 2>&1; then ok "/metrics"; else warn "/metrics (not present)"; fi

  # Issue
  ENV_FILE="$(mktemp)"
  code=$(curl_save "$url" POST "/v1/passport/issue" '{"hello":"world"}' "$ENV_FILE")
  [[ "$code" == "200" ]] && ok "issue → envelope" || { err "issue (code=$code)"; failures=$((failures+1)); }
  ENV="$(cat "$ENV_FILE")"; rm -f "$ENV_FILE"

  # Verify single
  tmp="$(mktemp)"
  code=$(curl_save "$url" POST "/v1/passport/verify" "$ENV" "$tmp"); body="$(cat "$tmp")"; rm -f "$tmp"
  [[ "$code" == "200" ]] && jq -e '. == true' >/dev/null 2>&1 <<<"$body" \
    && ok "verify (single)" || { err "verify single (code=$code body=$body)"; failures=$((failures+1)); }

  # Verify batch
  tmp="$(mktemp)"
  code=$(curl_save "$url" POST "/v1/passport/verify_batch" "[$ENV,$ENV]" "$tmp"); body="$(cat "$tmp")"; rm -f "$tmp"
  [[ "$code" == "200" ]] && jq -e '. == [true,true]' >/dev/null 2>&1 <<<"$body" \
    && ok "verify (batch)" || { err "verify batch (code=$code body=$body)"; failures=$((failures+1)); }

  # Negative: tamper → 200:false or 400
  local ENV_TAMPER code_tamper BODY_TAMPER body_tamper_file
  ENV_TAMPER="$(echo "$ENV" | jq '.msg_b64="e30"')" || ENV_TAMPER=''
  if [[ -n "$ENV_TAMPER" ]]; then
    body_tamper_file="$(mktemp)"
    code_tamper=$(curl_save "$url" POST "/v1/passport/verify" "$ENV_TAMPER" "$body_tamper_file")
    BODY_TAMPER="$(cat "$body_tamper_file" || true)"; rm -f "$body_tamper_file"
    if [[ "$code_tamper" == "200" ]] && echo "$BODY_TAMPER" | jq -e '. == false' >/dev/null 2>&1; then
      ok "negative: tampered → 200 false"
    elif [[ "$code_tamper" == "400" ]] ; then
      ok "negative: tampered → 400"
    else
      err "negative: tampered expected 200:false or 400; got ${code_tamper:-<none>}"
      failures=$((failures+1))
    fi
  fi

  (( failures == 0 )) && { ok "All checks passed"; return 0; }
  err "Smoke FAILED (${failures} failing check(s))"; return 1
}

# -------------------- main --------------------
{ set +e; echo "--- TRACE: env ---" >&2; env | grep -E '^PASSPORT_|^RUST_LOG' >&2 || true; echo "--------------" >&2; set -e; }

prepare_config_env
free_fixed_ports_if_needed

spawned=0
if maybe_spawn; then spawned=1; fi

log "--- REACHED: before wait_for_up (spawned=${spawned}) ---"

URL="$(wait_for_up)"
run_checks "$URL" "$spawned"

```

### crates/svc-passport/src/bootstrap.rs
<a id="crates-svc-passport-src-bootstrap-rs"></a>

```rust
// crates/svc-passport/src/bootstrap.rs
//! RO:WHAT   TCP listener + Axum server bootstrap.
//! RO:WHY    Keep signature expected by main.rs (bind, admin, cfg) -> (JoinHandle, addr).
//!           Print the *actual* bound addr so curl targets the right port.
//!           Router is unit-state so `axum::serve(listener, app)` compiles cleanly.

use crate::{config::Config, health::Health, http::router::build_router};
use anyhow::Result;
use std::net::SocketAddr;
use tokio::{net::TcpListener, task::JoinHandle};

pub async fn run(
    bind: SocketAddr,
    _admin: SocketAddr,
    cfg: Config,
) -> Result<(JoinHandle<()>, SocketAddr)> {
    // 1) Bind TCP listener (explicit address from main.rs)
    let listener = TcpListener::bind(bind).await?;
    let addr = listener.local_addr()?; // in case port=0, this tells you what you actually got

    // 2) Loud startup so you can't miss it (works even if tracing isn't configured)
    println!("svc-passport: listening on http://{addr}");
    eprintln!("svc-passport: listening on http://{addr}");

    // 3) Health (Default ok)
    let health: Health = Default::default();

    // 4) Build Router<()> (IssuerState is carried via Extension inside build_router)
    let app = build_router(cfg.clone(), health);

    // 5) Serve (await inside a task so main can hold the JoinHandle)
    let task = tokio::spawn(async move {
        if let Err(e) = axum::serve(listener, app).await {
            eprintln!("svc-passport server error: {e}");
        }
    });

    Ok((task, addr))
}

```

### crates/svc-passport/src/bus/mod.rs
<a id="crates-svc-passport-src-bus-mod-rs"></a>

```rust
//! Experimental Bus RPC surface (scaffold). HTTP remains canonical.
pub mod rpc;

```

### crates/svc-passport/src/bus/rpc.rs
<a id="crates-svc-passport-src-bus-rpc-rs"></a>

```rust
//! mint_cap RPC handler stubs (scaffold).

```

### crates/svc-passport/src/config.rs
<a id="crates-svc-passport-src-config-rs"></a>

```rust
//! RO:WHAT — Service configuration model + loader (env/file), with sane defaults.

use serde::Deserialize;
use std::{env, fs, path::Path};

#[derive(Debug, Clone, Deserialize)]
pub struct Config {
    pub server: Server,
    pub passport: Passport,
    pub verify: VerifyPolicy,
    pub cache: Cache,
    pub limits: Limits,
    pub security: Security,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Server {
    pub bind: String,
    pub admin_bind: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Passport {
    pub issuer: String,
    pub default_ttl_s: u64,
    pub max_ttl_s: u64,
    pub clock_skew_s: i64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct VerifyPolicy {
    pub target_batch: usize,
    pub max_batch: usize,
    pub max_wait_us: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Cache {
    pub vk_ttl_s: u64,
    pub jwks_ttl_s: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Limits {
    pub max_msg_bytes: usize,
    pub max_batch: usize,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Security {
    pub require_aud: bool,
}

impl Config {
    pub fn load() -> anyhow::Result<Self> {
        if let Ok(s) = env::var("PASSPORT_CONFIG") {
            return Ok(toml::from_str(&s)?);
        }
        let path = env::var("PASSPORT_CONFIG_FILE")
            .unwrap_or_else(|_| "crates/svc-passport/config/default.toml".to_string());
        let text = fs::read_to_string(Path::new(&path))?;
        Ok(toml::from_str(&text)?)
    }
}

```

### crates/svc-passport/src/dto/issue.rs
<a id="crates-svc-passport-src-dto-issue-rs"></a>

```rust
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct IssueRequest {
    pub sub: String,
    pub aud: Vec<String>,
    pub scopes: Vec<String>,
    #[serde(default)]
    pub ctx: Option<Value>,
    #[serde(default)]
    pub ttl_s: Option<u64>,
    #[serde(default)]
    pub nbf: Option<i64>,
    #[serde(default)]
    pub nonce: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct IssueResponse {
    pub envelope: super::verify::Envelope,
}

```

### crates/svc-passport/src/dto/mod.rs
<a id="crates-svc-passport-src-dto-mod-rs"></a>

```rust
//! RO:WHAT — Stable JSON DTOs for issue/verify/revoke (deny unknown fields).
pub mod issue;
pub mod revoke;
pub mod verify;

```

### crates/svc-passport/src/dto/revoke.rs
<a id="crates-svc-passport-src-dto-revoke-rs"></a>

```rust
#![allow(dead_code)]
use serde::Deserialize;

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct RevokeRequest {
    pub jti: String,
}

```

### crates/svc-passport/src/dto/verify.rs
<a id="crates-svc-passport-src-dto-verify-rs"></a>

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Envelope {
    pub alg: String,
    pub kid: String,
    pub sig_b64: String,
    pub msg_b64: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct VerifyRequest {
    pub envelope: Envelope,
}

#[derive(Debug, Serialize)]
pub struct VerifyResponse {
    pub ok: bool,
    pub reason: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct VerifyBatchRequest {
    pub envelopes: Vec<Envelope>,
}

#[derive(Debug, Serialize)]
pub struct VerifyBatchResponse {
    pub results: Vec<VerifyResult>,
}

#[derive(Debug, Serialize)]
pub struct VerifyResult {
    pub ok: bool,
    pub reason: Option<String>,
}

```

### crates/svc-passport/src/error.rs
<a id="crates-svc-passport-src-error-rs"></a>

```rust
//! RO:WHAT — Error taxonomy (stable, machine-parseable) and IntoResponse mapping.
//! RO:WHY  — Deterministic client behavior, SDK-friendly.
//! RO:INVARIANTS — No secrets in messages; stable codes.

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("malformed")]
    Malformed,
    #[error("verify_failed")]
    VerifyFailed,
    #[error("expired")]
    Expired,
    #[error("nbf")]
    NotBefore,
    #[error("bad_aud")]
    BadAudience,
    #[error("unknown_kid")]
    UnknownKid,
    #[error("scope_denied")]
    ScopeDenied,
    #[error("internal")]
    Internal(anyhow::Error),
}

#[derive(Serialize)]
pub struct Problem<'a> {
    code: &'a str,
    message: &'a str,
    retryable: bool,
}

impl IntoResponse for Error {
    fn into_response(self) -> Response {
        let (code, msg, status, retryable) = match &self {
            Error::Malformed => (
                "malformed",
                "bad request body",
                StatusCode::BAD_REQUEST,
                false,
            ),
            Error::VerifyFailed => (
                "verify_failed",
                "signature did not verify",
                StatusCode::UNAUTHORIZED,
                false,
            ),
            Error::Expired => ("expired", "token expired", StatusCode::UNAUTHORIZED, false),
            Error::NotBefore => ("nbf", "token not valid yet", StatusCode::UNAUTHORIZED, true),
            Error::BadAudience => ("bad_aud", "audience denied", StatusCode::FORBIDDEN, false),
            Error::UnknownKid => (
                "unknown_kid",
                "unknown verifying key",
                StatusCode::UNAUTHORIZED,
                true,
            ),
            Error::ScopeDenied => (
                "scope_denied",
                "capability denied",
                StatusCode::FORBIDDEN,
                false,
            ),
            Error::Internal(_) => (
                "internal",
                "internal error",
                StatusCode::INTERNAL_SERVER_ERROR,
                true,
            ),
        };
        let body = Json(Problem {
            code,
            message: msg,
            retryable,
        });
        (status, body).into_response()
    }
}

impl From<anyhow::Error> for Error {
    fn from(e: anyhow::Error) -> Self {
        Error::Internal(e)
    }
}

```

### crates/svc-passport/src/health.rs
<a id="crates-svc-passport-src-health-rs"></a>

```rust
//! Health/Readiness wrappers.

use ron_kernel::metrics::{health::HealthState, readiness::Readiness};

#[derive(Clone)]
pub struct Health {
    pub health: HealthState,
    pub ready: Readiness,
}

impl Health {
    pub fn new() -> Self {
        let health = HealthState::new();
        let ready = Readiness::new(health.clone());
        Self { health, ready }
    }
}

// Clippy asked for this; also makes it easy to construct.
impl Default for Health {
    fn default() -> Self {
        Self::new()
    }
}

```

### crates/svc-passport/src/http/handlers/healthz.rs
<a id="crates-svc-passport-src-http-handlers-healthz-rs"></a>

```rust
//! RO:WHAT — GET /healthz (passthrough to ron-kernel health).
use axum::response::IntoResponse;
use ron_kernel::metrics::health::HealthState;

pub async fn healthz(h: HealthState) -> impl IntoResponse {
    if h.all_ready() {
        "ok"
    } else {
        "degraded"
    }
}

```

### crates/svc-passport/src/http/handlers/issue.rs
<a id="crates-svc-passport-src-http-handlers-issue-rs"></a>

```rust
//! RO:WHAT   Issue + admin plane + JWKS export.
//! RO:WHY    Unit-state Router: state via Extension(Arc<_>); metrics intact.

use axum::{response::IntoResponse, Extension, Json};
use serde_json::{json, Value};
use std::sync::Arc;

use crate::{
    error::Error,
    metrics::{OPS_TOTAL, OP_LATENCY},
    state::issuer::IssuerState,
};

/// Minimal health probe keeps behavior stable even if other parts evolve.
pub async fn healthz() -> impl IntoResponse {
    Json(json!({ "ok": true }))
}

/// GET /v1/keys  -> JWKS (OKP/Ed25519)
pub async fn keys(
    Extension(issuer): Extension<Arc<IssuerState>>,
) -> Result<impl IntoResponse, Error> {
    let jwks = issuer.jwks().await?;
    Ok(Json(jwks))
}

/// POST /v1/passport/issue
/// Body: arbitrary JSON payload to be signed
/// Returns: Envelope { alg, kid, msg_b64, sig_b64 }
pub async fn issue(
    Extension(issuer): Extension<Arc<IssuerState>>,
    Json(payload): Json<Value>,
) -> Result<impl IntoResponse, Error> {
    let _timer = OP_LATENCY.start_timer();

    let bytes = serde_json::to_vec(&payload).map_err(|_| Error::Malformed)?;
    let (kid, sig) = issuer.sign(&bytes).await?;
    let env = issuer.build_envelope(kid, bytes, sig);

    OPS_TOTAL
        .with_label_values(&["issue", "ok", "Ed25519"])
        .inc();

    Ok(Json(json!({
        "alg": env.alg,
        "kid": env.kid,
        "sig_b64": env.sig_b64,
        "msg_b64": env.msg_b64
    })))
}

/// POST /admin/rotate  -> { current_kid }
pub async fn rotate(
    Extension(issuer): Extension<Arc<IssuerState>>,
) -> Result<impl IntoResponse, Error> {
    let kid = issuer.kms.rotate().await.map_err(Error::Internal)?;
    Ok(Json(json!({ "current_kid": kid })))
}

/// GET /admin/attest  -> attestation doc
pub async fn attest(
    Extension(issuer): Extension<Arc<IssuerState>>,
) -> Result<impl IntoResponse, Error> {
    let view = issuer.kms.attest().await.map_err(Error::Internal)?;
    Ok(Json(view))
}

```

### crates/svc-passport/src/http/handlers/mod.rs
<a id="crates-svc-passport-src-http-handlers-mod-rs"></a>

```rust
pub mod healthz;
pub mod issue;
pub mod readyz;
pub mod revoke;
pub mod verify;

```

### crates/svc-passport/src/http/handlers/readyz.rs
<a id="crates-svc-passport-src-http-handlers-readyz-rs"></a>

```rust
//! RO:WHAT — GET /readyz handled in bootstrap via ron-kernel readiness handler.
//! RO:WHY  — Keep handler here for symmetry if needed later.
#![allow(dead_code)]

```

### crates/svc-passport/src/http/handlers/revoke.rs
<a id="crates-svc-passport-src-http-handlers-revoke-rs"></a>

```rust
//! RO:WHAT — (stub) Revocation endpoint; Bronze stores nonce/jti in-memory with TTL.
//! RO:WHY  — Demonstrate shape; Silver will back by CAS/index if needed.
#![allow(dead_code)]

```

### crates/svc-passport/src/http/handlers/verify.rs
<a id="crates-svc-passport-src-http-handlers-verify-rs"></a>

```rust
//! RO:WHAT   Verify endpoints: single and batch (Envelope-based).
//! RO:WHY    Unit-state Router: pull IssuerState via Extension(Arc<_>); keep metrics.
//! RO:INVARS No secret leakage; errors mapped by Error; low-cardinality labels.

use axum::{http::StatusCode, Extension, Json};
use base64::{engine::general_purpose::STANDARD, Engine as _};
use std::sync::Arc;

use crate::{
    dto::verify::Envelope,
    error::Error,
    metrics::{BATCH_LEN, OPS_TOTAL, OP_LATENCY},
    state::issuer::IssuerState,
};

/// POST /v1/passport/verify  Envelope -> bool
pub async fn verify_one(
    Extension(issuer): Extension<Arc<IssuerState>>,
    Json(env): Json<Envelope>,
) -> Result<(StatusCode, Json<bool>), Error> {
    let _t = OP_LATENCY.start_timer();

    let msg = STANDARD
        .decode(&env.msg_b64)
        .map_err(|_| Error::Malformed)?;
    let sig = STANDARD
        .decode(&env.sig_b64)
        .map_err(|_| Error::Malformed)?;
    let ok = issuer.verify(&env.kid, &msg, &sig).await?;

    OPS_TOTAL
        .with_label_values(&["verify", if ok { "ok" } else { "bad_sig" }, "Ed25519"])
        .inc();

    Ok((StatusCode::OK, Json(ok)))
}

/// POST /v1/passport/verify_batch  [Envelope] -> [bool]
pub async fn verify_batch(
    Extension(issuer): Extension<Arc<IssuerState>>,
    Json(envs): Json<Vec<Envelope>>,
) -> Result<(StatusCode, Json<Vec<bool>>), Error> {
    let _t = OP_LATENCY.start_timer();
    BATCH_LEN.observe(envs.len() as f64);

    let mut out = Vec::with_capacity(envs.len());
    for env in &envs {
        let msg = STANDARD
            .decode(&env.msg_b64)
            .map_err(|_| Error::Malformed)?;
        let sig = STANDARD
            .decode(&env.sig_b64)
            .map_err(|_| Error::Malformed)?;
        let ok = issuer.verify(&env.kid, &msg, &sig).await?;
        out.push(ok);
    }

    OPS_TOTAL
        .with_label_values(&["verify_batch", "ok", "Ed25519"])
        .inc();

    Ok((StatusCode::OK, Json(out)))
}

```

### crates/svc-passport/src/http/middleware.rs
<a id="crates-svc-passport-src-http-middleware-rs"></a>

```rust
//! RO:WHAT — (stub) room for quotas/fair-queue/body caps if we front-door here.
//! RO:WHY  — Hardening blueprint hooks.
//! RO:INVARIANTS — keep simple for Bronze; svc-gateway can apply global guards.

#![allow(dead_code)]

```

### crates/svc-passport/src/http/mod.rs
<a id="crates-svc-passport-src-http-mod-rs"></a>

```rust
//! RO:WHAT — HTTP layer: router, middleware, and handlers.
//! RO:WHY  — Surface area kept small/boring; DTO hygiene.
//! RO:INVARIANTS — body caps, timeouts, deterministic errors.

pub mod handlers;
pub mod middleware;
pub mod router;

```

### crates/svc-passport/src/http/router.rs
<a id="crates-svc-passport-src-http-router-rs"></a>

```rust
// crates/svc-passport/src/http/router.rs
//! RO:WHAT   HTTP router assembly (unit-state Router<()>).
//! RO:WHY    Axum 0.7 serve() accepts Router<()> directly; state via Extension(Arc<_>).
//! RO:PLUS   /metrics + per-route body caps + concurrency guards for verify hotpaths.

use crate::{
    config::Config,
    health::Health,
    kms::client::{DevKms, KmsClient},
    metrics, // /metrics exporter
    state::issuer::IssuerState,
};
use axum::{
    extract::DefaultBodyLimit,
    response::IntoResponse,
    routing::{get, post},
    Extension, Json, Router,
};
use std::sync::Arc;
use tower::limit::ConcurrencyLimitLayer;

// Handlers
use crate::http::handlers::{issue, verify};

pub fn build_router(cfg: Config, _health: Health) -> Router {
    // KMS client (dev) and IssuerState as shared Arc
    let kms: Arc<dyn KmsClient> = Arc::new(DevKms::new());
    let issuer = Arc::new(IssuerState::new(cfg.clone(), kms));

    // Tunables (env-first; conservative defaults)
    let max_body_bytes: usize = std::env::var("PASSPORT_MAX_MSG_BYTES")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(1_048_576); // 1 MiB

    let verify_conc: usize = std::env::var("PASSPORT_VERIFY_CONCURRENCY")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(64);

    let verify_batch_conc: usize = std::env::var("PASSPORT_VERIFY_BATCH_CONCURRENCY")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(16);

    // Minimal /healthz so we can always probe quickly
    async fn healthz() -> impl IntoResponse {
        Json(serde_json::json!({ "ok": true }))
    }

    Router::new()
        // Admin/ops plane basics
        .route("/healthz", get(healthz))
        .route("/metrics", get(metrics::export))
        // v1 API
        .route(
            "/v1/passport/issue",
            post(issue::issue).route_layer(DefaultBodyLimit::max(max_body_bytes)),
        )
        .route(
            "/v1/passport/verify",
            post(verify::verify_one)
                .route_layer(DefaultBodyLimit::max(max_body_bytes))
                .route_layer(ConcurrencyLimitLayer::new(verify_conc)),
        )
        .route(
            "/v1/passport/verify_batch",
            post(verify::verify_batch)
                .route_layer(DefaultBodyLimit::max(max_body_bytes))
                .route_layer(ConcurrencyLimitLayer::new(verify_batch_conc)),
        )
        .route("/v1/keys", get(issue::keys))
        .route("/admin/rotate", post(issue::rotate))
        .route("/admin/attest", get(issue::attest))
        // Carry IssuerState via Extension so the Router stays unit-state
        .layer(Extension(issuer))
}

```

### crates/svc-passport/src/kms/client.rs
<a id="crates-svc-passport-src-kms-client-rs"></a>

```rust
//! RO:WHAT — KmsClient trait; DevKms (ed25519-dalek) for dev/tests.
//! RO:INVARIANTS — versioned KID "ed25519/default/v{n}"
//! RO:NOTES — DevKms is feature-gated behind `dev-kms` and uses rand_core::OsRng.

use async_trait::async_trait;

#[async_trait]
pub trait KmsClient: Send + Sync {
    async fn sign(&self, msg: &[u8]) -> anyhow::Result<(String, Vec<u8>)>;
    async fn verify(&self, kid: &str, msg: &[u8], sig: &[u8]) -> anyhow::Result<bool>;
    async fn public_keys(&self) -> anyhow::Result<serde_json::Value>;
    async fn rotate(&self) -> anyhow::Result<String>;
    async fn attest(&self) -> anyhow::Result<serde_json::Value>;
}

#[cfg(feature = "dev-kms")]
mod dev {
    use super::*;
    use base64::engine::general_purpose::URL_SAFE_NO_PAD;
    use base64::Engine;
    use ed25519_dalek::{Signer, SigningKey, VerifyingKey};
    use parking_lot::RwLock;
    use rand_core::OsRng; // rand_core 0.6 — CSPRNG compatible with dalek v2
    use serde_json::json;
    use std::sync::atomic::{AtomicU64, Ordering};

    /// Simple in-proc KMS for dev/tests.
    pub struct DevKms {
        version: AtomicU64,
        head: RwLock<(SigningKey, VerifyingKey)>,
        history: RwLock<Vec<(String, VerifyingKey)>>, // (kid, vk)
    }

    impl Default for DevKms {
        fn default() -> Self {
            Self::new()
        }
    }

    impl DevKms {
        pub fn new() -> Self {
            // Use OsRng (rand_core 0.6) to satisfy dalek's CryptoRngCore bound.
            let mut csprng = OsRng;
            let sk = SigningKey::generate(&mut csprng);
            let vk = sk.verifying_key();
            let kid = "ed25519/default/v1".to_string();
            Self {
                version: AtomicU64::new(1),
                head: RwLock::new((sk, vk)),
                history: RwLock::new(vec![(kid, vk)]),
            }
        }

        fn current_kid(&self) -> String {
            format!("ed25519/default/v{}", self.version.load(Ordering::SeqCst))
        }
    }

    #[async_trait]
    impl KmsClient for DevKms {
        async fn sign(&self, msg: &[u8]) -> anyhow::Result<(String, Vec<u8>)> {
            let (sk, _vk) = &*self.head.read();
            let sig = sk.sign(msg).to_bytes().to_vec();
            Ok((self.current_kid(), sig))
        }

        async fn verify(&self, kid: &str, msg: &[u8], sig: &[u8]) -> anyhow::Result<bool> {
            // find vk by kid
            let vk = {
                let hist = self.history.read();
                hist.iter().find(|(k, _)| k == kid).map(|(_, v)| *v)
            }
            .ok_or_else(|| anyhow::anyhow!("unknown kid"))?;

            let Ok(sig) = ed25519_dalek::Signature::from_slice(sig) else {
                return Ok(false);
            };
            Ok(vk.verify_strict(msg, &sig).is_ok())
        }

        async fn public_keys(&self) -> anyhow::Result<serde_json::Value> {
            let keys: Vec<_> = {
                let hist = self.history.read();
                hist.iter()
                    .map(|(kid, vk)| {
                        json!({"kid": kid, "vk_b64": URL_SAFE_NO_PAD.encode(vk.to_bytes()), "alg":"Ed25519"})
                    })
                    .collect()
            };
            Ok(json!({"alg":"Ed25519","current": self.current_kid(), "keys": keys }))
        }

        async fn rotate(&self) -> anyhow::Result<String> {
            // Bump to a new key/version using OsRng again.
            let mut csprng = OsRng;
            let sk = SigningKey::generate(&mut csprng);
            let vk = sk.verifying_key();

            {
                let mut head = self.head.write();
                *head = (sk, vk);
            }
            let next = self.version.load(Ordering::SeqCst) + 1;
            self.version.store(next, Ordering::SeqCst);
            let kid = self.current_kid();
            self.history.write().push((kid.clone(), vk));
            Ok(kid)
        }

        async fn attest(&self) -> anyhow::Result<serde_json::Value> {
            self.public_keys().await
        }
    }
}

#[cfg(feature = "dev-kms")]
pub use dev::DevKms;

#[cfg(not(feature = "dev-kms"))]
compile_error!("Enable feature `dev-kms` or wire a real ron-kms client here.");

```

### crates/svc-passport/src/kms/keyslot.rs
<a id="crates-svc-passport-src-kms-keyslot-rs"></a>

```rust
//! RO:WHAT — Keyslot types (versioned KID newtype).
#[derive(Debug, Clone)]
pub struct KeyId(pub String);
impl std::fmt::Display for KeyId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

```

### crates/svc-passport/src/kms/mod.rs
<a id="crates-svc-passport-src-kms-mod-rs"></a>

```rust
//! RO:WHAT — KMS boundary (trait) + local dev implementation.
//! RO:WHY  — Swap to ron-kms without touching service code.

pub mod client;
pub mod keyslot;
pub mod rotation;

```

### crates/svc-passport/src/kms/rotation.rs
<a id="crates-svc-passport-src-kms-rotation-rs"></a>

```rust
//! RO:WHAT — Rotation helpers (admin plane).
#![allow(dead_code)]

```

### crates/svc-passport/src/lib.rs
<a id="crates-svc-passport-src-lib-rs"></a>

```rust
//! RO:WHAT — Library root for svc-passport: issue/verify Ed25519 "passports" with versioned KID.
//! RO:WHY  — P3 Identity & Keys; Concerns: SEC/RES/PERF. Short-TTL capability tokens with batch verify.
//! RO:INTERACTS — http::handlers, token::{encode,macaroon}, kms::client, state::issuer, policy::eval
//! RO:INVARIANTS — strict Ed25519 only; deterministic envelopes; no locks across .await
//! RO:METRICS — passport_ops_total, passport_failures_total, passport_op_latency_seconds, passport_batch_len
//! RO:CONFIG — see config.rs (ttl, batch, caps); /metrics + /healthz + /readyz via ron-kernel surfaces
//! RO:SECURITY — no ambient authority; admin routes gated; zeroize ephemeral secrets
//! RO:TEST — tests/* (API smoke), fuzz/* (envelope/caveat), loom/* (rotation under races)
#![forbid(unsafe_code)]

pub mod bootstrap;
pub mod config;
pub mod dto;
pub mod error;
pub mod health;
pub mod http;
pub mod kms;
pub mod metrics;
pub mod policy;
pub mod state;
pub mod telemetry;
pub mod token;
pub mod util;
pub mod verify;

pub use crate::config::Config;

```

### crates/svc-passport/src/main.rs
<a id="crates-svc-passport-src-main-rs"></a>

```rust
//! RO:WHAT — Binary entrypoint: loads config, boots HTTP, exposes /metrics,/healthz,/readyz.
//! RO:WHY  — Service wrapper around library surfaces.
//! RO:INTERACTS — bootstrap::run, telemetry::tracing_init
//! RO:INVARIANTS — truthful readiness; graceful shutdown; no locks across .await

use std::net::SocketAddr;
use svc_passport::{bootstrap, telemetry::tracing_init, Config};
use tracing::info;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_init::init();
    let cfg = Config::load()?;
    let bind: SocketAddr = cfg.server.bind.parse()?;
    let admin: SocketAddr = cfg.server.admin_bind.parse()?;

    let (_http, http_addr) = bootstrap::run(bind, admin, cfg).await?;
    info!(%http_addr, "svc-passport: listening");
    // Block until Ctrl-C
    tokio::signal::ctrl_c().await?;
    Ok(())
}

```

### crates/svc-passport/src/metrics.rs
<a id="crates-svc-passport-src-metrics-rs"></a>

```rust
// crates/svc-passport/src/metrics.rs
//! RO:WHAT — Prometheus counters/histograms for passport ops + /metrics exporter.
//! RO:WHY  — Golden metrics & perf gates; scrapeable by Prometheus.

use axum::{http::StatusCode, response::IntoResponse};
use once_cell::sync::Lazy;
use prometheus::{
    gather, register_histogram, register_int_counter_vec, Encoder, Histogram, HistogramOpts,
    IntCounterVec, Opts, TextEncoder,
};

pub static OPS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    let opts = Opts::new("passport_ops_total", "passport operations total")
        .const_label("service", "svc-passport");
    register_int_counter_vec!(opts, &["op", "result", "alg"]).expect("register passport_ops_total")
});

pub static FAILURES_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    let opts = Opts::new("passport_failures_total", "passport failures by reason")
        .const_label("service", "svc-passport");
    register_int_counter_vec!(opts, &["reason"]).expect("register passport_failures_total")
});

pub static OP_LATENCY: Lazy<Histogram> = Lazy::new(|| {
    let opts = HistogramOpts {
        common_opts: Opts::new("passport_op_latency_seconds", "op latency")
            .const_label("service", "svc-passport"),
        buckets: vec![0.0002, 0.0005, 0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1],
    };
    register_histogram!(opts).expect("register passport_op_latency_seconds")
});

pub static BATCH_LEN: Lazy<Histogram> = Lazy::new(|| {
    let opts = HistogramOpts {
        common_opts: Opts::new("passport_batch_len", "verify batch length")
            .const_label("service", "svc-passport"),
        buckets: vec![1.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0],
    };
    register_histogram!(opts).expect("register passport_batch_len")
});

pub async fn export() -> impl IntoResponse {
    let metric_families = gather();
    let mut buf = Vec::with_capacity(16 * 1024);
    let encoder = TextEncoder::new();
    if let Err(e) = encoder.encode(&metric_families, &mut buf) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("encode metrics: {e}"),
        )
            .into_response();
    }
    (
        StatusCode::OK,
        (
            [(axum::http::header::CONTENT_TYPE, encoder.format_type())],
            buf,
        ),
    )
        .into_response()
}

```

### crates/svc-passport/src/policy/eval.rs
<a id="crates-svc-passport-src-policy-eval-rs"></a>

```rust
#![allow(dead_code)]
//! RO:WHAT — (stub) Evaluate scopes/caveats vs requested operation; default allow.
pub fn allow() -> bool {
    true
}

```

### crates/svc-passport/src/policy/mod.rs
<a id="crates-svc-passport-src-policy-mod-rs"></a>

```rust
//! RO:WHAT — Policy adapter (deny-by-default); Bronze: allow all.
pub mod eval;

```

### crates/svc-passport/src/state/audit.rs
<a id="crates-svc-passport-src-state-audit-rs"></a>

```rust
#![allow(dead_code)]
//! RO:WHAT — (stub) Audit sink for issue/verify/revoke events; Bronze: no-op.

```

### crates/svc-passport/src/state/issuer.rs
<a id="crates-svc-passport-src-state-issuer-rs"></a>

```rust
// RO:WHAT   IssuerState: thin service state around a KMS client + helpers.
// RO:WHY    Handlers expect helpers: build_envelope, jwks, rotate, attest, verify_envelope.

use crate::{config::Config, dto::verify::Envelope, error::Error, kms::client::KmsClient};
use base64::{engine::general_purpose::STANDARD, Engine as _};
use parking_lot::RwLock;
use serde_json::{json, Value};
use std::{collections::HashMap, sync::Arc};

#[derive(Clone)]
pub struct IssuerState {
    pub cfg: Config,
    pub kms: Arc<dyn KmsClient>,
    pub cache: Arc<RwLock<HashMap<String, ()>>>,
}

impl IssuerState {
    pub fn new(cfg: Config, kms: Arc<dyn KmsClient>) -> Self {
        Self {
            cfg,
            kms,
            cache: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Sign raw message bytes; returns (kid, signature).
    pub async fn sign(&self, msg: &[u8]) -> Result<(String, Vec<u8>), Error> {
        self.kms.sign(msg).await.map_err(Error::Internal)
    }

    /// Verify signature with kid; returns true/false.
    pub async fn verify(&self, kid: &str, msg: &[u8], sig: &[u8]) -> Result<bool, Error> {
        self.kms
            .verify(kid, msg, sig)
            .await
            .map_err(Error::Internal)
    }

    /// Build a transport envelope from parts.
    pub fn build_envelope(&self, kid: String, msg: Vec<u8>, sig: Vec<u8>) -> Envelope {
        Envelope {
            alg: "Ed25519".to_string(),
            kid,
            msg_b64: STANDARD.encode(msg),
            sig_b64: STANDARD.encode(sig),
        }
    }

    /// Public JWKS (OKP/Ed25519). Converts KMS `public_keys()` shape -> standard JWKS.
    ///
    /// DevKms `public_keys()` returns:
    /// { "alg":"Ed25519", "current":"ed25519/default/vN",
    ///   "keys":[{"kid": "...", "vk_b64": "<urlsafe-b64>", "alg":"Ed25519"}] }
    pub async fn jwks(&self) -> Result<Value, Error> {
        let kms_view = self.kms.public_keys().await.map_err(Error::Internal)?;
        let Some(keys) = kms_view.get("keys").and_then(|v| v.as_array()) else {
            return Ok(json!({ "keys": [] }));
        };

        // Map into OKP JWKS set
        let jwk_keys: Vec<Value> = keys
            .iter()
            .filter_map(|k| {
                let kid = k.get("kid")?.as_str()?;
                let x = k.get("vk_b64")?.as_str()?; // already URL_SAFE_NO_PAD encoded
                Some(json!({
                    "kty": "OKP",
                    "crv": "Ed25519",
                    "use": "sig",
                    "key_ops": ["verify"],
                    "alg": "EdDSA",
                    "kid": kid,
                    "x": x
                }))
            })
            .collect();

        Ok(json!({ "keys": jwk_keys }))
    }
}

```

### crates/svc-passport/src/state/mod.rs
<a id="crates-svc-passport-src-state-mod-rs"></a>

```rust
//! RO:WHAT — Service state (issuer, audit).
pub mod audit;
pub mod issuer;

```

### crates/svc-passport/src/telemetry/mod.rs
<a id="crates-svc-passport-src-telemetry-mod-rs"></a>

```rust
pub mod prometheus;
pub mod tracing_init;

```

### crates/svc-passport/src/telemetry/prometheus.rs
<a id="crates-svc-passport-src-telemetry-prometheus-rs"></a>

```rust
use axum::{http::StatusCode, response::IntoResponse};
use prometheus::{Encoder, TextEncoder};
use ron_kernel::metrics::health::HealthState;

pub async fn metrics_handler() -> impl IntoResponse {
    let mf = prometheus::default_registry().gather();
    let mut buf = Vec::new();
    TextEncoder::new().encode(&mf, &mut buf).unwrap();
    (StatusCode::OK, buf)
}

pub async fn healthz_handler(h: HealthState) -> impl IntoResponse {
    if h.all_ready() {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    }
}

```

### crates/svc-passport/src/telemetry/tracing_init.rs
<a id="crates-svc-passport-src-telemetry-tracinginit-rs"></a>

```rust
//! RO:WHAT — Init tracing subscriber with env filter.
use tracing_subscriber::{fmt, EnvFilter};

pub fn init() {
    let _ = fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .with_target(false)
        .try_init();
}

```

### crates/svc-passport/src/test_support.rs
<a id="crates-svc-passport-src-testsupport-rs"></a>

```rust
// crates/svc-passport/src/test_support.rs
// RO:WHAT  Helpers for integration tests that include this file via:
//          #[path = "../src/test_support.rs"] mod test_support;
// RO:WHY   Integration tests compile as a separate crate, so we must
//          import through the external crate name `svc_passport::…`.
// RO:INVARS Never read from disk unless PASSPORT_CONFIG(_FILE) is set;
//           otherwise embed the crate’s default TOML so tests are hermetic.

use std::{env, sync::Arc};

use svc_passport::{
    config::Config,
    kms::client::{DevKms, KmsClient},
    state::issuer::IssuerState,
};

// Embed the crate’s default config so tests don’t depend on CWD.
const DEFAULT_TOML: &str = include_str!("../config/default.toml");

fn load_cfg_for_tests() -> Config {
    // If the runner provided a config (string or file), honor it and let
    // svc_passport::config::Config::load() do the parsing.
    if env::var("PASSPORT_CONFIG").is_ok() || env::var("PASSPORT_CONFIG_FILE").is_ok() {
        return Config::load().expect("Config::load() in tests");
    }

    // Otherwise, inject the embedded TOML via PASSPORT_CONFIG so the crate’s
    // own loader will parse it (no extra dev-deps in the test crate).
    env::set_var("PASSPORT_CONFIG", DEFAULT_TOML);
    Config::load().expect("Config::load() with embedded DEFAULT_TOML")
}

pub fn issuer_state_for_tests() -> IssuerState {
    let kms: Arc<dyn KmsClient> = Arc::new(DevKms::new());
    let cfg = load_cfg_for_tests();
    IssuerState::new(cfg, kms)
}

pub fn default_config() -> Config {
    load_cfg_for_tests()
}

```

### crates/svc-passport/src/token/attenuate.rs
<a id="crates-svc-passport-src-token-attenuate-rs"></a>

```rust
#![allow(dead_code)]
//! Placeholder helpers to attenuate scopes/caveats deterministically.

```

### crates/svc-passport/src/token/caveat.rs
<a id="crates-svc-passport-src-token-caveat-rs"></a>

```rust
#![allow(dead_code)]
//! Placeholder for caveat definitions & serialization rules.

```

### crates/svc-passport/src/token/encode.rs
<a id="crates-svc-passport-src-token-encode-rs"></a>

```rust
//! RO:WHAT — Canonical JSON payload + envelope (base64url, no pad).
//! RO:INVARIANTS — sorted keys; UTF-8 bytes; stable across languages.

use crate::{
    dto::{issue::IssueRequest, verify::Envelope},
    Config,
};
use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine;
use serde_json::{json, Value};
use time::OffsetDateTime;

pub fn canonical_payload(cfg: &Config, req: &IssueRequest) -> anyhow::Result<Value> {
    let now = OffsetDateTime::now_utc().unix_timestamp();
    let ttl = req
        .ttl_s
        .unwrap_or(cfg.passport.default_ttl_s)
        .min(cfg.passport.max_ttl_s);
    let iat = now;
    let exp = now + ttl as i64;
    let nbf = req.nbf.unwrap_or(iat);

    // Basic payload; kid is stamped after sign via IssuerState (KMS head)
    let payload = json!({
        "iss": cfg.passport.issuer,
        "sub": req.sub,
        "aud": req.aud,
        "iat": iat,
        "exp": exp,
        "nbf": nbf,
        "scopes": req.scopes,
        "nonce": req.nonce,
        "ctx": req.ctx
    });

    Ok(payload)
}

pub fn envelope(payload: &Value, kid: &str, sig: &[u8]) -> anyhow::Result<Envelope> {
    let msg = serde_json::to_vec(payload)?;
    Ok(Envelope {
        alg: "Ed25519".into(),
        kid: kid.to_string(),
        sig_b64: URL_SAFE_NO_PAD.encode(sig),
        msg_b64: URL_SAFE_NO_PAD.encode(&msg),
    })
}

pub fn decode_envelope(env: &Envelope) -> anyhow::Result<(Vec<u8>, Vec<u8>)> {
    let msg = URL_SAFE_NO_PAD.decode(&env.msg_b64)?;
    let sig = URL_SAFE_NO_PAD.decode(&env.sig_b64)?;
    Ok((msg, sig))
}

```

### crates/svc-passport/src/token/macaroon.rs
<a id="crates-svc-passport-src-token-macaroon-rs"></a>

```rust
//! RO:WHAT — (stub) Macaroon-like caveats; keep deterministic JSON for signing.
//! RO:NOTE — Silver+: add first-class caveat evaluation and attenuation.

#![allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Caveat {
    pub kind: String,
    pub value: String,
}

```

### crates/svc-passport/src/token/mod.rs
<a id="crates-svc-passport-src-token-mod-rs"></a>

```rust
//! RO:WHAT — Token primitives: canonical payload + envelope helpers.
pub mod attenuate;
pub mod caveat;
pub mod encode;
pub mod macaroon;

```

### crates/svc-passport/src/util/hashing.rs
<a id="crates-svc-passport-src-util-hashing-rs"></a>

```rust
//! RO:WHAT — (stub) Hash helpers if needed later.
#![allow(dead_code)]

```

### crates/svc-passport/src/util/id.rs
<a id="crates-svc-passport-src-util-id-rs"></a>

```rust
//! RO:WHAT — ID helpers (nonce/jti).
pub fn rand_nonce() -> String {
    uuid::Uuid::new_v4().to_string()
}

```

### crates/svc-passport/src/util/mod.rs
<a id="crates-svc-passport-src-util-mod-rs"></a>

```rust
pub mod hashing;
pub mod id;
pub mod time;

```

### crates/svc-passport/src/util/time.rs
<a id="crates-svc-passport-src-util-time-rs"></a>

```rust
//! RO:WHAT — Time helpers (UTC seconds).
pub fn now_s() -> i64 {
    time::OffsetDateTime::now_utc().unix_timestamp()
}

```

### crates/svc-passport/src/verify/mod.rs
<a id="crates-svc-passport-src-verify-mod-rs"></a>

```rust
//! RO:WHAT — Verify pipeline: preflight + crypto calls.
pub mod preflight;

```

### crates/svc-passport/src/verify/preflight.rs
<a id="crates-svc-passport-src-verify-preflight-rs"></a>

```rust
//! RO:WHAT — Cheap checks (iat/nbf/exp/aud size) before crypto.
//! RO:INVARIANTS — bounded skew; msg bytes parsed once.

use crate::{dto::verify::Envelope, error::Error, token::encode::decode_envelope, Config};
use serde_json::Value;
use time::OffsetDateTime;

pub fn time_window(cfg: &Config, env: &Envelope) -> Result<(), Error> {
    let (msg, _sig) = decode_envelope(env).map_err(|_| Error::Malformed)?;
    let v: Value = serde_json::from_slice(&msg).map_err(|_| Error::Malformed)?;
    let now = OffsetDateTime::now_utc().unix_timestamp();
    let skew = cfg.passport.clock_skew_s;

    let iat = v
        .get("iat")
        .and_then(|x| x.as_i64())
        .ok_or(Error::Malformed)?;
    let exp = v
        .get("exp")
        .and_then(|x| x.as_i64())
        .ok_or(Error::Malformed)?;
    let nbf = v.get("nbf").and_then(|x| x.as_i64()).unwrap_or(iat);

    if now + skew < nbf {
        return Err(Error::NotBefore);
    }
    if now - skew > exp {
        return Err(Error::Expired);
    }
    Ok(())
}

```

### crates/svc-passport/testing/profiles/issue_80_20_local.json
<a id="crates-svc-passport-testing-profiles-issue8020local-json"></a>

```json
{
  "description": "80% issue, 15% verify, 5% revoke (local)",
  "rps": 100,
  "duration_s": 60
}

```

### crates/svc-passport/tests/api_issue.rs
<a id="crates-svc-passport-tests-apiissue-rs"></a>

```rust
// Black-box test scaffold for /v1/passport/issue
#[test]
fn issue_scaffold() {
    assert!(true);
}

```

### crates/svc-passport/tests/api_revoke.rs
<a id="crates-svc-passport-tests-apirevoke-rs"></a>

```rust
// Black-box test scaffold for /v1/passport/revoke
#[test]
fn revoke_scaffold() {
    assert!(true);
}

```

### crates/svc-passport/tests/api_verify.rs
<a id="crates-svc-passport-tests-apiverify-rs"></a>

```rust
// Black-box test scaffold for /v1/passport/verify
#[test]
fn verify_scaffold() {
    assert!(true);
}

```

### crates/svc-passport/tests/handlers.rs
<a id="crates-svc-passport-tests-handlers-rs"></a>

```rust
// crates/svc-passport/tests/handlers.rs
use axum::body::to_bytes;
use axum::{body::Body, http, http::Request};
use tower::ServiceExt;

use svc_passport::{health::Health, http::router::build_router};

#[path = "../src/test_support.rs"]
mod test_support;

use base64::{engine::general_purpose::STANDARD, Engine as _};
use serde_json::json;
use test_support::default_config;

#[tokio::test]
async fn healthz_ok() {
    let app = build_router(default_config(), Health::default());
    let resp = app
        .oneshot(
            Request::builder()
                .uri("/healthz")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert!(resp.status().is_success());
}

#[tokio::test]
async fn issue_then_verify_ok() {
    let app = build_router(default_config(), Health::default());

    // 1) issue
    let body = Body::from(serde_json::to_vec(&json!({"hello":"world"})).unwrap());
    let req = Request::builder()
        .method(http::Method::POST)
        .uri("/v1/passport/issue")
        .header(http::header::CONTENT_TYPE, "application/json")
        .body(body)
        .unwrap();

    let resp = app.clone().oneshot(req).await.unwrap();
    assert!(resp.status().is_success());

    // axum 0.7: to_bytes(body, limit)
    let bytes = to_bytes(resp.into_body(), usize::MAX).await.unwrap();
    let env: serde_json::Value = serde_json::from_slice(&bytes).unwrap();

    let kid = env["kid"].as_str().unwrap().to_string();
    let msg_b64 = env["msg_b64"].as_str().unwrap().to_string();
    let sig_b64 = env["sig_b64"].as_str().unwrap().to_string();

    // 2) verify single
    let verify_env = json!({
        "kid": kid,
        "msg_b64": msg_b64,
        "sig_b64": sig_b64,
        "alg": "Ed25519"
    });
    let req = Request::builder()
        .method(http::Method::POST)
        .uri("/v1/passport/verify")
        .header(http::header::CONTENT_TYPE, "application/json")
        .body(Body::from(serde_json::to_vec(&verify_env).unwrap()))
        .unwrap();

    let resp = app.clone().oneshot(req).await.unwrap();
    assert!(resp.status().is_success());
    let ok: bool =
        serde_json::from_slice(&to_bytes(resp.into_body(), usize::MAX).await.unwrap()).unwrap();
    assert!(ok, "verify should succeed");

    // 3) verify batch (one good, one tampered)
    let mut sig_tampered = STANDARD.decode(sig_b64.as_str()).unwrap();
    if !sig_tampered.is_empty() {
        sig_tampered[0] ^= 0x01;
    }
    let sig_tampered_b64 = STANDARD.encode(sig_tampered);

    let batch_envs = json!([
        verify_env,
        {
          "kid": env["kid"].as_str().unwrap(),
          "msg_b64": env["msg_b64"].as_str().unwrap(),
          "sig_b64": sig_tampered_b64,
          "alg": "Ed25519"
        }
    ]);
    let req = Request::builder()
        .method(http::Method::POST)
        .uri("/v1/passport/verify_batch")
        .header(http::header::CONTENT_TYPE, "application/json")
        .body(Body::from(serde_json::to_vec(&batch_envs).unwrap()))
        .unwrap();

    let resp = app.clone().oneshot(req).await.unwrap();
    assert!(resp.status().is_success());
    let results: Vec<bool> =
        serde_json::from_slice(&to_bytes(resp.into_body(), usize::MAX).await.unwrap()).unwrap();
    assert_eq!(results, vec![true, false], "batch should be [true,false]");
}

```

### crates/svc-passport/tests/invariants.rs
<a id="crates-svc-passport-tests-invariants-rs"></a>

```rust
// Property/invariant test scaffold: attenuation never widens authority.
#[test]
fn invariants_scaffold() {
    assert!(true);
}

```

### crates/svc-passport/tests/issuer.rs
<a id="crates-svc-passport-tests-issuer-rs"></a>

```rust
// crates/svc-passport/tests/issuer.rs
use svc_passport::state::issuer::IssuerState;

#[path = "../src/test_support.rs"]
mod test_support;

use test_support::issuer_state_for_tests;

#[tokio::test]
async fn sign_and_verify_round_trip_ok() {
    let issuer: IssuerState = issuer_state_for_tests();

    let msg = br#"{"hello":"world"}"#.to_vec();
    let (kid, sig) = issuer.sign(&msg).await.expect("sign");
    let ok = issuer.verify(&kid, &msg, &sig).await.expect("verify");

    assert!(ok, "signature should verify");
}

#[tokio::test]
async fn verify_fails_when_tampered() {
    let issuer: IssuerState = issuer_state_for_tests();

    let msg = br#"{"hello":"world"}"#.to_vec();
    let (kid, mut sig) = issuer.sign(&msg).await.expect("sign");

    // Tamper a single byte in the signature buffer (if long enough).
    if !sig.is_empty() {
        sig[0] ^= 0x01;
    }
    let ok = issuer
        .verify(&kid, &msg, &sig)
        .await
        .expect("verify call ok");
    assert!(!ok, "tampered signature must fail");
}

```

### crates/svc-passport/tests/readiness.rs
<a id="crates-svc-passport-tests-readiness-rs"></a>

```rust
// Readiness gate scaffold
#[test]
fn readiness_scaffold() {
    assert!(true);
}

```

