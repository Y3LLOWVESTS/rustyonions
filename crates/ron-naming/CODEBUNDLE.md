<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:54:34Z -->
# Code Bundle — `ron-naming`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-naming/.cargo/config.toml](#crates-ron-naming--cargo-config-toml)
- [crates/ron-naming/Cargo.toml](#crates-ron-naming-Cargo-toml)
- [crates/ron-naming/benches/encode_bench.rs](#crates-ron-naming-benches-encodebench-rs)
- [crates/ron-naming/benches/normalize_bench.rs](#crates-ron-naming-benches-normalizebench-rs)
- [crates/ron-naming/deny.toml](#crates-ron-naming-deny-toml)
- [crates/ron-naming/examples/encode_decode.rs](#crates-ron-naming-examples-encodedecode-rs)
- [crates/ron-naming/examples/normalize_roundtrip.rs](#crates-ron-naming-examples-normalizeroundtrip-rs)
- [crates/ron-naming/rust-toolchain.toml](#crates-ron-naming-rust-toolchain-toml)
- [crates/ron-naming/scripts/hash_vectors.sh](#crates-ron-naming-scripts-hashvectors-sh)
- [crates/ron-naming/scripts/render_mermaid.sh](#crates-ron-naming-scripts-rendermermaid-sh)
- [crates/ron-naming/scripts/verify_vectors_attestation.sh](#crates-ron-naming-scripts-verifyvectorsattestation-sh)
- [crates/ron-naming/src/address.rs](#crates-ron-naming-src-address-rs)
- [crates/ron-naming/src/bin/tldctl.rs](#crates-ron-naming-src-bin-tldctl-rs)
- [crates/ron-naming/src/lib.rs](#crates-ron-naming-src-lib-rs)
- [crates/ron-naming/src/normalize.rs](#crates-ron-naming-src-normalize-rs)
- [crates/ron-naming/src/types.rs](#crates-ron-naming-src-types-rs)
- [crates/ron-naming/src/verify/mod.rs](#crates-ron-naming-src-verify-mod-rs)
- [crates/ron-naming/src/version.rs](#crates-ron-naming-src-version-rs)
- [crates/ron-naming/src/wire/cbor.rs](#crates-ron-naming-src-wire-cbor-rs)
- [crates/ron-naming/src/wire/json.rs](#crates-ron-naming-src-wire-json-rs)
- [crates/ron-naming/src/wire/mod.rs](#crates-ron-naming-src-wire-mod-rs)
- [crates/ron-naming/testdata/vectors/names_ascii.json](#crates-ron-naming-testdata-vectors-namesascii-json)
- [crates/ron-naming/testdata/vectors/names_unicode_mixed.json](#crates-ron-naming-testdata-vectors-namesunicodemixed-json)
- [crates/ron-naming/testdata/vectors/tldmap_minimal.json](#crates-ron-naming-testdata-vectors-tldmapminimal-json)
- [crates/ron-naming/testdata/vectors/vectors.manifest.json](#crates-ron-naming-testdata-vectors-vectors-manifest-json)
- [crates/ron-naming/tests/address_hygiene.rs](#crates-ron-naming-tests-addresshygiene-rs)
- [crates/ron-naming/tests/cli_contract.rs](#crates-ron-naming-tests-clicontract-rs)
- [crates/ron-naming/tests/dto_wire_vectors.rs](#crates-ron-naming-tests-dtowirevectors-rs)
- [crates/ron-naming/tests/normalize_idempotence.rs](#crates-ron-naming-tests-normalizeidempotence-rs)

### crates/ron-naming/.cargo/config.toml
<a id="crates-ron-naming--cargo-config-toml"></a>

```toml
[build]
rustflags = ["-Dwarnings"]

[target.'cfg(all())']
# Keep builds deterministic and clean.

[term]
verbose = true

```

### crates/ron-naming/Cargo.toml
<a id="crates-ron-naming-Cargo-toml"></a>

```toml
[package]
name = "ron-naming"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RON-CORE naming & addressing types (schema-only; no runtime lookups)."
repository = "https://github.com/RustyOnions/RustyOnions"
readme = "README.md"
categories = ["network-programming", "encoding", "data-structures"]
keywords = ["RON", "naming", "addressing", "BLAKE3", "IDNA"]

[features]
default = []
cli = ["dep:clap", "dep:anyhow", "dep:base64"]
verify = []

[dependencies]
# Core
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_cbor = "0.11"
thiserror = "1.0"
bytes = "1.6"
blake3 = "1.5"
semver = { version = "1.0", features = ["serde"] }

# Naming / normalization
idna = "0.5"
unicode-normalization = "0.1"
regex = "1.11"
once_cell = "1.19"

# CLI (feature-gated)
clap = { version = "4.5", features = ["derive"], optional = true }
anyhow = { version = "1.0", optional = true }
base64 = { version = "0.22", optional = true }

[dev-dependencies]
proptest = "1.5"
insta = { version = "1.39", features = ["yaml"] }
criterion = "0.5"
assert_cmd = "2.0"
predicates = "3.1"

[[bin]]
name = "tldctl"
path = "src/bin/tldctl.rs"
required-features = ["cli"]

[[bench]]
name = "normalize_bench"
harness = false

[[bench]]
name = "encode_bench"
harness = false

```

### crates/ron-naming/benches/encode_bench.rs
<a id="crates-ron-naming-benches-encodebench-rs"></a>

```rust
//! RO:WHAT — Criterion benches for JSON/CBOR encode/decode of DTOs.
//! RO:WHY  — Wire-format throughput snapshot for SDK users.

use criterion::{black_box, criterion_group, criterion_main, Criterion};
use ron_naming::{
    types::{ContentId, Fqdn, NameRecord},
    version::parse_version,
    wire, Address,
};

fn bench_json_cbor(c: &mut Criterion) {
    let addr = Address::Name {
        fqdn: Fqdn("files.example".into()),
        version: Some(parse_version("1.2.3").unwrap()),
    };
    let rec = NameRecord {
        name: Fqdn("files.example".into()),
        version: Some(parse_version("1.2.3").unwrap()),
        content: ContentId(
            "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef".into(),
        ),
    };

    c.bench_function("json/address_roundtrip", |b| {
        b.iter(|| {
            let a = wire::json::roundtrip_address_json(black_box(&addr)).unwrap();
            black_box(a);
        })
    });

    c.bench_function("json/record_roundtrip", |b| {
        b.iter(|| {
            let r = wire::json::roundtrip_record_json(black_box(&rec)).unwrap();
            black_box(r);
        })
    });

    c.bench_function("cbor/address_roundtrip", |b| {
        b.iter(|| {
            let a = wire::cbor::roundtrip_address_cbor(black_box(&addr)).unwrap();
            black_box(a);
        })
    });

    c.bench_function("cbor/record_roundtrip", |b| {
        b.iter(|| {
            let r = wire::cbor::roundtrip_record_cbor(black_box(&rec)).unwrap();
            black_box(r);
        })
    });
}

criterion_group!(naming_encode, bench_json_cbor);
criterion_main!(naming_encode);

```

### crates/ron-naming/benches/normalize_bench.rs
<a id="crates-ron-naming-benches-normalizebench-rs"></a>

```rust
//! RO:WHAT — Criterion bench for domain normalization (Unicode → ASCII FQDN).
//! RO:WHY  — Track perf and regressions for IDNA/NFC pipeline.
//! RO:NOTES — Keep vectors tiny; this is a types crate (no I/O).

use criterion::{black_box, criterion_group, criterion_main, BatchSize, Criterion};
use ron_naming::normalize::normalize_fqdn_ascii;

fn bench_normalize(c: &mut Criterion) {
    let cases = [
        "example.com",
        "Café.Example",
        "bücher.example",
        "δοκιμή.Ελλάδα",       // Greek
        "пример.рф",           // Cyrillic
        "예시.테스트",         // Korean
        "مثال.إختبار",         // Arabic
        "παράδειγμα.δοκιμή",   // Greek extended
        "xn--caf-dma.example", // already punycoded
    ];

    c.bench_function("normalize_fqdn_ascii/mixed", |b| {
        b.iter_batched(
            || cases.to_vec(),
            |inputs| {
                for s in inputs {
                    let out = normalize_fqdn_ascii(black_box(s)).unwrap();
                    black_box(out);
                }
            },
            BatchSize::SmallInput,
        )
    });

    c.bench_function("normalize_fqdn_ascii/hot_ascii", |b| {
        b.iter(|| {
            let out = normalize_fqdn_ascii(black_box("sub.service.ron.dev")).unwrap();
            black_box(out);
        })
    });
}

criterion_group!(naming_norm, bench_normalize);
criterion_main!(naming_norm);

```

### crates/ron-naming/deny.toml
<a id="crates-ron-naming-deny-toml"></a>

```toml
# cargo-deny baseline for ron-naming2 (minimal, expand as needed)
[advisories]
yanked = "deny"

[licenses]
unlicensed = "deny"
copyleft = "deny"
allow = [
  "Apache-2.0",
  "MIT",
  "Unicode-DFS-2016",
  "Unicode-3.0",
  "CC0-1.0",
  "CDLA-Permissive-2.0",
  "BSD-3-Clause",
]
confidence-threshold = 0.8

```

### crates/ron-naming/examples/encode_decode.rs
<a id="crates-ron-naming-examples-encodedecode-rs"></a>

```rust
use ron_naming::{
    types::{ContentId, Fqdn, NameRecord},
    version::parse_version,
    wire,
};

fn main() {
    let rec = NameRecord {
        name: Fqdn("files.example".into()),
        version: Some(parse_version("1.0.0").unwrap()),
        content: ContentId(
            "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef".into(),
        ),
    };
    let jb = wire::json::to_json_bytes(&rec).unwrap();
    let round: NameRecord = wire::json::from_json_bytes(&jb).unwrap();
    assert_eq!(rec, round);
    println!("{}", String::from_utf8(jb).unwrap());
}

```

### crates/ron-naming/examples/normalize_roundtrip.rs
<a id="crates-ron-naming-examples-normalizeroundtrip-rs"></a>

```rust
fn main() {
    let input = std::env::args().nth(1).expect("name");
    let out = ron_naming::normalize::normalize_fqdn_ascii(&input).expect("normalize");
    println!("{}", (out.0).0);
}

```

### crates/ron-naming/rust-toolchain.toml
<a id="crates-ron-naming-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["clippy", "rustfmt"]
profile = "minimal"

```

### crates/ron-naming/scripts/hash_vectors.sh
<a id="crates-ron-naming-scripts-hashvectors-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Portable BLAKE3 hashing: prefer 'b3sum' if available, else fallback to 'shasum -a 256' as placeholder.
# Replace fallback with a real BLAKE3 tool in your env/CI.

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
VEC_DIR="$DIR/testdata/vectors"
OUT="$DIR/testdata/signatures/vectors.b3.txt"

if command -v b3sum >/dev/null 2>&1; then
  (cd "$VEC_DIR" && b3sum names_ascii.json names_unicode_mixed.json tldmap_minimal.json tldmap_minimal.cbor) > "$OUT"
  echo "algo=BLAKE3-256" >> "$OUT"
  echo "OK wrote $OUT (BLAKE3)"
else
  (cd "$VEC_DIR" && shasum -a 256 names_ascii.json names_unicode_mixed.json tldmap_minimal.json tldmap_minimal.cbor) > "$OUT"
  echo "algo=SHA-256 (TEMPORARY FALLBACK — replace with BLAKE3 in CI)" >> "$OUT"
  echo "Wrote $OUT (SHA-256 fallback)"
fi

```

### crates/ron-naming/scripts/render_mermaid.sh
<a id="crates-ron-naming-scripts-rendermermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Render Mermaid diagrams locally (optional).
# Requires 'mmdc' (mermaid-cli): npm install -g @mermaid-js/mermaid-cli
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
SRC="$ROOT/docs/diagrams/arch.mmd"
DST="$ROOT/docs/diagrams/arch.svg"

if command -v mmdc >/dev/null 2>&1; then
  mmdc -i "$SRC" -o "$DST"
  echo "Rendered $DST"
else
  echo "mermaid-cli (mmdc) not found; skipped render."
fi

```

### crates/ron-naming/scripts/verify_vectors_attestation.sh
<a id="crates-ron-naming-scripts-verifyvectorsattestation-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Placeholder: call your organization-approved verifier here.
# Intended to verify testdata/signatures/vectors.attestation.txt against vectors and vectors.b3.txt.
echo "verify_vectors_attestation.sh: placeholder (no-op)"

```

### crates/ron-naming/src/address.rs
<a id="crates-ron-naming-src-address-rs"></a>

```rust
//! RO:WHAT — High-level Name/Content addressing grammar.
//! RO:WHY  — Single, portable enum to represent user-facing addresses.
//! RO:INTERACTS — types::{Fqdn, ContentId}, version::NameVersion, normalize.
//! RO:INVARIANTS — Content ids are "b3:<hex>"; names are normalized ASCII; optional "@<semver>" suffix for versions.
//! RO:TEST — tests/address_hygiene.rs

use crate::normalize::{normalize_fqdn_ascii, NormalizedFqdn};
use crate::types::{ContentId, Fqdn};
use crate::version::{parse_version, NameVersion};
use serde::{Deserialize, Serialize};

/// A user-facing address: either content-id (b3:...) or a (name[@version]) tuple.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "kind", rename_all = "snake_case", deny_unknown_fields)]
pub enum Address {
    /// Canonical content-address (BLAKE3-256).
    ///
    /// The `id` must be of the form `"b3:<64 hex>"`, all lowercase.
    Content {
        /// Canonical content identifier (`"b3:<hex>"`).
        id: ContentId,
    },
    /// Named address with optional semantic version.
    Name {
        /// Normalized ASCII FQDN (no trailing dot).
        fqdn: Fqdn,
        /// Optional semantic version tagged to the name (e.g., `1.2.3`).
        version: Option<NameVersion>,
    },
}

impl Address {
    /// Parse from a user string: either `b3:<hex>` or `name[@semver]`.
    pub fn parse(s: &str) -> Result<Self, ParseAddressError> {
        let s = s.trim();
        if s.starts_with("b3:") {
            let id = ContentId(s.to_owned());
            if !id.validate() {
                return Err(ParseAddressError::InvalidContentId);
            }
            return Ok(Address::Content { id });
        }
        // version suffix: name@1.2.3 (optional)
        let (name_part, ver_opt) = match s.rsplit_once('@') {
            Some((left, right)) if !right.is_empty() && left.contains('.') => (left, Some(right)),
            _ => (s, None),
        };
        let NormalizedFqdn(Fqdn(name)) =
            normalize_fqdn_ascii(name_part).map_err(|_| ParseAddressError::InvalidName)?;
        let fqdn = Fqdn(name);
        let version = match ver_opt {
            Some(vs) => Some(parse_version(vs).map_err(|_| ParseAddressError::InvalidVersion)?),
            None => None,
        };
        Ok(Address::Name { fqdn, version })
    }

    /// Render compact string form: `b3:<hex>` or `name[@ver]`.
    pub fn to_compact(&self) -> String {
        match self {
            Address::Content { id } => id.0.clone(),
            Address::Name { fqdn, version } => match version {
                Some(v) => format!("{}@{}", fqdn.0, v),
                None => fqdn.0.clone(),
            },
        }
    }
}

/// Parse errors for [`Address::parse`].
#[derive(thiserror::Error, Debug)]
pub enum ParseAddressError {
    /// The content id is not a valid `"b3:<64 hex>"` string.
    #[error("invalid content id")]
    InvalidContentId,
    /// The provided name failed IDNA/ASCII hygiene.
    #[error("invalid name")]
    InvalidName,
    /// The version part is not valid semantic versioning.
    #[error("invalid version")]
    InvalidVersion,
}

```

### crates/ron-naming/src/bin/tldctl.rs
<a id="crates-ron-naming-src-bin-tldctl-rs"></a>

```rust
//! RO:WHAT — Minimal CLI for naming hygiene: parse/normalize/encode.
//! RO:WHY  — Folded from tldctl into ron-naming (canon); DX helper only.
//! RO:INTERACTS — address, normalize, wire::{json,cbor}
//! RO:INVARIANTS — No network; stdout-only. Errors are structured.

#![cfg(feature = "cli")]

use base64::Engine; // bring trait in-scope for .encode()
use clap::{Parser, Subcommand};
use ron_naming::{
    address::ParseAddressError, normalize::normalize_fqdn_ascii, wire, Address, NameRecord,
};

/// tldctl — RON naming toolbox (normalize, parse, encode)
#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Cli {
    #[command(subcommand)]
    cmd: Cmd,
}

#[derive(Subcommand, Debug)]
enum Cmd {
    /// Normalize a domain name to ASCII (UTS-46/IDNA)
    Normalize { name: String },

    /// Parse a user address string (b3:... or name[@ver]) and print JSON DTO
    Parse { addr: String },

    /// Encode a NameRecord as JSON
    Json {
        name: String,
        /// Optional semantic version like 1.2.3
        #[arg(long)]
        version: Option<String>,
        /// Content id in the form b3:<64hex>
        #[arg(long)]
        content: String,
    },

    /// Encode a NameRecord as CBOR (base64 to stdout)
    Cbor {
        name: String,
        /// Optional semantic version like 1.2.3
        #[arg(long)]
        version: Option<String>,
        /// Content id in the form b3:<64hex>
        #[arg(long)]
        content: String,
    },
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Cmd::Normalize { name } => {
            let nfqdn = normalize_fqdn_ascii(&name)?;
            println!("{}", (nfqdn.0).0);
        }
        Cmd::Parse { addr } => {
            let a = Address::parse(&addr).map_err(map_addr_err)?;
            let bytes = wire::json::to_json_bytes(&a)?;
            println!("{}", String::from_utf8(bytes).unwrap());
        }
        Cmd::Json {
            name,
            version,
            content,
        } => {
            let a = Address::parse(&format!(
                "{}{}",
                name,
                version
                    .as_deref()
                    .map(|v| format!("@{v}"))
                    .unwrap_or_default()
            ))?;
            let nr = match a {
                Address::Name { fqdn, version } => NameRecord {
                    name: fqdn,
                    version,
                    content: ron_naming::types::ContentId(content),
                },
                Address::Content { .. } => anyhow::bail!(
                    "content id form is not allowed for NameRecord 'name' (expect a domain)"
                ),
            };
            let bytes = wire::json::to_json_bytes(&nr)?;
            println!("{}", String::from_utf8(bytes).unwrap());
        }
        Cmd::Cbor {
            name,
            version,
            content,
        } => {
            let a = Address::parse(&format!(
                "{}{}",
                name,
                version
                    .as_deref()
                    .map(|v| format!("@{v}"))
                    .unwrap_or_default()
            ))?;
            let nr = match a {
                Address::Name { fqdn, version } => NameRecord {
                    name: fqdn,
                    version,
                    content: ron_naming::types::ContentId(content),
                },
                Address::Content { .. } => anyhow::bail!(
                    "content id form is not allowed for NameRecord 'name' (expect a domain)"
                ),
            };
            let bytes = wire::cbor::to_cbor_bytes(&nr)?;
            let b64 = base64::engine::general_purpose::STANDARD.encode(bytes);
            println!("{b64}");
        }
    }
    Ok(())
}

fn map_addr_err(e: ParseAddressError) -> anyhow::Error {
    match e {
        ParseAddressError::InvalidContentId => {
            anyhow::anyhow!("invalid content id (expect b3:<64 hex>)")
        }
        ParseAddressError::InvalidName => {
            anyhow::anyhow!("invalid name (IDNA/ASCII hygiene failed)")
        }
        ParseAddressError::InvalidVersion => {
            anyhow::anyhow!("invalid version (semver)")
        }
    }
}

```

### crates/ron-naming/src/lib.rs
<a id="crates-ron-naming-src-lib-rs"></a>

```rust
//! RO:WHAT — Public entry for RON naming/addressing types and wire helpers.
//! RO:WHY  — Pillar 9 (Content & Naming). This crate defines schemas & hygiene only;
//!           runtime lookups live in svc-index (DHT/overlay are elsewhere).
//! RO:INTERACTS — crate::types, crate::normalize, crate::address, crate::version, crate::wire::*
//! RO:INVARIANTS — DTOs are pure (serde, deny_unknown_fields); content ids are "b3:<hex>"; no locks across .await.
//! RO:SECURITY — No ambient I/O or network; pure value types; amnesia posture is N/A here.
//! RO:TEST — unit tests in module files; round-trip vectors in tests/ (JSON/CBOR).

#![forbid(unsafe_code)]
#![deny(rust_2018_idioms, missing_docs, clippy::all)]

pub mod address;
pub mod normalize;
pub mod types;
pub mod version;

/// Wire-encoding helpers (JSON/CBOR) for DTO round-trips.
///
/// These are thin serde wrappers used by tests/examples/SDKs. Transport/runtime
/// concerns live in services (e.g., svc-index); this module is schema-focused.
pub mod wire {
    /// CBOR helpers.
    pub mod cbor;
    /// JSON helpers.
    pub mod json;
}

#[cfg(feature = "verify")]
pub mod verify;

pub use address::{Address, ParseAddressError};
pub use normalize::{normalize_fqdn_ascii, NormalizedFqdn};
pub use types::{ContentId, Fqdn, NameRecord};
pub use version::{NameVersion, VersionParseError};

```

### crates/ron-naming/src/normalize.rs
<a id="crates-ron-naming-src-normalize-rs"></a>

```rust
//! RO:WHAT — Unicode/IDNA normalization to canonical ASCII FQDNs.
//! RO:WHY  — Interop & safety: enforce UTS-46/IDNA processing and local hygiene.
//! RO:INTERACTS — types::Fqdn
//! RO:INVARIANTS — Lowercase; NFC; IDNA ASCII (Punycode) with trailing dot stripped; collapse consecutive dots.
//! RO:TEST — tests/normalize_idempotence.rs; examples/normalize_roundtrip.rs

use idna::domain_to_ascii;
use once_cell::sync::Lazy;
use regex::Regex;
use unicode_normalization::UnicodeNormalization;

use crate::types::Fqdn;

/// Normalized ASCII FQDN (newtype wrapper for type-safety).
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct NormalizedFqdn(pub Fqdn);

static DOTS: Lazy<Regex> = Lazy::new(|| Regex::new(r"\.+").expect("regex"));

/// Normalize an input domain (Unicode or ASCII) into canonical ASCII FQDN.
///
/// Steps:
/// 1. Trim whitespace; strip any leading/trailing dots.
/// 2. Unicode NFC normalize.
/// 3. Collapse consecutive dots to a single dot.
/// 4. Apply UTS-46 / IDNA to ASCII (punycode).
/// 5. Lowercase; validate ASCII FQDN hygiene.
pub fn normalize_fqdn_ascii(input: &str) -> Result<NormalizedFqdn, NormalizeError> {
    let trimmed = input.trim();
    if trimmed.is_empty() {
        return Err(NormalizeError::Empty);
    }
    let nfc = trimmed.nfc().collect::<String>();
    let no_edges = nfc.trim_matches('.');
    let collapsed = DOTS.replace_all(no_edges, ".").into_owned();
    let ascii = domain_to_ascii(&collapsed).map_err(|_| NormalizeError::Idna)?;
    let lower = ascii.to_ascii_lowercase();
    let fqdn = Fqdn(lower);
    if !fqdn.is_valid() {
        return Err(NormalizeError::InvalidAscii);
    }
    Ok(NormalizedFqdn(fqdn))
}

/// Normalization errors.
#[derive(thiserror::Error, Debug)]
pub enum NormalizeError {
    /// Empty input.
    #[error("empty input")]
    Empty,
    /// IDNA/UTS-46 mapping failed.
    #[error("invalid domain (IDNA)")]
    Idna,
    /// Resulting ASCII FQDN failed hygiene checks.
    #[error("invalid ascii fqdn")]
    InvalidAscii,
}

```

### crates/ron-naming/src/types.rs
<a id="crates-ron-naming-src-types-rs"></a>

```rust
//! RO:WHAT — Fundamental naming/addressing DTOs used across RON.
//! RO:WHY  — Keep schemas/validation centralized; services (svc-index) consume these types.
//! RO:INTERACTS — address, normalize, version, wire::{json,cbor}
//! RO:INVARIANTS — DTO hygiene with #[serde(deny_unknown_fields)]; content id prefix "b3:" only.
//! RO:METRICS — none here (types-only).
//! RO:SECURITY — No secrets; no I/O.
//! RO:TEST — see tests/address_hygiene.rs and dto_wire_vectors.rs.

use serde::{Deserialize, Serialize};

/// Fully Qualified Domain Name (ASCII, normalized, no trailing dot).
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct Fqdn(pub String);

impl Fqdn {
    /// Returns `true` if this FQDN looks syntactically valid (cheap checks).
    pub fn is_valid(&self) -> bool {
        // Minimal hygiene: 1..=253 bytes, labels 1..=63, allowed chars (a-z0-9-), no leading/trailing hyphen.
        let s = self.0.as_str();
        if s.is_empty() || s.len() > 253 || s.starts_with('.') || s.ends_with('.') {
            return false;
        }
        for label in s.split('.') {
            if label.is_empty() || label.len() > 63 {
                return false;
            }
            if label.starts_with('-') || label.ends_with('-') {
                return false;
            }
            if !label
                .chars()
                .all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '-')
            {
                return false;
            }
        }
        true
    }
}

/// Content ID — canonical BLAKE3-256 address, always `"b3:<hex>"`.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct ContentId(pub String);

impl ContentId {
    /// Validate the `b3:<hex>` shape (lowercase, 64 hex chars).
    pub fn validate(&self) -> bool {
        let s = self.0.as_str();
        if !s.starts_with("b3:") {
            return false;
        }
        let hex = &s[3..];
        hex.len() == 64 && hex.bytes().all(|b| matches!(b, b'0'..=b'9' | b'a'..=b'f'))
    }
}

/// Example DTO representing a name→manifest mapping (types-only).
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct NameRecord {
    /// Normalized ASCII FQDN.
    pub name: Fqdn,
    /// Optional semantic version of the record (e.g., for app packages).
    pub version: Option<crate::version::NameVersion>,
    /// Addressed manifest/content.
    pub content: ContentId,
}

```

### crates/ron-naming/src/verify/mod.rs
<a id="crates-ron-naming-src-verify-mod-rs"></a>

```rust
//! RO:WHAT — Optional verification helpers for test vectors / attestations.
//! RO:WHY  — Keep checks in-library for CI without introducing runtime owners.
//! RO:INVARIANTS — No network or disk I/O beyond caller-provided bytes.

use blake3::Hasher;

/// Compute a BLAKE3-256 hex for provided bytes (lowercase).
pub fn blake3_hex(bytes: &[u8]) -> String {
    let mut h = Hasher::new();
    h.update(bytes);
    h.finalize().to_hex().to_string()
}

```

### crates/ron-naming/src/version.rs
<a id="crates-ron-naming-src-version-rs"></a>

```rust
//! RO:WHAT — Name version wrapper atop semver for optional versioned records.
//! RO:WHY  — Keep version grammar stable and decoupled from services.
//! RO:INVARIANTS — Strict semver parse; serialized as plain string.
//! RO:TEST — unit tests in this module.

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::fmt;

/// Semantic Version wrapper (e.g., "1.2.3").
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct NameVersion(pub semver::Version);

impl Serialize for NameVersion {
    fn serialize<S: Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        s.serialize_str(&self.0.to_string())
    }
}

impl<'de> Deserialize<'de> for NameVersion {
    fn deserialize<D: Deserializer<'de>>(d: D) -> Result<Self, D::Error> {
        let s = String::deserialize(d)?;
        semver::Version::parse(&s)
            .map(NameVersion)
            .map_err(|e| serde::de::Error::custom(e.to_string()))
    }
}

/// Parser error.
#[derive(thiserror::Error, Debug)]
#[error("invalid version: {0}")]
pub struct VersionParseError(pub String);

impl fmt::Display for NameVersion {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

/// Parse a version string into `NameVersion`.
pub fn parse_version(s: &str) -> Result<NameVersion, VersionParseError> {
    semver::Version::parse(s)
        .map(NameVersion)
        .map_err(|e| VersionParseError(e.to_string()))
}

```

### crates/ron-naming/src/wire/cbor.rs
<a id="crates-ron-naming-src-wire-cbor-rs"></a>

```rust
//! RO:WHAT — CBOR encode/decode helpers for Address and NameRecord.
//! RO:WHY  — Compact vectors for interop; mirrors JSON helpers.
//! RO:INVARIANTS — Pure serde; canonical map ordering is a caller concern.

use crate::{types::NameRecord, Address};
use serde::{de::DeserializeOwned, Serialize};

/// Encode any serializable DTO to CBOR bytes.
pub fn to_cbor_bytes<T: Serialize>(v: &T) -> Result<Vec<u8>, serde_cbor::Error> {
    serde_cbor::to_vec(v)
}

/// Decode any DTO from CBOR bytes.
pub fn from_cbor_bytes<T: DeserializeOwned>(bytes: &[u8]) -> Result<T, serde_cbor::Error> {
    serde_cbor::from_slice(bytes)
}

/// Round-trip an [`Address`] through CBOR (encode then decode).
pub fn roundtrip_address_cbor(a: &Address) -> Result<Address, serde_cbor::Error> {
    let bytes = to_cbor_bytes(a)?;
    from_cbor_bytes::<Address>(&bytes)
}

/// Round-trip a [`NameRecord`] through CBOR (encode then decode).
pub fn roundtrip_record_cbor(r: &NameRecord) -> Result<NameRecord, serde_cbor::Error> {
    let bytes = to_cbor_bytes(r)?;
    from_cbor_bytes::<NameRecord>(&bytes)
}

```

### crates/ron-naming/src/wire/json.rs
<a id="crates-ron-naming-src-wire-json-rs"></a>

```rust
//! RO:WHAT — JSON encode/decode helpers for Address and NameRecord.
//! RO:WHY  — Test vectors & SDK interop in a single place.
//! RO:INVARIANTS — Pure serde; deny unknown fields via parent DTOs.

use crate::{types::NameRecord, Address};
use serde::{de::DeserializeOwned, Serialize};

/// Encode any serializable DTO to JSON bytes.
pub fn to_json_bytes<T: Serialize>(v: &T) -> Result<Vec<u8>, serde_json::Error> {
    serde_json::to_vec_pretty(v)
}

/// Decode any DTO from JSON bytes.
pub fn from_json_bytes<T: DeserializeOwned>(bytes: &[u8]) -> Result<T, serde_json::Error> {
    serde_json::from_slice(bytes)
}

/// Convenience: round-trip an Address to JSON and back.
pub fn roundtrip_address_json(a: &Address) -> Result<Address, serde_json::Error> {
    let bytes = to_json_bytes(a)?;
    from_json_bytes::<Address>(&bytes)
}

/// Convenience: round-trip a NameRecord to JSON and back.
pub fn roundtrip_record_json(r: &NameRecord) -> Result<NameRecord, serde_json::Error> {
    let bytes = to_json_bytes(r)?;
    from_json_bytes::<NameRecord>(&bytes)
}

```

### crates/ron-naming/src/wire/mod.rs
<a id="crates-ron-naming-src-wire-mod-rs"></a>

```rust
//! RO:WHAT — Wire (encoding) helpers for JSON/CBOR round-trips.
//! RO:WHY  — Interop hygiene; DTOs are pure; services pick the transport.
//! RO:INVARIANTS — #[serde(deny_unknown_fields)] on message shapes.

pub mod json;
pub mod cbor;

```

### crates/ron-naming/testdata/vectors/names_ascii.json
<a id="crates-ron-naming-testdata-vectors-namesascii-json"></a>

```json
{
  "note": "placeholder ASCII names for normalization vectors",
  "items": ["example", "test", "alpha", "beta"]
}

```

### crates/ron-naming/testdata/vectors/names_unicode_mixed.json
<a id="crates-ron-naming-testdata-vectors-namesunicodemixed-json"></a>

```json
{
  "note": "placeholder mixed-script names for confusables/IDNA tests",
  "items": ["ｅxample", "Εxample", "ｅхампⅼе"]
}

```

### crates/ron-naming/testdata/vectors/tldmap_minimal.json
<a id="crates-ron-naming-testdata-vectors-tldmapminimal-json"></a>

```json
{
  "note": "placeholder minimal TLD map",
  "tlds": { "example": { "policy": "placeholder" } }
}

```

### crates/ron-naming/testdata/vectors/vectors.manifest.json
<a id="crates-ron-naming-testdata-vectors-vectors-manifest-json"></a>

```json
{
  "bundle": "ron-naming2-vectors",
  "files": [
    "names_ascii.json",
    "names_unicode_mixed.json",
    "tldmap_minimal.json",
    "tldmap_minimal.cbor"
  ],
  "integrity": {
    "algo": "BLAKE3-256",
    "hash_file": "../signatures/vectors.b3.txt"
  }
}

```

### crates/ron-naming/tests/address_hygiene.rs
<a id="crates-ron-naming-tests-addresshygiene-rs"></a>

```rust
use ron_naming::{normalize::normalize_fqdn_ascii, Address};

#[test]
fn parse_b3_ok() {
    let addr =
        Address::parse("b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef")
            .unwrap();
    assert!(matches!(addr, Address::Content { .. }));
}

#[test]
fn parse_name_with_version() {
    let addr = Address::parse("files.example@1.2.3").unwrap();
    match addr {
        Address::Name { fqdn, version } => {
            assert_eq!(fqdn.0, "files.example");
            assert_eq!(version.unwrap().0.to_string(), "1.2.3");
        }
        _ => panic!("expected name"),
    }
}

#[test]
fn normalize_then_parse() {
    let nf = normalize_fqdn_ascii(" Café.EXAMPLE ").unwrap();
    let addr = Address::parse(&nf.0 .0).unwrap();
    matches!(addr, Address::Name { .. });
}

```

### crates/ron-naming/tests/cli_contract.rs
<a id="crates-ron-naming-tests-clicontract-rs"></a>

```rust
//! RO:WHAT — CLI contract tests for `tldctl`.
//! RO:WHY  — Ensure CLI stays stable. Only runs with `--features cli`.

#![cfg(feature = "cli")]

use assert_cmd::Command;

#[test]
fn normalize_cli_outputs_ascii() {
    let mut cmd = Command::cargo_bin("tldctl").expect("build tldctl");
    cmd.args(["normalize", "Café.Example"]);
    let assert = cmd.assert().success();
    let out = String::from_utf8(assert.get_output().stdout.clone()).unwrap();
    assert_eq!(out.trim(), "xn--caf-dma.example");
}

#[test]
fn parse_cli_emits_json() {
    let mut cmd = Command::cargo_bin("tldctl").expect("build tldctl");
    cmd.args(["parse", "files.example@1.2.3"]);
    let assert = cmd.assert().success();
    let out = String::from_utf8(assert.get_output().stdout.clone()).unwrap();
    assert!(out.contains(r#""kind": "name""#));
    assert!(out.contains(r#""fqdn": "files.example""#));
    assert!(out.contains(r#""version": "1.2.3""#));
}

```

### crates/ron-naming/tests/dto_wire_vectors.rs
<a id="crates-ron-naming-tests-dtowirevectors-rs"></a>

```rust
#[test]
fn placeholder_dto_wire_vectors() {
    // This will later load testdata/vectors/*.json|*.cbor and assert deterministic bytes.
    assert!(true);
}

```

### crates/ron-naming/tests/normalize_idempotence.rs
<a id="crates-ron-naming-tests-normalizeidempotence-rs"></a>

```rust
use ron_naming::normalize::normalize_fqdn_ascii;

#[test]
fn idempotent_ascii() {
    let a = normalize_fqdn_ascii("EXAMPLE.COM").unwrap();
    let b = normalize_fqdn_ascii(&a.0 .0).unwrap();
    assert_eq!(a, b);
}

#[test]
fn unicode_maps_to_ascii() {
    let a = normalize_fqdn_ascii("café.example").unwrap();
    assert_eq!(a.0 .0, "xn--caf-dma.example");
}

```

