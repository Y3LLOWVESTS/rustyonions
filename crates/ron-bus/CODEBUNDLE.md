<!-- Generated by scripts/make_crate_codex.sh on 2025-10-24T01:09:41Z -->
# Code Bundle — `ron-bus`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-bus/.cargo/config.toml](#crates-ron-bus--cargo-config-toml)
- [crates/ron-bus/.clippy.toml](#crates-ron-bus--clippy-toml)
- [crates/ron-bus/.github/workflows/ci.yml](#crates-ron-bus--github-workflows-ci-yml)
- [crates/ron-bus/.github/workflows/coverage.yml](#crates-ron-bus--github-workflows-coverage-yml)
- [crates/ron-bus/.github/workflows/nightly-chaos.yml](#crates-ron-bus--github-workflows-nightly-chaos-yml)
- [crates/ron-bus/.github/workflows/render-mermaid.yml](#crates-ron-bus--github-workflows-render-mermaid-yml)
- [crates/ron-bus/Cargo.toml](#crates-ron-bus-Cargo-toml)
- [crates/ron-bus/benches/latency.rs](#crates-ron-bus-benches-latency-rs)
- [crates/ron-bus/benches/overflow.rs](#crates-ron-bus-benches-overflow-rs)
- [crates/ron-bus/benches/throughput.rs](#crates-ron-bus-benches-throughput-rs)
- [crates/ron-bus/deny.toml](#crates-ron-bus-deny-toml)
- [crates/ron-bus/examples/publish_smoke.rs](#crates-ron-bus-examples-publishsmoke-rs)
- [crates/ron-bus/rust-toolchain.toml](#crates-ron-bus-rust-toolchain-toml)
- [crates/ron-bus/scripts/update_api_snapshot.sh](#crates-ron-bus-scripts-updateapisnapshot-sh)
- [crates/ron-bus/src/bus.rs](#crates-ron-bus-src-bus-rs)
- [crates/ron-bus/src/config.rs](#crates-ron-bus-src-config-rs)
- [crates/ron-bus/src/errors.rs](#crates-ron-bus-src-errors-rs)
- [crates/ron-bus/src/event.rs](#crates-ron-bus-src-event-rs)
- [crates/ron-bus/src/internal/channel.rs](#crates-ron-bus-src-internal-channel-rs)
- [crates/ron-bus/src/internal/depth_estimator.rs](#crates-ron-bus-src-internal-depthestimator-rs)
- [crates/ron-bus/src/internal/mod.rs](#crates-ron-bus-src-internal-mod-rs)
- [crates/ron-bus/src/internal/seals.rs](#crates-ron-bus-src-internal-seals-rs)
- [crates/ron-bus/src/lib.rs](#crates-ron-bus-src-lib-rs)
- [crates/ron-bus/src/metrics.rs](#crates-ron-bus-src-metrics-rs)
- [crates/ron-bus/src/prelude.rs](#crates-ron-bus-src-prelude-rs)
- [crates/ron-bus/tests/api_surface.rs](#crates-ron-bus-tests-apisurface-rs)
- [crates/ron-bus/tests/capacity_cutover.rs](#crates-ron-bus-tests-capacitycutover-rs)
- [crates/ron-bus/tests/chaos_amnesia.rs](#crates-ron-bus-tests-chaosamnesia-rs)
- [crates/ron-bus/tests/fanout_ok.rs](#crates-ron-bus-tests-fanoutok-rs)
- [crates/ron-bus/tests/graceful_shutdown.rs](#crates-ron-bus-tests-gracefulshutdown-rs)
- [crates/ron-bus/tests/lagged_overflow_smoke.rs](#crates-ron-bus-tests-laggedoverflowsmoke-rs)
- [crates/ron-bus/tests/loom_model.rs](#crates-ron-bus-tests-loommodel-rs)
- [crates/ron-bus/tests/pq_labels_feature.rs](#crates-ron-bus-tests-pqlabelsfeature-rs)
- [crates/ron-bus/tests/property_bus.rs](#crates-ron-bus-tests-propertybus-rs)
- [crates/ron-bus/tests/receiver_ownership.rs](#crates-ron-bus-tests-receiverownership-rs)

### crates/ron-bus/.cargo/config.toml
<a id="crates-ron-bus--cargo-config-toml"></a>

```toml
[alias]
lint = "clippy -p ron-bus2 -- -D warnings"
test-all = "test -p ron-bus2 --all-features"
ci-check = "fmt --all && clippy -D warnings && test -p ron-bus2 && deny check"
bench-all = "bench -p ron-bus2"

```

### crates/ron-bus/.clippy.toml
<a id="crates-ron-bus--clippy-toml"></a>

```toml
# Keep lock-across-await and pedantic checks tight (placeholder)
warn-on-all-wildcard-imports = true

```

### crates/ron-bus/.github/workflows/ci.yml
<a id="crates-ron-bus--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
          components: rustfmt, clippy
      - run: cargo fmt --all --check
      - run: cargo clippy -p ron-bus2 -- -D warnings
      - run: cargo test -p ron-bus2 --all-features
      - run: cargo test -p ron-bus2 --doc

```

### crates/ron-bus/.github/workflows/coverage.yml
<a id="crates-ron-bus--github-workflows-coverage-yml"></a>

```yaml
name: coverage
on:
  push:
    branches: [ main ]
  pull_request:
jobs:
  cover:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
      - name: Run coverage (placeholder)
        run: echo "Implement tarpaulin/grcov coverage here with Bronze/Silver/Gold thresholds"

```

### crates/ron-bus/.github/workflows/nightly-chaos.yml
<a id="crates-ron-bus--github-workflows-nightly-chaos-yml"></a>

```yaml
name: nightly-chaos
on:
  schedule:
    - cron: "0 3 * * *"
jobs:
  chaos:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
      - name: Run ignored chaos tests (placeholder)
        run: cargo test -p ron-bus2 -- --ignored --nocapture

```

### crates/ron-bus/.github/workflows/render-mermaid.yml
<a id="crates-ron-bus--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          mkdir -p docs/diagrams
          for f in $(git ls-files 'docs/diagrams/*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out"
          done

```

### crates/ron-bus/Cargo.toml
<a id="crates-ron-bus-Cargo-toml"></a>

```toml
[package]
name = "ron-bus"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RustyOnions in-process broadcast bus (bounded, lossy, observable-by-host)"
rust-version = "1.80"
readme = "README.md"
repository = "https://example.com/RustyOnions" # update when ready

[features]
default = []
tracing = ["dep:tracing"]
pq-labels = []            # labels-only; no crypto here
loom = []                 # dev-only (cfg guarded in tests)

[dependencies]
tokio = { version = "1.48.0", features = ["sync", "rt", "macros", "time"] }
tracing = { version = "0.1.41", optional = true }
serde = { version = "1.0", features = ["derive"], optional = true }

[dev-dependencies]
tokio = { version = "1.48.0", features = ["rt-multi-thread", "macros", "time", "sync"] }
loom = "0.7"
criterion = "0.5"


[[bench]]
name = "throughput"
harness = false

[[bench]]
name = "latency"
harness = false


[[example]]
name = "publish_smoke"

```

### crates/ron-bus/benches/latency.rs
<a id="crates-ron-bus-benches-latency-rs"></a>

```rust
//! RO:WHAT — Simple recv-side latency microbench.
//! RO:WHY  — Complements throughput bench to sanity check service time for subscribers.
//! RO:INTERACTS — Bus, BusConfig, Event.
//! RO:NOTES — Coarse; for deep dives, use project-wide harness.

use std::time::Duration;

use criterion::{criterion_group, criterion_main, Criterion};
use ron_bus::{Bus, BusConfig, Event};
use tokio::runtime::Builder;

fn recv_latency_one_publisher(c: &mut Criterion) {
    let rt = Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .unwrap();

    let mut group = c.benchmark_group("recv_latency_one_publisher");
    group.sample_size(100);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(8));
    group.noise_threshold(0.02);
    group.significance_level(0.01);

    group.bench_function("recv_latency_one_publisher", |b| {
        b.iter_custom(|iters| {
            rt.block_on(async move {
                let bus = Bus::new(BusConfig::new().with_capacity(1024)).unwrap();
                let tx = bus.sender();
                let mut rx = bus.subscribe();

                let pubber = tokio::spawn({
                    let tx = tx.clone();
                    async move {
                        for i in 0..iters {
                            let _ = tx.send(Event::ConfigUpdated { version: i });
                        }
                        let _ = tx.send(Event::Shutdown);
                    }
                });

                // Measure the time to consume `iters` events
                let start = std::time::Instant::now();
                let mut seen = 0u64;
                loop {
                    match rx.recv().await {
                        Ok(Event::ConfigUpdated { .. }) => {
                            seen += 1;
                            if seen == iters {
                                break;
                            }
                        }
                        Ok(Event::Shutdown) => break,
                        Err(_) => break,
                        _ => {}
                    }
                }
                let _ = pubber.await;
                start.elapsed()
            })
        });
    });

    group.finish();
}

criterion_group!(benches, recv_latency_one_publisher);
criterion_main!(benches);

```

### crates/ron-bus/benches/overflow.rs
<a id="crates-ron-bus-benches-overflow-rs"></a>

```rust
// overflow bench placeholder

```

### crates/ron-bus/benches/throughput.rs
<a id="crates-ron-bus-benches-throughput-rs"></a>

```rust
//! RO:WHAT — Criterion throughput bench for ron-bus (sync harness + async runtime inside)
//! RO:WHY  — Avoid Criterion's async adapters; drive Tokio ourselves via block_on()
//! RO:INTERACTS — Bus, BusConfig, Event; isolated Tokio runtimes per bench
//! RO:INVARIANTS — bounded channel; no background tasks from the library
//! RO:NOTES — Coarse microbench; for deep dives, use repo-wide harness & baselines.

use std::time::Duration;

use criterion::{black_box, criterion_group, criterion_main, Criterion};
use ron_bus::{Bus, BusConfig, Event};
use tokio::runtime::Builder;

/// Busy-work to simulate a "slow" subscriber without OS sleep jitter.
/// Tune `ns` once on your machine if needed.
#[inline]
fn burn_cycles(ns: u64) {
    // The body is intentionally simple integer math; adjust divisor to match ~ns cost.
    let iters = ns / 10;
    let mut x = 0u64;
    for i in 0..iters {
        // LCG-ish mixing; keep it opaque to optimizer.
        x = x
            .wrapping_mul(1664525)
            .wrapping_add(i ^ 1013904223u64);
        std::hint::black_box(x);
    }
}

/// Publish cost with zero subscribers draining.
fn bench_publish_zero_subs(c: &mut Criterion) {
    // Current-thread runtime is enough here.
    let rt = Builder::new_current_thread().enable_all().build().unwrap();

    let mut group = c.benchmark_group("publish_zero_subs");
    group.sample_size(100);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(8));
    group.noise_threshold(0.02);
    group.significance_level(0.01);

    group.bench_function("publish_zero_subs", |b| {
        b.iter_custom(|iters| {
            rt.block_on(async move {
                // Setup is outside the measured window.
                let bus = Bus::new(BusConfig::new().with_capacity(1024)).unwrap();
                let tx = bus.sender();

                let start = std::time::Instant::now();
                for _ in 0..iters {
                    // Measure only the send loop.
                    let _ = black_box(&tx).send(Event::ConfigUpdated { version: 1 });
                }
                start.elapsed()
            })
        });
    });

    group.finish();
}

/// Publish throughput with 8 draining subscribers (fast consumers).
fn bench_publish_eight_subs(c: &mut Criterion) {
    let rt = Builder::new_multi_thread()
        .worker_threads(4)
        .enable_all()
        .build()
        .unwrap();

    let mut group = c.benchmark_group("publish_eight_subs");
    group.sample_size(100);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(8));
    group.noise_threshold(0.02);
    group.significance_level(0.01);

    group.bench_function("publish_eight_subs", |b| {
        b.iter_custom(|iters| {
            rt.block_on(async move {
                let bus = Bus::new(BusConfig::new().with_capacity(2048)).unwrap();
                let tx = bus.sender();

                // Spawn fast draining subscribers.
                let mut rxs = Vec::new();
                for _ in 0..8 {
                    rxs.push(bus.subscribe());
                }
                for mut rx in rxs {
                    tokio::spawn(async move {
                        while let Ok(ev) = rx.recv().await {
                            criterion::black_box(ev);
                        }
                    });
                }

                // Measure only the publish loop.
                let start = std::time::Instant::now();
                for i in 0..iters {
                    let _ = tx.send(Event::ConfigUpdated { version: i });
                }
                // Ensure convergence.
                let _ = tx.send(Event::Shutdown);
                start.elapsed()
            })
        });
    });

    group.finish();
}

/// Publish while one subscriber is intentionally slow to induce Lagged(n).
fn bench_publish_with_one_slow_subscriber(c: &mut Criterion) {
    let rt = Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .unwrap();

    let mut group = c.benchmark_group("publish_with_one_slow_subscriber");
    group.sample_size(100);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(8));
    group.noise_threshold(0.02);
    group.significance_level(0.01);

    group.bench_function("publish_with_one_slow_subscriber", |b| {
        b.iter_custom(|iters| {
            rt.block_on(async move {
                let bus = Bus::new(BusConfig::new().with_capacity(64)).unwrap();
                let tx = bus.sender();

                // Slow consumer to create pressure — use CPU burn instead of sleep.
                let mut rx = bus.subscribe();
                let slow = tokio::spawn(async move {
                    loop {
                        match rx.recv().await {
                            Ok(Event::Shutdown) => break,
                            Ok(_) => {
                                // ~0.1ms CPU burn; adjust if you want the same wall time as the old sleep.
                                burn_cycles(100_000);
                            }
                            Err(_) => break,
                        }
                    }
                });

                // Measure the publish loop.
                let start = std::time::Instant::now();
                for i in 0..iters {
                    let _ = tx.send(Event::ConfigUpdated { version: i });
                }
                let _ = tx.send(Event::Shutdown);
                let _ = slow.await;
                start.elapsed()
            })
        });
    });

    group.finish();
}

pub fn criterion_benches(c: &mut Criterion) {
    bench_publish_zero_subs(c);
    bench_publish_eight_subs(c);
    bench_publish_with_one_slow_subscriber(c);
}

criterion_group!(benches, criterion_benches);
criterion_main!(benches);

```

### crates/ron-bus/deny.toml
<a id="crates-ron-bus-deny-toml"></a>

```toml
# cargo-deny config (placeholder). See workspace root for canonical policy.

```

### crates/ron-bus/examples/publish_smoke.rs
<a id="crates-ron-bus-examples-publishsmoke-rs"></a>

```rust
//! RO:WHAT — Minimal publish/subscribe smoke example
//! RO:WHY  — Shows intended pattern: one receiver per task, bounded queue, graceful shutdown
//! RO:INTERACTS — Bus, BusConfig, Event
//! RO:INVARIANTS — no background tasks created by the library; host owns subscribers/metrics

use ron_bus::{Bus, BusConfig, Event};

#[tokio::main(flavor = "current_thread")]
async fn main() {
    let bus = Bus::new(BusConfig::new().with_capacity(256)).expect("bus");
    let tx = bus.sender();

    let mut rx = bus.subscribe();
    let worker = tokio::spawn(async move {
        loop {
            match rx.recv().await {
                Ok(Event::Shutdown) => {
                    println!("worker: shutdown received");
                    break;
                }
                Ok(ev) => {
                    println!("worker: got {:?}", ev);
                }
                Err(e) => {
                    println!("worker: recv error = {:?}", e);
                    break;
                }
            }
        }
    });

    let _ = tx.send(Event::Health { service: "svc.a".into(), ok: true });
    let _ = tx.send(Event::ConfigUpdated { version: 1 });
    let _ = tx.send(Event::Shutdown);

    let _ = worker.await;
}

```

### crates/ron-bus/rust-toolchain.toml
<a id="crates-ron-bus-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/ron-bus/scripts/update_api_snapshot.sh
<a id="crates-ron-bus-scripts-updateapisnapshot-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Placeholder to regenerate public API snapshot into docs/api-history/ron-bus/
echo "Implement public API snapshot generation here."

```

### crates/ron-bus/src/bus.rs
<a id="crates-ron-bus-src-bus-rs"></a>

```rust
//! RO:WHAT — Core Bus type wrapping a bounded Tokio broadcast channel
//! RO:WHY  — Provide monomorphic, bounded, lossy, observable-by-host semantics
//! RO:INTERACTS — config::BusConfig; internal::channel; event::Event
//! RO:INVARIANTS — bounded channel; capacity fixed; no background tasks; host updates metrics
//! RO:TEST — tests/* cover fanout, lag/overflow, cutover

use crate::{config::BusConfig, errors::BusError, event::Event, internal::channel};
use tokio::sync::broadcast::{Receiver, Sender};

/// Bounded in-process broadcast bus (lossy for lagging receivers).
pub struct Bus {
    tx: Sender<Event>,
    capacity: usize,
}

impl Bus {
    /// Construct a new Bus from a config (or default).
    pub fn new(cfg: impl Into<BusConfig>) -> Result<Self, BusError> {
        let cfg = cfg.into();
        cfg.validate()
            .map_err(BusError::Config)?;
        let capacity = cfg.capacity as usize;
        let (tx, _rx) = channel::bounded::<Event>(capacity);
        // Drop the initial receiver; users will call subscribe(). No background tasks here.
        Ok(Self { tx, capacity })
    }

    /// Cloneable sender handle for publishers.
    pub fn sender(&self) -> Sender<Event> {
        self.tx.clone()
    }

    /// Unique receiver for a single subscriber task.
    ///
    /// Pattern: **one receiver per task** to avoid unintended sharing/races.
    pub fn subscribe(&self) -> Receiver<Event> {
        self.tx.subscribe()
    }

    /// The bounded queue capacity (messages).
    pub fn capacity(&self) -> usize {
        self.capacity
    }
}

```

### crates/ron-bus/src/config.rs
<a id="crates-ron-bus-src-config-rs"></a>

```rust
//! RO:WHAT — Host-constructed configuration for Bus
//! RO:WHY  — Capacity & observability knobs are fixed at construction (cutover by rebuild)
//! RO:INTERACTS — Used by Bus::new(cfg); host is responsible for reading env/files/flags
//! RO:INVARIANTS — capacity >= 2 and reasonable upper bound; no runtime mutation
//! RO:TEST — Unit: validate bounds; Integration: capacity_cutover
//! RO:NOTE — Marked #[non_exhaustive] to allow additive evolution without SemVer breaks.
//!           Because of this, external crates must use the builder helpers rather than
//!           struct-literal syntax.

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// Host-facing configuration for constructing a [`Bus`].
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[derive(Debug, Clone)]
pub struct BusConfig {
    /// Bounded broadcast buffer size (messages).
    pub capacity: u32,
    /// Host WARN throttling (per minute) for overflow logs; library does not log.
    pub overflow_warn_rate_per_min: u32,
    /// Optional namespace the host may use for metrics; library is metrics-neutral.
    pub metrics_namespace: String,
    /// If true, hosts may attach amnesia={on|off} label to metrics.
    pub emit_amnesia_label: bool,
}

impl Default for BusConfig {
    fn default() -> Self {
        Self {
            capacity: 256,
            overflow_warn_rate_per_min: 60,
            metrics_namespace: "ronbus".to_string(),
            emit_amnesia_label: true,
        }
    }
}

impl BusConfig {
    /// Create with default values (same as `Default::default()`).
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the bounded capacity (messages).
    pub fn with_capacity(mut self, capacity: u32) -> Self {
        self.capacity = capacity;
        self
    }

    /// Set the overflow warn throttle (per minute).
    pub fn with_overflow_warn_rate_per_min(mut self, rate: u32) -> Self {
        self.overflow_warn_rate_per_min = rate;
        self
    }

    /// Set the metrics namespace hint (library remains metrics-neutral).
    pub fn with_metrics_namespace<S: Into<String>>(mut self, ns: S) -> Self {
        self.metrics_namespace = ns.into();
        self
    }

    /// Toggle amnesia label emission hint.
    pub fn with_emit_amnesia_label(mut self, yes: bool) -> Self {
        self.emit_amnesia_label = yes;
        self
    }

    /// Validate bounds & basic invariants.
    pub fn validate(&self) -> Result<(), String> {
        if self.capacity < 2 {
            return Err("capacity must be >= 2".into());
        }
        if self.capacity > (1 << 20) {
            // Keep memory sane; Tokio broadcast alloc is O(capacity)
            return Err("capacity too large; must be <= 1,048,576".into());
        }
        Ok(())
    }
}

```

### crates/ron-bus/src/errors.rs
<a id="crates-ron-bus-src-errors-rs"></a>

```rust
//! RO:WHAT — Local error taxonomy for Bus construction/usage
//! RO:WHY  — Keep external semantics explicit & stable (SemVer)
//! RO:INTERACTS — Returned by Bus::new(); complements tokio::broadcast RecvError at call sites
//! RO:INVARIANTS — small, non_exhaustive; no std::error::Error to avoid error stack bloat
//! RO:TEST — Unit: config errors; Integration: negative patterns

/// Errors constructing or using the Bus surface.
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum BusError {
    /// Invalid configuration: contains a human-readable reason.
    Config(String),
    /// Channel was closed (no subscribers left).
    Closed,
}

```

### crates/ron-bus/src/event.rs
<a id="crates-ron-bus-src-event-rs"></a>

```rust
//! RO:WHAT — Canonical Event enum carried on the bus
//! RO:WHY  — Aligns with kernel public surface; additive-safe growth (#[non_exhaustive])
//! RO:INTERACTS — Consumed by hosts/services; produced by kernel/supervision
//! RO:INVARIANTS — DTO hygiene; keep variants small; no secrets/PII in payloads
//! RO:TEST — Unit: variant roundtrips; Integration: fanout_ok

/// Kernel-aligned, additive-safe event set.
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Event {
    /// Liveness of a named service.
    Health { service: String, ok: bool },
    /// Host config hot-reload emitted version.
    ConfigUpdated { version: u64 },
    /// Supervisor noticed a crash; reason is informational.
    ServiceCrashed { service: String, reason: String },
    /// Coordinated shutdown signal.
    Shutdown,
}

```

### crates/ron-bus/src/internal/channel.rs
<a id="crates-ron-bus-src-internal-channel-rs"></a>

```rust
//! RO:WHAT — Narrow wrapper for creating a bounded Tokio broadcast channel
//! RO:WHY  — Centralize invariants and future tweaks (e.g., debug asserts)
//! RO:INTERACTS — used by Bus::new()
//! RO:INVARIANTS — capacity >= 2; bounded queue; one receiver per task pattern
//! RO:TEST — Indirect via Bus integration tests

use tokio::sync::broadcast;

/// A simple constructor wrapper to emphasize bounded semantics.
pub fn bounded<T: Clone>(capacity: usize) -> (broadcast::Sender<T>, broadcast::Receiver<T>) {
    // Tokio ensures capacity >= 1 produces a bounded channel; we pre-validate in BusConfig.
    broadcast::channel(capacity)
}

```

### crates/ron-bus/src/internal/depth_estimator.rs
<a id="crates-ron-bus-src-internal-depthestimator-rs"></a>

```rust
// queue depth heuristic placeholder

```

### crates/ron-bus/src/internal/mod.rs
<a id="crates-ron-bus-src-internal-mod-rs"></a>

```rust
//! RO:WHAT — Small internal helpers to keep public files tiny
//! RO:WHY  — Encapsulate channel creation and document invariants once
//! RO:INTERACTS — channel (Tokio broadcast wrapper)
//! RO:INVARIANTS — no locks across .await; bounded channels only
//! RO:TEST — Covered indirectly via integration tests

pub mod channel;

```

### crates/ron-bus/src/internal/seals.rs
<a id="crates-ron-bus-src-internal-seals-rs"></a>

```rust
// sealed traits placeholder

```

### crates/ron-bus/src/lib.rs
<a id="crates-ron-bus-src-lib-rs"></a>

```rust
//! RO:WHAT — Public surface for the in-process broadcast bus (bounded, lossy, observable-by-host)
//! RO:WHY  — Pillar 1 (Kernel & Orchestration); Concerns: RES/PERF (bounded backpressure, no locks across .await)
//! RO:INTERACTS — internal::channel (tokio::broadcast wrapper); public: Bus, BusConfig, Event, BusError
//! RO:INVARIANTS — bounded channel; one receiver per task; no background tasks; no secrets/PII on bus
//! RO:METRICS — none inside crate (host updates counters/gauges in recv loop)
//! RO:CONFIG — capacity fixed at construction; cutover by constructing a new Bus
//! RO:SECURITY — no network/disk I/O; no payload logging; secret-free surface
//! RO:TEST — integration tests in tests/*; loom model optional (cfg(loom))

#![forbid(unsafe_code)]
#![deny(warnings)]

mod bus;
mod config;
mod errors;
mod event;

pub mod internal; // kept small; still non-public APIs within it

pub use bus::Bus;
pub use config::BusConfig;
pub use errors::BusError;
pub use event::Event;

#[cfg(doctest)]
mod _doctests {
    /// Minimal host-side pattern (bounded, one receiver per task).
    ///
    /// ```ignore
    /// use ron_bus::{Bus, BusConfig, Event};
    /// # #[tokio::main(flavor="current_thread")]
    /// # async fn main() {
    /// let bus = Bus::new(BusConfig::default()).unwrap();
    /// let mut rx = bus.subscribe();
    /// tokio::spawn(async move {
    ///     loop {
    ///         match rx.recv().await {
    ///             Ok(_ev) => { /* handle */ }
    ///             Err(tokio::sync::broadcast::error::RecvError::Lagged(n)) => {
    ///                 // host increments metrics here (outside this library)
    ///                 // metrics::bus_overflow_dropped_total().inc_by(n as u64);
    ///             }
    ///             Err(tokio::sync::broadcast::error::RecvError::Closed) => break,
    ///         }
    ///     }
    /// });
    /// bus.sender().send(Event::Shutdown).ok();
    /// # }
    /// ```
    fn _marker() {}
}

```

### crates/ron-bus/src/metrics.rs
<a id="crates-ron-bus-src-metrics-rs"></a>

```rust
// host-owned metrics facade placeholder

```

### crates/ron-bus/src/prelude.rs
<a id="crates-ron-bus-src-prelude-rs"></a>

```rust
// minimal prelude placeholder

```

### crates/ron-bus/tests/api_surface.rs
<a id="crates-ron-bus-tests-apisurface-rs"></a>

```rust
// RO:WHAT — API surface smoke tests for ron-bus.
// RO:WHY  — Lock in the basic constructors and methods to catch accidental drift.
// RO:INTERACTS — Bus, BusConfig, Event.
// RO:INVARIANTS — Monomorphic Bus; capacity fixed at construction; one receiver per task.

use ron_bus::{Bus, BusConfig, Event};
use tokio::sync::broadcast::error::RecvError;

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn api_surface_basic() {
    // Default config path
    let bus = Bus::new(BusConfig::new()).expect("bus");
    assert!(bus.capacity() >= 2);

    // Builder path
    let bus = Bus::new(BusConfig::new().with_capacity(512)).expect("bus");
    assert_eq!(bus.capacity(), 512);

    // Sender / subscribe / send / recv
    let tx = bus.sender();
    let mut rx = bus.subscribe();

    tx.send(Event::ConfigUpdated { version: 1 }).unwrap();
    match rx.recv().await {
        Ok(Event::ConfigUpdated { version }) => assert_eq!(version, 1),
        other => panic!("unexpected recv: {:?}", other),
    }

    // Shutdown should be observable by the same receiver.
    tx.send(Event::Shutdown).unwrap();
    match rx.recv().await {
        Ok(Event::Shutdown) => {}
        Err(RecvError::Closed) => panic!("channel unexpectedly closed"),
        other => panic!("unexpected recv: {:?}", other),
    }
}

```

### crates/ron-bus/tests/capacity_cutover.rs
<a id="crates-ron-bus-tests-capacitycutover-rs"></a>

```rust
// RO:WHAT — Capacity cutover test (A -> drop -> B).
// RO:WHY  — Capacity is fixed; resizing is done by constructing a new Bus.
// RO:INTERACTS — Bus, BusConfig, Event.
// RO:INVARIANTS — No background tasks; old bus is dropped before new is created.

use ron_bus::{Bus, BusConfig, Event};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn capacity_cutover_recreate_bus() {
    // Bus A
    let bus_a = Bus::new(BusConfig::new().with_capacity(64)).expect("bus A");
    assert_eq!(bus_a.capacity(), 64);

    // Prove basic send/recv works
    let tx_a = bus_a.sender();
    let mut rx_a = bus_a.subscribe();
    tx_a.send(Event::ConfigUpdated { version: 100 }).unwrap();
    let ev = rx_a.recv().await.unwrap();
    match ev {
        Event::ConfigUpdated { version } => assert_eq!(version, 100),
        _ => panic!("unexpected event on bus A: {:?}", ev),
    }

    // Drop A, construct B with different capacity
    drop(rx_a);
    drop(tx_a);
    drop(bus_a);

    // Bus B
    let bus_b = Bus::new(BusConfig::new().with_capacity(128)).expect("bus B");
    assert_eq!(bus_b.capacity(), 128);

    let tx_b = bus_b.sender();
    let mut rx_b = bus_b.subscribe();
    tx_b.send(Event::Shutdown).unwrap();
    let ev = rx_b.recv().await.unwrap();
    matches!(ev, Event::Shutdown);
}

```

### crates/ron-bus/tests/chaos_amnesia.rs
<a id="crates-ron-bus-tests-chaosamnesia-rs"></a>

```rust
// ignored chaos amnesia test placeholder

```

### crates/ron-bus/tests/fanout_ok.rs
<a id="crates-ron-bus-tests-fanoutok-rs"></a>

```rust
// RO:WHAT — Happy-path fanout: N subscribers receive all events without lag
// RO:WHY  — Proves bounded bus works for steady load; publishers non-blocking
// RO:INTERACTS — Bus, BusConfig, Event
// RO:INVARIANTS — no deadlocks; all receivers get events when not lagging

use ron_bus::{Bus, BusConfig, Event};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn fanout_ok() {
    // Use builder because BusConfig is #[non_exhaustive]
    let cfg = BusConfig::new().with_capacity(256);
    let bus = Bus::new(cfg).unwrap();

    let mut rx1 = bus.subscribe();
    let mut rx2 = bus.subscribe();

    // Publish a couple of events
    let tx = bus.sender();
    tx.send(Event::Health { service: "svc.a".into(), ok: true }).unwrap();
    tx.send(Event::Shutdown).unwrap();

    let a1 = rx1.recv().await.unwrap();
    let a2 = rx1.recv().await.unwrap();
    let b1 = rx2.recv().await.unwrap();
    let b2 = rx2.recv().await.unwrap();

    assert_eq!(a1, Event::Health { service: "svc.a".into(), ok: true });
    assert_eq!(a2, Event::Shutdown);
    assert_eq!(b1, Event::Health { service: "svc.a".into(), ok: true });
    assert_eq!(b2, Event::Shutdown);
}

```

### crates/ron-bus/tests/graceful_shutdown.rs
<a id="crates-ron-bus-tests-gracefulshutdown-rs"></a>

```rust
// RO:WHAT — Graceful shutdown convergence test.
// RO:WHY  — Final Shutdown should let receivers exit promptly (no hangs).
// RO:INTERACTS — Bus, BusConfig, Event.
// RO:INVARIANTS — Bounded, no background tasks; receivers exit on Shutdown.

use ron_bus::{Bus, BusConfig, Event};
use tokio::time::{timeout, Duration};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn graceful_shutdown_converges() {
    let bus = Bus::new(BusConfig::new().with_capacity(256)).unwrap();
    let tx = bus.sender();

    let mut rx1 = bus.subscribe();
    let t1 = tokio::spawn(async move {
        loop {
            match rx1.recv().await {
                Ok(Event::Shutdown) | Err(_) => break,
                _ => {}
            }
        }
    });

    let mut rx2 = bus.subscribe();
    let t2 = tokio::spawn(async move {
        loop {
            match rx2.recv().await {
                Ok(Event::Shutdown) | Err(_) => break,
                _ => {}
            }
        }
    });

    // Emit some traffic then Shutdown
    for i in 0..10 {
        let _ = tx.send(Event::ConfigUpdated { version: i });
    }
    let _ = tx.send(Event::Shutdown);

    // Must converge quickly
    timeout(Duration::from_secs(2), async { let _ = tokio::join!(t1, t2); })
        .await
        .expect("receivers failed to observe Shutdown in time");
}

```

### crates/ron-bus/tests/lagged_overflow_smoke.rs
<a id="crates-ron-bus-tests-laggedoverflowsmoke-rs"></a>

```rust
// RO:WHAT — Force lag on a slow subscriber to observe Lagged(n)
// RO:WHY  — Demonstrate lossy semantics under bounded overflow (host would count metrics)
// RO:INTERACTS — Bus, BusConfig, Event
// RO:INVARIANTS — publisher never blocks; slow consumer gets Lagged(n) and eventually exits on Shutdown
//
// Behavior notes:
// - We intentionally make the consumer slow to trigger RecvError::Lagged(n).
// - We publish Shutdown as the *last* message so that after any lag, the next Ok()
//   should observe Shutdown and break cleanly.

use ron_bus::{Bus, BusConfig, Event};
use std::sync::Arc;
use tokio::sync::broadcast::error::RecvError;
use tokio::sync::Barrier;
use tokio::time::{sleep, timeout, Duration};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn lagged_overflow_smoke() {
    let cap = 8u32; // tiny to trigger lag
    let bus = Bus::new(BusConfig::new().with_capacity(cap)).unwrap();
    let tx = bus.sender();

    let barrier = Arc::new(Barrier::new(2));

    // Slow consumer
    let mut rx_slow = bus.subscribe();
    let slow = {
        let barrier = Arc::clone(&barrier);
        tokio::spawn(async move {
            barrier.wait().await;
            let mut lagged_total = 0u64;
            loop {
                match rx_slow.recv().await {
                    Ok(Event::Shutdown) => break lagged_total,
                    Ok(_ev) => {
                        // Simulate work; large enough to induce lag with small capacity.
                        sleep(Duration::from_millis(2)).await;
                    }
                    Err(RecvError::Lagged(n)) => {
                        lagged_total += n;
                        // host would: metrics::bus_overflow_dropped_total().inc_by(n as u64);
                    }
                    Err(RecvError::Closed) => break lagged_total,
                }
            }
        })
    };

    // Fast publisher loop
    let pubber = {
        let barrier = Arc::clone(&barrier);
        tokio::spawn(async move {
            barrier.wait().await;
            for i in 0..200u32 {
                let _ = tx.send(Event::ConfigUpdated { version: i as u64 });
            }
            // Place Shutdown as the final message so late receivers converge to it.
            let _ = tx.send(Event::Shutdown);
        })
    };

    // Add a timeout safety net so the test never hangs indefinitely.
    let result = timeout(Duration::from_secs(5), async {
        let (_pub_res, lagged_total) = tokio::join!(pubber, slow);
        lagged_total.unwrap()
    })
    .await;

    match result {
        Ok(lagged_total) => {
            assert!(
                lagged_total > 0,
                "expected Lagged(n) to occur for slow consumer"
            );
        }
        Err(_elapsed) => panic!("test timed out waiting for consumer to observe Shutdown"),
    }
}

```

### crates/ron-bus/tests/loom_model.rs
<a id="crates-ron-bus-tests-loommodel-rs"></a>

```rust
// loom model test placeholder

```

### crates/ron-bus/tests/pq_labels_feature.rs
<a id="crates-ron-bus-tests-pqlabelsfeature-rs"></a>

```rust
// pq-labels feature test placeholder

```

### crates/ron-bus/tests/property_bus.rs
<a id="crates-ron-bus-tests-propertybus-rs"></a>

```rust
// property-based tests placeholder

```

### crates/ron-bus/tests/receiver_ownership.rs
<a id="crates-ron-bus-tests-receiverownership-rs"></a>

```rust
// receiver_ownership test placeholder

```

