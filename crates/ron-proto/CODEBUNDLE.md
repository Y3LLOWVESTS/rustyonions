<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:48:14Z -->
# Code Bundle — `ron-proto`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-proto/.github/workflows/ci.yml](#crates-ron-proto--github-workflows-ci-yml)
- [crates/ron-proto/.github/workflows/fuzz.yml](#crates-ron-proto--github-workflows-fuzz-yml)
- [crates/ron-proto/.github/workflows/render-mermaid.yml](#crates-ron-proto--github-workflows-render-mermaid-yml)
- [crates/ron-proto/Cargo.toml](#crates-ron-proto-Cargo-toml)
- [crates/ron-proto/benches/encode_decode_large.rs](#crates-ron-proto-benches-encodedecodelarge-rs)
- [crates/ron-proto/benches/encode_decode_small.rs](#crates-ron-proto-benches-encodedecodesmall-rs)
- [crates/ron-proto/examples/hello_json.rs](#crates-ron-proto-examples-hellojson-rs)
- [crates/ron-proto/fuzz/Cargo.toml](#crates-ron-proto-fuzz-Cargo-toml)
- [crates/ron-proto/fuzz/fuzz_targets/decode_capability.rs](#crates-ron-proto-fuzz-fuzztargets-decodecapability-rs)
- [crates/ron-proto/fuzz/fuzz_targets/decode_manifest.rs](#crates-ron-proto-fuzz-fuzztargets-decodemanifest-rs)
- [crates/ron-proto/fuzz/fuzz_targets/decode_oap_header.rs](#crates-ron-proto-fuzz-fuzztargets-decodeoapheader-rs)
- [crates/ron-proto/fuzz/fuzz_targets/parse_contentid.rs](#crates-ron-proto-fuzz-fuzztargets-parsecontentid-rs)
- [crates/ron-proto/src/cap/caveats.rs](#crates-ron-proto-src-cap-caveats-rs)
- [crates/ron-proto/src/cap/header.rs](#crates-ron-proto-src-cap-header-rs)
- [crates/ron-proto/src/cap/mod.rs](#crates-ron-proto-src-cap-mod-rs)
- [crates/ron-proto/src/config/mod.rs](#crates-ron-proto-src-config-mod-rs)
- [crates/ron-proto/src/config/validate.rs](#crates-ron-proto-src-config-validate-rs)
- [crates/ron-proto/src/econ/mod.rs](#crates-ron-proto-src-econ-mod-rs)
- [crates/ron-proto/src/econ/move_entry.rs](#crates-ron-proto-src-econ-moveentry-rs)
- [crates/ron-proto/src/error/kind.rs](#crates-ron-proto-src-error-kind-rs)
- [crates/ron-proto/src/error/mod.rs](#crates-ron-proto-src-error-mod-rs)
- [crates/ron-proto/src/error/reason.rs](#crates-ron-proto-src-error-reason-rs)
- [crates/ron-proto/src/gov/mod.rs](#crates-ron-proto-src-gov-mod-rs)
- [crates/ron-proto/src/gov/signed_descriptor.rs](#crates-ron-proto-src-gov-signeddescriptor-rs)
- [crates/ron-proto/src/id/content_id.rs](#crates-ron-proto-src-id-contentid-rs)
- [crates/ron-proto/src/id/mod.rs](#crates-ron-proto-src-id-mod-rs)
- [crates/ron-proto/src/id/parse.rs](#crates-ron-proto-src-id-parse-rs)
- [crates/ron-proto/src/lib.rs](#crates-ron-proto-src-lib-rs)
- [crates/ron-proto/src/mailbox/ack.rs](#crates-ron-proto-src-mailbox-ack-rs)
- [crates/ron-proto/src/mailbox/mod.rs](#crates-ron-proto-src-mailbox-mod-rs)
- [crates/ron-proto/src/mailbox/recv.rs](#crates-ron-proto-src-mailbox-recv-rs)
- [crates/ron-proto/src/mailbox/send.rs](#crates-ron-proto-src-mailbox-send-rs)
- [crates/ron-proto/src/manifest/common.rs](#crates-ron-proto-src-manifest-common-rs)
- [crates/ron-proto/src/manifest/mod.rs](#crates-ron-proto-src-manifest-mod-rs)
- [crates/ron-proto/src/manifest/v1.rs](#crates-ron-proto-src-manifest-v1-rs)
- [crates/ron-proto/src/naming.rs](#crates-ron-proto-src-naming-rs)
- [crates/ron-proto/src/oap/data.rs](#crates-ron-proto-src-oap-data-rs)
- [crates/ron-proto/src/oap/end.rs](#crates-ron-proto-src-oap-end-rs)
- [crates/ron-proto/src/oap/error.rs](#crates-ron-proto-src-oap-error-rs)
- [crates/ron-proto/src/oap/hello.rs](#crates-ron-proto-src-oap-hello-rs)
- [crates/ron-proto/src/oap/mod.rs](#crates-ron-proto-src-oap-mod-rs)
- [crates/ron-proto/src/oap/start.rs](#crates-ron-proto-src-oap-start-rs)
- [crates/ron-proto/src/quantum/mod.rs](#crates-ron-proto-src-quantum-mod-rs)
- [crates/ron-proto/src/quantum/pq_tags.rs](#crates-ron-proto-src-quantum-pqtags-rs)
- [crates/ron-proto/src/trace.rs](#crates-ron-proto-src-trace-rs)
- [crates/ron-proto/src/version.rs](#crates-ron-proto-src-version-rs)
- [crates/ron-proto/testing/performance/baselines/ron-proto.json](#crates-ron-proto-testing-performance-baselines-ron-proto-json)
- [crates/ron-proto/tests/content_id.rs](#crates-ron-proto-tests-contentid-rs)
- [crates/ron-proto/tests/cross_version.rs](#crates-ron-proto-tests-crossversion-rs)
- [crates/ron-proto/tests/econ_conservation.rs](#crates-ron-proto-tests-econconservation-rs)
- [crates/ron-proto/tests/golden_vectors.rs](#crates-ron-proto-tests-goldenvectors-rs)
- [crates/ron-proto/tests/hash_truth.rs](#crates-ron-proto-tests-hashtruth-rs)
- [crates/ron-proto/tests/interop_parity.rs](#crates-ron-proto-tests-interopparity-rs)
- [crates/ron-proto/tests/manifest_defaults.rs](#crates-ron-proto-tests-manifestdefaults-rs)
- [crates/ron-proto/tests/oap_roundtrip.rs](#crates-ron-proto-tests-oaproundtrip-rs)
- [crates/ron-proto/tests/validate_helpers.rs](#crates-ron-proto-tests-validatehelpers-rs)
- [crates/ron-proto/tests/vectors/content_id.json](#crates-ron-proto-tests-vectors-contentid-json)
- [crates/ron-proto/tests/vectors/manifest_v1.json](#crates-ron-proto-tests-vectors-manifestv1-json)
- [crates/ron-proto/tests/vectors/oap_data_min.json](#crates-ron-proto-tests-vectors-oapdatamin-json)
- [crates/ron-proto/tests/vectors/oap_error_envelope.json](#crates-ron-proto-tests-vectors-oaperrorenvelope-json)
- [crates/ron-proto/tests/vectors/oap_hello_v1.json](#crates-ron-proto-tests-vectors-oaphellov1-json)

### crates/ron-proto/.github/workflows/ci.yml
<a id="crates-ron-proto--github-workflows-ci-yml"></a>

```yaml

```

### crates/ron-proto/.github/workflows/fuzz.yml
<a id="crates-ron-proto--github-workflows-fuzz-yml"></a>

```yaml

```

### crates/ron-proto/.github/workflows/render-mermaid.yml
<a id="crates-ron-proto--github-workflows-render-mermaid-yml"></a>

```yaml

```

### crates/ron-proto/Cargo.toml
<a id="crates-ron-proto-Cargo-toml"></a>

```toml
[package]
name = "ron-proto"
version = "0.1.0"
edition = "2021"
rust-version = "1.80"
license = "MIT OR Apache-2.0"
description = "RustyOnions canonical DTOs: IDs, OAP/1 envelopes, manifests, mailbox, capability headers, error taxonomy."
repository = "https://example.com/RustyOnions"
readme = "README.md"
categories = ["network-programming", "data-structures"]
keywords = ["dto", "serde", "protocol"]

[lib]
name = "ron_proto"
path = "src/lib.rs"

[features]
# No "serde" feature here—serde is required always.
cbor = ["serde_cbor"]
schemars = ["dep:schemars"]

[dependencies]
bytes = { version = "1.7", default-features = false }
serde = { version = "1.0", features = ["derive"] }
serde_json = { version = "1.0", default-features = true }
serde_bytes = "0.11"
thiserror = "1.0"

# Optional formats / tooling
serde_cbor = { version = "0.11", optional = true }
schemars = { version = "0.8", optional = true, default-features = false, features = ["either", "uuid"] }

[dev-dependencies]
proptest = "1.6"
rand = "0.9"

```

### crates/ron-proto/benches/encode_decode_large.rs
<a id="crates-ron-proto-benches-encodedecodelarge-rs"></a>

```rust


```

### crates/ron-proto/benches/encode_decode_small.rs
<a id="crates-ron-proto-benches-encodedecodesmall-rs"></a>

```rust


```

### crates/ron-proto/examples/hello_json.rs
<a id="crates-ron-proto-examples-hellojson-rs"></a>

```rust
use ron_proto::oap::hello::Hello;
use serde_json as json;

fn main() {
    let hello = Hello::default();
    println!("{}", json::to_string_pretty(&hello).unwrap());
}

```

### crates/ron-proto/fuzz/Cargo.toml
<a id="crates-ron-proto-fuzz-Cargo-toml"></a>

```toml

```

### crates/ron-proto/fuzz/fuzz_targets/decode_capability.rs
<a id="crates-ron-proto-fuzz-fuzztargets-decodecapability-rs"></a>

```rust

```

### crates/ron-proto/fuzz/fuzz_targets/decode_manifest.rs
<a id="crates-ron-proto-fuzz-fuzztargets-decodemanifest-rs"></a>

```rust

```

### crates/ron-proto/fuzz/fuzz_targets/decode_oap_header.rs
<a id="crates-ron-proto-fuzz-fuzztargets-decodeoapheader-rs"></a>

```rust

```

### crates/ron-proto/fuzz/fuzz_targets/parse_contentid.rs
<a id="crates-ron-proto-fuzz-fuzztargets-parsecontentid-rs"></a>

```rust

```

### crates/ron-proto/src/cap/caveats.rs
<a id="crates-ron-proto-src-cap-caveats-rs"></a>

```rust
//! RO:WHAT — Enumerated caveats/flags attached to capability tokens.
//! RO:WHY  — Additive growth via non_exhaustive enum + reserved fields.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "kind", rename_all = "snake_case", deny_unknown_fields)]
#[non_exhaustive]
pub enum Caveat {
    IpAllowlist { cidrs: Vec<String> },
    WriteOnce,
    ContentPrefix { prefix: String }, // e.g., restrict to a subtree/name
}
pub type CaveatKind = Caveat;

```

### crates/ron-proto/src/cap/header.rs
<a id="crates-ron-proto-src-cap-header-rs"></a>

```rust
//! RO:WHAT — `CapTokenHdr` with typed claims (no signatures here).
//! RO:WHY  — Stable header schema for capability enforcement.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct CapTokenHdr {
    pub subject: String, // e.g., user or service id
    pub scope: String,   // e.g., "read", "write-once"
    pub issued_at: u64,  // seconds
    pub expires_at: u64, // seconds (short TTL recommended)
    #[serde(default)]
    pub caveats: Vec<crate::cap::Caveat>,
}

```

### crates/ron-proto/src/cap/mod.rs
<a id="crates-ron-proto-src-cap-mod-rs"></a>

```rust
//! RO:WHAT — Capability token header DTOs (claims/caveats only).
//! RO:WHY  — Typed claims for macaroon-style caps; verification lives in auth services.

pub mod caveats;
pub mod header;

pub use caveats::{Caveat, CaveatKind};
pub use header::CapTokenHdr;

```

### crates/ron-proto/src/config/mod.rs
<a id="crates-ron-proto-src-config-mod-rs"></a>

```rust
//! RO:WHAT — Lightweight, DTO-level validation helpers (no I/O).
//! RO:WHY  — Central place to enforce protocol invariants shared by hosts.
//! RO:INTERACTS — oap::{hello,start,data,end}, version::PROTO_VERSION, error::{ProtoError,Kind}.
//! RO:INVARIANTS — Pure functions; return `ProtoError` with stable reason strings.

use crate::error::{Kind, ProtoError};

/// Validate that the peer speaks our protocol/version.
pub fn validate_hello(h: &crate::oap::hello::Hello) -> Result<(), ProtoError> {
    if h.protocol != "OAP/1" {
        return Err(ProtoError {
            kind: Kind::ProtoMismatch,
            message: format!("unsupported protocol '{}'", h.protocol),
        });
    }
    if h.version != crate::version::PROTO_VERSION {
        return Err(ProtoError {
            kind: Kind::ProtoMismatch,
            message: format!("version {} != {}", h.version, crate::version::PROTO_VERSION),
        });
    }
    Ok(())
}

/// Validate START frame limits against the OAP cap.
pub fn validate_start(s: &crate::oap::start::Start) -> Result<(), ProtoError> {
    if (s.max_frame_bytes as usize) > crate::oap::MAX_FRAME_BYTES {
        return Err(ProtoError {
            kind: Kind::TooLarge,
            message: format!(
                "max_frame_bytes={} exceeds cap {}",
                s.max_frame_bytes,
                crate::oap::MAX_FRAME_BYTES
            ),
        });
    }
    Ok(())
}

/// Validate a DATA frame's payload size against a negotiated bound.
///
/// `negotiated_max` should come from `Start.max_frame_bytes` (after `validate_start`).
pub fn validate_data(d: &crate::oap::data::Data, negotiated_max: u32) -> Result<(), ProtoError> {
    let len = d.bytes.len() as u32;
    if len > negotiated_max {
        return Err(ProtoError {
            kind: Kind::TooLarge,
            message: format!("data bytes={} > negotiated_max={}", len, negotiated_max),
        });
    }
    Ok(())
}

/// Validate monotonic sequence progression (host streams can opt-in).
pub fn validate_seq_progress(prev: u64, next: u64) -> Result<(), ProtoError> {
    if next <= prev {
        return Err(ProtoError {
            kind: Kind::BadRequest,
            message: format!("non-monotonic seq: next={} <= prev={}", next, prev),
        });
    }
    Ok(())
}

// Re-export trait sugar for callers who prefer impl-based validation.
pub mod validate;
pub use validate::{Limits, Validate}; // <— re-export both so users can `use ron_proto::{Validate, Limits};`

```

### crates/ron-proto/src/config/validate.rs
<a id="crates-ron-proto-src-config-validate-rs"></a>

```rust
//! RO:WHAT — Trait-based validation sugar for DTOs.
//! RO:WHY  — Optional ergonomics so hosts can call `x.validate(...)` directly.

use crate::config::{validate_data, validate_hello, validate_start};
use crate::error::ProtoError;

/// Negotiated/host limits needed for validating certain frames.
#[derive(Debug, Clone, Copy)]
pub struct Limits {
    /// Max bytes allowed in a single DATA frame (usually negotiated from START).
    pub max_frame_bytes: u32,
}

impl Default for Limits {
    fn default() -> Self {
        // Be conservative by default; many hosts will set this from START.
        Self {
            max_frame_bytes: crate::oap::MAX_FRAME_BYTES as u32,
        }
    }
}

/// DTOs can opt into trait-based validation.
pub trait Validate {
    fn validate(&self, limits: Limits) -> Result<(), ProtoError>;
}

impl Validate for crate::oap::hello::Hello {
    fn validate(&self, _limits: Limits) -> Result<(), ProtoError> {
        validate_hello(self)
    }
}

impl Validate for crate::oap::start::Start {
    fn validate(&self, _limits: Limits) -> Result<(), ProtoError> {
        validate_start(self)
    }
}

impl Validate for crate::oap::data::Data {
    fn validate(&self, limits: Limits) -> Result<(), ProtoError> {
        validate_data(self, limits.max_frame_bytes)
    }
}

```

### crates/ron-proto/src/econ/mod.rs
<a id="crates-ron-proto-src-econ-mod-rs"></a>

```rust
//! RO:WHAT — ECON-adjacent DTOs used by ledger/rewarder (pure data).
//! RO:WHY  — Keep conservation-friendly shapes; no arithmetic logic here.

pub mod move_entry;

pub use move_entry::MoveEntryV1;

```

### crates/ron-proto/src/econ/move_entry.rs
<a id="crates-ron-proto-src-econ-moveentry-rs"></a>

```rust
//! RO:WHAT — `MoveEntryV1` debit/credit record shape (no arithmetic here).
//! RO:WHY  — Deterministic, signed-friendly DTO for ECON services.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct MoveEntryV1 {
    pub entry_id: String,
    pub account: String,
    /// Positive integer value in minor units (e.g., cents)
    pub amount_minor: u64,
    /// +1 for credit, -1 for debit (host logic enforces consistency)
    pub sign: i8,
    #[serde(default)]
    pub memo: Option<String>,
}

```

### crates/ron-proto/src/error/kind.rs
<a id="crates-ron-proto-src-error-kind-rs"></a>

```rust
//! RO:WHAT — Enumerated error kinds used across DTOs.
//! RO:WHY  — Stable, additive error space for interop & metrics.

use serde::{Deserialize, Serialize};

#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
#[non_exhaustive]
pub enum Kind {
    BadRequest,
    Unauthorized,
    Forbidden,
    NotFound,
    Conflict,
    TooLarge,
    RateLimited,
    Internal,
    Unavailable,
    ProtoMismatch,
}

```

### crates/ron-proto/src/error/mod.rs
<a id="crates-ron-proto-src-error-mod-rs"></a>

```rust
//! RO:WHAT — Typed error taxonomy (`ProtoError`, `Kind`) with stable reasons.
//! RO:WHY  — Deterministic errors for metrics and control flow; immutable reason strings.
//! RO:TEST — Unit tests assert reason strings remain stable across versions.

mod kind;
mod reason;

pub use kind::Kind;
pub use reason::stable_reason;

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct ProtoError {
    pub kind: Kind,
    pub message: String,
}

impl ProtoError {
    pub fn metric_reason(&self) -> &'static str {
        stable_reason(self.kind)
    }
}

```

### crates/ron-proto/src/error/reason.rs
<a id="crates-ron-proto-src-error-reason-rs"></a>

```rust
//! RO:WHAT — Stable mapping from `Kind` to metric reason strings.
//! RO:WHY  — Metric labels must be immutable across versions.

use super::Kind;

pub fn stable_reason(k: Kind) -> &'static str {
    match k {
        Kind::BadRequest => "bad_request",
        Kind::Unauthorized => "unauthorized",
        Kind::Forbidden => "forbidden",
        Kind::NotFound => "not_found",
        Kind::Conflict => "conflict",
        Kind::TooLarge => "too_large",
        Kind::RateLimited => "rate_limited",
        Kind::Internal => "internal",
        Kind::Unavailable => "unavailable",
        Kind::ProtoMismatch => "proto_mismatch",
    }
}

```

### crates/ron-proto/src/gov/mod.rs
<a id="crates-ron-proto-src-gov-mod-rs"></a>

```rust
//! RO:WHAT — Governance DTOs (signable descriptors; no signatures here).
//! RO:WHY  — Typed inputs for policy/registry; PQ-agile via quantum:: tags.

pub mod signed_descriptor;

pub use signed_descriptor::{MultiSigNofM, SignedDescriptorV1};

```

### crates/ron-proto/src/gov/signed_descriptor.rs
<a id="crates-ron-proto-src-gov-signeddescriptor-rs"></a>

```rust
//! RO:WHAT — SignedDescriptorV1 header (detached signature carried elsewhere).
//! RO:WHY  — Replay-safe governance inputs; PQ-agile via quantum tags.
//! RO:INVARIANTS — deny_unknown_fields; deterministic field order.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct MultiSigNofM {
    pub n: u8,
    pub m: u8,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct SignedDescriptorV1 {
    pub descriptor_cid: crate::id::ContentId,
    pub alg: crate::quantum::SignatureAlg,
    pub quorum: MultiSigNofM,
    pub issued_at: u64,
    pub expires_at: u64,
    /// CID of rationale or supplemental evidence
    pub rationale_cid: Option<crate::id::ContentId>,
}

```

### crates/ron-proto/src/id/content_id.rs
<a id="crates-ron-proto-src-id-contentid-rs"></a>

```rust
//! RO:WHAT — `ContentId` newtype ("b3:<hex>") with strict parser/serde.
//! RO:WHY  — Enforce I-1 addressing (BLAKE3) and deterministic casing across SDKs.
//! RO:INTERACTS — oap::Data/End, manifest entries, naming refs.
//! RO:INVARIANTS — hex length=64, lowercase, prefix "b3:"; serde rejects unknown/invalid forms.
//! RO:TEST — proptest for random valid/invalid strings; vector parity tests.

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::{fmt, str::FromStr};

pub const CONTENT_ID_PREFIX: &str = "b3:";
pub const CONTENT_ID_HEX_LEN: usize = 64;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ContentId(String);

impl ContentId {
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Parse with strict validation.
    pub fn parse(s: &str) -> Result<Self, crate::id::ParseContentIdError> {
        crate::id::validate_b3_str(s)?;
        Ok(Self(s.to_string()))
    }
}

impl fmt::Debug for ContentId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Avoid dumping long hex in logs: short preview
        write!(
            f,
            "ContentId({}…)",
            &self.0[..std::cmp::min(self.0.len(), 8)]
        )
    }
}

impl fmt::Display for ContentId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

impl FromStr for ContentId {
    type Err = crate::id::ParseContentIdError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::parse(s)
    }
}

impl Serialize for ContentId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.0)
    }
}

impl<'de> Deserialize<'de> for ContentId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        crate::id::validate_b3_str(&s).map_err(serde::de::Error::custom)?;
        Ok(Self(s))
    }
}

```

### crates/ron-proto/src/id/mod.rs
<a id="crates-ron-proto-src-id-mod-rs"></a>

```rust
//! RO:WHAT — Newtypes and helpers for canonical IDs (content-addresses, names).
//! RO:WHY  — Strong typing for interop; prevent stringly-typed bugs.
//! RO:INTERACTS — Used across OAP envelopes, manifests, mailbox, governance.
//! RO:INVARIANTS — ContentId must be "b3:<64 lowercase hex>"; no hashing performed here.
//! RO:TEST — Round-trip serde tests and parser property tests live in this module.

mod content_id;
mod parse;

pub use content_id::{ContentId, CONTENT_ID_HEX_LEN, CONTENT_ID_PREFIX};
pub use parse::{is_lower_hex64, validate_b3_str, ParseContentIdError};

```

### crates/ron-proto/src/id/parse.rs
<a id="crates-ron-proto-src-id-parse-rs"></a>

```rust
//! RO:WHAT — Strict validators and parse errors for `ContentId`.
//! RO:WHY  — Keep hashing out of ron-proto; only parse/validate.
//! RO:INTERACTS — Used by ContentId serde and FromStr.
//! RO:INVARIANTS — 64 lowercase hex after "b3:" prefix.

use thiserror::Error;

#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum ParseContentIdError {
    #[error("missing 'b3:' prefix")]
    MissingPrefix,
    #[error("hex length must be 64 characters")]
    BadLen,
    #[error("hex must be lowercase [0-9a-f]")]
    BadHex,
}

pub fn validate_b3_str(s: &str) -> Result<(), ParseContentIdError> {
    if !s.starts_with(super::CONTENT_ID_PREFIX) {
        return Err(ParseContentIdError::MissingPrefix);
    }
    let hex = &s[super::CONTENT_ID_PREFIX.len()..];
    if hex.len() != super::CONTENT_ID_HEX_LEN {
        return Err(ParseContentIdError::BadLen);
    }
    if !is_lower_hex64(hex) {
        return Err(ParseContentIdError::BadHex);
    }
    Ok(())
}

pub fn is_lower_hex64(hex: &str) -> bool {
    hex.bytes().all(|b| matches!(b, b'0'..=b'9'|b'a'..=b'f'))
}

```

### crates/ron-proto/src/lib.rs
<a id="crates-ron-proto-src-lib-rs"></a>

```rust
//! RO:WHAT — Flat public facade for RustyOnions canonical DTOs (pure types).
//! RO:WHY  — Pillar 7 (SDK/Interop); Concerns: DX/RES. Deterministic, strict schemas for cross-SDK parity.
//! RO:INTERACTS — oap (frames), id::ContentId, manifest::*, mailbox::*, cap::*, error::*, version::*, naming::*, econ::*, gov::*, quantum::*
//! RO:INVARIANTS — DTO-only (no I/O/crypto); #[serde(deny_unknown_fields)] on externals; OAP max_frame=1MiB; storage chunk≈64KiB.
//! RO:METRICS — N/A (library types only; reason strings stable for host metrics).
//! RO:CONFIG — None (schema helpers only).
//! RO:SECURITY — No secrets/PII; capability types are headers only (no verification).
//! RO:TEST — See tests/ in crate (vectors, cross-version, property tests).

#![forbid(unsafe_code)]
#![deny(warnings)]

pub mod cap;
pub mod config;
pub mod econ;
pub mod error;
pub mod gov;
pub mod id;
pub mod mailbox;
pub mod manifest;
pub mod naming;
pub mod oap;
pub mod quantum;
pub mod trace;
pub mod version; // <— export config helpers/traits

pub use cap::*;
pub use config::{Limits, Validate};
pub use econ::*;
pub use error::*;
pub use gov::*;
pub use id::*;
pub use mailbox::*;
pub use manifest::*;
pub use naming::*;
pub use oap::*;
pub use quantum::*;
pub use trace::*;
pub use version::*; // <— re-export trait + limits for ergonomics

```

### crates/ron-proto/src/mailbox/ack.rs
<a id="crates-ron-proto-src-mailbox-ack-rs"></a>

```rust
//! RO:WHAT — Mailbox Ack DTO.
//! RO:WHY  — Allows hosts to acknowledge processing; no side-effects here.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Ack {
    pub msg_id: String,
    pub ok: bool,
    #[serde(default)]
    pub error: Option<crate::error::ProtoError>,
}

```

### crates/ron-proto/src/mailbox/mod.rs
<a id="crates-ron-proto-src-mailbox-mod-rs"></a>

```rust
//! RO:WHAT — Mailbox DTO entrypoint (Send/Recv/Ack).
//! RO:WHY  — Cross-service message shapes; at-least-once semantics live elsewhere.

pub mod ack;
pub mod recv;
pub mod send;

pub use ack::Ack;
pub use recv::Recv;
pub use send::Send;

```

### crates/ron-proto/src/mailbox/recv.rs
<a id="crates-ron-proto-src-mailbox-recv-rs"></a>

```rust
//! RO:WHAT — Mailbox Recv DTO (deliver to consumer).
//! RO:WHY  — Symmetric with Send; pure data only.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Recv {
    pub msg_id: String,
    pub from: String,
    pub kind: String,
    #[serde(with = "serde_bytes")]
    pub payload: Vec<u8>,
}

```

### crates/ron-proto/src/mailbox/send.rs
<a id="crates-ron-proto-src-mailbox-send-rs"></a>

```rust
//! RO:WHAT — Mailbox Send DTO with idempotency headers.
//! RO:WHY  — Enable at-least-once delivery patterns without logic here.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Send {
    pub msg_id: String,
    pub to: String,
    pub kind: String,
    #[serde(with = "serde_bytes")]
    pub payload: Vec<u8>,
    /// Host-side idempotency key for dedupe
    #[serde(default)]
    pub idempotency_key: Option<String>,
}

```

### crates/ron-proto/src/manifest/common.rs
<a id="crates-ron-proto-src-manifest-common-rs"></a>

```rust
//! RO:WHAT — Shared enums/consts across manifest versions.
//! RO:WHY  — Keep cross-version evolution clean and explicit.
//! RO:INVARIANTS — Deterministic defaults; serde rejects unknown fields where used.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
#[non_exhaustive]
pub enum MediaKind {
    #[default]
    Blob,
    Manifest,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct EntryRef {
    pub id: crate::id::ContentId,
    pub size: u64,
    /// Default to `blob` when omitted for backward compatibility.
    #[serde(default)]
    pub kind: MediaKind,
}

```

### crates/ron-proto/src/manifest/mod.rs
<a id="crates-ron-proto-src-manifest-mod-rs"></a>

```rust
//! RO:WHAT — Versioned manifest DTOs for content graphs.
//! RO:WHY  — Names → manifests → providers; pure data for index/storage.
//! RO:INVARIANTS — Explicit versioning; deterministic ordering (BTreeMap when maps appear).

pub mod common;
pub mod v1;

pub use common::*;
pub use v1::*;

```

### crates/ron-proto/src/manifest/v1.rs
<a id="crates-ron-proto-src-manifest-v1-rs"></a>

```rust
//! RO:WHAT — `ManifestV1` DTO (explicit version field).
//! RO:WHY  — Deterministic, growth-tolerant manifest for CAS graphs.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct ManifestV1 {
    pub version: u32, // = 1
    pub root: crate::id::ContentId,
    /// Ordered mapping (deterministic) from name → object reference
    pub entries: BTreeMap<String, crate::manifest::EntryRef>,
    #[serde(default)]
    pub meta: BTreeMap<String, String>,
}

impl Default for ManifestV1 {
    fn default() -> Self {
        Self {
            version: 1,
            root: "b3:0000000000000000000000000000000000000000000000000000000000000000"
                .parse()
                .unwrap(),
            entries: BTreeMap::new(),
            meta: BTreeMap::new(),
        }
    }
}

```

### crates/ron-proto/src/naming.rs
<a id="crates-ron-proto-src-naming-rs"></a>

```rust
//! RO:WHAT — Naming/manifest reference types (pure data).
//! RO:WHY  — Provide typed handles for index/gateway layers; resolution lives elsewhere.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct NameRef {
    pub name: String,                           // e.g., "user:stevan/avatar"
    pub expected: Option<crate::id::ContentId>, // optional pin for strong reads
}

```

### crates/ron-proto/src/oap/data.rs
<a id="crates-ron-proto-src-oap-data-rs"></a>

```rust
//! RO:WHAT — OAP DATA frame with object address and payload chunk.
//! RO:WHY  — Carries addressed bytes; readers verify BLAKE3 elsewhere.
//! RO:INVARIANTS — obj is "b3:<hex>"; bytes length must respect max_frame (host-enforced).

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Data {
    pub obj: crate::id::ContentId,
    pub seq: u64,
    #[serde(with = "serde_bytes")]
    pub bytes: Vec<u8>,
}

```

### crates/ron-proto/src/oap/end.rs
<a id="crates-ron-proto-src-oap-end-rs"></a>

```rust
//! RO:WHAT — OAP END frame (finalization status).
//! RO:WHY  — Terminates a flow and conveys integrity/result summary.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct End {
    pub seq_end: u64,
    pub ok: bool,
    #[serde(default)]
    pub error: Option<crate::oap::error::Error>,
}

```

### crates/ron-proto/src/oap/error.rs
<a id="crates-ron-proto-src-oap-error-rs"></a>

```rust
//! RO:WHAT — OAP ERROR envelope (wire-level error details).
//! RO:WHY  — Stable, typed error codes that SDKs can rely on for metrics and control flow.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Error {
    pub code: crate::error::Kind,
    pub message: String,
    #[serde(default)]
    pub detail: Option<String>,
}

```

### crates/ron-proto/src/oap/hello.rs
<a id="crates-ron-proto-src-oap-hello-rs"></a>

```rust
//! RO:WHAT — OAP HELLO frame (protocol/version negotiation).
//! RO:WHY  — Establishes version/features; first contact envelope.
//! RO:INVARIANTS — Strict fields; unknown fields rejected. Use owned `String`
//!                 so JSON deserialization doesn't require a `'static` lifetime.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Hello {
    pub protocol: String, // was &'static str; use String for serde-compat
    pub version: u32,     // mirrors PROTO_VERSION
    #[serde(default)]
    pub features: Vec<String>, // future growth; strings must be stable tokens
}

impl Default for Hello {
    fn default() -> Self {
        Self {
            protocol: "OAP/1".to_string(),
            version: crate::version::PROTO_VERSION,
            features: Vec::new(),
        }
    }
}

```

### crates/ron-proto/src/oap/mod.rs
<a id="crates-ron-proto-src-oap-mod-rs"></a>

```rust
//! RO:WHAT — OAP/1 envelope DTOs (HELLO/START/DATA/END/ERROR).
//! RO:WHY  — Interop contract: frames carry DTOs between services/SDKs.
//! RO:INTERACTS — id::ContentId; version::PROTO_VERSION; error::ProtoError.
//! RO:INVARIANTS — OAP/1 max_frame=1MiB; chunk≈64KiB is a storage guideline (not enforced here). Strict serde.
//! RO:TEST — vectors under tests/vectors; fuzz targets for headers.

use serde::{Deserialize, Serialize};

pub const MAX_FRAME_BYTES: usize = 1024 * 1024; // 1 MiB

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "UPPERCASE")]
#[non_exhaustive]
pub enum OapKind {
    Hello,
    Start,
    Data,
    End,
    Error,
}

pub mod data;
pub mod end;
pub mod error;
pub mod hello;
pub mod start;

```

### crates/ron-proto/src/oap/start.rs
<a id="crates-ron-proto-src-oap-start-rs"></a>

```rust
//! RO:WHAT — OAP START frame (session/stream parameters).
//! RO:WHY  — Sets negotiated limits before DATA frames flow.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Start {
    pub seq_start: u64,
    pub max_frame_bytes: u32, // must be <= 1MiB; validated by hosts
    #[serde(default)]
    pub meta: Option<String>, // reserved for growth (e.g., codec hints)
}

```

### crates/ron-proto/src/quantum/mod.rs
<a id="crates-ron-proto-src-quantum-mod-rs"></a>

```rust
//! RO:WHAT — PQ-hybrid algorithm tags (enums only; no crypto).
//! RO:WHY  — Keep protocol PQ-agile without dragging crypto deps here.

pub mod pq_tags;

pub use pq_tags::{KemAlg, SignatureAlg};

```

### crates/ron-proto/src/quantum/pq_tags.rs
<a id="crates-ron-proto-src-quantum-pqtags-rs"></a>

```rust
//! RO:WHAT — Enumerations for PQ-capable algorithms referenced by DTOs.
//! RO:WHY  — Wire-stable tokens for hybrid/transition periods (no crypto here).

use serde::{Deserialize, Serialize};

#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
#[non_exhaustive]
pub enum SignatureAlg {
    Ed25519,
    Dilithium3,
    HybridEd25519Dilithium3,
}

#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
#[non_exhaustive]
pub enum KemAlg {
    X25519,
    Kyber768,
    HybridX25519Kyber768,
}

```

### crates/ron-proto/src/trace.rs
<a id="crates-ron-proto-src-trace-rs"></a>

```rust
//! RO:WHAT — Tiny helpers for correlation/trace fields in DTOs.
//! RO:WHY  — Allow hosts to carry correlation IDs without depending on tracing crates.

use serde::{Deserialize, Serialize};

#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Hash, Default)]
#[serde(deny_unknown_fields)]
pub struct CorrId {
    pub id: u64,
}

```

### crates/ron-proto/src/version.rs
<a id="crates-ron-proto-src-version-rs"></a>

```rust
//! RO:WHAT — Protocol version & ABI fingerprint constants.
//! RO:WHY  — Gate breaking changes; SDKs/tests assert these during upgrades.

pub const PROTO_VERSION: u32 = 1;

// NOTE: In CI you can replace this with include_str!("../docs/schema/fingerprint.txt")
// to enforce schema-diff gates. Using a placeholder here to keep the crate self-contained.
pub const PROTO_ABI_FINGERPRINT: &str = "dev-fingerprint";

```

### crates/ron-proto/testing/performance/baselines/ron-proto.json
<a id="crates-ron-proto-testing-performance-baselines-ron-proto-json"></a>

```json

```

### crates/ron-proto/tests/content_id.rs
<a id="crates-ron-proto-tests-contentid-rs"></a>

```rust
use ron_proto::ContentId;

#[test]
fn content_id_parses_and_displays() {
    let s = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    let cid: ContentId = s.parse().unwrap();
    assert_eq!(cid.to_string(), s);
    assert_eq!(cid.as_str(), s);
}

#[test]
fn content_id_rejects_bad_prefix() {
    let s = "b2:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    assert!(s.parse::<ContentId>().is_err());
}

#[test]
fn content_id_rejects_bad_len() {
    let s = "b3:0123456789abcdef"; // too short
    assert!(s.parse::<ContentId>().is_err());
}

#[test]
fn content_id_rejects_uppercase() {
    let s = "b3:0123456789ABCDEF0123456789abcdef0123456789abcdef0123456789abcdef";
    assert!(s.parse::<ContentId>().is_err());
}

```

### crates/ron-proto/tests/cross_version.rs
<a id="crates-ron-proto-tests-crossversion-rs"></a>

```rust


```

### crates/ron-proto/tests/econ_conservation.rs
<a id="crates-ron-proto-tests-econconservation-rs"></a>

```rust


```

### crates/ron-proto/tests/golden_vectors.rs
<a id="crates-ron-proto-tests-goldenvectors-rs"></a>

```rust
use serde_json as json;

#[test]
fn golden_oap_hello_v1_loads() {
    // Embedded golden vector
    const HELLO_JSON: &str = r#"
    {
      "protocol": "OAP/1",
      "version": 1,
      "features": []
    }
    "#;

    let hello: ron_proto::oap::hello::Hello = json::from_str(HELLO_JSON).unwrap();
    assert_eq!(hello.protocol, "OAP/1");
    assert_eq!(hello.version, ron_proto::version::PROTO_VERSION);
}

#[test]
fn golden_oap_data_min_loads() {
    // IMPORTANT: serde_json + serde_bytes represent Vec<u8> as an array of integers
    // (not base64) by default. Use numeric bytes here for portable goldens.
    const DATA_JSON: &str = r#"
    {
      "obj": "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
      "seq": 1,
      "bytes": [104,101,108,108,111]
    }
    "#;

    let data: ron_proto::oap::data::Data = json::from_str(DATA_JSON).unwrap();
    assert_eq!(data.seq, 1);
    assert_eq!(data.bytes, b"hello");
}

```

### crates/ron-proto/tests/hash_truth.rs
<a id="crates-ron-proto-tests-hashtruth-rs"></a>

```rust


```

### crates/ron-proto/tests/interop_parity.rs
<a id="crates-ron-proto-tests-interopparity-rs"></a>

```rust


```

### crates/ron-proto/tests/manifest_defaults.rs
<a id="crates-ron-proto-tests-manifestdefaults-rs"></a>

```rust
use ron_proto::{manifest::EntryRef, ContentId};
use serde_json as json;

#[test]
fn entryref_kind_defaults_to_blob() {
    let cid: ContentId = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
        .parse()
        .unwrap();

    // kind omitted on purpose (should default to "blob")
    let value = json::json!({
        "id": cid.to_string(),
        "size": 1234
    });

    let parsed: EntryRef = json::from_value(value).unwrap();

    // Serialize back and ensure "blob" is present
    let round = json::to_value(&parsed).unwrap();
    assert_eq!(round.get("kind").unwrap().as_str().unwrap(), "blob");
}

```

### crates/ron-proto/tests/oap_roundtrip.rs
<a id="crates-ron-proto-tests-oaproundtrip-rs"></a>

```rust
use ron_proto::ContentId;
use serde_json as json;

#[test]
fn hello_default_roundtrip() {
    let h = ron_proto::oap::hello::Hello::default();
    let s = json::to_string(&h).unwrap();
    let back: ron_proto::oap::hello::Hello = json::from_str(&s).unwrap();
    assert_eq!(h.protocol, back.protocol);
    assert_eq!(h.version, back.version);
}

#[test]
fn data_frame_roundtrip() {
    let cid: ContentId = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
        .parse()
        .unwrap();
    let d = ron_proto::oap::data::Data {
        obj: cid,
        seq: 42,
        bytes: b"hello world".to_vec(),
    };
    let s = json::to_string(&d).unwrap();
    let back: ron_proto::oap::data::Data = json::from_str(&s).unwrap();
    assert_eq!(back.seq, 42);
    assert_eq!(back.bytes, b"hello world");
}

#[test]
fn end_with_error_roundtrip() {
    let e = ron_proto::oap::error::Error {
        code: ron_proto::error::Kind::TooLarge,
        message: "frame exceeds limit".into(),
        detail: Some("max 1MiB".into()),
    };
    let end = ron_proto::oap::end::End {
        seq_end: 99,
        ok: false,
        error: Some(e),
    };
    let s = json::to_string(&end).unwrap();
    let back: ron_proto::oap::end::End = json::from_str(&s).unwrap();
    assert!(!back.ok);
    assert!(matches!(
        back.error.as_ref().unwrap().code,
        ron_proto::error::Kind::TooLarge
    ));
}

#[test]
fn kind_enum_ser_names_match() {
    use ron_proto::oap::OapKind;
    let kinds = [
        OapKind::Hello,
        OapKind::Start,
        OapKind::Data,
        OapKind::End,
        OapKind::Error,
    ];
    let names: Vec<String> = kinds.iter().map(|k| json::to_string(k).unwrap()).collect();
    assert_eq!(
        names,
        vec![
            r#""HELLO""#,
            r#""START""#,
            r#""DATA""#,
            r#""END""#,
            r#""ERROR""#
        ]
    );
}

```

### crates/ron-proto/tests/validate_helpers.rs
<a id="crates-ron-proto-tests-validatehelpers-rs"></a>

```rust
use ron_proto::{oap, ContentId, Limits, Validate};

#[test]
fn hello_and_start_validate() {
    let hello = oap::hello::Hello::default();
    hello.validate(Limits::default()).unwrap();

    let start = oap::start::Start {
        seq_start: 0,
        max_frame_bytes: 1_048_576,
        meta: None,
    };
    start.validate(Limits::default()).unwrap();
}

#[test]
fn data_respects_negotiated_max() {
    let limits = Limits { max_frame_bytes: 8 };

    // Make the type explicit so .parse() knows the target type:
    let cid: ContentId = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
        .parse()
        .unwrap();

    let ok = oap::data::Data {
        obj: cid.clone(),
        seq: 1,
        bytes: b"12345678".to_vec(),
    };
    ok.validate(limits).unwrap();

    let too_big = oap::data::Data {
        obj: cid,
        seq: 2,
        bytes: b"abcdefghi".to_vec(),
    };
    assert!(too_big.validate(limits).is_err());
}

```

### crates/ron-proto/tests/vectors/content_id.json
<a id="crates-ron-proto-tests-vectors-contentid-json"></a>

```json

```

### crates/ron-proto/tests/vectors/manifest_v1.json
<a id="crates-ron-proto-tests-vectors-manifestv1-json"></a>

```json

```

### crates/ron-proto/tests/vectors/oap_data_min.json
<a id="crates-ron-proto-tests-vectors-oapdatamin-json"></a>

```json
{
  "obj": "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
  "seq": 1,
  "bytes": "aGVsbG8="
}

```

### crates/ron-proto/tests/vectors/oap_error_envelope.json
<a id="crates-ron-proto-tests-vectors-oaperrorenvelope-json"></a>

```json

```

### crates/ron-proto/tests/vectors/oap_hello_v1.json
<a id="crates-ron-proto-tests-vectors-oaphellov1-json"></a>

```json
{
  "protocol": "OAP/1",
  "version": 1,
  "features": []
}

```

