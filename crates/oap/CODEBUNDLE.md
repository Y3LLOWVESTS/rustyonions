<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:43:11Z -->
# Code Bundle — `oap`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/oap/.cargo/config.toml](#crates-oap--cargo-config-toml)
- [crates/oap/.github/workflows/ci.yml](#crates-oap--github-workflows-ci-yml)
- [crates/oap/.github/workflows/public-api.yml](#crates-oap--github-workflows-public-api-yml)
- [crates/oap/.github/workflows/render-mermaid.yml](#crates-oap--github-workflows-render-mermaid-yml)
- [crates/oap/Cargo.toml](#crates-oap-Cargo-toml)
- [crates/oap/benches/decode_happy.rs](#crates-oap-benches-decodehappy-rs)
- [crates/oap/benches/decode_pathological.rs](#crates-oap-benches-decodepathological-rs)
- [crates/oap/benches/encode_ack.rs](#crates-oap-benches-encodeack-rs)
- [crates/oap/fuzz/fuzz_targets/ack_fuzz.rs](#crates-oap-fuzz-fuzztargets-ackfuzz-rs)
- [crates/oap/fuzz/fuzz_targets/header_fuzz.rs](#crates-oap-fuzz-fuzztargets-headerfuzz-rs)
- [crates/oap/fuzz/fuzz_targets/parser_fuzz.rs](#crates-oap-fuzz-fuzztargets-parserfuzz-rs)
- [crates/oap/rust-toolchain.toml](#crates-oap-rust-toolchain-toml)
- [crates/oap/scripts/perf_compare.sh](#crates-oap-scripts-perfcompare-sh)
- [crates/oap/src/codec.rs](#crates-oap-src-codec-rs)
- [crates/oap/src/constants.rs](#crates-oap-src-constants-rs)
- [crates/oap/src/envelope.rs](#crates-oap-src-envelope-rs)
- [crates/oap/src/error.rs](#crates-oap-src-error-rs)
- [crates/oap/src/flags.rs](#crates-oap-src-flags-rs)
- [crates/oap/src/frame.rs](#crates-oap-src-frame-rs)
- [crates/oap/src/header.rs](#crates-oap-src-header-rs)
- [crates/oap/src/hello.rs](#crates-oap-src-hello-rs)
- [crates/oap/src/lib.rs](#crates-oap-src-lib-rs)
- [crates/oap/src/metrics.rs](#crates-oap-src-metrics-rs)
- [crates/oap/src/parser/config.rs](#crates-oap-src-parser-config-rs)
- [crates/oap/src/parser/mod.rs](#crates-oap-src-parser-mod-rs)
- [crates/oap/src/parser/state.rs](#crates-oap-src-parser-state-rs)
- [crates/oap/src/prelude.rs](#crates-oap-src-prelude-rs)
- [crates/oap/src/seq.rs](#crates-oap-src-seq-rs)
- [crates/oap/src/writer/config.rs](#crates-oap-src-writer-config-rs)
- [crates/oap/src/writer/mod.rs](#crates-oap-src-writer-mod-rs)
- [crates/oap/tests/ack_algebra.rs](#crates-oap-tests-ackalgebra-rs)
- [crates/oap/tests/config_validation.rs](#crates-oap-tests-configvalidation-rs)
- [crates/oap/tests/conformance.rs](#crates-oap-tests-conformance-rs)
- [crates/oap/tests/envelope_builder.rs](#crates-oap-tests-envelopebuilder-rs)
- [crates/oap/tests/metrics_labels.rs](#crates-oap-tests-metricslabels-rs)
- [crates/oap/tests/metrics_mapping.rs](#crates-oap-tests-metricsmapping-rs)
- [crates/oap/tests/parser_partial_read.rs](#crates-oap-tests-parserpartialread-rs)
- [crates/oap/tests/seq_monotonic.rs](#crates-oap-tests-seqmonotonic-rs)
- [crates/oap/tests/split_need_more.rs](#crates-oap-tests-splitneedmore-rs)
- [crates/oap/tests/vectors.rs](#crates-oap-tests-vectors-rs)
- [crates/oap/tests/writer_roundtrip.rs](#crates-oap-tests-writerroundtrip-rs)

### crates/oap/.cargo/config.toml
<a id="crates-oap--cargo-config-toml"></a>

```toml
[build]
# keep fast and strict in CI
rustflags = []

[target.'cfg(all())']
# You can tighten lints globally in the workspace root; keep crate-local light here.

```

### crates/oap/.github/workflows/ci.yml
<a id="crates-oap--github-workflows-ci-yml"></a>

```yaml
name: ci (oap2)
on: [push, pull_request]
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo fmt --all --check
      - run: cargo clippy -p oap2 -- -D warnings || true
      - run: cargo test -p oap2 --all-features || true
      - run: cargo install cargo-deny || true
      - run: cargo deny check || true

```

### crates/oap/.github/workflows/public-api.yml
<a id="crates-oap--github-workflows-public-api-yml"></a>

```yaml
name: public-api (oap2)
on: [push, pull_request]
jobs:
  api-diff:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo install cargo-public-api || true
      - run: cargo public-api --manifest-path crates/oap2/Cargo.toml || true

```

### crates/oap/.github/workflows/render-mermaid.yml
<a id="crates-oap--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid (oap2)
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          for f in $(git ls-files 'crates/oap2/docs/*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out" || true
          done

```

### crates/oap/Cargo.toml
<a id="crates-oap-Cargo-toml"></a>

```toml
[package]
name = "oap"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Overlay Access Protocol (OAP/1) framing and Tokio codec for RustyOnions"
repository = "https://example.invalid/RustyOnions"
authors = ["RustyOnions contributors"]

[lib]
name = "oap"
path = "src/lib.rs"

[features]
default = []
# Optional bounded decompression for payloads flagged with COMP.
zstd = ["dep:zstd"]

[dependencies]
bytes = "1.6"
tokio-util = { version = "0.7.16", features = ["codec"] }
tokio = { version = "1.47.1", features = ["io-util"] }
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
serde_repr = "0.1"
serde_json = "1.0"
tracing = "0.1"
bitflags = "2.6"
# Only pulled when feature=zstd is on
zstd = { version = "0.13", optional = true }

# Types-only crates (no IO/logic). Keep DTO hygiene.
ron-proto = { path = "../ron-proto", optional = true }

[dev-dependencies]
pretty_assertions = "1.4"

```

### crates/oap/benches/decode_happy.rs
<a id="crates-oap-benches-decodehappy-rs"></a>

```rust
// Criterion bench scaffold (no implementation).
fn main() {}

```

### crates/oap/benches/decode_pathological.rs
<a id="crates-oap-benches-decodepathological-rs"></a>

```rust
fn main() {}

```

### crates/oap/benches/encode_ack.rs
<a id="crates-oap-benches-encodeack-rs"></a>

```rust
fn main() {}

```

### crates/oap/fuzz/fuzz_targets/ack_fuzz.rs
<a id="crates-oap-fuzz-fuzztargets-ackfuzz-rs"></a>

```rust
// libFuzzer target placeholder

```

### crates/oap/fuzz/fuzz_targets/header_fuzz.rs
<a id="crates-oap-fuzz-fuzztargets-headerfuzz-rs"></a>

```rust
// libFuzzer target placeholder

```

### crates/oap/fuzz/fuzz_targets/parser_fuzz.rs
<a id="crates-oap-fuzz-fuzztargets-parserfuzz-rs"></a>

```rust
// libFuzzer target placeholder

```

### crates/oap/rust-toolchain.toml
<a id="crates-oap-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["clippy", "rustfmt"]

```

### crates/oap/scripts/perf_compare.sh
<a id="crates-oap-scripts-perfcompare-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "perf_compare: scaffold placeholder (wire to Criterion JSON once benches exist)"

```

### crates/oap/src/codec.rs
<a id="crates-oap-src-codec-rs"></a>

```rust
//! RO:WHAT — Tokio `Encoder`/`Decoder` for OAP/1 frames (length-prefixed, bounded).
//! RO:WHY — Interop needs a safe, reusable codec with strict limits and optional zstd inflate.
//! RO:INTERACTS — bytes, tokio-util::codec; uses Header/Flags and error taxonomy.
//! RO:INVARIANTS — Enforce MAX_FRAME_BYTES; START-only cap; optional COMP → bounded inflate ≤ 8×.

use bytes::BytesMut;
use tokio_util::codec::{Decoder, Encoder};

use crate::constants::MAX_FRAME_BYTES;
use crate::error::{OapDecodeError as DE, OapEncodeError as EE};
use crate::flags::Flags;
use crate::{Frame, Header};

#[cfg(feature = "zstd")]
use crate::constants::MAX_DECOMPRESS_EXPANSION;
#[cfg(feature = "zstd")]
use bytes::Bytes;

#[derive(Debug, Default)]
pub struct OapDecoder;

#[derive(Debug, Default)]
pub struct OapEncoder;

impl Decoder for OapDecoder {
    type Item = Frame;
    type Error = DE; // must be From<std::io::Error>; satisfied via Io(#[from]).

    fn decode(&mut self, src: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {
        // Need at least the fixed header.
        if src.len() < Header::WIRE_SIZE {
            return Ok(None);
        }

        // Peek a copy for header parsing without moving yet.
        let mut peek = src.clone().freeze();
        let hdr = Header::read_from(&mut peek)?;

        // If we don't have the whole frame yet, wait.
        if src.len() < hdr.len as usize {
            return Ok(None);
        }

        // Split off exactly the frame to work on.
        let mut frame_bytes = src.split_to(hdr.len as usize).freeze();

        // Re-read header from the real slice (advance).
        let _ = Header::read_from(&mut frame_bytes)?; // validated already

        // Cap section
        let cap = if hdr.cap_len > 0 {
            if !hdr.flags.contains(Flags::START) {
                return Err(DE::CapOnNonStart);
            }
            if frame_bytes.len() < hdr.cap_len as usize {
                return Err(DE::CapOutOfBounds);
            }
            Some(frame_bytes.split_to(hdr.cap_len as usize))
        } else {
            None
        };

        // Remaining is payload (may be empty)
        let payload = if frame_bytes.is_empty() {
            None
        } else {
            Some(frame_bytes)
        };

        // Optional bounded decompression when COMP flag set
        #[cfg(feature = "zstd")]
        let mut payload = payload;

        if hdr.flags.contains(Flags::COMP) {
            #[cfg(not(feature = "zstd"))]
            {
                return Err(DE::ZstdFeatureNotEnabled);
            }
            #[cfg(feature = "zstd")]
            {
                if let Some(body) = payload.take() {
                    let max_out = (MAX_FRAME_BYTES * MAX_DECOMPRESS_EXPANSION) as usize;
                    let mut dec = zstd::stream::read::Decoder::new(std::io::Cursor::new(body))
                        .map_err(|e| DE::Zstd(e.to_string()))?;
                    use std::io::Read;
                    let mut out = Vec::new();
                    let mut buf = [0u8; 16 * 1024];
                    loop {
                        let n = dec.read(&mut buf)?;
                        if n == 0 {
                            break;
                        }
                        out.extend_from_slice(&buf[..n]);
                        if out.len() > max_out {
                            return Err(DE::DecompressBoundExceeded);
                        }
                    }
                    payload = Some(Bytes::from(out));
                }
            }
        }

        Ok(Some(Frame {
            header: hdr,
            cap,
            payload,
        }))
    }
}

impl Encoder<Frame> for OapEncoder {
    type Error = EE; // must be From<std::io::Error>; satisfied via Io(#[from]).

    fn encode(&mut self, item: Frame, dst: &mut BytesMut) -> Result<(), Self::Error> {
        // Sanity on lengths vs declared header.len
        let cap_len = item.cap.as_ref().map(|b| b.len()).unwrap_or(0);
        let payload_len = item.payload.as_ref().map(|b| b.len()).unwrap_or(0);
        if cap_len > u16::MAX as usize {
            return Err(EE::CapOutOfBounds);
        }
        let total_len = Header::WIRE_SIZE + cap_len + payload_len;
        if total_len > MAX_FRAME_BYTES as usize {
            return Err(EE::FrameTooLarge {
                len: total_len as u32,
                max: MAX_FRAME_BYTES,
            });
        }

        // Write header (with corrected cap_len & len)
        let mut hdr = item.header;
        hdr.cap_len = cap_len as u16;
        hdr.len = total_len as u32;

        // Reserve and emit
        dst.reserve(total_len);
        hdr.put_to(dst);
        if let Some(cap) = item.cap {
            dst.extend_from_slice(&cap);
        }
        if let Some(payload) = item.payload {
            dst.extend_from_slice(&payload);
        }
        Ok(())
    }
}

```

### crates/oap/src/constants.rs
<a id="crates-oap-src-constants-rs"></a>

```rust
//! RO:WHAT — Canonical OAP/1 constants and limits.
//! RO:WHY — Keep protocol bounds single-sourced and drift-proof (Hardening & Interop blueprints).
//! RO:INTERACTS — Used by header/frame/codec modules and by callers for guardrails.
//! RO:INVARIANTS — max_frame=1MiB; bounded decompress guard ≤ 8× frame cap; chunk hint=64KiB.

/// Maximum allowed OAP frame size in bytes (protocol invariant).
pub const MAX_FRAME_BYTES: u32 = 1024 * 1024; // 1 MiB

/// Recommended streaming chunk size used by storage paths (not a protocol limit).
pub const STREAM_CHUNK_SIZE: usize = 64 * 1024; // 64 KiB

/// Upper bound on decompressed size relative to `MAX_FRAME_BYTES` when COMP flag is set.
/// Per Interop blueprint: bounded inflate (≤ 8× frame cap) → reject with 413 if exceeded.
pub const MAX_DECOMPRESS_EXPANSION: u32 = 8;

/// OAP protocol version.
pub const OAP_VERSION: u16 = 1;

```

### crates/oap/src/envelope.rs
<a id="crates-oap-src-envelope-rs"></a>

```rust
//! RO:WHAT — Ergonomic envelope helpers: capability wrapper and frame builders.
//! RO:WHY  — Reduce boilerplate for callers while enforcing OAP invariants at build time.
//! RO:INTERACTS — Uses Frame/Header/Flags/StatusCode plus HELLO DTOs from `hello.rs`.
//! RO:INVARIANTS — No I/O; the Encoder normalizes `len`/`cap_len`; caps only valid with START.

use bytes::Bytes;

use crate::{
    flags::Flags,
    hello::{Hello, HelloReply},
    Frame, Header, StatusCode, OAP_VERSION,
};

/// Opaque capability bytes carried on `START` frames.
/// Semantics (macaroons, scopes, etc.) live above OAP.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Capability(Bytes);

impl Capability {
    pub fn new(bytes: Bytes) -> Self {
        Self(bytes)
    }
    pub fn as_bytes(&self) -> &Bytes {
        &self.0
    }
    pub fn into_bytes(self) -> Bytes {
        self.0
    }
    /// Size guard for START frames (u16 fit).
    pub fn fits_u16(&self) -> bool {
        self.0.len() <= u16::MAX as usize
    }
}

/// True if a sender requests an ACK.
pub fn wants_ack(flags: Flags) -> bool {
    flags.contains(Flags::ACK_REQ)
}
/// True if a frame marks the logical end of a request/stream.
pub fn is_terminal(flags: Flags) -> bool {
    flags.contains(Flags::END)
}
/// True if a frame is fire-and-forget (EVENT without ACK).
pub fn is_fire_and_forget(flags: Flags) -> bool {
    flags.contains(Flags::EVENT) && !wants_ack(flags)
}

/// Minimal, chainable builder for common envelopes.
/// The encoder will set `len`/`cap_len` on write.
#[derive(Debug, Clone)]
pub struct FrameBuilder {
    header: Header,
    cap: Option<Bytes>,
    payload: Option<Bytes>,
}

impl FrameBuilder {
    /// Begin a request for `app_proto_id`.
    pub fn request(app_proto_id: u16, tenant_id: u128, corr_id: u64) -> Self {
        Self {
            header: Header {
                len: 0,
                ver: OAP_VERSION,
                flags: Flags::REQ,
                code: 0,
                app_proto_id,
                tenant_id,
                cap_len: 0,
                corr_id,
            },
            cap: None,
            payload: None,
        }
    }

    /// Begin a response for `app_proto_id` with a status code.
    pub fn response(app_proto_id: u16, tenant_id: u128, corr_id: u64, code: StatusCode) -> Self {
        Self {
            header: Header {
                len: 0,
                ver: OAP_VERSION,
                flags: Flags::RESP,
                code: code as u16,
                app_proto_id,
                tenant_id,
                cap_len: 0,
                corr_id,
            },
            cap: None,
            payload: None,
        }
    }

    /// Mark as START and attach capability bytes (REQ is set if not already).
    pub fn start_with_cap(mut self, cap: Bytes) -> Self {
        self.header.flags |= Flags::START | Flags::REQ;
        self.cap = Some(cap);
        self
    }

    /// Attach opaque payload.
    pub fn payload(mut self, p: Bytes) -> Self {
        self.payload = Some(p);
        self
    }

    /// Request ACK.
    pub fn want_ack(mut self) -> Self {
        self.header.flags |= Flags::ACK_REQ;
        self
    }

    /// Mark as END.
    pub fn end(mut self) -> Self {
        self.header.flags |= Flags::END;
        self
    }

    /// Build a `Frame`.
    pub fn build(self) -> Frame {
        Frame {
            header: self.header,
            cap: self.cap,
            payload: self.payload,
        }
    }
}

/// Convenience: HELLO request frame (app_proto_id=0).
pub fn hello_request(ua: Option<&str>, tenant_id: u128, corr_id: u64) -> Frame {
    let h = Hello {
        ua: ua.map(str::to_owned),
    };
    h.to_frame(tenant_id, corr_id)
}

/// Convenience: HELLO reply frame (app_proto_id=0), using default server caps.
pub fn hello_reply_default(tenant_id: u128, corr_id: u64) -> Frame {
    HelloReply::default_for_server().to_frame(tenant_id, corr_id)
}

```

### crates/oap/src/error.rs
<a id="crates-oap-src-error-rs"></a>

```rust
//! RO:WHAT — Error taxonomy for OAP codec and helpers.
//! RO:WHY — Stable, typed errors that map to protocol status codes where meaningful.
//! RO:INTERACTS — Used by codec/frame/hello; callers can translate to HTTP or OAP rejects.
//! RO:INVARIANTS — 413 on size violations; 400 family for client misuse; 5xx for internal.

use thiserror::Error;

/// Minimal status code set suitable for mapping OAP outcomes (also maps to HTTP when proxied).
#[derive(
    Copy, Clone, Debug, PartialEq, Eq, serde_repr::Serialize_repr, serde_repr::Deserialize_repr,
)]
#[repr(u16)]
pub enum StatusCode {
    Ok = 200,
    Partial = 206,
    BadRequest = 400,
    Unauthorized = 401,
    Forbidden = 403,
    NotFound = 404,
    PayloadTooLarge = 413,
    TooManyRequests = 429,
    Internal = 500,
    Unavailable = 503,
}

#[derive(Debug, Error)]
pub enum OapDecodeError {
    #[error("truncated header")]
    TruncatedHeader,
    #[error("bad version {0}")]
    BadVersion(u16),
    #[error("bad flags bits {0:#06x}")]
    BadFlags(u16),
    #[error("cap section present but START flag not set")]
    CapOnNonStart,
    #[error("frame too large: {len} > {max}")]
    FrameTooLarge { len: u32, max: u32 },
    #[error("cap length exceeds frame")]
    CapOutOfBounds,
    #[error("payload length exceeds frame")]
    PayloadOutOfBounds,
    #[error("decompression exceeded bound")]
    DecompressBoundExceeded,
    #[error("zstd not enabled")]
    ZstdFeatureNotEnabled,
    #[error("zstd decode error: {0}")]
    Zstd(String),
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
}

#[derive(Debug, Error)]
pub enum OapEncodeError {
    #[error("frame too large: {len} > {max}")]
    FrameTooLarge { len: u32, max: u32 },
    #[error("cap length exceeds frame")]
    CapOutOfBounds,
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
}

#[derive(Debug, Error)]
pub enum OapError {
    #[error(transparent)]
    Decode(#[from] OapDecodeError),
    #[error(transparent)]
    Encode(#[from] OapEncodeError),
}

// Allow `?` on std::io::Error to bubble into OapError (encode path preferred).
impl From<std::io::Error> for OapError {
    fn from(err: std::io::Error) -> Self {
        OapError::Encode(OapEncodeError::Io(err))
    }
}

```

### crates/oap/src/flags.rs
<a id="crates-oap-src-flags-rs"></a>

```rust
//! RO:WHAT — Bitflags for OAP/1 `flags,u16` header field.
//! RO:WHY — Explicit bit meanings for interop; avoids magic numbers.
//! RO:INTERACTS — Used by header/frame/codec; callers set semantics via these bits.
//! RO:INVARIANTS — Bits stable under semver; RESERVED kept for forward-compat.

bitflags::bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    pub struct Flags: u16 {
        const REQ     = 1 << 0;
        const RESP    = 1 << 1;
        const EVENT   = 1 << 2;
        const START   = 1 << 3;
        const END     = 1 << 4;
        const ACK_REQ = 1 << 5;
        const COMP    = 1 << 6; // payload compressed (zstd) with bounded inflate
        const APP_E2E = 1 << 7; // opaque app-layer E2E crypto; platform does not inspect
        // reserve upper bits for future use
    }
}

```

### crates/oap/src/frame.rs
<a id="crates-oap-src-frame-rs"></a>

```rust
//! RO:WHAT — High-level OAP frame value (header + optional cap + payload).
//! RO:WHY — Keep parsing/encoding logic separate from transport loops; safe, owned bytes.
//! RO:INTERACTS — Header/Flags; codec reads/writes `Frame` to/from wire.
//! RO:INVARIANTS — Owned buffers; bounds validated; START carries capability bytes only.

use crate::Header;
use bytes::Bytes;

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Frame {
    pub header: Header,
    pub cap: Option<Bytes>,
    pub payload: Option<Bytes>,
}

impl Frame {
    pub fn new(header: Header, cap: Option<Bytes>, payload: Option<Bytes>) -> Self {
        Self {
            header,
            cap,
            payload,
        }
    }

    pub fn payload_len(&self) -> usize {
        self.payload.as_ref().map(|b| b.len()).unwrap_or(0)
    }

    pub fn cap_len(&self) -> usize {
        self.cap.as_ref().map(|b| b.len()).unwrap_or(0)
    }
}

```

### crates/oap/src/header.rs
<a id="crates-oap-src-header-rs"></a>

```rust
//! RO:WHAT — OAP/1 fixed header (without [cap] and [payload]) and (de)serialization helpers.
//! RO:WHY — Deterministic, endian-stable wire header; validates size/field bounds before alloc.
//! RO:INTERACTS — Flags; codec uses this to parse before reading variable sections.
//! RO:INVARIANTS — Length checked ≤ MAX_FRAME_BYTES; version=1; cap_len for START frames only.

use crate::constants::{MAX_FRAME_BYTES, OAP_VERSION};
use crate::flags::Flags;
use bytes::{Buf, BufMut, BytesMut};

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Header {
    /// Total frame length in bytes (header + cap + payload).
    pub len: u32,
    /// Protocol version (must be 1).
    pub ver: u16,
    /// Bit flags.
    pub flags: Flags,
    /// Status or app code (e.g., 2xx/4xx/5xx or app-defined).
    pub code: u16,
    /// Application protocol id (0 = control/HELLO).
    pub app_proto_id: u16,
    /// Tenant id (128-bit).
    pub tenant_id: u128,
    /// Capability section length in bytes (only valid/allowed with START).
    pub cap_len: u16,
    /// Correlation id (64-bit).
    pub corr_id: u64,
}

impl Header {
    pub const WIRE_SIZE: usize = 4 + 2 + 2 + 2 + 2 + 16 + 2 + 8;

    pub fn validate(&self) -> Result<(), crate::error::OapDecodeError> {
        if self.ver != OAP_VERSION {
            return Err(crate::error::OapDecodeError::BadVersion(self.ver));
        }
        if self.len == 0 || self.len > MAX_FRAME_BYTES {
            return Err(crate::error::OapDecodeError::FrameTooLarge {
                len: self.len,
                max: MAX_FRAME_BYTES,
            });
        }
        if self.cap_len > 0 && !self.flags.contains(Flags::START) {
            return Err(crate::error::OapDecodeError::CapOnNonStart);
        }
        Ok(())
    }

    pub fn put_to(&self, dst: &mut BytesMut) {
        dst.put_u32(self.len);
        dst.put_u16(self.ver);
        dst.put_u16(self.flags.bits());
        dst.put_u16(self.code);
        dst.put_u16(self.app_proto_id);
        dst.put_u128(self.tenant_id);
        dst.put_u16(self.cap_len);
        dst.put_u64(self.corr_id);
    }

    pub fn read_from(src: &mut bytes::Bytes) -> Result<Self, crate::error::OapDecodeError> {
        use crate::error::OapDecodeError as E;
        if src.len() < Self::WIRE_SIZE {
            return Err(E::TruncatedHeader);
        }
        let len = src.get_u32();
        let ver = src.get_u16();
        let flags_bits = src.get_u16();
        let code = src.get_u16();
        let app_proto_id = src.get_u16();
        let tenant_id = src.get_u128();
        let cap_len = src.get_u16();
        let corr_id = src.get_u64();
        let flags = Flags::from_bits(flags_bits).ok_or(E::BadFlags(flags_bits))?;
        let hdr = Header {
            len,
            ver,
            flags,
            code,
            app_proto_id,
            tenant_id,
            cap_len,
            corr_id,
        };
        hdr.validate()?;
        Ok(hdr)
    }
}

```

### crates/oap/src/hello.rs
<a id="crates-oap-src-hello-rs"></a>

```rust
//! RO:WHAT — Small helpers for OAP/1 HELLO (app_proto_id=0) request/response.
//! RO:WHY — Normalize what clients/servers exchange during negotiation.
//! RO:INTERACTS — Flags/Frame/Header; used by SDK and services at connect time.
//! RO:INVARIANTS — ver=1; code=200 on success; returns server caps & versions.

use crate::{constants::*, flags::Flags, Frame, Header};
use bytes::Bytes;
use serde::{Deserialize, Serialize};
use serde_json;

/// Minimal HELLO request (client → server).
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Hello {
    /// Optional user-agent/version string.
    pub ua: Option<String>,
}

/// Minimal HELLO reply (server → client).
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct HelloReply {
    pub max_frame: u32,
    pub max_inflight: u16,
    pub flags_supported: u16,
    pub versions: Vec<u16>,
    pub transports: Vec<String>,
}

impl Hello {
    pub fn to_frame(&self, tenant_id: u128, corr_id: u64) -> Frame {
        let payload = serde_json::to_vec(self).expect("serialize hello");
        let header = Header {
            len: 0, // filled by encoder
            ver: OAP_VERSION,
            flags: Flags::REQ,
            code: 0,
            app_proto_id: 0,
            tenant_id,
            cap_len: 0,
            corr_id,
        };
        Frame {
            header,
            cap: None,
            payload: Some(Bytes::from(payload)),
        }
    }
}

impl HelloReply {
    pub fn default_for_server() -> Self {
        Self {
            max_frame: MAX_FRAME_BYTES,
            max_inflight: 64,
            flags_supported: (Flags::REQ
                | Flags::RESP
                | Flags::EVENT
                | Flags::START
                | Flags::END
                | Flags::ACK_REQ
                | Flags::COMP
                | Flags::APP_E2E)
                .bits(),
            versions: vec![OAP_VERSION],
            transports: vec!["tcp+tls".into()],
        }
    }

    pub fn from_frame(frame: &Frame) -> Result<Self, crate::error::OapDecodeError> {
        let Some(payload) = &frame.payload else {
            return Err(crate::error::OapDecodeError::PayloadOutOfBounds);
        };
        serde_json::from_slice(payload)
            .map_err(|e| crate::error::OapDecodeError::Zstd(e.to_string()))
    }

    pub fn to_frame(&self, tenant_id: u128, corr_id: u64) -> Frame {
        let json = serde_json::to_vec(self).expect("serialize hello reply");
        let header = Header {
            len: 0,
            ver: OAP_VERSION,
            flags: Flags::RESP,
            code: crate::error::StatusCode::Ok as u16,
            app_proto_id: 0,
            tenant_id,
            cap_len: 0,
            corr_id,
        };
        Frame {
            header,
            cap: None,
            payload: Some(Bytes::from(json)),
        }
    }
}

```

### crates/oap/src/lib.rs
<a id="crates-oap-src-lib-rs"></a>

```rust
//! RO:WHAT — OAP/1 constants, flags, header & frame types, and a Tokio codec (Encoder/Decoder).
//! RO:WHY  — Pillar 7 (App BFF & SDK); Concerns: SEC/RES/PERF/DX. Stable envelopes for interop.
//! RO:INTERACTS — bytes, tokio-util::codec; optional ron-proto DTOs; consumed by ron-app-sdk/omnigate.
//! RO:INVARIANTS — OAP/1 max_frame=1MiB; stream chunk≈64KiB (storage); no lock across .await in codec.
//! RO:METRICS — (none here; callers record RED metrics around IO).
//! RO:CONFIG — Bounds are constants; optional zstd with ≤8× expansion guard.
//! RO:SECURITY — No ambient auth; capabilities carried as opaque bytes in START; DTOs deny_unknown_fields upstream.
//! RO:TEST — unit tests in module; golden vectors for HELLO/START/DATA; fuzz hooks to be added in oap-fuzz.

#![forbid(unsafe_code)]

pub mod codec;
pub mod constants;
pub mod error;
pub mod flags;
pub mod frame;
pub mod header;
pub mod hello;

// TODO-aligned modules
pub mod envelope;
pub mod metrics;
pub mod prelude;
pub mod seq;

// Stream helpers (as per TODO folders)
pub mod parser;
pub mod writer;

// Core exports
pub use codec::{OapDecoder, OapEncoder};
pub use constants::*;
pub use error::{OapDecodeError, OapEncodeError, OapError, StatusCode};
pub use flags::Flags;
pub use frame::Frame;
pub use header::Header;
pub use hello::{Hello, HelloReply};

// Ergonomic helpers from TODO modules
pub use envelope::{
    hello_reply_default, hello_request, is_fire_and_forget, is_terminal, wants_ack, Capability,
    FrameBuilder,
};
pub use metrics::{
    is_client_err, is_server_err, is_success, labels_for_outcome, outcome_from_decode,
    outcome_from_status, reason, OutcomeClass,
};
pub use seq::Seq;

// Parser/Writer facades
pub use parser::{ParserConfig, ParserState};
pub use writer::{OapWriter, WriterConfig};

```

### crates/oap/src/metrics.rs
<a id="crates-oap-src-metrics-rs"></a>

```rust
//! RO:WHAT — Status helpers and canonical outcome→label mapping for metrics.
//! RO:WHY  — Keep vocabulary consistent across services; no direct prometheus deps here.
//! RO:INTERACTS — Callers map these to ron-metrics counters/histograms.
//! RO:INVARIANTS — Stable label triplets; conservative defaults.

use crate::error::{OapDecodeError, StatusCode};

/// Human-friendly reason text for a status code (stable subset).
pub fn reason(code: StatusCode) -> &'static str {
    match code {
        StatusCode::Ok => "OK",
        StatusCode::Partial => "Partial Content",
        StatusCode::BadRequest => "Bad Request",
        StatusCode::Unauthorized => "Unauthorized",
        StatusCode::Forbidden => "Forbidden",
        StatusCode::NotFound => "Not Found",
        StatusCode::PayloadTooLarge => "Payload Too Large",
        StatusCode::TooManyRequests => "Too Many Requests",
        StatusCode::Internal => "Internal Server Error",
        StatusCode::Unavailable => "Service Unavailable",
    }
}

/// Quick predicates.
pub fn is_success(code: StatusCode) -> bool {
    (code as u16) / 100 == 2
}
pub fn is_client_err(code: StatusCode) -> bool {
    (code as u16) / 100 == 4
}
pub fn is_server_err(code: StatusCode) -> bool {
    (code as u16) / 100 == 5
}

/// Outcome class for accounting.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum OutcomeClass {
    Success,
    ClientError,
    ServerError,
    DecodeError,
    Oversize,
}

/// Convert a status code into a high-level outcome class.
pub fn outcome_from_status(code: StatusCode) -> OutcomeClass {
    match (code as u16) / 100 {
        2 => OutcomeClass::Success,
        4 => OutcomeClass::ClientError,
        5 => OutcomeClass::ServerError,
        _ => OutcomeClass::ClientError, // default conservative
    }
}

/// Map a decode error to an outcome class (for ingress parse failures).
pub fn outcome_from_decode(err: &OapDecodeError) -> OutcomeClass {
    use OapDecodeError::*;
    match err {
        FrameTooLarge { .. } => OutcomeClass::Oversize,
        BadVersion(_) | BadFlags(_) | CapOnNonStart | CapOutOfBounds | PayloadOutOfBounds => {
            OutcomeClass::DecodeError
        }
        TruncatedHeader | DecompressBoundExceeded | ZstdFeatureNotEnabled | Zstd(_) | Io(_) => {
            OutcomeClass::DecodeError
        }
    }
}

/// Convert outcome into stable label triplet (kind, cause, detail).
/// Keep these short and low-cardinality.
pub fn labels_for_outcome(outcome: OutcomeClass) -> (&'static str, &'static str, &'static str) {
    match outcome {
        OutcomeClass::Success => ("oap", "ok", "2xx"),
        OutcomeClass::ClientError => ("oap", "client", "4xx"),
        OutcomeClass::ServerError => ("oap", "server", "5xx"),
        OutcomeClass::DecodeError => ("oap", "decode", "error"),
        OutcomeClass::Oversize => ("oap", "oversize", "413"),
    }
}

```

### crates/oap/src/parser/config.rs
<a id="crates-oap-src-parser-config-rs"></a>

```rust
//! RO:WHAT — Parser configuration (buffer policy hooks).
//! RO:WHY  — Centralize tunables; allow callers to cap parser memory if desired.
//! RO:INTERACTS — Used by `ParserState`.
//! RO:INVARIANTS — Defaults are conservative and safe.

/// Parser configuration.
/// Currently only exposes a soft maximum buffer size; the OAP decoder still
/// enforces per-frame bounds independently.
#[derive(Clone, Copy, Debug)]
pub struct ParserConfig {
    /// Soft cap for buffered bytes. `None` disables the soft check.
    pub max_buffer_bytes: Option<usize>,
}

impl Default for ParserConfig {
    fn default() -> Self {
        // 4 MiB soft buffer cap is usually sufficient for a few frames in flight.
        Self {
            max_buffer_bytes: Some(4 * 1024 * 1024),
        }
    }
}

```

### crates/oap/src/parser/mod.rs
<a id="crates-oap-src-parser-mod-rs"></a>

```rust
//! RO:WHAT — Incremental OAP frame parser facade.
//! RO:WHY  — Provide a clean API to feed bytes and pull parsed `Frame`s.
//! RO:INTERACTS — Wraps `OapDecoder`; used by gateways/SDKs.
//! RO:INVARIANTS — No blocking; bounded by decoder invariants; zero `unsafe`.

pub mod config;
pub mod state;

pub use config::ParserConfig;
pub use state::ParserState;

```

### crates/oap/src/parser/state.rs
<a id="crates-oap-src-parser-state-rs"></a>

```rust
//! RO:WHAT — Parser state machine: push bytes, pop frames.
//! RO:WHY  — Make partial reads easy without reinventing decoding logic.
//! RO:INTERACTS — `OapDecoder`; returns `Frame`s as they become available.
//! RO:INVARIANTS — No blocking; honors parser config soft cap; zero `unsafe`.

use bytes::BytesMut;
use tokio_util::codec::Decoder; // bring `decode` into scope

use super::ParserConfig;
use crate::{codec::OapDecoder, Frame};

#[derive(Debug)]
pub struct ParserState {
    dec: OapDecoder,
    buf: BytesMut,
    cfg: ParserConfig,
}

impl ParserState {
    pub fn new(cfg: ParserConfig) -> Self {
        Self {
            dec: OapDecoder,
            buf: BytesMut::new(),
            cfg,
        }
    }

    pub fn with_default() -> Self {
        Self::new(ParserConfig::default())
    }

    /// Feed raw bytes into the parser buffer.
    /// Returns `Ok(())` even if no full frame is available yet.
    pub fn push(&mut self, chunk: &[u8]) -> Result<(), crate::OapDecodeError> {
        self.buf.extend_from_slice(chunk);

        // Soft cap (best-effort): callers decide response; decoding still enforces per-frame caps.
        if let Some(max) = self.cfg.max_buffer_bytes {
            if self.buf.len() > max {
                // Return a decode error to signal backpressure to caller (no new variant needed).
                return Err(crate::OapDecodeError::PayloadOutOfBounds);
            }
        }
        Ok(())
    }

    /// Try to decode a single frame if enough data is buffered.
    pub fn try_next(&mut self) -> Result<Option<Frame>, crate::OapDecodeError> {
        self.dec.decode(&mut self.buf)
    }

    /// Drain all currently-available frames.
    pub fn drain(&mut self) -> Result<Vec<Frame>, crate::OapDecodeError> {
        let mut out = Vec::new();
        while let Some(f) = self.dec.decode(&mut self.buf)? {
            out.push(f);
        }
        Ok(out)
    }

    /// Inspect buffered byte count (useful for tests/telemetry).
    pub fn buffered_len(&self) -> usize {
        self.buf.len()
    }
}

```

### crates/oap/src/prelude.rs
<a id="crates-oap-src-prelude-rs"></a>

```rust
//! RO:WHAT — Common imports for ergonomic use of OAP.
//! RO:WHY  — Reduce `use` boilerplate in services and SDKs.
//! RO:INTERACTS — Pure re-exports.

pub use crate::{
    codec::{OapDecoder, OapEncoder},
    constants::{MAX_FRAME_BYTES, OAP_VERSION, STREAM_CHUNK_SIZE},
    envelope::{
        hello_reply_default, hello_request, is_fire_and_forget, is_terminal, wants_ack, Capability,
        FrameBuilder,
    },
    error::{OapDecodeError, OapEncodeError, OapError, StatusCode},
    flags::Flags,
    frame::Frame,
    header::Header,
    metrics::{
        is_client_err, is_server_err, is_success, labels_for_outcome, outcome_from_decode,
        outcome_from_status, reason, OutcomeClass,
    },
    seq::Seq,
};

```

### crates/oap/src/seq.rs
<a id="crates-oap-src-seq-rs"></a>

```rust
//! RO:WHAT — Simple, allocator-free sequence/correlation id generator.
//! RO:WHY  — Provide monotonic ids for `corr_id` without globals/unsafe.
//! RO:INTERACTS — Used by clients/servers to stamp `Header::corr_id`.
//! RO:INVARIANTS — Monotonic per-instance; seed adds time entropy to avoid collisions.

use std::sync::atomic::{AtomicU64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};

/// Monotonic sequence generator (per-instance).
#[derive(Debug)]
pub struct Seq {
    counter: AtomicU64,
}

impl Default for Seq {
    fn default() -> Self {
        // Seed with current nanos (truncated) to diversify instances.
        let seed = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| (d.as_nanos() as u64) ^ 0xA5A5_5A5A_D3C3_3C3D)
            .unwrap_or(0xD00D_F00D_C0FF_EE00);
        Self {
            counter: AtomicU64::new(seed),
        }
    }
}

impl Seq {
    pub fn new() -> Self {
        Self::default()
    }

    /// Fetch-next correlation id.
    #[inline]
    pub fn next(&self) -> u64 {
        self.counter.fetch_add(1, Ordering::Relaxed).wrapping_add(1)
    }
}

```

### crates/oap/src/writer/config.rs
<a id="crates-oap-src-writer-config-rs"></a>

```rust
//! RO:WHAT — Writer configuration.
//! RO:WHY  — Centralize tunables for buffered writes.
//! RO:INTERACTS — Used by `OapWriter`.
//! RO:INVARIANTS — Defaults tuned to typical MTU/page sizes.

use crate::constants::STREAM_CHUNK_SIZE;

/// Writer configuration.
#[derive(Clone, Copy, Debug)]
pub struct WriterConfig {
    /// When internal buffer reaches this size, `write_frame` will flush it automatically.
    pub flush_hint_bytes: usize,
}

impl Default for WriterConfig {
    fn default() -> Self {
        // Use the 64 KiB stream chunk as a reasonable flush hint.
        Self {
            flush_hint_bytes: STREAM_CHUNK_SIZE,
        }
    }
}

```

### crates/oap/src/writer/mod.rs
<a id="crates-oap-src-writer-mod-rs"></a>

```rust
//! RO:WHAT — Buffered OAP frame writer for async sinks.
//! RO:WHY  — Provide a simple way to encode frames and flush to `AsyncWrite`.
//! RO:INTERACTS — `OapEncoder`; tokio `AsyncWrite`.
//! RO:INVARIANTS — No locks across `.await`; zero `unsafe`.

pub mod config;

use bytes::BytesMut;
use tokio::io::{AsyncWrite, AsyncWriteExt};
use tokio_util::codec::Encoder; // bring `encode` into scope

use crate::{codec::OapEncoder, Frame};
pub use config::WriterConfig;

/// Buffered OAP writer: encodes frames into an internal buffer,
/// then writes/flushes to an `AsyncWrite`.
#[derive(Debug)]
pub struct OapWriter {
    enc: OapEncoder,
    buf: BytesMut,
    cfg: WriterConfig,
}

impl OapWriter {
    pub fn new(cfg: WriterConfig) -> Self {
        Self {
            enc: OapEncoder,
            buf: BytesMut::new(),
            cfg,
        }
    }

    pub fn with_default() -> Self {
        Self::new(WriterConfig::default())
    }

    /// Encode a frame into the internal buffer (does not perform I/O).
    pub fn encode_to_buf(&mut self, frame: Frame) -> Result<(), crate::OapEncodeError> {
        self.enc.encode(frame, &mut self.buf)
    }

    /// Take the internal buffer as bytes (leaves buffer empty).
    pub fn take_buf(&mut self) -> bytes::Bytes {
        std::mem::take(&mut self.buf).freeze()
    }

    /// Encode and write a frame to an async sink, flushing if buffer exceeds `flush_hint_bytes`.
    pub async fn write_frame<S: AsyncWrite + Unpin>(
        &mut self,
        sink: &mut S,
        frame: Frame,
    ) -> Result<(), crate::OapError> {
        // Encoding errors -> OapEncodeError -> OapError (From impl)
        self.enc.encode(frame, &mut self.buf)?;

        if self.buf.len() >= self.cfg.flush_hint_bytes {
            // I/O errors -> std::io::Error -> OapError (From impl)
            sink.write_all(&self.buf).await?;
            self.buf.clear();
            sink.flush().await?;
        }
        Ok(())
    }

    /// Force-flush any buffered bytes to the sink.
    pub async fn flush<S: AsyncWrite + Unpin>(
        &mut self,
        sink: &mut S,
    ) -> Result<(), crate::OapError> {
        if !self.buf.is_empty() {
            sink.write_all(&self.buf).await?;
            self.buf.clear();
        }
        sink.flush().await?;
        Ok(())
    }
}

```

### crates/oap/tests/ack_algebra.rs
<a id="crates-oap-tests-ackalgebra-rs"></a>

```rust
//! Exercises ACK/END/EVENT helpers from `envelope`.

use bytes::Bytes;
use oap::{prelude::*, Flags};

#[test]
fn ack_end_event_algebra() {
    // EVENT without ACK → fire-and-forget
    let _ = FrameBuilder::request(1, 0xAB, 1)
        .payload(Bytes::from_static(b"evt"))
        .build();
    let flags = Flags::EVENT;
    assert!(is_fire_and_forget(flags));
    assert!(!wants_ack(flags));
    assert!(!is_terminal(flags));

    // REQUEST with ACK
    let f = FrameBuilder::request(1, 0xAB, 2)
        .payload(Bytes::from_static(b"req"))
        .want_ack()
        .build();
    let flags = f.header.flags | Flags::ACK_REQ;
    assert!(wants_ack(flags));
    assert!(!is_fire_and_forget(flags));

    // RESPONSE terminal
    let f = FrameBuilder::response(1, 0xAB, 3, StatusCode::Ok)
        .payload(Bytes::from_static(b"ok"))
        .end()
        .build();
    let flags = f.header.flags;
    assert!(is_terminal(flags));
}

```

### crates/oap/tests/config_validation.rs
<a id="crates-oap-tests-configvalidation-rs"></a>

```rust
//! Parser config soft-cap behavior and minimal builder sanity.

use bytes::Bytes;
use oap::{parser::ParserConfig, parser::ParserState, prelude::*};

#[test]
fn parser_soft_cap_trips() {
    // Tiny soft cap to trigger error on push.
    let mut p = ParserState::new(ParserConfig {
        max_buffer_bytes: Some(8),
    });
    // Push more than 8 bytes; we expect a decode error (soft-cap signal).
    let err = p.push(&[0u8; 16]).expect_err("should hit soft-cap");
    // We reuse PayloadOutOfBounds to signal backpressure.
    match err {
        oap::OapDecodeError::PayloadOutOfBounds => {}
        e => panic!("unexpected error: {e:?}"),
    }
}

#[test]
fn builder_minimal() {
    // Basic request/response builders compile and set flags.
    let r = FrameBuilder::request(7, 0xCAFE, 1)
        .payload(Bytes::from_static(b"ping"))
        .build();
    assert!(r.header.flags.contains(Flags::REQ));

    let s = FrameBuilder::response(7, 0xCAFE, 1, StatusCode::Ok)
        .payload(Bytes::from_static(b"pong"))
        .build();
    assert!(s.header.flags.contains(Flags::RESP));
}

```

### crates/oap/tests/conformance.rs
<a id="crates-oap-tests-conformance-rs"></a>

```rust
//! Conformance checks against protocol invariants (header size, START+cap rules).

use bytes::BytesMut;
use oap::{flags::Flags, prelude::*};
use tokio_util::codec::Decoder as _;

#[test]
fn header_size_constant() {
    // Defensive: if the header layout ever changes, this test will flag it.
    assert_eq!(Header::WIRE_SIZE, 4 + 2 + 2 + 2 + 2 + 16 + 2 + 8);
}

#[test]
fn cap_requires_start_flag() {
    // Craft a frame with cap_len>0 but without START flag → decoder must reject.
    let hdr = Header {
        len: (Header::WIRE_SIZE + 3) as u32,
        ver: OAP_VERSION,
        flags: Flags::REQ, // no START
        code: 0,
        app_proto_id: 123,
        tenant_id: 0xABCD,
        cap_len: 3,
        corr_id: 99,
    };
    let mut buf = BytesMut::new();
    // Put header, then 3 bytes of "cap".
    hdr.put_to(&mut buf);
    buf.extend_from_slice(b"cap");

    let mut dec = OapDecoder::default();
    let err = dec.decode(&mut buf).expect_err("should fail without START");
    match err {
        oap::OapDecodeError::CapOnNonStart => {}
        e => panic!("unexpected error: {e:?}"),
    }
}

```

### crates/oap/tests/envelope_builder.rs
<a id="crates-oap-tests-envelopebuilder-rs"></a>

```rust
use bytes::Bytes;
use oap::{prelude::*, Flags, StatusCode};

#[test]
fn builder_sets_flags_and_fields() {
    let f = FrameBuilder::request(9, 0xDEAD, 777)
        .start_with_cap(Bytes::from_static(b"macaroon"))
        .payload(Bytes::from_static(b"body"))
        .want_ack()
        .end()
        .build();

    let flags = f.header.flags;
    assert!(flags.contains(Flags::REQ));
    assert!(flags.contains(Flags::START));
    assert!(flags.contains(Flags::ACK_REQ));
    assert!(flags.contains(Flags::END));

    // Response builder sanity.
    let r = FrameBuilder::response(9, 0xDEAD, 777, StatusCode::Ok)
        .payload(Bytes::from_static(b"ok"))
        .build();
    assert!(r.header.flags.contains(Flags::RESP));
    assert_eq!(r.header.code, StatusCode::Ok as u16);
}

```

### crates/oap/tests/metrics_labels.rs
<a id="crates-oap-tests-metricslabels-rs"></a>

```rust
use oap::{metrics::*, StatusCode};

#[test]
fn reason_and_classification() {
    assert_eq!(reason(StatusCode::Ok), "OK");
    assert!(is_success(StatusCode::Ok));
    assert!(is_client_err(StatusCode::BadRequest));
    assert!(is_server_err(StatusCode::Internal));

    assert_eq!(outcome_from_status(StatusCode::Ok), OutcomeClass::Success);
    assert_eq!(
        labels_for_outcome(OutcomeClass::Oversize),
        ("oap", "oversize", "413")
    );
}

```

### crates/oap/tests/metrics_mapping.rs
<a id="crates-oap-tests-metricsmapping-rs"></a>

```rust
//! Outcome classification & labels; decode-error mapping.

use oap::{metrics::*, OapDecodeError, StatusCode};

#[test]
fn status_outcomes_and_labels() {
    assert_eq!(outcome_from_status(StatusCode::Ok), OutcomeClass::Success);
    assert_eq!(
        outcome_from_status(StatusCode::BadRequest),
        OutcomeClass::ClientError
    );
    assert_eq!(
        outcome_from_status(StatusCode::Internal),
        OutcomeClass::ServerError
    );

    assert_eq!(
        labels_for_outcome(OutcomeClass::Success),
        ("oap", "ok", "2xx")
    );
    assert_eq!(
        labels_for_outcome(OutcomeClass::Oversize),
        ("oap", "oversize", "413")
    );
}

#[test]
fn decode_error_to_outcome() {
    let e = OapDecodeError::FrameTooLarge {
        len: 2_000_000,
        max: 1_048_576,
    };
    assert_eq!(outcome_from_decode(&e), OutcomeClass::Oversize);

    let e = OapDecodeError::BadFlags(0xFFFF);
    assert_eq!(outcome_from_decode(&e), OutcomeClass::DecodeError);
}

```

### crates/oap/tests/parser_partial_read.rs
<a id="crates-oap-tests-parserpartialread-rs"></a>

```rust
use bytes::Bytes;
use oap::{codec::OapEncoder, parser::ParserConfig, parser::ParserState, prelude::*};
use tokio_util::codec::Encoder as _;

fn normalize(mut f: Frame) -> Frame {
    let cap_len = f.cap.as_ref().map(|b| b.len()).unwrap_or(0);
    let payload_len = f.payload.as_ref().map(|b| b.len()).unwrap_or(0);
    f.header.cap_len = cap_len as u16;
    f.header.len = (Header::WIRE_SIZE + cap_len + payload_len) as u32;
    f
}

#[test]
fn parses_frames_across_chunks() {
    // Build two frames and encode into one buffer.
    let f1 = FrameBuilder::request(7, 0xA, 1)
        .payload(Bytes::from_static(b"hello"))
        .end()
        .build();
    let f2 = FrameBuilder::response(7, 0xA, 1, StatusCode::Ok)
        .payload(Bytes::from_static(b"world"))
        .build();

    let mut enc = OapEncoder::default();
    let mut buf = bytes::BytesMut::new();
    enc.encode(f1.clone(), &mut buf).unwrap();
    enc.encode(f2.clone(), &mut buf).unwrap();
    let bytes = buf.freeze();

    // Feed in small chunks to the parser.
    let mut p = ParserState::new(ParserConfig::default());
    for chunk in bytes.chunks(3) {
        p.push(chunk).unwrap();
    }

    let frames = p.drain().unwrap();
    assert_eq!(frames.len(), 2);
    assert_eq!(frames[0], normalize(f1));
    assert_eq!(frames[1], normalize(f2));
}

```

### crates/oap/tests/seq_monotonic.rs
<a id="crates-oap-tests-seqmonotonic-rs"></a>

```rust
use oap::Seq;
use std::collections::HashSet;

#[test]
fn seq_is_monotonic_and_unique_across_sample() {
    let s = Seq::new();
    let mut seen = HashSet::new();
    let n = 10_000;
    for _ in 0..n {
        let id = s.next();
        assert!(seen.insert(id), "duplicate id detected");
    }
}

```

### crates/oap/tests/split_need_more.rs
<a id="crates-oap-tests-splitneedmore-rs"></a>

```rust
//! Ensure decoder returns `None` until a full frame is buffered.

use bytes::{Bytes, BytesMut};
use oap::{codec::OapEncoder, prelude::*};
use tokio_util::codec::{Decoder as _, Encoder as _};

fn encode_frame(f: Frame) -> bytes::Bytes {
    let mut enc = OapEncoder::default();
    let mut buf = BytesMut::new();
    enc.encode(f, &mut buf).unwrap();
    buf.freeze()
}

#[test]
fn need_more_before_full_header() {
    let f = FrameBuilder::request(7, 0xAA, 1)
        .payload(Bytes::from_static(b"hello"))
        .build();
    let bytes = encode_frame(f);

    let mut dec = OapDecoder::default();
    let mut buf = BytesMut::new();

    // Feed fewer than the header size — decode must return None.
    buf.extend_from_slice(&bytes[..Header::WIRE_SIZE - 1]);
    assert!(dec.decode(&mut buf).unwrap().is_none());

    // Feed rest — now a frame should be produced.
    buf.extend_from_slice(&bytes[Header::WIRE_SIZE - 1..]);
    let out = dec.decode(&mut buf).unwrap();
    assert!(out.is_some());
}

```

### crates/oap/tests/vectors.rs
<a id="crates-oap-tests-vectors-rs"></a>

```rust
//! RO:WHAT — Golden test vectors for OAP/1: HELLO, START+cap, DATA (with/without COMP).
//! RO:WHY — Guard interop stability; ensure encoder/decoder symmetry and bounds.
//! RO:INVARIANTS — 1MiB bound enforced; START carries cap; COMP requires feature=zstd to decode.

use bytes::{Bytes, BytesMut};
use oap::{
    Flags, Frame, Header, Hello, HelloReply, OapDecoder, OapEncoder, MAX_FRAME_BYTES, OAP_VERSION,
};
// Bring trait methods (encode/decode) into scope:
use tokio_util::codec::{Decoder, Encoder};

/// Compute the canonical on-wire header fields (`len`, `cap_len`) and
/// return a copy of `frame` updated with those values so equality works.
fn normalize(mut frame: Frame) -> Frame {
    let cap_len = frame.cap.as_ref().map(|b| b.len()).unwrap_or(0);
    let payload_len = frame.payload.as_ref().map(|b| b.len()).unwrap_or(0);
    let total_len = Header::WIRE_SIZE + cap_len + payload_len;

    frame.header.cap_len = cap_len as u16;
    frame.header.len = total_len as u32;
    frame
}

fn roundtrip(frame: Frame) {
    let mut enc = OapEncoder::default();
    let mut buf = BytesMut::new();
    enc.encode(frame.clone(), &mut buf).expect("encode");
    let mut dec = OapDecoder::default();
    let out = dec.decode(&mut buf).expect("decode").expect("one frame");

    // Normalize the input to match encoder-corrected header fields.
    let expect = normalize(frame);
    assert_eq!(out, expect);
}

#[test]
fn hello_roundtrip() {
    let h = Hello {
        ua: Some("sdk/0.1".into()),
    };
    let f = h.to_frame(0xAA, 42);
    roundtrip(f);
}

#[test]
fn hello_reply_roundtrip() {
    let hr = HelloReply::default_for_server();
    let f = hr.to_frame(0xBB, 7);
    roundtrip(f);
}

#[test]
fn start_with_cap() {
    let cap = Bytes::from_static(b"macaroon:scope=read:ttl=60s");
    let hdr = Header {
        len: 0,
        ver: OAP_VERSION,
        flags: Flags::START | Flags::REQ,
        code: 0,
        app_proto_id: 100,
        tenant_id: 0xCC,
        cap_len: 0,
        corr_id: 99,
    };
    let frame = Frame {
        header: hdr,
        cap: Some(cap),
        payload: None,
    };
    roundtrip(frame);
}

#[test]
fn data_without_cap() {
    let payload = Bytes::from_static(b"hello world");
    let hdr = Header {
        len: 0,
        ver: OAP_VERSION,
        flags: Flags::RESP,
        code: 200,
        app_proto_id: 200,
        tenant_id: 0xDD,
        cap_len: 0,
        corr_id: 123,
    };
    let frame = Frame {
        header: hdr,
        cap: None,
        payload: Some(payload),
    };
    roundtrip(frame);
}

#[test]
fn rejects_oversize() {
    let payload = vec![0u8; (MAX_FRAME_BYTES as usize) + 1];
    let hdr = Header {
        len: 0,
        ver: OAP_VERSION,
        flags: Flags::RESP,
        code: 200,
        app_proto_id: 1,
        tenant_id: 1,
        cap_len: 0,
        corr_id: 1,
    };
    let mut enc = OapEncoder::default();
    let mut buf = BytesMut::new();
    let res = enc.encode(
        Frame {
            header: hdr,
            cap: None,
            payload: Some(Bytes::from(payload)),
        },
        &mut buf,
    );
    assert!(res.is_err());
}

#[cfg(feature = "zstd")]
#[test]
fn comp_bounded_inflate() {
    // Small payload compressed; ensure decode returns original.
    let raw = vec![42u8; 4096];
    let mut comp = Vec::new();
    {
        let mut enc = zstd::stream::write::Encoder::new(&mut comp, 1).unwrap();
        use std::io::Write;
        enc.write_all(&raw).unwrap();
        enc.finish().unwrap();
    }

    let hdr = Header {
        len: 0,
        ver: OAP_VERSION,
        flags: Flags::RESP | Flags::COMP,
        code: 200,
        app_proto_id: 2,
        tenant_id: 2,
        cap_len: 0,
        corr_id: 2,
    };
    let mut enc = OapEncoder::default();
    let mut buf = BytesMut::new();
    enc.encode(
        Frame {
            header: hdr,
            cap: None,
            payload: Some(Bytes::from(comp)),
        },
        &mut buf,
    )
    .unwrap();

    let mut dec = OapDecoder::default();
    let out = dec.decode(&mut buf).unwrap().unwrap();
    assert_eq!(out.payload.unwrap().len(), raw.len());
}

```

### crates/oap/tests/writer_roundtrip.rs
<a id="crates-oap-tests-writerroundtrip-rs"></a>

```rust
use bytes::Bytes;
use oap::{codec::OapDecoder, prelude::*, writer::OapWriter, writer::WriterConfig};
use tokio_util::codec::Decoder as _;

fn normalize(mut f: Frame) -> Frame {
    let cap_len = f.cap.as_ref().map(|b| b.len()).unwrap_or(0);
    let payload_len = f.payload.as_ref().map(|b| b.len()).unwrap_or(0);
    f.header.cap_len = cap_len as u16;
    f.header.len = (Header::WIRE_SIZE + cap_len + payload_len) as u32;
    f
}

#[test]
fn encode_to_buf_and_decode_back() {
    // Build a START frame with cap + payload.
    let f = FrameBuilder::request(42, 0xCAFE, 99)
        .start_with_cap(Bytes::from_static(b"scope=read"))
        .payload(Bytes::from_static(b"ping"))
        .want_ack()
        .build();

    // Encode using writer (buffered, no async I/O used).
    let mut w = OapWriter::new(WriterConfig::default());
    w.encode_to_buf(f.clone()).unwrap();
    let bytes = w.take_buf();

    // Decode back.
    let mut dec = OapDecoder::default();
    let mut buf: bytes::BytesMut = bytes.clone().into(); // <-- direct From<Bytes>
    let out = dec.decode(&mut buf).unwrap().unwrap();

    assert_eq!(out, normalize(f));
    assert!(buf.is_empty(), "buffer fully consumed");
}

```

