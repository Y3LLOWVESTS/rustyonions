<!-- Generated by scripts/make_crate_codex.sh on 2025-11-14T02:18:37Z -->
# Code Bundle — `svc-edge`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-edge/.cargo/config.toml](#crates-svc-edge--cargo-config-toml)
- [crates/svc-edge/.github/workflows/ci.yaml](#crates-svc-edge--github-workflows-ci-yaml)
- [crates/svc-edge/.github/workflows/perf-guard.yaml](#crates-svc-edge--github-workflows-perf-guard-yaml)
- [crates/svc-edge/.github/workflows/public-api.yaml](#crates-svc-edge--github-workflows-public-api-yaml)
- [crates/svc-edge/.github/workflows/render-mermaid.yaml](#crates-svc-edge--github-workflows-render-mermaid-yaml)
- [crates/svc-edge/Cargo.toml](#crates-svc-edge-Cargo-toml)
- [crates/svc-edge/benches/bench_blake3.rs](#crates-svc-edge-benches-benchblake3-rs)
- [crates/svc-edge/benches/bench_pack_read.rs](#crates-svc-edge-benches-benchpackread-rs)
- [crates/svc-edge/benches/bench_range.rs](#crates-svc-edge-benches-benchrange-rs)
- [crates/svc-edge/configs/svc-edge.toml](#crates-svc-edge-configs-svc-edge-toml)
- [crates/svc-edge/scripts/dev-run.sh](#crates-svc-edge-scripts-dev-run-sh)
- [crates/svc-edge/scripts/perf-smoke.sh](#crates-svc-edge-scripts-perf-smoke-sh)
- [crates/svc-edge/scripts/render-mermaid.sh](#crates-svc-edge-scripts-render-mermaid-sh)
- [crates/svc-edge/scripts/smoke_edge.sh](#crates-svc-edge-scripts-smokeedge-sh)
- [crates/svc-edge/src/adapters/cas.rs](#crates-svc-edge-src-adapters-cas-rs)
- [crates/svc-edge/src/adapters/live_fill.rs](#crates-svc-edge-src-adapters-livefill-rs)
- [crates/svc-edge/src/adapters/pack.rs](#crates-svc-edge-src-adapters-pack-rs)
- [crates/svc-edge/src/adapters/tls.rs](#crates-svc-edge-src-adapters-tls-rs)
- [crates/svc-edge/src/admission/body_cap.rs](#crates-svc-edge-src-admission-bodycap-rs)
- [crates/svc-edge/src/admission/decompress_guard.rs](#crates-svc-edge-src-admission-decompressguard-rs)
- [crates/svc-edge/src/admission/inflight_cap.rs](#crates-svc-edge-src-admission-inflightcap-rs)
- [crates/svc-edge/src/admission/mod.rs](#crates-svc-edge-src-admission-mod-rs)
- [crates/svc-edge/src/admission/rps_limit.rs](#crates-svc-edge-src-admission-rpslimit-rs)
- [crates/svc-edge/src/admission/timeout.rs](#crates-svc-edge-src-admission-timeout-rs)
- [crates/svc-edge/src/bin/svc-edge.rs](#crates-svc-edge-src-bin-svc-edge-rs)
- [crates/svc-edge/src/cli.rs](#crates-svc-edge-src-cli-rs)
- [crates/svc-edge/src/config.rs](#crates-svc-edge-src-config-rs)
- [crates/svc-edge/src/errors.rs](#crates-svc-edge-src-errors-rs)
- [crates/svc-edge/src/http/etag.rs](#crates-svc-edge-src-http-etag-rs)
- [crates/svc-edge/src/http/headers.rs](#crates-svc-edge-src-http-headers-rs)
- [crates/svc-edge/src/http/range.rs](#crates-svc-edge-src-http-range-rs)
- [crates/svc-edge/src/lib.rs](#crates-svc-edge-src-lib-rs)
- [crates/svc-edge/src/metrics.rs](#crates-svc-edge-src-metrics-rs)
- [crates/svc-edge/src/readiness.rs](#crates-svc-edge-src-readiness-rs)
- [crates/svc-edge/src/routes/assets.rs](#crates-svc-edge-src-routes-assets-rs)
- [crates/svc-edge/src/routes/health.rs](#crates-svc-edge-src-routes-health-rs)
- [crates/svc-edge/src/routes/mod.rs](#crates-svc-edge-src-routes-mod-rs)
- [crates/svc-edge/src/routes/prometheus.rs](#crates-svc-edge-src-routes-prometheus-rs)
- [crates/svc-edge/src/routes/ready.rs](#crates-svc-edge-src-routes-ready-rs)
- [crates/svc-edge/src/security/audit.rs](#crates-svc-edge-src-security-audit-rs)
- [crates/svc-edge/src/security/cors.rs](#crates-svc-edge-src-security-cors-rs)
- [crates/svc-edge/src/security/hsts.rs](#crates-svc-edge-src-security-hsts-rs)
- [crates/svc-edge/src/state.rs](#crates-svc-edge-src-state-rs)
- [crates/svc-edge/src/supervisor.rs](#crates-svc-edge-src-supervisor-rs)
- [crates/svc-edge/src/util/backoff.rs](#crates-svc-edge-src-util-backoff-rs)
- [crates/svc-edge/src/util/bytes.rs](#crates-svc-edge-src-util-bytes-rs)
- [crates/svc-edge/src/util/size_parse.rs](#crates-svc-edge-src-util-sizeparse-rs)
- [crates/svc-edge/src/work/queue.rs](#crates-svc-edge-src-work-queue-rs)
- [crates/svc-edge/src/work/shutdown.rs](#crates-svc-edge-src-work-shutdown-rs)
- [crates/svc-edge/src/work/worker.rs](#crates-svc-edge-src-work-worker-rs)
- [crates/svc-edge/tests/concurrency_backpressure.rs](#crates-svc-edge-tests-concurrencybackpressure-rs)
- [crates/svc-edge/tests/fuzz_headers.rs](#crates-svc-edge-tests-fuzzheaders-rs)
- [crates/svc-edge/tests/http_contract.rs](#crates-svc-edge-tests-httpcontract-rs)
- [crates/svc-edge/tests/i_10_deterministic_failures.rs](#crates-svc-edge-tests-i10deterministicfailures-rs)
- [crates/svc-edge/tests/i_11_pack_integrity.rs](#crates-svc-edge-tests-i11packintegrity-rs)
- [crates/svc-edge/tests/i_1_hardening_ingress.rs](#crates-svc-edge-tests-i1hardeningingress-rs)
- [crates/svc-edge/tests/i_4_http_semantics.rs](#crates-svc-edge-tests-i4httpsemantics-rs)
- [crates/svc-edge/tests/i_5_content_address.rs](#crates-svc-edge-tests-i5contentaddress-rs)
- [crates/svc-edge/tests/i_6_amnesia.rs](#crates-svc-edge-tests-i6amnesia-rs)
- [crates/svc-edge/tests/i_8_size_bounds.rs](#crates-svc-edge-tests-i8sizebounds-rs)
- [crates/svc-edge/tests/i_9_observability_contract.rs](#crates-svc-edge-tests-i9observabilitycontract-rs)
- [crates/svc-edge/tests/readiness_logic.rs](#crates-svc-edge-tests-readinesslogic-rs)

### crates/svc-edge/.cargo/config.toml
<a id="crates-svc-edge--cargo-config-toml"></a>

```toml
[build]
rustflags = ["-Dwarnings"]

[env]
RUST_LOG = "info"

```

### crates/svc-edge/.github/workflows/ci.yaml
<a id="crates-svc-edge--github-workflows-ci-yaml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  rust:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo fmt --all --check
      - run: cargo clippy -p svc-edge2 -- -D warnings
      - run: cargo test -p svc-edge2

```

### crates/svc-edge/.github/workflows/perf-guard.yaml
<a id="crates-svc-edge--github-workflows-perf-guard-yaml"></a>

```yaml
name: perf-guard
on:
  schedule:
    - cron: '0 3 * * *'
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'perf guard placeholder'

```

### crates/svc-edge/.github/workflows/public-api.yaml
<a id="crates-svc-edge--github-workflows-public-api-yaml"></a>

```yaml
name: public-api
on: [push, pull_request]
jobs:
  api:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo install cargo-public-api || true
      - run: cargo public-api -p svc-edge2

```

### crates/svc-edge/.github/workflows/render-mermaid.yaml
<a id="crates-svc-edge--github-workflows-render-mermaid-yaml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: bash crates/svc-edge2/scripts/render-mermaid.sh

```

### crates/svc-edge/Cargo.toml
<a id="crates-svc-edge-Cargo-toml"></a>

```toml
[package]
name = "svc-edge"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[features]
default = ["cli"]
cli = ["dep:clap"]
tls = ["dep:tokio-rustls"]
pq = []
otel = []

[dependencies]
# Core utils
anyhow = { workspace = true, features = ["std"] }
once_cell = { workspace = true }
parking_lot = { workspace = true }
thiserror = { workspace = true }
toml = { workspace = true }

# Serde / JSON
serde = { workspace = true }
serde_json = { workspace = true }

# Logging / metrics
tracing = { workspace = true }
tracing-subscriber = { workspace = true, features = ["fmt","env-filter"] }
prometheus = { workspace = true }

# Axum & friends (Axum 0.7 via workspace pins)
# IMPORTANT: enable "tokio","http1","http2","json" so Router<S> works with axum::serve
axum = { workspace = true, features = ["tokio","http1","http2","json"] }
http = { workspace = true }

# Tokio runtime
tokio = { workspace = true, features = ["rt-multi-thread","macros","signal","net","time","io-util"] }
tokio-util = { workspace = true }              # for CancellationToken

# TLS (optional)
tokio-rustls = { workspace = true, optional = true }

# Tower stack (limits/timeout we actually use)
tower = { workspace = true, features = ["util","limit","timeout"] }
# We’re using Axum’s DefaultBodyLimit, but keeping tower-http 'limit' is fine for future use.
tower-http = { workspace = true, features = ["limit"] }

# CLI (optional)
clap = { version = "4", features = ["derive"], optional = true }

# project-internal
ron-kernel = { path = "../ron-kernel" }

# NEW: assets/CAS helpers
blake3 = "1.5.4"
percent-encoding = "2.3.1"
mime_guess = "2.0.5"

[dev-dependencies]

```

### crates/svc-edge/benches/bench_blake3.rs
<a id="crates-svc-edge-benches-benchblake3-rs"></a>

```rust

```

### crates/svc-edge/benches/bench_pack_read.rs
<a id="crates-svc-edge-benches-benchpackread-rs"></a>

```rust

```

### crates/svc-edge/benches/bench_range.rs
<a id="crates-svc-edge-benches-benchrange-rs"></a>

```rust

```

### crates/svc-edge/configs/svc-edge.toml
<a id="crates-svc-edge-configs-svc-edge-toml"></a>

```toml
# Minimal runnable config (admin plane only in this increment).
bind_addr = "0.0.0.0:8080"
metrics_addr = "127.0.0.1:9909"

[security]
amnesia = true

```

### crates/svc-edge/scripts/dev-run.sh
<a id="crates-svc-edge-scripts-dev-run-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "${BASH_SOURCE[0]}")/.."
RUST_LOG=${RUST_LOG:-info} \
SVC_EDGE_BIND_ADDR=${SVC_EDGE_BIND_ADDR:-0.0.0.0:8080} \
SVC_EDGE_METRICS_ADDR=${SVC_EDGE_METRICS_ADDR:-127.0.0.1:9909} \
SVC_EDGE_SECURITY__AMNESIA=${SVC_EDGE_SECURITY__AMNESIA:-true} \
cargo run -p svc-edge2 -- \
  --config ./configs/svc-edge.toml

```

### crates/svc-edge/scripts/perf-smoke.sh
<a id="crates-svc-edge-scripts-perf-smoke-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
URL=${1:-http://127.0.0.1:8080/edge/assets/path}
bombardier -c 64 -d 60s -l "$URL"

```

### crates/svc-edge/scripts/render-mermaid.sh
<a id="crates-svc-edge-scripts-render-mermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "${BASH_SOURCE[0]}")/.."
for f in $(git ls-files 'docs/mmd/*.mmd'); do
  out=${f/mmd/svg}
  out=${out%.mmd}.svg
  mkdir -p $(dirname "$out")
  mmdc -i "$f" -o "$out"
done

```

### crates/svc-edge/scripts/smoke_edge.sh
<a id="crates-svc-edge-scripts-smokeedge-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

ADMIN=${ADMIN:-127.0.0.1:9909}
API=${API:-127.0.0.1:8080}
ASSETS_DIR=${SVC_EDGE_ASSETS_DIR:-assets}
TEST_FILE=${TEST_FILE:-hello.txt}

echo "[INFO] Admin plane checks @ http://${ADMIN}"
curl -fsS -o /dev/null http://${ADMIN}/healthz && echo "[OK] /healthz"
curl -fsS -o /dev/null http://${ADMIN}/metrics && echo "[OK] /metrics"

echo "[STEP] Ensure assets dir + test file"
mkdir -p "${ASSETS_DIR}"
if [ ! -f "${ASSETS_DIR}/${TEST_FILE}" ]; then
  echo "hello-edge" > "${ASSETS_DIR}/${TEST_FILE}"
fi

echo "[STEP] Readiness"
curl -fsS http://${ADMIN}/readyz && echo

echo "[STEP] GET /edge/assets/${TEST_FILE}"
resp_headers=$(mktemp)
curl -i -fsS http://${API}/edge/assets/${TEST_FILE} | tee "${resp_headers}" | sed -n '1,999p' >/dev/null
etag=$(grep -i '^etag:' "${resp_headers}" | awk '{print $2}' | tr -d '\r')
echo "[OK] ETag: ${etag}"

echo "[STEP] 304 via If-None-Match"
curl -i -fsS http://${API}/edge/assets/${TEST_FILE} -H "If-None-Match: ${etag}" | head -n 1

echo "[STEP] 206 via Range: bytes=2-"
curl -i -fsS http://${API}/edge/assets/${TEST_FILE} -H 'Range: bytes=2-' | sed -n '1,6p'

echo "[STEP] CAS demo (blake3)"
# Use the same ETag (it’s the blake3 digest) to stage CAS file
digest=$(echo "${etag}" | tr -d '"')
mkdir -p "${ASSETS_DIR}/cas/blake3"
cp "${ASSETS_DIR}/${TEST_FILE}" "${ASSETS_DIR}/cas/blake3/${digest}"
curl -i -fsS http://${API}/cas/blake3/${digest} | sed -n '1,6p'
curl -i -fsS http://${API}/cas/blake3/${digest} -H 'Range: bytes=2-' | sed -n '1,6p'

echo "[STEP] Burst /edge/assets/${TEST_FILE} (200×200)"
seq 1 200 | xargs -n1 -P200 -I{} curl -s -o /dev/null -w "%{http_code}\n" \
  http://${API}/edge/assets/${TEST_FILE} | sort | uniq -c

echo "[DONE] smoke_edge.sh completed successfully."

```

### crates/svc-edge/src/adapters/cas.rs
<a id="crates-svc-edge-src-adapters-cas-rs"></a>

```rust
//! Adapter: content-addressed storage (read-only) — stub.

/// Digest bytes (opaque placeholder).
pub type Digest = [u8; 32];

/// CAS interface (read-only, stubbed).
pub trait CasStore: Send + Sync {
    /// Fetch a blob by digest. Returns `None` if missing.
    fn get(&self, _digest: &Digest) -> Option<Vec<u8>>;
}

/// No-op CAS for early wiring.
#[derive(Debug, Clone, Default)]
pub struct NullCas;

impl CasStore for NullCas {
    fn get(&self, _digest: &Digest) -> Option<Vec<u8>> {
        None
    }
}

```

### crates/svc-edge/src/adapters/live_fill.rs
<a id="crates-svc-edge-src-adapters-livefill-rs"></a>

```rust
//! Adapter: live-fill miss handler (fetch-on-miss) — stub.

use super::cas::{CasStore, Digest};

/// Miss policy for live fill (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum LiveFillPolicy {
    /// Do not attempt live-fill on misses.
    Off,
    /// Allow live-fill with bounded concurrency (details TBD).
    On,
}

impl Default for LiveFillPolicy {
    fn default() -> Self {
        LiveFillPolicy::Off
    }
}

/// Live-fill engine stub.
#[derive(Debug, Default)]
pub struct LiveFill;

impl LiveFill {
    /// Attempt to fill a digest; always returns `None` for now.
    pub async fn fill<C: CasStore>(&self, _cas: &C, _d: &Digest) -> Option<Vec<u8>> {
        None
    }
}

```

### crates/svc-edge/src/adapters/pack.rs
<a id="crates-svc-edge-src-adapters-pack-rs"></a>

```rust
//! Adapter: read-only pack access (e.g., PMTiles/pack files) — stub.

use std::path::PathBuf;

/// Pack source descriptor (placeholder).
#[derive(Debug, Clone)]
pub struct PackSource {
    /// Path to on-disk pack file (or future remote locator).
    pub path: PathBuf,
}

/// Minimal pack trait (read-only, stubbed).
pub trait PackStore: Send + Sync {
    /// Return `true` if the pack appears available.
    fn available(&self) -> bool;
}

/// No-op pack implementation used for wiring tests.
#[derive(Debug, Clone, Default)]
pub struct NullPack;

impl PackStore for NullPack {
    fn available(&self) -> bool {
        false
    }
}

```

### crates/svc-edge/src/adapters/tls.rs
<a id="crates-svc-edge-src-adapters-tls-rs"></a>

```rust
//! TLS adapter placeholders (server config wiring) — stub.

/// TLS mode (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum TlsMode {
    /// Plain TCP (no TLS).
    Plain,
    /// TLS via rustls (details TBD).
    Rustls,
}

impl Default for TlsMode {
    fn default() -> Self {
        TlsMode::Plain
    }
}

```

### crates/svc-edge/src/admission/body_cap.rs
<a id="crates-svc-edge-src-admission-bodycap-rs"></a>

```rust
//! Admission guard: maximum request body bytes (stub).

/// Configuration for a future body cap guard.
#[derive(Debug, Clone, Copy)]
pub struct BodyCap {
    /// Maximum allowed bytes in the request body.
    pub max_bytes: u64,
}

impl Default for BodyCap {
    fn default() -> Self {
        Self { max_bytes: 1_048_576 } // 1 MiB
    }
}

impl BodyCap {
    /// Create a new cap with the given maximum.
    pub fn new(max_bytes: u64) -> Self {
        Self { max_bytes }
    }
}

```

### crates/svc-edge/src/admission/decompress_guard.rs
<a id="crates-svc-edge-src-admission-decompressguard-rs"></a>

```rust
//! Admission guard: optional transparent decompression (stub).

/// Decompression posture (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum Decompress {
    /// Allow a safe set (e.g., gzip) — details TBD.
    Safe,
    /// Disable all decompression.
    Off,
}

impl Default for Decompress {
    fn default() -> Self {
        Decompress::Off
    }
}

```

### crates/svc-edge/src/admission/inflight_cap.rs
<a id="crates-svc-edge-src-admission-inflightcap-rs"></a>

```rust
//! Admission guard: cap concurrent in-flight requests (stub).

/// In-flight concurrency cap (placeholder).
#[derive(Debug, Clone, Copy)]
pub struct InflightCap {
    /// Maximum concurrent requests the service will process.
    pub max: usize,
}

impl Default for InflightCap {
    fn default() -> Self {
        Self { max: 256 }
    }
}

```

### crates/svc-edge/src/admission/mod.rs
<a id="crates-svc-edge-src-admission-mod-rs"></a>

```rust
//! Admission chain (custom minimal layer) for the API plane.
//!
//! RO:WHAT
//! - Enforce **timeout** and **inflight cap** with a tiny, cloneable Tower `Layer`.
//!
//! RO:WHY
//! - Keeps the service `Clone + Send + 'static` with `Error = Infallible` to satisfy
//!   `Router::route_layer` bounds in axum 0.7, avoiding brittle combinator stacks.
//! - No `http_body`/`bytes` deps; no body-type churn.
//!
//! RO:INVARIANTS
//! - No locks across `.await`; uses `Arc<Semaphore>`.
//! - Deterministic rejections (408/503); no ambiguous 500s from the layer itself.
//!
//! RO:METRICS
//! - Ticks `edge_rejects_total{reason}` on 408 (timeout) and 503 (busy).
//!
//! RO:CONFIG
//! - Prefer `apply_with(router, timeout, max_inflight)` for env/Config-driven caps.
//! - `apply_defaults(...)` kept for dev convenience.

use std::{
    convert::Infallible,
    future::Future,
    pin::Pin,
    sync::Arc,
    task::{Context, Poll},
    time::Duration,
};

use axum::{
    response::{IntoResponse, Response},
    Json, Router,
};
use http::{Request, StatusCode};
use serde_json::json;
use tokio::sync::Semaphore;
use tower::{Layer, Service};

/// Default tunables (dev convenience).
const DEFAULT_TIMEOUT: Duration = Duration::from_secs(5);
const DEFAULT_MAX_INFLIGHT: usize = 256;

/// Apply admission guards with dev defaults.
pub fn apply_defaults<S>(router: Router<S>) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    apply_with(router, DEFAULT_TIMEOUT, DEFAULT_MAX_INFLIGHT)
}

/// Apply admission guards with explicit caps (Config/env-friendly).
pub fn apply_with<S>(router: Router<S>, timeout: Duration, max_inflight: usize) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    let layer = AdmissionLayer::new(AdmissionConfig {
        timeout,
        max_inflight,
    });
    router.route_layer(layer)
}

/// Configuration for the admission guard.
#[derive(Debug, Clone, Copy)]
pub struct AdmissionConfig {
    /// Per-request wall-clock timeout (e.g., 5s → 408 on expiry).
    pub timeout: Duration,
    /// Maximum number of inflight requests (beyond this → 503).
    pub max_inflight: usize,
}

/// Layer that installs [`AdmissionService`] on the router.
#[derive(Clone)]
pub struct AdmissionLayer {
    cfg: AdmissionConfig,
}

impl AdmissionLayer {
    /// Build a new admission layer with the given config.
    pub fn new(cfg: AdmissionConfig) -> Self {
        Self { cfg }
    }
}

impl<S> Layer<S> for AdmissionLayer {
    type Service = AdmissionService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        AdmissionService::new(inner, self.cfg)
    }
}

/// Service wrapper that enforces timeout and inflight limits.
#[derive(Clone)]
pub struct AdmissionService<S> {
    inner: S,
    cfg: AdmissionConfig,
    inflight: Arc<Semaphore>,
}

impl<S> AdmissionService<S> {
    fn new(inner: S, cfg: AdmissionConfig) -> Self {
        Self {
            inner,
            cfg,
            inflight: Arc::new(Semaphore::new(cfg.max_inflight)),
        }
    }
}

impl<S, B> Service<Request<B>> for AdmissionService<S>
where
    S: Service<Request<B>, Error = Infallible> + Clone + Send + 'static,
    S::Response: IntoResponse + Send + 'static,
    S::Future: Send + 'static,
    B: Send + 'static,
{
    // Use axum::Response so we can build responses from any IntoResponse.
    type Response = Response;
    type Error = Infallible;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        // Error is already Infallible; just forward it.
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        let cfg = self.cfg;
        let mut inner = self.inner.clone();
        let inflight = Arc::clone(&self.inflight);

        Box::pin(async move {
            // Inflight cap → 503 when saturated.
            let _permit = match inflight.try_acquire() {
                Ok(p) => p,
                Err(_) => {
                    crate::metrics::inc_reject("busy");
                    let body = Json(json!({ "ok": false, "reason": "busy" }));
                    return Ok((StatusCode::SERVICE_UNAVAILABLE, body).into_response());
                }
            };

            // Timeout → 408 when exceeded.
            match tokio::time::timeout(cfg.timeout, inner.call(req)).await {
                Ok(Ok(resp)) => Ok(resp.into_response()),
                Ok(Err(_)) => {
                    // Inner service promised Infallible; this should be unreachable.
                    let body = Json(json!({ "ok": false, "reason": "inner_error" }));
                    Ok((StatusCode::INTERNAL_SERVER_ERROR, body).into_response())
                }
                Err(_) => {
                    crate::metrics::inc_reject("timeout");
                    let body = Json(json!({ "ok": false, "reason": "timeout" }));
                    Ok((StatusCode::REQUEST_TIMEOUT, body).into_response())
                }
            }
        })
    }
}

```

### crates/svc-edge/src/admission/rps_limit.rs
<a id="crates-svc-edge-src-admission-rpslimit-rs"></a>

```rust
//! Admission guard: requests-per-second limiter (stub).

/// Simple RPS limiter configuration (placeholder).
#[derive(Debug, Clone, Copy)]
pub struct RpsLimit {
    /// Approximate target request rate (per second).
    pub rps: u64,
}

impl Default for RpsLimit {
    fn default() -> Self {
        Self { rps: 1000 }
    }
}

```

### crates/svc-edge/src/admission/timeout.rs
<a id="crates-svc-edge-src-admission-timeout-rs"></a>

```rust
//! Admission guard: per-request timeout (stub).

use std::time::Duration;

/// Timeout configuration (placeholder).
#[derive(Debug, Clone, Copy)]
pub struct Timeout {
    /// Maximum request processing time.
    pub duration: Duration,
}

impl Default for Timeout {
    fn default() -> Self {
        Self { duration: Duration::from_secs(5) }
    }
}

```

### crates/svc-edge/src/bin/svc-edge.rs
<a id="crates-svc-edge-src-bin-svc-edge-rs"></a>

```rust
/// GROK WROTE THIS (adapted to use svc-edge lib surface)
// svc-edge — bin wiring for Axum 0.7 with stateful routers and the real library state.
// - Uses Router directly with `axum::serve` (no manual make_service).
// - Clean graceful shutdown with CancellationToken.
// - Two listeners: admin (health/ready/metrics) and api (edge surface).
// RO:WHAT — Binary entrypoint for svc-edge.
// RO:WHY — Boots admin + API planes; uses Config/AppState/EdgeMetrics/HealthState from the lib.
// RO:INTERACTS — axum::serve, tokio::net, ron_kernel::wait_for_ctrl_c; AppState (config/metrics/health).
// RO:INVARIANTS — No ambient auth; binds config-driven; readiness is degrade-first until gates flip.
// RO:METRICS — /metrics exposes Prometheus; admission layer will tick rejects/latency later.
// RO:CONFIG — Uses `Config::from_sources(None)` (env + defaults) + temp env knobs for admission/assets.
// RO:SECURITY — Amnesia posture exposed via metrics (future: enforced persistence rules).
// RO:TEST — Driven by http_contract, readiness_logic, i_1_hardening_ingress, etc.

use std::{env, net::SocketAddr, sync::Arc, time::Duration};

use anyhow::Context;
use axum::{
    routing::{get, post},
    Router,
};
use tokio::{net::TcpListener, signal};
use tokio_util::sync::CancellationToken;
use tracing::{error, info, Level};
use tracing_subscriber::{fmt, EnvFilter};

use svc_edge::admission;
use svc_edge::metrics::seed_from_health;
use svc_edge::readiness::readiness_handler;
use svc_edge::routes::{assets, health, prometheus};
use svc_edge::{wait_for_ctrl_c, AppState, Config, EdgeMetrics, HealthState};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    init_tracing();

    // --- Config (from svc-edge::Config, env + defaults) --------------------
    // Reads SVC_EDGE_BIND_ADDR, SVC_EDGE_METRICS_ADDR, SVC_EDGE_SECURITY__AMNESIA, etc.
    let cfg: Config = Config::from_sources(None).context("load svc-edge config")?;

    let admin_addr: SocketAddr = cfg.metrics_addr;
    let api_addr: SocketAddr = cfg.bind_addr;

    // Admission env overrides (temporary until wired into Config fully).
    let timeout_ms: u64 = env_var_parse("SVC_EDGE_ADMISSION_TIMEOUT_MS", 5_000);
    let max_inflight: usize = env_var_parse("SVC_EDGE_ADMISSION_MAX_INFLIGHT", 256);

    // Asset root (temporary; real path will come from Config.assets.root).
    // Default to ./assets relative to current working dir.
    let assets_root: String = env::var("SVC_EDGE_ASSETS_DIR").unwrap_or_else(|_| "assets".to_string());

    info!(
        %admin_addr, %api_addr, timeout_ms, max_inflight, assets_root,
        "svc-edge: resolved bind addresses and admission caps"
    );

    // --- Health + metrics + shared AppState --------------------------------
    let health: Arc<HealthState> = Arc::new(HealthState::new());
    let metrics = EdgeMetrics::new();

    // Seed metrics with amnesia posture (additional gates will be wired later).
    seed_from_health(health.clone(), &metrics, cfg.security.amnesia);

    // Flip readiness: config_loaded=true (we made it here).
    health.set("config_loaded", true);

    let state = AppState::new(cfg, metrics, health.clone());

    // --- Simple service readiness probe (assets dir exists) -----------------
    // For now, require that the assets root exists to consider "services_ok".
    let services_ok = std::path::Path::new(&assets_root).exists();
    health.set("services_ok", services_ok);

    // --- Bind listeners -----------------------------------------------------
    let admin_listener = TcpListener::bind(admin_addr)
        .await
        .with_context(|| format!("bind admin listener at {admin_addr}"))?;
    let api_listener = TcpListener::bind(api_addr)
        .await
        .with_context(|| format!("bind api listener at {api_addr}"))?;

    info!(%admin_addr, "svc-edge: admin plane listening");
    info!(%api_addr, "svc-edge: api plane listening");

    // --- Build routers (admin + api) ---------------------------------------

    // Admin plane: /healthz, /readyz, /metrics.
    let admin_app: Router = Router::new()
        .route("/healthz", get(health::healthz))
        .route("/readyz", get(readiness_handler))
        .route("/metrics", get(prometheus::metrics))
        .with_state(state.clone());

    // API plane: assets + CAS + test endpoints.
    let api_router: Router = Router::new()
        // Assets and CAS (basic ETag + Range)
        .route("/edge/assets/*path", get(assets::get_asset))
        .route("/cas/:algo/:digest", get(assets::get_cas))
        // Test helpers
        .route("/echo", post(assets::echo))
        .route("/echo/slow/:ms", post(assets::echo_slow))
        .with_state(state.clone());

    // Apply the admission chain with env-driven caps.
    let api_app: Router = admission::apply_with(
        api_router,
        Duration::from_millis(timeout_ms),
        max_inflight,
    );

    // --- Graceful shutdown wiring ------------------------------------------
    let cancel = CancellationToken::new();
    let t_admin = cancel.clone();
    let t_api = cancel.clone();

    let admin_srv = async move {
        axum::serve(admin_listener, admin_app)
            .with_graceful_shutdown(t_admin.cancelled_owned())
            .await
            .context("admin server failed")
    };

    let api_srv = async move {
        axum::serve(api_listener, api_app)
            .with_graceful_shutdown(t_api.cancelled_owned())
            .await
            .context("api server failed")
    };

    info!("svc-edge: up; waiting for traffic or shutdown signal");

    tokio::select! {
        res = admin_srv => {
            if let Err(e) = res {
                error!(error=%e, "admin server error");
                return Err(e);
            }
        }
        res = api_srv => {
            if let Err(e) = res {
                error!(error=%e, "api server error");
                return Err(e);
            }
        }
        _ = wait_for_shutdown_signal() => {
            info!("shutdown signal received");
        }
    }

    cancel.cancel();
    tokio::time::sleep(Duration::from_millis(100)).await;
    info!("svc-edge exiting");
    Ok(())
}

fn env_var_parse<T: std::str::FromStr>(key: &str, default: T) -> T {
    match std::env::var(key) {
        Ok(v) => v.parse().unwrap_or(default),
        Err(_) => default,
    }
}

async fn wait_for_shutdown_signal() {
    // Prefer the kernel helper if available, otherwise fallback.
    wait_for_ctrl_c().await;
    // Fallback: tokio ctrl-c (no-op if already triggered).
    let _ = signal::ctrl_c().await;
}

fn init_tracing() {
    // Example: RUST_LOG=info,hyper=warn,axum::rejection=trace
    let filter =
        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn"));

    fmt()
        .with_max_level(Level::INFO)
        .with_env_filter(filter)
        .with_target(false)
        .compact()
        .init();
}

```

### crates/svc-edge/src/cli.rs
<a id="crates-svc-edge-src-cli-rs"></a>

```rust
//! CLI parsing (flags are minimal for the first increment).

use std::path::PathBuf;

#[cfg(feature = "cli")]
use clap::Parser;

/// CLI flags (mirrors docs/CONFIG.md as we grow).
#[cfg_attr(feature = "cli", derive(Parser))]
#[derive(Clone, Debug, Default)]
#[cfg_attr(
    feature = "cli",
    command(name = "svc-edge", author, version, about = "svc-edge service")
)]
pub struct Cli {
    /// Path to the svc-edge TOML config file.
    #[cfg_attr(feature = "cli", arg(long = "config"))]
    pub config_path: Option<PathBuf>,
}

impl Cli {
    /// Parse CLI flags from the current process environment/argv.
    ///
    /// When the `cli` feature is disabled, returns defaults.
    #[cfg(feature = "cli")]
    pub fn parse_from_env() -> Self {
        <Self as clap::Parser>::parse()
    }

    /// Parse CLI flags from the current process environment/argv.
    ///
    /// When the `cli` feature is disabled, returns defaults.
    #[cfg(not(feature = "cli"))]
    pub fn parse_from_env() -> Self {
        Self::default()
    }
}

```

### crates/svc-edge/src/config.rs
<a id="crates-svc-edge-src-config-rs"></a>

```rust
//! Config for svc-edge.
//!
//! RO:WHAT
//! - Provides bind addresses, security posture, admission caps, and assets root.
//! - Loads from ENV (TOML reader can be added later without changing the API).
//!
//! RO:ENV
//! - `SVC_EDGE_BIND_ADDR`              (default `"0.0.0.0:8080"`)
//! - `SVC_EDGE_METRICS_ADDR`           (default `"127.0.0.1:9909"`)
//! - `SVC_EDGE_SECURITY__AMNESIA`      (default `"0"`)
//! - `SVC_EDGE_ADMISSION_TIMEOUT_MS`   (default `"5000"`)
//! - `SVC_EDGE_ADMISSION_MAX_INFLIGHT` (default `"256"`)
//! - `SVC_EDGE_ASSETS_DIR`             (default `"assets"`)

use std::{net::SocketAddr, path::PathBuf, str::FromStr};

/// Top-level configuration for the svc-edge process.
///
/// Values are derived from environment variables (see module docs).
#[derive(Clone, Debug)]
pub struct Config {
    /// Address for the public API plane (e.g., `/edge/assets/*`, `/cas/*`).
    pub bind_addr: SocketAddr,
    /// Address for the admin plane (e.g., `/healthz`, `/readyz`, `/metrics`).
    pub metrics_addr: SocketAddr,
    /// Security posture settings (e.g., amnesia mode).
    pub security: SecurityCfg,
    /// Admission guard settings (timeouts, inflight caps).
    pub admission: AdmissionCfg,
    /// Asset adapter settings (temporary FS root until pack/CAS adapters land).
    pub assets: AssetsCfg,
}

/// Security posture for the service.
#[derive(Clone, Debug)]
pub struct SecurityCfg {
    /// Amnesia mode (true = prefer RAM/avoid persistence; best-effort on this crate).
    pub amnesia: bool,
}

/// Admission caps for the API plane.
#[derive(Clone, Debug)]
pub struct AdmissionCfg {
    /// Per-request wall-clock timeout in milliseconds (→ HTTP 408 on expiry).
    pub timeout_ms: u64,
    /// Maximum number of inflight requests (→ HTTP 503 when saturated).
    pub max_inflight: usize,
}

/// Asset adapter configuration (temporary filesystem root).
#[derive(Clone, Debug)]
pub struct AssetsCfg {
    /// Filesystem root used by the current asset scaffold.
    pub root: PathBuf,
}

impl Config {
    /// Load configuration from environment variables.
    ///
    /// The `_maybe_path` parameter is reserved for future TOML loading and is
    /// ignored for now to keep the public API stable.
    pub fn from_sources(_maybe_path: Option<&str>) -> anyhow::Result<Self> {
        let bind_addr = env_parse("SVC_EDGE_BIND_ADDR", "0.0.0.0:8080".to_string());
        let metrics_addr = env_parse("SVC_EDGE_METRICS_ADDR", "127.0.0.1:9909".to_string());
        let amnesia = env_parse_bool("SVC_EDGE_SECURITY__AMNESIA", false);
        let timeout_ms = env_parse("SVC_EDGE_ADMISSION_TIMEOUT_MS", 5_000u64);
        let max_inflight = env_parse("SVC_EDGE_ADMISSION_MAX_INFLIGHT", 256usize);
        let assets_root = std::env::var("SVC_EDGE_ASSETS_DIR").unwrap_or_else(|_| "assets".into());

        Ok(Self {
            bind_addr: parse_addr(bind_addr)?,
            metrics_addr: parse_addr(metrics_addr)?,
            security: SecurityCfg { amnesia },
            admission: AdmissionCfg {
                timeout_ms,
                max_inflight,
            },
            assets: AssetsCfg {
                root: PathBuf::from(assets_root),
            },
        })
    }
}

/// Parse a `SocketAddr` from a string.
fn parse_addr(s: String) -> anyhow::Result<SocketAddr> {
    Ok(SocketAddr::from_str(&s)?)
}

/// Parse an environment variable into a type implementing `FromStr`,
/// falling back to `default` on absence or parse failure.
fn env_parse<T: FromStr>(key: &str, default: T) -> T {
    match std::env::var(key) {
        Ok(v) => v.parse().unwrap_or(default),
        Err(_) => default,
    }
}

/// Parse an environment boolean with common truthy/falsey values
/// (e.g., `1/0`, `true/false`, `yes/no`, `on/off`).
fn env_parse_bool(key: &str, default: bool) -> bool {
    match std::env::var(key) {
        Ok(v) => match v.as_str() {
            "1" | "true" | "TRUE" | "yes" | "on" => true,
            "0" | "false" | "FALSE" | "no" | "off" => false,
            _ => default,
        },
        Err(_) => default,
    }
}

```

### crates/svc-edge/src/errors.rs
<a id="crates-svc-edge-src-errors-rs"></a>

```rust
//! Error taxonomy → deterministic HTTP mapping (reserved for later endpoints).

use thiserror::Error;

/// Edge service error kinds used to categorize failures.
///
/// Mapping to HTTP status codes happens in the route layer.
#[derive(Debug, Error)]
pub enum EdgeError {
    /// Service is not yet ready to serve the requested operation.
    #[error("not ready: {0}")]
    NotReady(&'static str),

    /// The request was rejected by rate limiting or admission controls.
    #[error("rate limited")]
    RateLimited,

    /// The request was malformed or violated input constraints.
    #[error("bad request: {0}")]
    BadRequest(&'static str),

    /// An unexpected internal error occurred.
    #[error("internal error")]
    Internal,
}

impl EdgeError {
    /// Short machine-readable reason tag (for logs/metrics labels).
    pub fn reason(&self) -> &'static str {
        match self {
            EdgeError::NotReady(_) => "not_ready",
            EdgeError::RateLimited => "rate_limit",
            EdgeError::BadRequest(_) => "bad_request",
            EdgeError::Internal => "internal",
        }
    }
}

```

### crates/svc-edge/src/http/etag.rs
<a id="crates-svc-edge-src-http-etag-rs"></a>

```rust
//! ETag helpers (opaque ETag strings) — stub.

/// Strong ETag wrapper (opaque).
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ETag(pub String);

impl ETag {
    /// Format as a strong ETag: `"value"`.
    pub fn strong(value: impl AsRef<str>) -> Self {
        Self(format!("\"{}\"", value.as_ref()))
    }
}

```

### crates/svc-edge/src/http/headers.rs
<a id="crates-svc-edge-src-http-headers-rs"></a>

```rust
//! HTTP helper utilities — header names and helpers (stub).

/// Common constant header names (subset, placeholders).
pub mod names {
    /// `ETag`
    pub const ETAG: &str = "ETag";
    /// `If-None-Match`
    pub const IF_NONE_MATCH: &str = "If-None-Match";
    /// `Accept-Ranges`
    pub const ACCEPT_RANGES: &str = "Accept-Ranges";
}

```

### crates/svc-edge/src/http/range.rs
<a id="crates-svc-edge-src-http-range-rs"></a>

```rust
//! HTTP range parsing primitives (single-range only) — stub.

/// Single byte range (inclusive start, inclusive end).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ByteRange {
    /// Start offset.
    pub start: u64,
    /// End offset (inclusive).
    pub end: u64,
}

impl ByteRange {
    /// Length of the range in bytes, saturating.
    pub fn len(&self) -> u64 {
        self.end.saturating_sub(self.start) + 1
    }
}

```

### crates/svc-edge/src/lib.rs
<a id="crates-svc-edge-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]
#![deny(missing_docs, clippy::all, clippy::pedantic)]
//! svc-edge — stateless edge service (admin + api scaffold).
//!
//! RO:WHAT
//! - Minimal library surface that re-exports kernel facilities used by the binary.
//! - Admission middleware, config, metrics, readiness, and routes are exposed for tests.
//!
//! RO:WHY
//! - Keep compile surface tiny so we can add features incrementally.
//!
//! RO:INVARIANTS
//! - Admin plane is always available: /metrics, /healthz, /readyz.
//! - Readiness is degrade-first until gates flip ready.
//! - `AppState` is `Clone + Send + Sync + 'static` so routers can use `into_make_service()`
//!   cleanly under Axum 0.7.

/// Command-line parsing and process flags.
pub mod cli;

/// Runtime configuration parsing/validation.
pub mod config;

/// Service-local error types.
pub mod errors;

/// Prometheus metrics (edge_* counters/histograms).
pub mod metrics;

/// Readiness gates and handler.
pub mod readiness;

/// HTTP route handlers (admin + API).
pub mod routes;

/// Shared application state (must be Clone + Send + Sync).
pub mod state;

/// Admission chain (ingress guards applied to API router).
pub mod admission;

// Re-export kernel helpers used by the bin.
pub use ron_kernel::{wait_for_ctrl_c, HealthState};

/// Public convenience re-exports for the binary and integration tests.
pub use config::Config;
pub use metrics::EdgeMetrics;
pub use state::AppState;

```

### crates/svc-edge/src/metrics.rs
<a id="crates-svc-edge-src-metrics-rs"></a>

```rust
//! Edge metrics (Prometheus).
//!
//! RO:WHAT
//! - Default-registry counters/histograms so we can tick from anywhere.
//! - Request accounting: requests_total{route,method,status}
//! - Rejects: edge_rejects_total{reason}
//! - Latency: edge_request_latency_seconds_bucket{route,method}
//! - Amnesia posture gauge.
//!
//! RO:USAGE
//! - In handlers: call `record_request(route, method, status, secs)`.
//! - In admission rejections: `inc_reject(reason)`.
//! - At startup: `seed_from_health(..., amnesia)`.

use once_cell::sync::Lazy;
use prometheus::{
    opts, register_histogram_vec, register_int_counter_vec, register_int_gauge, Encoder, HistogramVec,
    IntCounterVec, IntGauge, TextEncoder,
};
use std::time::Duration;

use crate::HealthState;

static HTTP_REQS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        opts!("edge_requests_total", "HTTP requests by route/method/status"),
        &["route", "method", "status"]
    )
    .unwrap()
});

static HTTP_LATENCY: Lazy<HistogramVec> = Lazy::new(|| {
    // 1ms..10s range buckets (prometheus default-ish).
    register_histogram_vec!(
        "edge_request_latency_seconds",
        "Request latency seconds by route/method",
        &["route", "method"],
        vec![
            0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0, 10.0
        ]
    )
    .unwrap()
});

static REJECTS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        opts!("edge_rejects_total", "Admission rejects"),
        &["reason"]
    )
    .unwrap()
});

static AMNESIA: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(opts!("amnesia_mode", "Amnesia posture (1/0)")).unwrap()
});

/// Thin handle for metrics (future: attach more state here if needed).
#[derive(Clone, Debug)]
pub struct EdgeMetrics;

impl EdgeMetrics {
    /// Create and register all edge metrics in the default Prometheus registry.
    ///
    /// Touches each static to ensure registration has occurred before use.
    pub fn new() -> Self {
        let _ = &*HTTP_REQS;
        let _ = &*HTTP_LATENCY;
        let _ = &*REJECTS;
        let _ = &*AMNESIA;
        Self
    }
}

/// Seed gauges derived from initial health/config (currently just amnesia).
///
/// Call once at startup, after `EdgeMetrics::new()`.
pub fn seed_from_health(
    _health: std::sync::Arc<HealthState>,
    _metrics: &EdgeMetrics,
    amnesia: bool,
) {
    AMNESIA.set(if amnesia { 1 } else { 0 });
}

/// Record a single HTTP request outcome (increments counters and observes latency).
///
/// * `route`  — stable route label (e.g., `"/edge/assets/*path"`).
/// * `method` — HTTP method (e.g., `"GET"`, `"POST"`).
/// * `status` — final HTTP status code (e.g., `200`, `503`).
/// * `dur`    — wall time spent handling the request.
pub fn record_request(route: &str, method: &str, status: u16, dur: Duration) {
    HTTP_REQS
        .with_label_values(&[route, method, &status.to_string()])
        .inc();
    HTTP_LATENCY
        .with_label_values(&[route, method])
        .observe(dur.as_secs_f64());
}

/// Increment a reject counter for an admission-layer decision (e.g., `"timeout"`, `"busy"`).
pub fn inc_reject(reason: &str) {
    REJECTS.with_label_values(&[reason]).inc();
}

/// Render the Prometheus exposition text for `/metrics` (default registry).
///
/// This helper is used by the HTTP handler to return the encoded metrics body.
pub fn render() -> (axum::http::StatusCode, String) {
    let metric_families = prometheus::gather();
    let mut buf = Vec::new();
    let encoder = TextEncoder::new();
    encoder.encode(&metric_families, &mut buf).unwrap();
    (
        axum::http::StatusCode::OK,
        String::from_utf8(buf).unwrap_or_default(),
    )
}

```

### crates/svc-edge/src/readiness.rs
<a id="crates-svc-edge-src-readiness-rs"></a>

```rust
//! /readyz handler: degrade-first semantics with reasons payload.

use crate::state::AppState;
use axum::{extract::State, http::StatusCode, response::IntoResponse, Json};
use http::{header, HeaderValue};
use serde::Serialize;

/// JSON payload returned by `/readyz`.
#[derive(Serialize)]
struct ReadyPayload {
    /// Whether the service is ready to serve traffic.
    ready: bool,
    /// Missing gates/conditions preventing readiness.
    missing: Vec<String>,
}

/// Report readiness based on `HealthState` keyed flags.
///
/// Current policy: ready when `services_ok` and `config_loaded` are true.
/// Returns 503 with `Retry-After: 1` when not ready.
pub async fn readiness_handler(State(state): State<AppState>) -> impl IntoResponse {
    // HealthState::snapshot() returns a BTreeMap<&str,bool> in this project.
    let snapshot = state.health.snapshot();
    let services_ok = *snapshot.get("services_ok").unwrap_or(&false);
    let config_loaded = *snapshot.get("config_loaded").unwrap_or(&false);

    if services_ok && config_loaded {
        return (StatusCode::OK, Json(ReadyPayload { ready: true, missing: vec![] }))
            .into_response();
    }

    let mut missing = Vec::new();
    if !services_ok {
        missing.push("services_ok".to_string());
    }
    if !config_loaded {
        missing.push("config_loaded".to_string());
    }

    let payload = ReadyPayload { ready: false, missing };
    let mut res = (StatusCode::SERVICE_UNAVAILABLE, Json(payload)).into_response();
    res.headers_mut()
        .insert(header::RETRY_AFTER, HeaderValue::from_static("1"));
    res
}

```

### crates/svc-edge/src/routes/assets.rs
<a id="crates-svc-edge-src-routes-assets-rs"></a>

```rust
//! Edge surface routes.
//!
//! RO:WHAT
//! - `/echo` — counts request body bytes; returns `{ ok, len }`.
//! - `/echo/slow/:ms` — sleeps `ms` milliseconds, then echoes length.
//! - `GET /edge/assets/*path` — serve file from assets dir with ETag/Range.
//! - `GET /cas/:algo/:digest` — minimal CAS fetch (blake3 only), ETag/Range.
//!
//! RO:WHY
//! - Echo routes exercise admission guards.
//! - Assets/CAS scaffold the beta surface (packs/CAS later).
//!
//! RO:HTTP
//! - Strong ETag = BLAKE3(content).
//! - Honor `If-None-Match` → 304 when tag matches.
//! - Support a single range `bytes=start-` → 206; else 200.
//! - Always emit `Accept-Ranges: bytes`.
//!
//! RO:SECURITY
//! - Test-only surface; no auth. Keep payloads small.
//! - Path normalization protects against traversal.
//!
//! RO:METRICS
//! - Record `edge_requests_total` and `edge_request_latency_seconds` per route.

use std::{fs, io, path::PathBuf, time::{Duration, Instant}};

use axum::{
    body::Bytes,
    extract::{Path, State},
    http::{
        header::{ACCEPT_RANGES, CONTENT_LENGTH, CONTENT_RANGE, CONTENT_TYPE, ETAG, IF_NONE_MATCH, RANGE},
        HeaderMap, HeaderValue, StatusCode,
    },
    response::{IntoResponse, Response},
    Json,
};
use blake3::Hasher;
use mime_guess::mime;
use percent_encoding::percent_decode_str;
use serde::Serialize;
use tracing::warn;

use crate::{metrics, AppState};

// ---------- Echo test endpoints ----------

#[derive(Serialize)]
struct EchoResp {
    ok: bool,
    len: usize,
}

/// POST /echo
pub async fn echo(body: Bytes) -> impl IntoResponse {
    let t0 = Instant::now();
    let out = Json(EchoResp { ok: true, len: body.len() });
    metrics::record_request("echo", "POST", 200, t0.elapsed());
    out
}

/// POST /echo/slow/:ms
pub async fn echo_slow(Path(ms): Path<u64>, body: Bytes) -> impl IntoResponse {
    let t0 = Instant::now();
    if ms > 0 {
        tokio::time::sleep(Duration::from_millis(ms)).await;
    }
    let out = Json(EchoResp { ok: true, len: body.len() });
    metrics::record_request("echo_slow", "POST", 200, t0.elapsed());
    out
}

// ---------- Assets (filesystem scaffold) ----------

/// GET /edge/assets/*path
pub async fn get_asset(
    State(_state): State<AppState>,
    Path(path): Path<String>,
    headers: HeaderMap,
) -> Response {
    let t0 = Instant::now();

    // Resolve root from env (temp) — will come from Config later if not already.
    let root = std::env::var("SVC_EDGE_ASSETS_DIR").unwrap_or_else(|_| "assets".to_string());

    let resp = match resolve_and_read(&root, &path) {
        Ok(file) => reply_with_etag_range(file, &headers),
        Err(e) => map_fs_err(e),
    };

    metrics::record_request("edge_assets", "GET", resp.status().as_u16(), t0.elapsed());
    resp
}

// ---------- CAS (simple blake3 filesystem scaffold) ----------

/// GET /cas/:algo/:digest
///
/// Only supports algo=blake3 for now. Looks under assets/cas/blake3/{digest}
pub async fn get_cas(
    State(_state): State<AppState>,
    Path((algo, digest)): Path<(String, String)>,
    headers: HeaderMap,
) -> Response {
    let t0 = Instant::now();

    let resp = if algo != "blake3" {
        (StatusCode::BAD_REQUEST, "unsupported algo").into_response()
    } else {
        let root = std::env::var("SVC_EDGE_ASSETS_DIR").unwrap_or_else(|_| "assets".to_string());
        let mut p = PathBuf::from(root);
        p.push("cas");
        p.push("blake3");
        p.push(sanitize_component(&digest));

        match read_file(&p) {
            Ok(file) => reply_with_etag_range(file, &headers),
            Err(e) => map_fs_err(e),
        }
    };

    metrics::record_request("cas_get", "GET", resp.status().as_u16(), t0.elapsed());
    resp
}

// ---------- Helpers ----------

struct LoadedFile {
    bytes: Vec<u8>,
    etag: String, // blake3 hex
    mime: String,
}

fn resolve_and_read(root: &str, raw_path: &str) -> io::Result<LoadedFile> {
    // Decode URL components and prevent path traversal.
    let decoded = percent_decode_str(raw_path).decode_utf8_lossy();
    let safe = decoded.trim_start_matches('/');
    let safe = sanitize_path(safe);

    let mut p = PathBuf::from(root);
    p.push(safe);

    read_file(&p)
}

fn read_file(p: &PathBuf) -> io::Result<LoadedFile> {
    let data = fs::read(p)?;
    let mut hasher = Hasher::new();
    hasher.update(&data);
    let etag = hasher.finalize().to_hex().to_string();

    // Very simple content-type detection.
    let mime = mime_guess::from_path(p)
        .first_or(mime::APPLICATION_OCTET_STREAM)
        .essence_str()
        .to_string();

    Ok(LoadedFile { bytes: data, etag, mime })
}

fn reply_with_etag_range(file: LoadedFile, headers: &HeaderMap) -> Response {
    // If-None-Match
    if let Some(tag) = headers.get(IF_NONE_MATCH).and_then(|v| v.to_str().ok()) {
        if tag.trim_matches('"') == file.etag {
            return (
                StatusCode::NOT_MODIFIED,
                [(ETAG, quoted(&file.etag)), (ACCEPT_RANGES, HeaderValue::from_static("bytes"))],
            )
                .into_response();
        }
    }

    // Range: only support "bytes=start-"
    let total = file.bytes.len() as u64;
    if let Some(range) = headers.get(RANGE).and_then(|v| v.to_str().ok()) {
        if let Some(start) = parse_range_start(range) {
            if start >= total {
                // 416 Range Not Satisfiable
                let cr = format!("bytes */{}", total);
                return (
                    StatusCode::RANGE_NOT_SATISFIABLE,
                    [
                        (ACCEPT_RANGES, HeaderValue::from_static("bytes")),
                        (CONTENT_RANGE, HeaderValue::from_str(&cr).unwrap()),
                        (ETAG, quoted(&file.etag)),
                    ],
                )
                    .into_response();
            }
            let slice = &file.bytes[start as usize..];
            let len = slice.len() as u64;
            let cr = format!("bytes {}-{}/{}", start, start + len - 1, total);
            return (
                StatusCode::PARTIAL_CONTENT,
                [
                    (ACCEPT_RANGES, HeaderValue::from_static("bytes")),
                    (CONTENT_TYPE, HeaderValue::from_str(&file.mime).unwrap()),
                    (CONTENT_LENGTH, HeaderValue::from_str(&len.to_string()).unwrap()),
                    (CONTENT_RANGE, HeaderValue::from_str(&cr).unwrap()),
                    (ETAG, quoted(&file.etag)),
                ],
                slice.to_vec(),
            )
                .into_response();
        }
    }

    // 200 OK full
    (
        StatusCode::OK,
        [
            (ACCEPT_RANGES, HeaderValue::from_static("bytes")),
            (CONTENT_TYPE, HeaderValue::from_str(&file.mime).unwrap()),
            (
                CONTENT_LENGTH,
                HeaderValue::from_str(&file.bytes.len().to_string()).unwrap(),
            ),
            (ETAG, quoted(&file.etag)),
        ],
        file.bytes,
    )
        .into_response()
}

fn parse_range_start(range: &str) -> Option<u64> {
    // Accept "bytes=START-" only.
    let s = range.trim();
    if !s.starts_with("bytes=") || !s.ends_with('-') {
        return None;
    }
    let inner = &s[6..s.len() - 1]; // drop "bytes=" and trailing '-'
    inner.parse::<u64>().ok()
}

fn quoted(s: &str) -> HeaderValue {
    HeaderValue::from_str(&format!("\"{}\"", s)).unwrap()
}

fn sanitize_path(p: &str) -> String {
    // Simple traversal prevention: strip .. and normalize separators.
    let parts: Vec<_> = p
        .split('/')
        .filter(|seg| !seg.is_empty() && *seg != "." && *seg != "..")
        .collect();
    parts.join("/")
}

fn sanitize_component(c: &str) -> String {
    // Allow only hex-ish tokens for digests.
    let filtered: String = c.chars().filter(|ch| ch.is_ascii_hexdigit()).collect();
    if filtered.is_empty() {
        // fallback to avoid empty path
        "invalid".to_string()
    } else {
        filtered
    }
}

fn map_fs_err(e: io::Error) -> Response {
    match e.kind() {
        io::ErrorKind::NotFound => (StatusCode::NOT_FOUND, "not found").into_response(),
        io::ErrorKind::PermissionDenied => (StatusCode::FORBIDDEN, "forbidden").into_response(),
        _ => {
            warn!("asset error: {e:?}");
            (StatusCode::INTERNAL_SERVER_ERROR, "error").into_response()
        }
    }
}

```

### crates/svc-edge/src/routes/health.rs
<a id="crates-svc-edge-src-routes-health-rs"></a>

```rust
//! /healthz — liveness endpoint.

use axum::response::IntoResponse;
use http::StatusCode;

/// Liveness probe.
///
/// Returns `200 OK` unconditionally if the process is alive.
pub async fn healthz() -> impl IntoResponse {
    StatusCode::OK
}

```

### crates/svc-edge/src/routes/mod.rs
<a id="crates-svc-edge-src-routes-mod-rs"></a>

```rust
//! Route modules.

pub mod health;
pub mod prometheus;
pub mod assets; // temp API routes while we wire the stack
// ready route lives in crate::readiness

```

### crates/svc-edge/src/routes/prometheus.rs
<a id="crates-svc-edge-src-routes-prometheus-rs"></a>

```rust
//! /metrics — Prometheus exposition.

use crate::state::AppState;
use axum::{extract::State, response::IntoResponse};
use http::{header, HeaderValue, StatusCode};
use prometheus::{Encoder, TextEncoder};

/// Render the Prometheus metrics exposition format from the default registry.
pub async fn metrics(State(_state): State<AppState>) -> impl IntoResponse {
    let metric_families = prometheus::gather();
    let encoder = TextEncoder::new();

    let mut buf = Vec::new();
    if let Err(_e) = encoder.encode(&metric_families, &mut buf) {
        // Conservative fallback: don't leak internals; keep content-type text/plain.
        let mut res = (StatusCode::INTERNAL_SERVER_ERROR, "metrics encode error\n").into_response();
        res.headers_mut()
            .insert(header::CONTENT_TYPE, HeaderValue::from_static("text/plain; charset=utf-8"));
        return res;
    }

    let body = String::from_utf8(buf).unwrap_or_default();

    let mut res = (StatusCode::OK, body).into_response();
    res.headers_mut()
        .insert(header::CONTENT_TYPE, HeaderValue::from_static("text/plain; version=0.0.4"));
    res
}

```

### crates/svc-edge/src/routes/ready.rs
<a id="crates-svc-edge-src-routes-ready-rs"></a>

```rust

```

### crates/svc-edge/src/security/audit.rs
<a id="crates-svc-edge-src-security-audit-rs"></a>

```rust
//! Security audit trail placeholder (stub).

/// Minimal audit event (placeholder).
#[derive(Debug, Clone)]
pub struct AuditEvent {
    /// Category (e.g., "admission", "security", "policy").
    pub category: String,
    /// Short message.
    pub message: String,
}

/// Audit sink (no-op).
#[derive(Debug, Default, Clone)]
pub struct Auditor;

impl Auditor {
    /// Record an audit event (no-op).
    pub fn record(&self, _evt: AuditEvent) {
        // Future: write to structured log / metrics.
    }
}

```

### crates/svc-edge/src/security/cors.rs
<a id="crates-svc-edge-src-security-cors-rs"></a>

```rust
//! CORS policy placeholder (stub).

/// CORS posture (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum Cors {
    /// Deny all cross-origin requests.
    Deny,
    /// Allow a restricted set (details TBD).
    Restricted,
}

impl Default for Cors {
    fn default() -> Self {
        Cors::Deny
    }
}

```

### crates/svc-edge/src/security/hsts.rs
<a id="crates-svc-edge-src-security-hsts-rs"></a>

```rust
//! HSTS policy placeholder (stub).

/// HSTS posture (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum Hsts {
    /// Disabled.
    Off,
    /// Enabled with defaults (details TBD).
    On,
}

impl Default for Hsts {
    fn default() -> Self {
        Hsts::Off
    }
}

```

### crates/svc-edge/src/state.rs
<a id="crates-svc-edge-src-state-rs"></a>

```rust
//! Process-wide shared state for svc-edge.
//
// RO:WHAT
// - Holds immutable runtime config, metrics handle, and health gate.
// - Must be `Clone + Send + Sync + 'static` to satisfy axum 0.7 router state bounds.
//
// RO:INVARIANTS
// - No interior mutability hidden here; mutable bits live behind explicit APIs
//   (metrics handles, health gates) or are wrapped in Arcs.

use std::sync::Arc;

use crate::{Config, EdgeMetrics, HealthState};

/// Application state shared across axum handlers.
///
/// This type **must** be `Clone + Send + Sync + 'static` so that
/// `Router<AppState>::into_make_service()` is available in axum 0.7.
#[derive(Clone)]
pub struct AppState {
    /// Effective runtime configuration (immutable at runtime).
    pub cfg: Arc<Config>,
    /// Metrics handle (counters/histograms are internally synchronized).
    pub metrics: EdgeMetrics,
    /// Process health/readiness gates.
    pub health: Arc<HealthState>,
}

impl AppState {
    /// Construct a new [`AppState`].
    ///
    /// The `cfg` is wrapped into an `Arc` to make cloning cheap and to satisfy
    /// axum's `Clone + Send + Sync + 'static` bounds for router state.
    pub fn new(cfg: Config, metrics: EdgeMetrics, health: Arc<HealthState>) -> Self {
        Self {
            cfg: Arc::new(cfg),
            metrics,
            health,
        }
    }
}

```

### crates/svc-edge/src/supervisor.rs
<a id="crates-svc-edge-src-supervisor-rs"></a>

```rust
//! Process supervisor scaffold for svc-edge.
//!
//! RO:WHAT
//! - Placeholder for listener/task lifecycle management and orderly shutdown.
//!
//! RO:NEXT
//! - Add accept loops, task JoinHandles, and a `cancel()` to request drain.

/// No-op supervisor placeholder.
#[derive(Debug, Clone, Default)]
pub struct Supervisor;

impl Supervisor {
    /// Create a new no-op supervisor.
    pub fn new() -> Self {
        Self
    }
    /// Request shutdown (no-op for now).
    pub async fn shutdown(&self) {
        // Future: signal tasks and await joins with a timeout.
    }
}

```

### crates/svc-edge/src/util/backoff.rs
<a id="crates-svc-edge-src-util-backoff-rs"></a>

```rust
//! Simple exponential backoff calculator (stub).

use std::time::Duration;

/// Exponential backoff parameters (placeholder).
#[derive(Debug, Clone, Copy)]
pub struct Backoff {
    /// Base delay.
    pub base: Duration,
    /// Maximum delay.
    pub max: Duration,
    /// Multiplier per attempt.
    pub factor: f64,
}

impl Default for Backoff {
    fn default() -> Self {
        Self {
            base: Duration::from_millis(10),
            max: Duration::from_secs(2),
            factor: 2.0,
        }
    }
}

impl Backoff {
    /// Compute delay for `attempt` (0-based).
    pub fn delay(&self, attempt: u32) -> Duration {
        let ms = (self.base.as_millis() as f64) * self.factor.powi(attempt as i32);
        let d = Duration::from_millis(ms as u64);
        if d > self.max { self.max } else { d }
    }
}

```

### crates/svc-edge/src/util/bytes.rs
<a id="crates-svc-edge-src-util-bytes-rs"></a>

```rust
//! Byte utilities (stub).

/// Clamp `n` to `max`.
pub fn clamp_len(n: usize, max: usize) -> usize {
    if n > max { max } else { n }
}

```

### crates/svc-edge/src/util/size_parse.rs
<a id="crates-svc-edge-src-util-sizeparse-rs"></a>

```rust
//! Parse human-readable sizes like "64k", "10MiB" (stub).
//!
//! Accepted suffixes (case-insensitive; decimal only for now):
//! - k, m, g, t  → 10^3 steps.

/// Parse a simple size string. Returns bytes on success.
///
/// Examples: "0", "64k", "10m". Binary units and MiB/GiB will arrive later.
pub fn parse_decimal_size(s: &str) -> Option<u64> {
    let s = s.trim();
    if s.is_empty() {
        return None;
    }
    let (num, suf) = s.split_at(s.find(|c: char| !c.is_ascii_digit()).unwrap_or(s.len()));
    let mut n: u64 = num.parse().ok()?;
    let suffix = suf.trim().to_ascii_lowercase();
    n *= match suffix.as_str() {
        "" => 1,
        "k" => 1_000,
        "m" => 1_000_000,
        "g" => 1_000_000_000,
        "t" => 1_000_000_000_000,
        _ => return None,
    };
    Some(n)
}

```

### crates/svc-edge/src/work/queue.rs
<a id="crates-svc-edge-src-work-queue-rs"></a>

```rust
//! Work queue placeholder (bounded, no implementation yet).

/// Opaque job type (placeholder).
#[derive(Debug, Clone)]
pub struct Job {
    /// Human-readable label for diagnostics.
    pub label: String,
}

/// Bounded work queue (stub).
#[derive(Debug, Default)]
pub struct WorkQueue;

impl WorkQueue {
    /// Construct a new, empty work queue.
    pub fn new() -> Self {
        Self
    }
    /// Enqueue a job (no-op).
    pub fn push(&self, _job: Job) -> bool {
        false
    }
}

```

### crates/svc-edge/src/work/shutdown.rs
<a id="crates-svc-edge-src-work-shutdown-rs"></a>

```rust
//! Cooperative shutdown helpers (stub).

/// A cooperative shutdown token (stub).
#[derive(Debug, Clone, Default)]
pub struct ShutdownToken {
    /// Whether shutdown was requested.
    pub requested: bool,
}

impl ShutdownToken {
    /// Request shutdown (no-op).
    pub fn request(&mut self) {
        self.requested = true;
    }
    /// Check whether shutdown was requested.
    pub fn is_requested(&self) -> bool {
        self.requested
    }
}

```

### crates/svc-edge/src/work/worker.rs
<a id="crates-svc-edge-src-work-worker-rs"></a>

```rust
//! Worker placeholder for background tasks (stub).

use super::queue::WorkQueue;

/// Simple worker (no behavior yet).
#[derive(Debug, Default)]
pub struct Worker;

impl Worker {
    /// Run a no-op worker loop (immediate return for now).
    pub async fn run(&self, _queue: WorkQueue) {
        // Future: read jobs; process; record metrics; respect shutdown.
    }
}

```

### crates/svc-edge/tests/concurrency_backpressure.rs
<a id="crates-svc-edge-tests-concurrencybackpressure-rs"></a>

```rust

```

### crates/svc-edge/tests/fuzz_headers.rs
<a id="crates-svc-edge-tests-fuzzheaders-rs"></a>

```rust

```

### crates/svc-edge/tests/http_contract.rs
<a id="crates-svc-edge-tests-httpcontract-rs"></a>

```rust

```

### crates/svc-edge/tests/i_10_deterministic_failures.rs
<a id="crates-svc-edge-tests-i10deterministicfailures-rs"></a>

```rust

```

### crates/svc-edge/tests/i_11_pack_integrity.rs
<a id="crates-svc-edge-tests-i11packintegrity-rs"></a>

```rust

```

### crates/svc-edge/tests/i_1_hardening_ingress.rs
<a id="crates-svc-edge-tests-i1hardeningingress-rs"></a>

```rust

```

### crates/svc-edge/tests/i_4_http_semantics.rs
<a id="crates-svc-edge-tests-i4httpsemantics-rs"></a>

```rust

```

### crates/svc-edge/tests/i_5_content_address.rs
<a id="crates-svc-edge-tests-i5contentaddress-rs"></a>

```rust

```

### crates/svc-edge/tests/i_6_amnesia.rs
<a id="crates-svc-edge-tests-i6amnesia-rs"></a>

```rust

```

### crates/svc-edge/tests/i_8_size_bounds.rs
<a id="crates-svc-edge-tests-i8sizebounds-rs"></a>

```rust

```

### crates/svc-edge/tests/i_9_observability_contract.rs
<a id="crates-svc-edge-tests-i9observabilitycontract-rs"></a>

```rust

```

### crates/svc-edge/tests/readiness_logic.rs
<a id="crates-svc-edge-tests-readinesslogic-rs"></a>

```rust

```

