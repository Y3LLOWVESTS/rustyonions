<!-- Generated by scripts/make_crate_codex.sh on 2025-11-11T00:37:49Z -->
# Code Bundle — `svc-edge`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-edge/.cargo/config.toml](#crates-svc-edge--cargo-config-toml)
- [crates/svc-edge/.github/workflows/ci.yaml](#crates-svc-edge--github-workflows-ci-yaml)
- [crates/svc-edge/.github/workflows/perf-guard.yaml](#crates-svc-edge--github-workflows-perf-guard-yaml)
- [crates/svc-edge/.github/workflows/public-api.yaml](#crates-svc-edge--github-workflows-public-api-yaml)
- [crates/svc-edge/.github/workflows/render-mermaid.yaml](#crates-svc-edge--github-workflows-render-mermaid-yaml)
- [crates/svc-edge/Cargo.toml](#crates-svc-edge-Cargo-toml)
- [crates/svc-edge/benches/bench_blake3.rs](#crates-svc-edge-benches-benchblake3-rs)
- [crates/svc-edge/benches/bench_pack_read.rs](#crates-svc-edge-benches-benchpackread-rs)
- [crates/svc-edge/benches/bench_range.rs](#crates-svc-edge-benches-benchrange-rs)
- [crates/svc-edge/configs/svc-edge.toml](#crates-svc-edge-configs-svc-edge-toml)
- [crates/svc-edge/scripts/dev-run.sh](#crates-svc-edge-scripts-dev-run-sh)
- [crates/svc-edge/scripts/perf-smoke.sh](#crates-svc-edge-scripts-perf-smoke-sh)
- [crates/svc-edge/scripts/render-mermaid.sh](#crates-svc-edge-scripts-render-mermaid-sh)
- [crates/svc-edge/src/adapters/cas.rs](#crates-svc-edge-src-adapters-cas-rs)
- [crates/svc-edge/src/adapters/live_fill.rs](#crates-svc-edge-src-adapters-livefill-rs)
- [crates/svc-edge/src/adapters/pack.rs](#crates-svc-edge-src-adapters-pack-rs)
- [crates/svc-edge/src/adapters/tls.rs](#crates-svc-edge-src-adapters-tls-rs)
- [crates/svc-edge/src/admission/body_cap.rs](#crates-svc-edge-src-admission-bodycap-rs)
- [crates/svc-edge/src/admission/decompress_guard.rs](#crates-svc-edge-src-admission-decompressguard-rs)
- [crates/svc-edge/src/admission/inflight_cap.rs](#crates-svc-edge-src-admission-inflightcap-rs)
- [crates/svc-edge/src/admission/mod.rs](#crates-svc-edge-src-admission-mod-rs)
- [crates/svc-edge/src/admission/rps_limit.rs](#crates-svc-edge-src-admission-rpslimit-rs)
- [crates/svc-edge/src/admission/timeout.rs](#crates-svc-edge-src-admission-timeout-rs)
- [crates/svc-edge/src/bin/svc-edge.rs](#crates-svc-edge-src-bin-svc-edge-rs)
- [crates/svc-edge/src/cli.rs](#crates-svc-edge-src-cli-rs)
- [crates/svc-edge/src/config.rs](#crates-svc-edge-src-config-rs)
- [crates/svc-edge/src/errors.rs](#crates-svc-edge-src-errors-rs)
- [crates/svc-edge/src/http/etag.rs](#crates-svc-edge-src-http-etag-rs)
- [crates/svc-edge/src/http/headers.rs](#crates-svc-edge-src-http-headers-rs)
- [crates/svc-edge/src/http/range.rs](#crates-svc-edge-src-http-range-rs)
- [crates/svc-edge/src/lib.rs](#crates-svc-edge-src-lib-rs)
- [crates/svc-edge/src/metrics.rs](#crates-svc-edge-src-metrics-rs)
- [crates/svc-edge/src/readiness.rs](#crates-svc-edge-src-readiness-rs)
- [crates/svc-edge/src/routes/assets.rs](#crates-svc-edge-src-routes-assets-rs)
- [crates/svc-edge/src/routes/health.rs](#crates-svc-edge-src-routes-health-rs)
- [crates/svc-edge/src/routes/mod.rs](#crates-svc-edge-src-routes-mod-rs)
- [crates/svc-edge/src/routes/prometheus.rs](#crates-svc-edge-src-routes-prometheus-rs)
- [crates/svc-edge/src/routes/ready.rs](#crates-svc-edge-src-routes-ready-rs)
- [crates/svc-edge/src/security/audit.rs](#crates-svc-edge-src-security-audit-rs)
- [crates/svc-edge/src/security/cors.rs](#crates-svc-edge-src-security-cors-rs)
- [crates/svc-edge/src/security/hsts.rs](#crates-svc-edge-src-security-hsts-rs)
- [crates/svc-edge/src/state.rs](#crates-svc-edge-src-state-rs)
- [crates/svc-edge/src/supervisor.rs](#crates-svc-edge-src-supervisor-rs)
- [crates/svc-edge/src/util/backoff.rs](#crates-svc-edge-src-util-backoff-rs)
- [crates/svc-edge/src/util/bytes.rs](#crates-svc-edge-src-util-bytes-rs)
- [crates/svc-edge/src/util/size_parse.rs](#crates-svc-edge-src-util-sizeparse-rs)
- [crates/svc-edge/src/work/queue.rs](#crates-svc-edge-src-work-queue-rs)
- [crates/svc-edge/src/work/shutdown.rs](#crates-svc-edge-src-work-shutdown-rs)
- [crates/svc-edge/src/work/worker.rs](#crates-svc-edge-src-work-worker-rs)
- [crates/svc-edge/tests/concurrency_backpressure.rs](#crates-svc-edge-tests-concurrencybackpressure-rs)
- [crates/svc-edge/tests/fuzz_headers.rs](#crates-svc-edge-tests-fuzzheaders-rs)
- [crates/svc-edge/tests/http_contract.rs](#crates-svc-edge-tests-httpcontract-rs)
- [crates/svc-edge/tests/i_10_deterministic_failures.rs](#crates-svc-edge-tests-i10deterministicfailures-rs)
- [crates/svc-edge/tests/i_11_pack_integrity.rs](#crates-svc-edge-tests-i11packintegrity-rs)
- [crates/svc-edge/tests/i_1_hardening_ingress.rs](#crates-svc-edge-tests-i1hardeningingress-rs)
- [crates/svc-edge/tests/i_4_http_semantics.rs](#crates-svc-edge-tests-i4httpsemantics-rs)
- [crates/svc-edge/tests/i_5_content_address.rs](#crates-svc-edge-tests-i5contentaddress-rs)
- [crates/svc-edge/tests/i_6_amnesia.rs](#crates-svc-edge-tests-i6amnesia-rs)
- [crates/svc-edge/tests/i_8_size_bounds.rs](#crates-svc-edge-tests-i8sizebounds-rs)
- [crates/svc-edge/tests/i_9_observability_contract.rs](#crates-svc-edge-tests-i9observabilitycontract-rs)
- [crates/svc-edge/tests/readiness_logic.rs](#crates-svc-edge-tests-readinesslogic-rs)

### crates/svc-edge/.cargo/config.toml
<a id="crates-svc-edge--cargo-config-toml"></a>

```toml
[build]
rustflags = ["-Dwarnings"]

[env]
RUST_LOG = "info"

```

### crates/svc-edge/.github/workflows/ci.yaml
<a id="crates-svc-edge--github-workflows-ci-yaml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  rust:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo fmt --all --check
      - run: cargo clippy -p svc-edge2 -- -D warnings
      - run: cargo test -p svc-edge2

```

### crates/svc-edge/.github/workflows/perf-guard.yaml
<a id="crates-svc-edge--github-workflows-perf-guard-yaml"></a>

```yaml
name: perf-guard
on:
  schedule:
    - cron: '0 3 * * *'
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'perf guard placeholder'

```

### crates/svc-edge/.github/workflows/public-api.yaml
<a id="crates-svc-edge--github-workflows-public-api-yaml"></a>

```yaml
name: public-api
on: [push, pull_request]
jobs:
  api:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo install cargo-public-api || true
      - run: cargo public-api -p svc-edge2

```

### crates/svc-edge/.github/workflows/render-mermaid.yaml
<a id="crates-svc-edge--github-workflows-render-mermaid-yaml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: bash crates/svc-edge2/scripts/render-mermaid.sh

```

### crates/svc-edge/Cargo.toml
<a id="crates-svc-edge-Cargo-toml"></a>

```toml
[package]
name = "svc-edge"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[features]
default = ["cli"]
cli = ["dep:clap"]
tls = ["dep:tokio-rustls"]
pq = []
otel = []

[dependencies]
anyhow = { workspace = true, features = ["std"] }
axum = { workspace = true, features = ["tokio","http1","http2","json"] }
clap = { version = "4", features = ["derive"], optional = true }
http = { workspace = true }
hyper = "1"
once_cell = { workspace = true }
parking_lot = { workspace = true }
prometheus = { workspace = true, default-features = false }
serde = { workspace = true }
serde_json = { workspace = true }
thiserror = { workspace = true }
tokio = { workspace = true, features = ["rt-multi-thread","macros","signal","net","time","io-util"] }
tokio-util = { workspace = true }
tokio-rustls = { workspace = true, optional = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true, features = ["fmt","env-filter"] }
toml = { workspace = true }

# IMPORTANT: use workspace Tower pin (0.5.2) and add features needed by admission/
tower = { workspace = true, features = ["util","limit","timeout"] }
# Reuse workspace pin for tower-http and enable the RequestBodyLimit layer
tower-http = { workspace = true, features = ["limit"] }

# project-internal
ron-kernel = { path = "../ron-kernel" }

[dev-dependencies]

```

### crates/svc-edge/benches/bench_blake3.rs
<a id="crates-svc-edge-benches-benchblake3-rs"></a>

```rust

```

### crates/svc-edge/benches/bench_pack_read.rs
<a id="crates-svc-edge-benches-benchpackread-rs"></a>

```rust

```

### crates/svc-edge/benches/bench_range.rs
<a id="crates-svc-edge-benches-benchrange-rs"></a>

```rust

```

### crates/svc-edge/configs/svc-edge.toml
<a id="crates-svc-edge-configs-svc-edge-toml"></a>

```toml
# Minimal runnable config (admin plane only in this increment).
bind_addr = "0.0.0.0:8080"
metrics_addr = "127.0.0.1:9909"

[security]
amnesia = true

```

### crates/svc-edge/scripts/dev-run.sh
<a id="crates-svc-edge-scripts-dev-run-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "${BASH_SOURCE[0]}")/.."
RUST_LOG=${RUST_LOG:-info} \
SVC_EDGE_BIND_ADDR=${SVC_EDGE_BIND_ADDR:-0.0.0.0:8080} \
SVC_EDGE_METRICS_ADDR=${SVC_EDGE_METRICS_ADDR:-127.0.0.1:9909} \
SVC_EDGE_SECURITY__AMNESIA=${SVC_EDGE_SECURITY__AMNESIA:-true} \
cargo run -p svc-edge2 -- \
  --config ./configs/svc-edge.toml

```

### crates/svc-edge/scripts/perf-smoke.sh
<a id="crates-svc-edge-scripts-perf-smoke-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
URL=${1:-http://127.0.0.1:8080/edge/assets/path}
bombardier -c 64 -d 60s -l "$URL"

```

### crates/svc-edge/scripts/render-mermaid.sh
<a id="crates-svc-edge-scripts-render-mermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "${BASH_SOURCE[0]}")/.."
for f in $(git ls-files 'docs/mmd/*.mmd'); do
  out=${f/mmd/svg}
  out=${out%.mmd}.svg
  mkdir -p $(dirname "$out")
  mmdc -i "$f" -o "$out"
done

```

### crates/svc-edge/src/adapters/cas.rs
<a id="crates-svc-edge-src-adapters-cas-rs"></a>

```rust
//! Adapter: content-addressed storage (read-only) — stub.

/// Digest bytes (opaque placeholder).
pub type Digest = [u8; 32];

/// CAS interface (read-only, stubbed).
pub trait CasStore: Send + Sync {
    /// Fetch a blob by digest. Returns `None` if missing.
    fn get(&self, _digest: &Digest) -> Option<Vec<u8>>;
}

/// No-op CAS for early wiring.
#[derive(Debug, Clone, Default)]
pub struct NullCas;

impl CasStore for NullCas {
    fn get(&self, _digest: &Digest) -> Option<Vec<u8>> {
        None
    }
}

```

### crates/svc-edge/src/adapters/live_fill.rs
<a id="crates-svc-edge-src-adapters-livefill-rs"></a>

```rust
//! Adapter: live-fill miss handler (fetch-on-miss) — stub.

use super::cas::{CasStore, Digest};

/// Miss policy for live fill (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum LiveFillPolicy {
    /// Do not attempt live-fill on misses.
    Off,
    /// Allow live-fill with bounded concurrency (details TBD).
    On,
}

impl Default for LiveFillPolicy {
    fn default() -> Self {
        LiveFillPolicy::Off
    }
}

/// Live-fill engine stub.
#[derive(Debug, Default)]
pub struct LiveFill;

impl LiveFill {
    /// Attempt to fill a digest; always returns `None` for now.
    pub async fn fill<C: CasStore>(&self, _cas: &C, _d: &Digest) -> Option<Vec<u8>> {
        None
    }
}

```

### crates/svc-edge/src/adapters/pack.rs
<a id="crates-svc-edge-src-adapters-pack-rs"></a>

```rust
//! Adapter: read-only pack access (e.g., PMTiles/pack files) — stub.

use std::path::PathBuf;

/// Pack source descriptor (placeholder).
#[derive(Debug, Clone)]
pub struct PackSource {
    /// Path to on-disk pack file (or future remote locator).
    pub path: PathBuf,
}

/// Minimal pack trait (read-only, stubbed).
pub trait PackStore: Send + Sync {
    /// Return `true` if the pack appears available.
    fn available(&self) -> bool;
}

/// No-op pack implementation used for wiring tests.
#[derive(Debug, Clone, Default)]
pub struct NullPack;

impl PackStore for NullPack {
    fn available(&self) -> bool {
        false
    }
}

```

### crates/svc-edge/src/adapters/tls.rs
<a id="crates-svc-edge-src-adapters-tls-rs"></a>

```rust
//! TLS adapter placeholders (server config wiring) — stub.

/// TLS mode (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum TlsMode {
    /// Plain TCP (no TLS).
    Plain,
    /// TLS via rustls (details TBD).
    Rustls,
}

impl Default for TlsMode {
    fn default() -> Self {
        TlsMode::Plain
    }
}

```

### crates/svc-edge/src/admission/body_cap.rs
<a id="crates-svc-edge-src-admission-bodycap-rs"></a>

```rust
//! Admission guard: maximum request body bytes (stub).

/// Configuration for a future body cap guard.
#[derive(Debug, Clone, Copy)]
pub struct BodyCap {
    /// Maximum allowed bytes in the request body.
    pub max_bytes: u64,
}

impl Default for BodyCap {
    fn default() -> Self {
        Self { max_bytes: 1_048_576 } // 1 MiB
    }
}

impl BodyCap {
    /// Create a new cap with the given maximum.
    pub fn new(max_bytes: u64) -> Self {
        Self { max_bytes }
    }
}

```

### crates/svc-edge/src/admission/decompress_guard.rs
<a id="crates-svc-edge-src-admission-decompressguard-rs"></a>

```rust
//! Admission guard: optional transparent decompression (stub).

/// Decompression posture (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum Decompress {
    /// Allow a safe set (e.g., gzip) — details TBD.
    Safe,
    /// Disable all decompression.
    Off,
}

impl Default for Decompress {
    fn default() -> Self {
        Decompress::Off
    }
}

```

### crates/svc-edge/src/admission/inflight_cap.rs
<a id="crates-svc-edge-src-admission-inflightcap-rs"></a>

```rust
//! Admission guard: cap concurrent in-flight requests (stub).

/// In-flight concurrency cap (placeholder).
#[derive(Debug, Clone, Copy)]
pub struct InflightCap {
    /// Maximum concurrent requests the service will process.
    pub max: usize,
}

impl Default for InflightCap {
    fn default() -> Self {
        Self { max: 256 }
    }
}

```

### crates/svc-edge/src/admission/mod.rs
<a id="crates-svc-edge-src-admission-mod-rs"></a>

```rust
//! Admission chain builder (timeout → inflight → RPS → body cap).
//!
//! RO:WHAT
//! - Small helper to apply a standard set of hardening layers to a `Router`.
//!
//! RO:WHY
//! - Keep the main binary uncluttered; centralize the composition here.

use std::time::Duration;

use axum::{
    error_handling::HandleErrorLayer,
    response::IntoResponse,
    Router,
};
use http::StatusCode;
use tower::{
    limit::{ConcurrencyLimitLayer, RateLimitLayer},
    timeout::{error::Elapsed, TimeoutLayer},
    util::BoxCloneService,
    BoxError, ServiceBuilder,
};
use tower_http::limit::RequestBodyLimitLayer;

use crate::AppState;

/// Apply the default admission stack to a router.
///
/// Defaults (aligned with docs; adjustable later via `Config`):
/// - timeout: 5s  → 408 on expiry
/// - inflight cap: 256 → 503 when saturated
/// - RPS: 1000 req/s → 429 when exceeded
/// - body cap: 1 MiB → 413 handled by the layer
pub fn apply_defaults(router: Router<AppState>) -> Router<AppState> {
    let layers = ServiceBuilder::new()
        // 1) Map middleware errors → HTTP responses (makes Error=Infallible for Axum).
        .layer(HandleErrorLayer::new(|err: BoxError| async move {
            // Timeout → 408
            if err.is::<Elapsed>() {
                return (StatusCode::REQUEST_TIMEOUT, "request timed out").into_response();
            }
            // Rate or concurrency limiting → 429, otherwise treat as overload → 503.
            let msg = err.to_string();
            if msg.contains("rate limit") || msg.contains("RateLimit") {
                (StatusCode::TOO_MANY_REQUESTS, "rate limit").into_response()
            } else {
                (StatusCode::SERVICE_UNAVAILABLE, "overloaded").into_response()
            }
        }))
        // 2) Admission layers (cheap guards first is fine here).
        .layer(TimeoutLayer::new(Duration::from_secs(5)))
        .layer(ConcurrencyLimitLayer::new(256))
        .layer(RateLimitLayer::new(1000, Duration::from_secs(1)))
        .layer(RequestBodyLimitLayer::new(1_048_576)) // 1 MiB
        // 3) Ensure the composed service is Clone for Router::layer().
        .layer(BoxCloneService::layer());

    router.layer(layers)
}

```

### crates/svc-edge/src/admission/rps_limit.rs
<a id="crates-svc-edge-src-admission-rpslimit-rs"></a>

```rust
//! Admission guard: requests-per-second limiter (stub).

/// Simple RPS limiter configuration (placeholder).
#[derive(Debug, Clone, Copy)]
pub struct RpsLimit {
    /// Approximate target request rate (per second).
    pub rps: u64,
}

impl Default for RpsLimit {
    fn default() -> Self {
        Self { rps: 1000 }
    }
}

```

### crates/svc-edge/src/admission/timeout.rs
<a id="crates-svc-edge-src-admission-timeout-rs"></a>

```rust
//! Admission guard: per-request timeout (stub).

use std::time::Duration;

/// Timeout configuration (placeholder).
#[derive(Debug, Clone, Copy)]
pub struct Timeout {
    /// Maximum request processing time.
    pub duration: Duration,
}

impl Default for Timeout {
    fn default() -> Self {
        Self { duration: Duration::from_secs(5) }
    }
}

```

### crates/svc-edge/src/bin/svc-edge.rs
<a id="crates-svc-edge-src-bin-svc-edge-rs"></a>

```rust
//! Binary entrypoint for svc-edge.

use std::sync::Arc;

use axum::{routing::{get, post}, Router};
use tokio::net::TcpListener;
use tokio_util::sync::CancellationToken;
use tracing_subscriber::{fmt, EnvFilter};

use svc_edge::{
    admission,
    cli::Cli,
    readiness::readiness_handler,
    routes::{assets::echo, health::healthz, prometheus::metrics},
    wait_for_ctrl_c, AppState, Config, EdgeMetrics, HealthState,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Logging
    let env_filter =
        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,hyper=warn"));
    fmt().with_env_filter(env_filter).compact().init();

    // Parse CLI / config
    #[cfg(feature = "cli")]
    let cli = Cli::parse_from_env();
    #[cfg(not(feature = "cli"))]
    let cli = Cli::default();
    let cfg = Config::from_sources(cli.config_path.as_deref().and_then(|p| p.to_str()))?;

    // Health/metrics
    let health: Arc<HealthState> = Arc::new(HealthState::new());
    let edge_metrics = EdgeMetrics::new();
    // seed amnesia gauge from config
    edge_metrics.set_amnesia(cfg.security.amnesia);
    let state = AppState::new(cfg.clone(), edge_metrics.clone(), health.clone());

    // ----- Admin router (health/ready/metrics) -----
    let admin = Router::new()
        .route("/healthz", get(healthz))
        .route("/readyz", get(readiness_handler))
        .route("/metrics", get(metrics))
        .with_state(state.clone());

    // ----- API router (temporary: /echo) with admission layers -----
    let api = Router::new()
        .route("/echo", post(echo))
        .with_state(state.clone());
    let api = admission::apply_defaults(api);

    // Bind listeners
    let api_addr = cfg.bind_addr;
    let metrics_addr = cfg.metrics_addr;

    let admin_listener = TcpListener::bind(metrics_addr).await?;
    tracing::info!(%metrics_addr, "svc-edge: admin plane bound (health/ready/metrics)");

    let api_listener = TcpListener::bind(api_addr).await?;
    tracing::info!(%api_addr, "svc-edge: api plane bound");

    // Flip initial health gates after config loaded
    health.set("services_ok", true);
    health.set("config_loaded", true);

    // Shared shutdown token
    let token = CancellationToken::new();
    let t_admin = token.clone();
    let t_api = token.clone();

    // Task: wait for Ctrl-C / SIGTERM then cancel token
    let cancel_task = tokio::spawn({
        let token = token.clone();
        async move {
            shutdown_signal().await;
            token.cancel();
        }
    });

    // Serve both planes with graceful shutdown
    let admin_srv = axum::serve(admin_listener, admin)
        .with_graceful_shutdown(t_admin.cancelled());
    let api_srv = axum::serve(api_listener, api)
        .with_graceful_shutdown(t_api.cancelled());

    tracing::info!("svc-edge: starting (admin + api planes)");

    // Join servers first (concrete types inferred), then await canceller.
    let (r1, r2) = tokio::join!(admin_srv, api_srv);
    r1?;
    r2?;
    let _ = cancel_task.await;

    tracing::info!("svc-edge: shutdown complete");
    Ok(())
}

/// Unified shutdown signal: Ctrl-C on all platforms, plus SIGTERM on Unix.
async fn shutdown_signal() {
    #[cfg(unix)]
    {
        use tokio::signal::unix::{signal, SignalKind};
        let mut term = signal(SignalKind::terminate()).expect("install SIGTERM handler");
        tokio::select! {
            _ = wait_for_ctrl_c() => {
                tracing::info!("shutdown: received Ctrl-C");
            }
            _ = term.recv() => {
                tracing::info!("shutdown: received SIGTERM");
            }
        }
    }
    #[cfg(not(unix))]
    {
        wait_for_ctrl_c().await;
        tracing::info!("shutdown: received Ctrl-C");
    }
}

```

### crates/svc-edge/src/cli.rs
<a id="crates-svc-edge-src-cli-rs"></a>

```rust
//! CLI parsing (flags are minimal for the first increment).

use std::path::PathBuf;

#[cfg(feature = "cli")]
use clap::Parser;

/// CLI flags (mirrors docs/CONFIG.md as we grow).
#[cfg_attr(feature = "cli", derive(Parser))]
#[derive(Clone, Debug, Default)]
#[cfg_attr(
    feature = "cli",
    command(name = "svc-edge", author, version, about = "svc-edge service")
)]
pub struct Cli {
    /// Path to the svc-edge TOML config file.
    #[cfg_attr(feature = "cli", arg(long = "config"))]
    pub config_path: Option<PathBuf>,
}

impl Cli {
    /// Parse CLI flags from the current process environment/argv.
    ///
    /// When the `cli` feature is disabled, returns defaults.
    #[cfg(feature = "cli")]
    pub fn parse_from_env() -> Self {
        <Self as clap::Parser>::parse()
    }

    /// Parse CLI flags from the current process environment/argv.
    ///
    /// When the `cli` feature is disabled, returns defaults.
    #[cfg(not(feature = "cli"))]
    pub fn parse_from_env() -> Self {
        Self::default()
    }
}

```

### crates/svc-edge/src/config.rs
<a id="crates-svc-edge-src-config-rs"></a>

```rust
//! Typed config with strict defaults and validation.

use serde::Deserialize;
use std::{fs, net::SocketAddr};

/// Service configuration (first increment: admin plane and reserved API bind).
#[derive(Debug, Clone, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Config {
    /// API bind address (reserved for next increment; logged only right now).
    #[serde(default = "default_api")]
    pub bind_addr: SocketAddr,
    /// Metrics/health/ready bind (admin plane).
    #[serde(default = "default_metrics")]
    pub metrics_addr: SocketAddr,
    /// Security posture. Additional knobs will arrive as the feature set grows.
    #[serde(default)]
    pub security: Security,
}

/// Security posture for the service.
///
/// In this increment we only expose the `amnesia` toggle to signal ephemeral
/// mode. Later, persistence/backends will tie into readiness if `amnesia` is on.
#[derive(Debug, Clone, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct Security {
    /// Whether the node runs in “amnesia mode” (strong ephemerality, no
    /// persistent state). This currently only drives metrics/readiness semantics.
    pub amnesia: bool,
}

fn default_api() -> SocketAddr {
    "0.0.0.0:8080".parse().unwrap()
}
fn default_metrics() -> SocketAddr {
    "127.0.0.1:9909".parse().unwrap()
}

impl Config {
    /// Load configuration from a TOML file if provided, otherwise from
    /// environment variables with baked-in defaults.
    pub fn from_sources(toml_path: Option<&str>) -> anyhow::Result<Self> {
        if let Some(p) = toml_path {
            let text = fs::read_to_string(p)?;
            let cfg: Config = toml::from_str(&text)?;
            cfg.validate()?;
            return Ok(cfg);
        }
        // Minimal env reading (future: env prefix SVC_EDGE_* → fields)
        let cfg = Config {
            bind_addr: std::env::var("SVC_EDGE_BIND_ADDR")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or_else(default_api),
            metrics_addr: std::env::var("SVC_EDGE_METRICS_ADDR")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or_else(default_metrics),
            security: Security {
                amnesia: std::env::var("SVC_EDGE_SECURITY__AMNESIA")
                    .ok()
                    .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
                    .unwrap_or(false),
            },
        };
        cfg.validate()?;
        Ok(cfg)
    }

    /// Validate configuration invariants.
    ///
    /// In this initial increment, there are no cross-field constraints yet.
    fn validate(&self) -> anyhow::Result<()> {
        Ok(())
    }
}

```

### crates/svc-edge/src/errors.rs
<a id="crates-svc-edge-src-errors-rs"></a>

```rust
//! Error taxonomy → deterministic HTTP mapping (reserved for later endpoints).

use thiserror::Error;

/// Edge service error kinds used to categorize failures.
///
/// Mapping to HTTP status codes happens in the route layer.
#[derive(Debug, Error)]
pub enum EdgeError {
    /// Service is not yet ready to serve the requested operation.
    #[error("not ready: {0}")]
    NotReady(&'static str),

    /// The request was rejected by rate limiting or admission controls.
    #[error("rate limited")]
    RateLimited,

    /// The request was malformed or violated input constraints.
    #[error("bad request: {0}")]
    BadRequest(&'static str),

    /// An unexpected internal error occurred.
    #[error("internal error")]
    Internal,
}

impl EdgeError {
    /// Short machine-readable reason tag (for logs/metrics labels).
    pub fn reason(&self) -> &'static str {
        match self {
            EdgeError::NotReady(_) => "not_ready",
            EdgeError::RateLimited => "rate_limit",
            EdgeError::BadRequest(_) => "bad_request",
            EdgeError::Internal => "internal",
        }
    }
}

```

### crates/svc-edge/src/http/etag.rs
<a id="crates-svc-edge-src-http-etag-rs"></a>

```rust
//! ETag helpers (opaque ETag strings) — stub.

/// Strong ETag wrapper (opaque).
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ETag(pub String);

impl ETag {
    /// Format as a strong ETag: `"value"`.
    pub fn strong(value: impl AsRef<str>) -> Self {
        Self(format!("\"{}\"", value.as_ref()))
    }
}

```

### crates/svc-edge/src/http/headers.rs
<a id="crates-svc-edge-src-http-headers-rs"></a>

```rust
//! HTTP helper utilities — header names and helpers (stub).

/// Common constant header names (subset, placeholders).
pub mod names {
    /// `ETag`
    pub const ETAG: &str = "ETag";
    /// `If-None-Match`
    pub const IF_NONE_MATCH: &str = "If-None-Match";
    /// `Accept-Ranges`
    pub const ACCEPT_RANGES: &str = "Accept-Ranges";
}

```

### crates/svc-edge/src/http/range.rs
<a id="crates-svc-edge-src-http-range-rs"></a>

```rust
//! HTTP range parsing primitives (single-range only) — stub.

/// Single byte range (inclusive start, inclusive end).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ByteRange {
    /// Start offset.
    pub start: u64,
    /// End offset (inclusive).
    pub end: u64,
}

impl ByteRange {
    /// Length of the range in bytes, saturating.
    pub fn len(&self) -> u64 {
        self.end.saturating_sub(self.start) + 1
    }
}

```

### crates/svc-edge/src/lib.rs
<a id="crates-svc-edge-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]
#![deny(missing_docs, clippy::all, clippy::pedantic)]
//! svc-edge — stateless edge service (admin + api scaffold).
//!
//! RO:WHAT
//! - Minimal library surface that re-exports kernel facilities used by the binary.
//! - No stable SDK; this is a service crate.
//!
//! RO:WHY
//! - Keep compile surface tiny so we can add features incrementally.
//!
//! RO:INVARIANTS
//! - Admin plane is always available: /metrics, /healthz, /readyz.
//! - Readiness is degrade-first until gates flip ready.

pub mod cli;
pub mod config;
pub mod errors;
pub mod metrics;
pub mod readiness;
pub mod routes;
pub mod state;
pub mod admission; // <— expose admission chain builder

pub use ron_kernel::{wait_for_ctrl_c, HealthState};

/// Public convenience re-exports for the binary.
pub use config::Config;
pub use metrics::EdgeMetrics;
pub use state::AppState;

```

### crates/svc-edge/src/metrics.rs
<a id="crates-svc-edge-src-metrics-rs"></a>

```rust
//! Edge metrics wrapper over the shared Prometheus registry.

use once_cell::sync::Lazy;
use prometheus::{
    register_gauge, register_histogram, register_int_counter_vec, Encoder, Gauge, Histogram,
    IntCounterVec, TextEncoder,
};
use ron_kernel::HealthState;
use std::sync::Arc;

static REQ_LATENCY: Lazy<Histogram> = Lazy::new(|| {
    register_histogram!(
        "edge_request_latency_seconds",
        "Latency of handled edge requests (admin plane for now)"
    )
    .unwrap()
});

static REJECTS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!("edge_rejects_total", "Rejects by reason", &["reason"]).unwrap()
});

static AMNESIA: Lazy<Gauge> =
    Lazy::new(|| register_gauge!("amnesia_mode", "Amnesia posture (1/0)").unwrap());

/// Handle to edge metrics (cheap clone).
#[derive(Clone, Default)]
pub struct EdgeMetrics;

impl EdgeMetrics {
    /// Create a new metrics handle.
    pub fn new() -> Self {
        Self
    }

    /// Observe a request latency in seconds.
    pub fn observe_req_latency(&self, secs: f64) {
        REQ_LATENCY.observe(secs);
    }

    /// Increment the rejects counter for a given reason label.
    pub fn inc_reject(&self, reason: &str) {
        REJECTS.with_label_values(&[reason]).inc();
    }

    /// Set the amnesia posture gauge to 1 (on) or 0 (off).
    pub fn set_amnesia(&self, on: bool) {
        AMNESIA.set(if on { 1.0 } else { 0.0 });
    }

    /// Render Prometheus exposition format into bytes using the global registry.
    pub fn gather() -> Vec<u8> {
        let mut buf = Vec::with_capacity(16 * 1024);
        let mf = prometheus::gather();
        let _ = TextEncoder::new().encode(&mf, &mut buf);
        buf
    }
}

/// Seed metric gauges from the health snapshot if needed.
///
/// This is a convenience for startup synchronization patterns.
pub fn seed_from_health(_health: Arc<HealthState>, metrics: &EdgeMetrics, amnesia: bool) {
    metrics.set_amnesia(amnesia);
}

```

### crates/svc-edge/src/readiness.rs
<a id="crates-svc-edge-src-readiness-rs"></a>

```rust
//! /readyz handler: degrade-first semantics with reasons payload.

use crate::state::AppState;
use axum::{extract::State, http::StatusCode, response::IntoResponse, Json};
use http::{header, HeaderValue};
use serde::Serialize;

/// JSON payload returned by `/readyz`.
#[derive(Serialize)]
struct ReadyPayload {
    /// Whether the service is ready to serve traffic.
    ready: bool,
    /// Missing gates/conditions preventing readiness.
    missing: Vec<String>,
}

/// Report readiness based on `HealthState` keyed flags.
///
/// Current policy: ready when `services_ok` and `config_loaded` are true.
/// Returns 503 with `Retry-After: 1` when not ready.
pub async fn readiness_handler(State(state): State<AppState>) -> impl IntoResponse {
    // HealthState::snapshot() returns a BTreeMap<&str,bool> in this project.
    let snapshot = state.health.snapshot();
    let services_ok = *snapshot.get("services_ok").unwrap_or(&false);
    let config_loaded = *snapshot.get("config_loaded").unwrap_or(&false);

    if services_ok && config_loaded {
        return (StatusCode::OK, Json(ReadyPayload { ready: true, missing: vec![] }))
            .into_response();
    }

    let mut missing = Vec::new();
    if !services_ok {
        missing.push("services_ok".to_string());
    }
    if !config_loaded {
        missing.push("config_loaded".to_string());
    }

    let payload = ReadyPayload { ready: false, missing };
    let mut res = (StatusCode::SERVICE_UNAVAILABLE, Json(payload)).into_response();
    res.headers_mut()
        .insert(header::RETRY_AFTER, HeaderValue::from_static("1"));
    res
}

```

### crates/svc-edge/src/routes/assets.rs
<a id="crates-svc-edge-src-routes-assets-rs"></a>

```rust
//! Temporary API route(s) to exercise the admission chain.

use axum::{extract::State, body::Bytes, response::IntoResponse, Json};
use http::StatusCode;

use crate::state::AppState;

/// POST /echo — echos back the body length as JSON.
///
/// This is intentionally simple so we can validate body caps, timeouts,
/// RPS shaping, etc., without introducing domain behavior yet.
pub async fn echo(State(_state): State<AppState>, body: Bytes) -> impl IntoResponse {
    let len = body.len();
    let payload = serde_json::json!({ "ok": true, "len": len });
    (StatusCode::OK, Json(payload))
}

```

### crates/svc-edge/src/routes/health.rs
<a id="crates-svc-edge-src-routes-health-rs"></a>

```rust
//! /healthz — liveness endpoint.

use axum::response::IntoResponse;
use http::StatusCode;

/// Liveness probe.
///
/// Returns `200 OK` unconditionally if the process is alive.
pub async fn healthz() -> impl IntoResponse {
    StatusCode::OK
}

```

### crates/svc-edge/src/routes/mod.rs
<a id="crates-svc-edge-src-routes-mod-rs"></a>

```rust
//! Route modules.

pub mod health;
pub mod prometheus;
pub mod assets; // temp API routes while we wire the stack
// ready route lives in crate::readiness

```

### crates/svc-edge/src/routes/prometheus.rs
<a id="crates-svc-edge-src-routes-prometheus-rs"></a>

```rust
//! /metrics — Prometheus exposition.

use crate::metrics::EdgeMetrics;
use crate::state::AppState;
use axum::{extract::State, response::IntoResponse};
use http::{header, HeaderValue, StatusCode};

/// Render the Prometheus metrics exposition format.
///
/// Uses the global registry populated by the service.
pub async fn metrics(State(_state): State<AppState>) -> impl IntoResponse {
    let body = EdgeMetrics::gather();
    let mut res = (StatusCode::OK, body).into_response();
    res.headers_mut()
        .insert(header::CONTENT_TYPE, HeaderValue::from_static("text/plain; version=0.0.4"));
    res
}

```

### crates/svc-edge/src/routes/ready.rs
<a id="crates-svc-edge-src-routes-ready-rs"></a>

```rust

```

### crates/svc-edge/src/security/audit.rs
<a id="crates-svc-edge-src-security-audit-rs"></a>

```rust
//! Security audit trail placeholder (stub).

/// Minimal audit event (placeholder).
#[derive(Debug, Clone)]
pub struct AuditEvent {
    /// Category (e.g., "admission", "security", "policy").
    pub category: String,
    /// Short message.
    pub message: String,
}

/// Audit sink (no-op).
#[derive(Debug, Default, Clone)]
pub struct Auditor;

impl Auditor {
    /// Record an audit event (no-op).
    pub fn record(&self, _evt: AuditEvent) {
        // Future: write to structured log / metrics.
    }
}

```

### crates/svc-edge/src/security/cors.rs
<a id="crates-svc-edge-src-security-cors-rs"></a>

```rust
//! CORS policy placeholder (stub).

/// CORS posture (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum Cors {
    /// Deny all cross-origin requests.
    Deny,
    /// Allow a restricted set (details TBD).
    Restricted,
}

impl Default for Cors {
    fn default() -> Self {
        Cors::Deny
    }
}

```

### crates/svc-edge/src/security/hsts.rs
<a id="crates-svc-edge-src-security-hsts-rs"></a>

```rust
//! HSTS policy placeholder (stub).

/// HSTS posture (placeholder).
#[derive(Debug, Clone, Copy)]
pub enum Hsts {
    /// Disabled.
    Off,
    /// Enabled with defaults (details TBD).
    On,
}

impl Default for Hsts {
    fn default() -> Self {
        Hsts::Off
    }
}

```

### crates/svc-edge/src/state.rs
<a id="crates-svc-edge-src-state-rs"></a>

```rust
//! AppState — shared state for handlers (Arc by Axum state).

use crate::{config::Config, metrics::EdgeMetrics};
use ron_kernel::HealthState;
use std::sync::Arc;

/// Shared application state used by Axum handlers.
///
/// Must be `Clone + Send + Sync + 'static` for Axum. We achieve this with
/// `Arc<...>` for reference-counted, thread-safe ownership.
#[derive(Clone)]
pub struct AppState {
    /// Immutable configuration for the running process.
    pub cfg: Arc<Config>,
    /// Metrics handle for recording service metrics.
    pub metrics: EdgeMetrics,
    /// Health state used by /readyz and other liveness gates.
    pub health: Arc<HealthState>,
}

impl AppState {
    /// Construct a new `AppState` from config, metrics, and health.
    pub fn new(cfg: Config, metrics: EdgeMetrics, health: Arc<HealthState>) -> Self {
        Self {
            cfg: Arc::new(cfg),
            metrics,
            health,
        }
    }
}

```

### crates/svc-edge/src/supervisor.rs
<a id="crates-svc-edge-src-supervisor-rs"></a>

```rust
//! Process supervisor scaffold for svc-edge.
//!
//! RO:WHAT
//! - Placeholder for listener/task lifecycle management and orderly shutdown.
//!
//! RO:NEXT
//! - Add accept loops, task JoinHandles, and a `cancel()` to request drain.

/// No-op supervisor placeholder.
#[derive(Debug, Clone, Default)]
pub struct Supervisor;

impl Supervisor {
    /// Create a new no-op supervisor.
    pub fn new() -> Self {
        Self
    }
    /// Request shutdown (no-op for now).
    pub async fn shutdown(&self) {
        // Future: signal tasks and await joins with a timeout.
    }
}

```

### crates/svc-edge/src/util/backoff.rs
<a id="crates-svc-edge-src-util-backoff-rs"></a>

```rust
//! Simple exponential backoff calculator (stub).

use std::time::Duration;

/// Exponential backoff parameters (placeholder).
#[derive(Debug, Clone, Copy)]
pub struct Backoff {
    /// Base delay.
    pub base: Duration,
    /// Maximum delay.
    pub max: Duration,
    /// Multiplier per attempt.
    pub factor: f64,
}

impl Default for Backoff {
    fn default() -> Self {
        Self {
            base: Duration::from_millis(10),
            max: Duration::from_secs(2),
            factor: 2.0,
        }
    }
}

impl Backoff {
    /// Compute delay for `attempt` (0-based).
    pub fn delay(&self, attempt: u32) -> Duration {
        let ms = (self.base.as_millis() as f64) * self.factor.powi(attempt as i32);
        let d = Duration::from_millis(ms as u64);
        if d > self.max { self.max } else { d }
    }
}

```

### crates/svc-edge/src/util/bytes.rs
<a id="crates-svc-edge-src-util-bytes-rs"></a>

```rust
//! Byte utilities (stub).

/// Clamp `n` to `max`.
pub fn clamp_len(n: usize, max: usize) -> usize {
    if n > max { max } else { n }
}

```

### crates/svc-edge/src/util/size_parse.rs
<a id="crates-svc-edge-src-util-sizeparse-rs"></a>

```rust
//! Parse human-readable sizes like "64k", "10MiB" (stub).
//!
//! Accepted suffixes (case-insensitive; decimal only for now):
//! - k, m, g, t  → 10^3 steps.

/// Parse a simple size string. Returns bytes on success.
///
/// Examples: "0", "64k", "10m". Binary units and MiB/GiB will arrive later.
pub fn parse_decimal_size(s: &str) -> Option<u64> {
    let s = s.trim();
    if s.is_empty() {
        return None;
    }
    let (num, suf) = s.split_at(s.find(|c: char| !c.is_ascii_digit()).unwrap_or(s.len()));
    let mut n: u64 = num.parse().ok()?;
    let suffix = suf.trim().to_ascii_lowercase();
    n *= match suffix.as_str() {
        "" => 1,
        "k" => 1_000,
        "m" => 1_000_000,
        "g" => 1_000_000_000,
        "t" => 1_000_000_000_000,
        _ => return None,
    };
    Some(n)
}

```

### crates/svc-edge/src/work/queue.rs
<a id="crates-svc-edge-src-work-queue-rs"></a>

```rust
//! Work queue placeholder (bounded, no implementation yet).

/// Opaque job type (placeholder).
#[derive(Debug, Clone)]
pub struct Job {
    /// Human-readable label for diagnostics.
    pub label: String,
}

/// Bounded work queue (stub).
#[derive(Debug, Default)]
pub struct WorkQueue;

impl WorkQueue {
    /// Construct a new, empty work queue.
    pub fn new() -> Self {
        Self
    }
    /// Enqueue a job (no-op).
    pub fn push(&self, _job: Job) -> bool {
        false
    }
}

```

### crates/svc-edge/src/work/shutdown.rs
<a id="crates-svc-edge-src-work-shutdown-rs"></a>

```rust
//! Cooperative shutdown helpers (stub).

/// A cooperative shutdown token (stub).
#[derive(Debug, Clone, Default)]
pub struct ShutdownToken {
    /// Whether shutdown was requested.
    pub requested: bool,
}

impl ShutdownToken {
    /// Request shutdown (no-op).
    pub fn request(&mut self) {
        self.requested = true;
    }
    /// Check whether shutdown was requested.
    pub fn is_requested(&self) -> bool {
        self.requested
    }
}

```

### crates/svc-edge/src/work/worker.rs
<a id="crates-svc-edge-src-work-worker-rs"></a>

```rust
//! Worker placeholder for background tasks (stub).

use super::queue::WorkQueue;

/// Simple worker (no behavior yet).
#[derive(Debug, Default)]
pub struct Worker;

impl Worker {
    /// Run a no-op worker loop (immediate return for now).
    pub async fn run(&self, _queue: WorkQueue) {
        // Future: read jobs; process; record metrics; respect shutdown.
    }
}

```

### crates/svc-edge/tests/concurrency_backpressure.rs
<a id="crates-svc-edge-tests-concurrencybackpressure-rs"></a>

```rust

```

### crates/svc-edge/tests/fuzz_headers.rs
<a id="crates-svc-edge-tests-fuzzheaders-rs"></a>

```rust

```

### crates/svc-edge/tests/http_contract.rs
<a id="crates-svc-edge-tests-httpcontract-rs"></a>

```rust

```

### crates/svc-edge/tests/i_10_deterministic_failures.rs
<a id="crates-svc-edge-tests-i10deterministicfailures-rs"></a>

```rust

```

### crates/svc-edge/tests/i_11_pack_integrity.rs
<a id="crates-svc-edge-tests-i11packintegrity-rs"></a>

```rust

```

### crates/svc-edge/tests/i_1_hardening_ingress.rs
<a id="crates-svc-edge-tests-i1hardeningingress-rs"></a>

```rust

```

### crates/svc-edge/tests/i_4_http_semantics.rs
<a id="crates-svc-edge-tests-i4httpsemantics-rs"></a>

```rust

```

### crates/svc-edge/tests/i_5_content_address.rs
<a id="crates-svc-edge-tests-i5contentaddress-rs"></a>

```rust

```

### crates/svc-edge/tests/i_6_amnesia.rs
<a id="crates-svc-edge-tests-i6amnesia-rs"></a>

```rust

```

### crates/svc-edge/tests/i_8_size_bounds.rs
<a id="crates-svc-edge-tests-i8sizebounds-rs"></a>

```rust

```

### crates/svc-edge/tests/i_9_observability_contract.rs
<a id="crates-svc-edge-tests-i9observabilitycontract-rs"></a>

```rust

```

### crates/svc-edge/tests/readiness_logic.rs
<a id="crates-svc-edge-tests-readinesslogic-rs"></a>

```rust

```

