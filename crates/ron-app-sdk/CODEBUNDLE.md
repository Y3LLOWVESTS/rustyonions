<!-- Generated by scripts/make_crate_codex.sh on 2025-11-15T00:31:48Z -->
# Code Bundle — `ron-app-sdk`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-app-sdk/.github/workflows/api-semver.yml](#crates-ron-app-sdk--github-workflows-api-semver-yml)
- [crates/ron-app-sdk/.github/workflows/ci.yml](#crates-ron-app-sdk--github-workflows-ci-yml)
- [crates/ron-app-sdk/.github/workflows/perf-guardrails.yml](#crates-ron-app-sdk--github-workflows-perf-guardrails-yml)
- [crates/ron-app-sdk/.github/workflows/render-mermaid.yml](#crates-ron-app-sdk--github-workflows-render-mermaid-yml)
- [crates/ron-app-sdk/Cargo.toml](#crates-ron-app-sdk-Cargo-toml)
- [crates/ron-app-sdk/benches/sdk_benches.rs](#crates-ron-app-sdk-benches-sdkbenches-rs)
- [crates/ron-app-sdk/examples/demo.rs](#crates-ron-app-sdk-examples-demo-rs)
- [crates/ron-app-sdk/fuzz/Cargo.toml](#crates-ron-app-sdk-fuzz-Cargo-toml)
- [crates/ron-app-sdk/fuzz/fuzz_targets/dto_roundtrip.rs](#crates-ron-app-sdk-fuzz-fuzztargets-dtoroundtrip-rs)
- [crates/ron-app-sdk/fuzz/fuzz_targets/oap_frame_parser.rs](#crates-ron-app-sdk-fuzz-fuzztargets-oapframeparser-rs)
- [crates/ron-app-sdk/rust-toolchain.toml](#crates-ron-app-sdk-rust-toolchain-toml)
- [crates/ron-app-sdk/scripts/gen_api_snapshot.sh](#crates-ron-app-sdk-scripts-genapisnapshot-sh)
- [crates/ron-app-sdk/src/cache/lru.rs](#crates-ron-app-sdk-src-cache-lru-rs)
- [crates/ron-app-sdk/src/cache/mod.rs](#crates-ron-app-sdk-src-cache-mod-rs)
- [crates/ron-app-sdk/src/config/mod.rs](#crates-ron-app-sdk-src-config-mod-rs)
- [crates/ron-app-sdk/src/config/types.rs](#crates-ron-app-sdk-src-config-types-rs)
- [crates/ron-app-sdk/src/context.rs](#crates-ron-app-sdk-src-context-rs)
- [crates/ron-app-sdk/src/errors.rs](#crates-ron-app-sdk-src-errors-rs)
- [crates/ron-app-sdk/src/idempotency.rs](#crates-ron-app-sdk-src-idempotency-rs)
- [crates/ron-app-sdk/src/lib.rs](#crates-ron-app-sdk-src-lib-rs)
- [crates/ron-app-sdk/src/metrics.rs](#crates-ron-app-sdk-src-metrics-rs)
- [crates/ron-app-sdk/src/planes/edge.rs](#crates-ron-app-sdk-src-planes-edge-rs)
- [crates/ron-app-sdk/src/planes/index.rs](#crates-ron-app-sdk-src-planes-index-rs)
- [crates/ron-app-sdk/src/planes/mailbox.rs](#crates-ron-app-sdk-src-planes-mailbox-rs)
- [crates/ron-app-sdk/src/planes/mod.rs](#crates-ron-app-sdk-src-planes-mod-rs)
- [crates/ron-app-sdk/src/planes/storage.rs](#crates-ron-app-sdk-src-planes-storage-rs)
- [crates/ron-app-sdk/src/ready.rs](#crates-ron-app-sdk-src-ready-rs)
- [crates/ron-app-sdk/src/retry.rs](#crates-ron-app-sdk-src-retry-rs)
- [crates/ron-app-sdk/src/tracing.rs](#crates-ron-app-sdk-src-tracing-rs)
- [crates/ron-app-sdk/src/transport/mod.rs](#crates-ron-app-sdk-src-transport-mod-rs)
- [crates/ron-app-sdk/src/types.rs](#crates-ron-app-sdk-src-types-rs)
- [crates/ron-app-sdk/tests/i_10_semver_snapshot.rs](#crates-ron-app-sdk-tests-i10semversnapshot-rs)
- [crates/ron-app-sdk/tests/i_11_no_persistence.rs](#crates-ron-app-sdk-tests-i11nopersistence-rs)
- [crates/ron-app-sdk/tests/i_12_canon_deps.rs](#crates-ron-app-sdk-tests-i12canondeps-rs)
- [crates/ron-app-sdk/tests/i_1_profile_parity.rs](#crates-ron-app-sdk-tests-i1profileparity-rs)
- [crates/ron-app-sdk/tests/i_2_caps_required.rs](#crates-ron-app-sdk-tests-i2capsrequired-rs)
- [crates/ron-app-sdk/tests/i_3_oap_bounds.rs](#crates-ron-app-sdk-tests-i3oapbounds-rs)
- [crates/ron-app-sdk/tests/i_4_content_addressing.rs](#crates-ron-app-sdk-tests-i4contentaddressing-rs)
- [crates/ron-app-sdk/tests/i_5_retries_deadlines.rs](#crates-ron-app-sdk-tests-i5retriesdeadlines-rs)
- [crates/ron-app-sdk/tests/i_6_dto_strictness.rs](#crates-ron-app-sdk-tests-i6dtostrictness-rs)
- [crates/ron-app-sdk/tests/i_7_transport_agnostic.rs](#crates-ron-app-sdk-tests-i7transportagnostic-rs)
- [crates/ron-app-sdk/tests/i_8_deadlines_everywhere.rs](#crates-ron-app-sdk-tests-i8deadlineseverywhere-rs)
- [crates/ron-app-sdk/tests/i_9_error_taxonomy.rs](#crates-ron-app-sdk-tests-i9errortaxonomy-rs)
- [crates/ron-app-sdk/tests/interop_vectors.rs](#crates-ron-app-sdk-tests-interopvectors-rs)
- [crates/ron-app-sdk/tests/prop_oap_frames.rs](#crates-ron-app-sdk-tests-propoapframes-rs)
- [crates/ron-app-sdk/tests/prop_retry_bounds.rs](#crates-ron-app-sdk-tests-propretrybounds-rs)
- [crates/ron-app-sdk/tests/vectors/capability_example.json](#crates-ron-app-sdk-tests-vectors-capabilityexample-json)
- [crates/ron-app-sdk/tests/vectors/oap1_min_req.json](#crates-ron-app-sdk-tests-vectors-oap1minreq-json)

### crates/ron-app-sdk/.github/workflows/api-semver.yml
<a id="crates-ron-app-sdk--github-workflows-api-semver-yml"></a>

```yaml
name: api-semver
on: [pull_request]
jobs:
  semver:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "public-api check scaffold"
```

### crates/ron-app-sdk/.github/workflows/ci.yml
<a id="crates-ron-app-sdk--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
      - run: cargo fmt --all -- --check
      - run: cargo clippy -p ron-app-sdk2 -- -D warnings
      - run: cargo test -p ron-app-sdk2
```

### crates/ron-app-sdk/.github/workflows/perf-guardrails.yml
<a id="crates-ron-app-sdk--github-workflows-perf-guardrails-yml"></a>

```yaml
name: perf-guardrails
on:
  workflow_dispatch:
  schedule:
    - cron: "0 6 * * *"
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: cargo bench -p ron-app-sdk2 || true
```

### crates/ron-app-sdk/.github/workflows/render-mermaid.yml
<a id="crates-ron-app-sdk--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          mkdir -p docs/diagrams
          for f in $(git ls-files 'docs/diagrams/*.mmd'); do
            out="${f%.mmd}.svg"; mmdc -i "$f" -o "$out";
          done
```

### crates/ron-app-sdk/Cargo.toml
<a id="crates-ron-app-sdk-Cargo-toml"></a>

```toml
[package]
name = "ron-app-sdk"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RustyOnions application SDK (developer-facing client for RON-CORE)."
readme = "README.md"
repository = ""
publish = false

[lib]
path = "src/lib.rs"

[features]
# Default posture: direct TLS.
default = ["tls"]

# Transport toggles (we’ll wire actual deps as we add transport code).
tls = []
tor = []

# Optional extras we’ll hook up later (metrics, PQ hybrids, etc.).
metrics = []
pq = []
pq-hybrid = []

[dependencies]
# Error handling
anyhow = { workspace = true }

# Serialization
serde = { workspace = true, features = ["derive"] }
humantime-serde = { workspace = true }

# Canonical DTOs (capabilities, content IDs, mailbox, manifests, etc.)
ron-proto = { path = "../ron-proto" }

# Binary blob helper for plane APIs (edge/storage).
bytes = { version = "1.7", default-features = false }

[dev-dependencies]
serde_json = { workspace = true }
tokio = { workspace = true, features = ["macros", "rt-multi-thread"] }

[package.metadata.docs]

```

### crates/ron-app-sdk/benches/sdk_benches.rs
<a id="crates-ron-app-sdk-benches-sdkbenches-rs"></a>

```rust
// Criterion benches placeholder (scaffold).
fn main() { println!("benches scaffold"); }
```

### crates/ron-app-sdk/examples/demo.rs
<a id="crates-ron-app-sdk-examples-demo-rs"></a>

```rust
//! Minimal demo for ron-app-sdk.
//!
//! RO:WHAT — Tiny example that exercises config loading, readiness
//!           checks, and constructing `RonAppSdk`.
//! RO:WHY  — Gives integrators a copy-paste starting point without
//!           requiring a running Micronode/Macronode or real transport.
//! RO:NOTE — This example intentionally **does not** call any plane
//!           methods yet (storage/edge/mailbox/index) so we avoid the
//!           unfinished `todo!()` implementations.

use ron_app_sdk::{check_ready, RonAppSdk, SdkConfig};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Load config from environment.
    //
    // In a real deployment you’d set variables like:
    //   RON_APP_SDK_GATEWAY_ADDR=https://micronode.example
    //   RON_APP_SDK_TRANSPORT=tls
    //   RON_APP_SDK_OVERALL_TIMEOUT=30s
    let cfg = match SdkConfig::from_env() {
        Ok(cfg) => cfg,
        Err(err) => {
            eprintln!("[demo] failed to load SdkConfig from env: {err}");
            std::process::exit(1);
        }
    };

    // Run a lightweight readiness check (no network I/O).
    let ready = check_ready(&cfg);
    println!("[demo] ReadyReport: {:?}", ready);

    if !ready.is_ready() {
        eprintln!("[demo] SDK not ready; missing: {:?}", ready.missing);
        std::process::exit(1);
    }

    // Construct the SDK client. This validates config again and
    // prepares the internal transport handle (stubbed for now).
    let sdk = RonAppSdk::new(cfg).await?;
    let ctx = sdk.context();

    println!(
        "[demo] SDK context: profile={:?}, amnesia={}",
        ctx.profile(),
        ctx.amnesia()
    );

    // NOTE: We intentionally do *not* call `storage_get`, `edge_get`,
    // or any other plane methods yet because the underlying transport
    // wiring is still `todo!()`. Once transport is implemented, this
    // example can be extended to make a real call.

    Ok(())
}

```

### crates/ron-app-sdk/fuzz/Cargo.toml
<a id="crates-ron-app-sdk-fuzz-Cargo-toml"></a>

```toml
[workspace]
members = ["."]
```

### crates/ron-app-sdk/fuzz/fuzz_targets/dto_roundtrip.rs
<a id="crates-ron-app-sdk-fuzz-fuzztargets-dtoroundtrip-rs"></a>

```rust
// fuzz target placeholder: dto_roundtrip (scaffold)
fn main() {}
```

### crates/ron-app-sdk/fuzz/fuzz_targets/oap_frame_parser.rs
<a id="crates-ron-app-sdk-fuzz-fuzztargets-oapframeparser-rs"></a>

```rust
// fuzz target placeholder: oap_frame_parser (scaffold)
fn main() {}
```

### crates/ron-app-sdk/rust-toolchain.toml
<a id="crates-ron-app-sdk-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]
```

### crates/ron-app-sdk/scripts/gen_api_snapshot.sh
<a id="crates-ron-app-sdk-scripts-genapisnapshot-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# gen_api_snapshot.sh — run cargo public-api and save to docs/api-history (scaffold)
echo "api snapshot scaffold"
```

### crates/ron-app-sdk/src/cache/lru.rs
<a id="crates-ron-app-sdk-src-cache-lru-rs"></a>

```rust
//! RO:WHAT — Tiny, std-only LRU cache (size-bounded).
//! RO:WHY  — Provide a simple building block for SDK-local caches without
//!           pulling in an external LRU crate.
//! RO:INTERACTS — Wrapped by `cache::mod` to add TTL behavior and metrics.
//! RO:INVARIANTS —
//!   - Capacity is always >= 1.
//!   - Insertion is bounded: on overflow, the least-recently-used entry
//!     is evicted.
//!   - `get` and `insert` are O(n) (small n: max_entries from config).
//! RO:METRICS — None here; outer cache may emit hit/miss counters.
//! RO:CONFIG — Capacity supplied by `CacheCfg.max_entries`.
//! RO:SECURITY — In-memory only; no persistence.
//! RO:TEST — Unit tests in this module.

use std::collections::VecDeque;

/// Very small LRU cache backed by a `VecDeque`.
///
/// This is intentionally simple and does not attempt to be maximally
/// efficient; for typical SDK cache sizes (≈1k entries) an O(n) scan
/// is sufficient and keeps the implementation easy to audit.
#[derive(Debug)]
pub struct Lru<K, V> {
    capacity: usize,
    entries: VecDeque<(K, V)>,
}

impl<K, V> Lru<K, V> {
    /// Construct a new LRU with the given capacity.
    pub fn new(capacity: usize) -> Self {
        let cap = capacity.max(1);
        Self {
            capacity: cap,
            entries: VecDeque::with_capacity(cap),
        }
    }

    /// Current number of entries in the cache.
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Whether the cache is empty.
    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }
}

impl<K, V> Lru<K, V>
where
    K: Eq,
    V: Clone,
{
    /// Get a value by key, marking it as most-recently-used.
    ///
    /// Returns a cloned value. This keeps the implementation simple and
    /// avoids lifetime juggling while still being cheap for typical V.
    pub fn get(&mut self, key: &K) -> Option<V> {
        let mut hit_index = None;

        for (idx, (k, _)) in self.entries.iter().enumerate() {
            if k == key {
                hit_index = Some(idx);
                break;
            }
        }

        let idx = hit_index?;
        let (_, v) = &self.entries[idx];
        let value = v.clone();

        // Move the entry to the back if it wasn't already there.
        if idx + 1 != self.entries.len() {
            if let Some(entry) = self.entries.remove(idx) {
                self.entries.push_back(entry);
            }
        }

        Some(value)
    }

    /// Insert or replace a value.
    ///
    /// Returns the previous value for this key, if any.
    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
        // Remove existing entry if present.
        let mut old = None;
        let mut existing_index = None;

        for (idx, (k, _)) in self.entries.iter().enumerate() {
            if k == &key {
                existing_index = Some(idx);
                break;
            }
        }

        if let Some(idx) = existing_index {
            if let Some((_, v)) = self.entries.remove(idx) {
                old = Some(v);
            }
        }

        self.entries.push_back((key, value));

        // Enforce capacity.
        if self.entries.len() > self.capacity {
            let _ = self.entries.pop_front();
        }

        old
    }

    /// Remove a key from the cache, returning its value if present.
    pub fn remove(&mut self, key: &K) -> Option<V> {
        let mut index = None;
        for (idx, (k, _)) in self.entries.iter().enumerate() {
            if k == key {
                index = Some(idx);
                break;
            }
        }

        index.and_then(|idx| self.entries.remove(idx).map(|(_, v)| v))
    }
}

#[cfg(test)]
mod tests {
    use super::Lru;

    #[test]
    fn obeys_capacity_and_lru_order() {
        let mut lru = Lru::new(2);

        lru.insert("a", 1);
        lru.insert("b", 2);

        // Access "a" to make it most recent.
        assert_eq!(lru.get(&"a"), Some(1));

        // Insert "c" — should evict "b".
        lru.insert("c", 3);

        assert_eq!(lru.get(&"a"), Some(1));
        assert_eq!(lru.get(&"b"), None);
        assert_eq!(lru.get(&"c"), Some(3));
    }

    #[test]
    fn remove_works() {
        let mut lru = Lru::new(2);
        lru.insert("a", 1);
        lru.insert("b", 2);

        assert_eq!(lru.remove(&"a"), Some(1));
        assert_eq!(lru.get(&"a"), None);
        assert_eq!(lru.len(), 1);
    }
}

```

### crates/ron-app-sdk/src/cache/mod.rs
<a id="crates-ron-app-sdk-src-cache-mod-rs"></a>

```rust
//! RO:WHAT — Ephemeral TTL cache facade for SDK callers.
//! RO:WHY  — Provide a small, in-memory cache to hide repeated GETs or
//!           metadata lookups without ever touching disk (I-11 no-persistence).
//! RO:INTERACTS — Wraps `cache::lru::Lru`; driven by `CacheCfg` from config;
//!                may be used by storage/index planes later.
//! RO:INVARIANTS —
//!   - Obeys `CacheCfg.max_entries` (bounded size).
//!   - Per-entry TTL enforced on read; expired entries are evicted.
//!   - Purely in-memory, process-local; no serialization.
//! RO:METRICS — Places to hook cache hit/miss counters via `SdkMetrics`.
//! RO:CONFIG — Reads `CacheCfg { enabled, max_entries, ttl }`.
//! RO:SECURITY — Does not store secrets long-term; caller chooses what to
//!               cache. Amnesia mode may disable cache at a higher level.
//! RO:TEST — Unit tests in this module.

mod lru;

pub use lru::Lru;

use std::time::{Duration, Instant};

use crate::config::CacheCfg;

/// Internal wrapper storing value + insertion timestamp.
#[derive(Debug, Clone)]
struct Entry<V> {
    value: V,
    inserted_at: Instant,
}

impl<V> Entry<V> {
    fn new(value: V) -> Self {
        Self {
            value,
            inserted_at: Instant::now(),
        }
    }

    fn is_expired(&self, ttl: Duration) -> bool {
        self.inserted_at.elapsed() > ttl
    }
}

/// Simple TTL + size-bounded cache built on top of `Lru`.
///
/// Generic over key and value types. This is intended for relatively
/// small caches (hundreds to a few thousand entries).
#[derive(Debug)]
pub struct TtlCache<K, V> {
    cfg: CacheCfg,
    inner: Lru<K, Entry<V>>,
}

impl<K, V> TtlCache<K, V>
where
    K: Eq,
    V: Clone,
{
    /// Create a new cache from configuration.
    ///
    /// If `cfg.enabled` is false, callers should typically avoid creating
    /// the cache at all and treat this as a no-op.
    pub fn new(cfg: CacheCfg) -> Self {
        let cap = cfg.max_entries.max(1);
        Self {
            cfg,
            inner: Lru::new(cap),
        }
    }

    /// Access the underlying config.
    pub fn config(&self) -> &CacheCfg {
        &self.cfg
    }

    /// Look up a value by key, enforcing TTL.
    ///
    /// Returns `None` if the key is not present or the entry has expired.
    pub fn get(&mut self, key: &K) -> Option<V> {
        if !self.cfg.enabled {
            return None;
        }

        let ttl = self.cfg.ttl;
        if ttl.is_zero() {
            return None;
        }

        if let Some(entry) = self.inner.get(key) {
            if entry.is_expired(ttl) {
                // Evict expired entry.
                let _ = self.inner.remove(key);
                None
            } else {
                Some(entry.value)
            }
        } else {
            None
        }
    }

    /// Insert or replace a value for the given key.
    pub fn insert(&mut self, key: K, value: V) {
        if !self.cfg.enabled {
            return;
        }

        let entry = Entry::new(value);
        let _ = self.inner.insert(key, entry);
    }

    /// Remove an entry (if present).
    pub fn remove(&mut self, key: &K) {
        let _ = self.inner.remove(key);
    }

    /// Clear all entries.
    pub fn clear(&mut self) {
        // Reinitialize the LRU with the configured capacity.
        let cap = self.cfg.max_entries.max(1);
        self.inner = Lru::new(cap);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn cfg_enabled() -> CacheCfg {
        CacheCfg {
            enabled: true,
            max_entries: 2,
            ttl: Duration::from_millis(10),
        }
    }

    #[test]
    fn respects_enabled_flag() {
        let cfg = CacheCfg {
            enabled: false,
            max_entries: 2,
            ttl: Duration::from_secs(60),
        };

        let mut cache = TtlCache::new(cfg);
        cache.insert("a", 1);
        assert_eq!(cache.get(&"a"), None);
    }

    #[test]
    fn evicts_on_ttl() {
        let cfg = cfg_enabled();
        let mut cache = TtlCache::new(cfg);

        cache.insert("a", 1);
        assert_eq!(cache.get(&"a"), Some(1));

        std::thread::sleep(Duration::from_millis(15));
        assert_eq!(cache.get(&"a"), None);
    }

    #[test]
    fn respects_capacity_lru_behavior() {
        let cfg = CacheCfg {
            enabled: true,
            max_entries: 2,
            ttl: Duration::from_secs(60),
        };

        let mut cache = TtlCache::new(cfg);

        cache.insert("a", 1);
        cache.insert("b", 2);

        // Touch "a" to make it recently used.
        assert_eq!(cache.get(&"a"), Some(1));

        // Insert "c" — should evict "b".
        cache.insert("c", 3);

        assert_eq!(cache.get(&"a"), Some(1));
        assert_eq!(cache.get(&"b"), None);
        assert_eq!(cache.get(&"c"), Some(3));
    }
}

```

### crates/ron-app-sdk/src/config/mod.rs
<a id="crates-ron-app-sdk-src-config-mod-rs"></a>

```rust
//! High-level config helpers for ron-app-sdk.
//!
//! RO:WHAT — Glue for `SdkConfig`: validation + environment loader + helpers.
//! RO:WHY  — Central place for config rules so the rest of the SDK can stay
//!           boring (just read fields).
//! RO:INTERACTS — Used by `RonAppSdk::new`, examples, and tests; reads env
//!                via `SdkConfig::from_env()`.
//! RO:INVARIANTS — No panics; invalid configs surface as errors
//!                 (`anyhow::Result`); env parsing is explicit, no silent
//!                 fallbacks.

mod types;

pub use types::{
    CacheCfg, IdemCfg, Jitter, PqMode, Redaction, RetryCfg, SdkConfig, Timeouts, TorCfg,
    TracingCfg, Transport,
};

use std::{collections::HashMap, time::Duration};

use anyhow::{anyhow, bail, Result as AnyResult};

impl SdkConfig {
    /// Validate semantic invariants for this configuration.
    ///
    /// This is called automatically from `from_env` and should also be
    /// invoked by host apps that construct configs programmatically.
    pub fn validate(&self) -> AnyResult<()> {
        if self.gateway_addr.trim().is_empty() {
            bail!("gateway_addr must not be empty");
        }

        if self.retry.max_attempts == 0 {
            bail!("retry.max_attempts must be at least 1");
        }

        if self.retry.factor < 1.0 {
            bail!("retry.factor must be >= 1.0");
        }

        if self.retry.base.is_zero() {
            bail!("retry.base must be > 0");
        }

        if self.retry.cap < self.retry.base {
            bail!("retry.cap must be >= retry.base");
        }

        if self.overall_timeout < Duration::from_secs(1) {
            bail!("overall_timeout must be >= 1s");
        }

        if self.overall_timeout < self.timeouts.read
            || self.overall_timeout < self.timeouts.write
        {
            bail!("overall_timeout must be >= read/write timeouts");
        }

        if self.cache.enabled {
            if self.cache.max_entries == 0 {
                bail!("cache.max_entries must be >= 1 when cache.enabled=true");
            }
            if self.cache.ttl < Duration::from_secs(1) {
                bail!("cache.ttl must be >= 1s when cache.enabled=true");
            }
        }

        // PQ mode + Tor reachability checks can be extended later; for now
        // we just ensure the socks address is non-empty when Tor is chosen.
        if matches!(self.transport, Transport::Tor) && self.tor.socks5_addr.trim().is_empty() {
            bail!("tor.socks5_addr must not be empty when transport=tor");
        }

        Ok(())
    }

    /// Build a config from environment variables, with safe defaults.
    ///
    /// Mapping roughly follows `docs/CONFIG.md`:
    ///
    /// - `RON_SDK_TRANSPORT`              → `transport`
    /// - `RON_SDK_GATEWAY_ADDR`           → `gateway_addr`
    /// - `RON_SDK_OVERALL_TIMEOUT_MS`     → `overall_timeout`
    /// - `RON_SDK_CONNECT_TIMEOUT_MS`     → `timeouts.connect`
    /// - `RON_SDK_READ_TIMEOUT_MS`        → `timeouts.read`
    /// - `RON_SDK_WRITE_TIMEOUT_MS`       → `timeouts.write`
    /// - `RON_SDK_RETRY_BASE_MS`          → `retry.base`
    /// - `RON_SDK_RETRY_FACTOR`           → `retry.factor`
    /// - `RON_SDK_RETRY_CAP_MS`           → `retry.cap`
    /// - `RON_SDK_RETRY_MAX_ATTEMPTS`     → `retry.max_attempts`
    /// - `RON_SDK_RETRY_JITTER`           → `retry.jitter`
    /// - `RON_SDK_IDEM_ENABLED`           → `idempotency.enabled`
    /// - `RON_SDK_IDEM_PREFIX`            → `idempotency.key_prefix`
    /// - `RON_SDK_CACHE_ENABLED`          → `cache.enabled`
    /// - `RON_SDK_CACHE_MAX_ENTRIES`      → `cache.max_entries`
    /// - `RON_SDK_CACHE_TTL_MS`           → `cache.ttl`
    /// - `RON_SDK_TRACING_SPANS`          → `tracing.spans`
    /// - `RON_SDK_TRACING_METRICS`        → `tracing.metrics`
    /// - `RON_SDK_TRACING_REDACTION`      → `tracing.redaction`
    /// - `RON_SDK_PQ_MODE`                → `pq_mode`
    /// - `RON_SDK_TOR_SOCKS5_ADDR`        → `tor.socks5_addr`
    pub fn from_env() -> AnyResult<SdkConfig> {
        // FIX: pass `std::env::vars()` directly; it already implements
        // `IntoIterator<Item = (String, String)>`.
        Self::from_env_with(std::env::vars())
    }

    /// Testable helper behind `from_env` that works off an arbitrary map.
    pub(crate) fn from_env_with<I>(vars: I) -> AnyResult<SdkConfig>
    where
        I: IntoIterator<Item = (String, String)>,
    {
        let map: HashMap<_, _> = vars.into_iter().collect();
        let get = |key: &str| map.get(key).map(String::as_str);

        let mut cfg = SdkConfig::default();

        // Transport + gateway
        if let Some(v) = get("RON_SDK_TRANSPORT") {
            cfg.transport = match v.to_ascii_lowercase().as_str() {
                "tls" => Transport::Tls,
                "tor" => Transport::Tor,
                other => {
                    return Err(anyhow!(
                        "invalid RON_SDK_TRANSPORT: {other} (expected `tls` or `tor`)"
                    ));
                }
            };
        }

        if let Some(v) = get("RON_SDK_GATEWAY_ADDR") {
            cfg.gateway_addr = v.to_string();
        }

        // Timeouts (ms)
        if let Some(v) = get("RON_SDK_OVERALL_TIMEOUT_MS") {
            cfg.overall_timeout = parse_ms("RON_SDK_OVERALL_TIMEOUT_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_CONNECT_TIMEOUT_MS") {
            cfg.timeouts.connect = parse_ms("RON_SDK_CONNECT_TIMEOUT_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_READ_TIMEOUT_MS") {
            cfg.timeouts.read = parse_ms("RON_SDK_READ_TIMEOUT_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_WRITE_TIMEOUT_MS") {
            cfg.timeouts.write = parse_ms("RON_SDK_WRITE_TIMEOUT_MS", v)?;
        }

        // Retry
        if let Some(v) = get("RON_SDK_RETRY_BASE_MS") {
            cfg.retry.base = parse_ms("RON_SDK_RETRY_BASE_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_RETRY_FACTOR") {
            cfg.retry.factor = parse_f32("RON_SDK_RETRY_FACTOR", v)?;
        }

        if let Some(v) = get("RON_SDK_RETRY_CAP_MS") {
            cfg.retry.cap = parse_ms("RON_SDK_RETRY_CAP_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_RETRY_MAX_ATTEMPTS") {
            cfg.retry.max_attempts = parse_u32("RON_SDK_RETRY_MAX_ATTEMPTS", v)?;
        }

        if let Some(v) = get("RON_SDK_RETRY_JITTER") {
            cfg.retry.jitter = match v.to_ascii_lowercase().as_str() {
                "full" => Jitter::Full,
                "none" => Jitter::None,
                other => {
                    return Err(anyhow!(
                        "invalid RON_SDK_RETRY_JITTER: {other} (expected `full` or `none`)"
                    ));
                }
            };
        }

        // Idempotency
        if let Some(v) = get("RON_SDK_IDEM_ENABLED") {
            cfg.idempotency.enabled = parse_bool("RON_SDK_IDEM_ENABLED", v)?;
        }

        if let Some(v) = get("RON_SDK_IDEM_PREFIX") {
            cfg.idempotency.key_prefix = if v.is_empty() {
                None
            } else {
                Some(v.to_string())
            };
        }

        // Cache
        if let Some(v) = get("RON_SDK_CACHE_ENABLED") {
            cfg.cache.enabled = parse_bool("RON_SDK_CACHE_ENABLED", v)?;
        }

        if let Some(v) = get("RON_SDK_CACHE_MAX_ENTRIES") {
            cfg.cache.max_entries = parse_usize("RON_SDK_CACHE_MAX_ENTRIES", v)?;
        }

        if let Some(v) = get("RON_SDK_CACHE_TTL_MS") {
            cfg.cache.ttl = parse_ms("RON_SDK_CACHE_TTL_MS", v)?;
        }

        // Tracing
        if let Some(v) = get("RON_SDK_TRACING_SPANS") {
            cfg.tracing.spans = parse_bool("RON_SDK_TRACING_SPANS", v)?;
        }

        if let Some(v) = get("RON_SDK_TRACING_METRICS") {
            cfg.tracing.metrics = parse_bool("RON_SDK_TRACING_METRICS", v)?;
        }

        if let Some(v) = get("RON_SDK_TRACING_REDACTION") {
            cfg.tracing.redaction = match v.to_ascii_lowercase().as_str() {
                "safe" => Redaction::Safe,
                "none" => Redaction::None,
                other => {
                    return Err(anyhow!(
                        "invalid RON_SDK_TRACING_REDACTION: {other} (expected `safe` or `none`)"
                    ));
                }
            };
        }

        // PQ mode
        if let Some(v) = get("RON_SDK_PQ_MODE") {
            cfg.pq_mode = match v.to_ascii_lowercase().as_str() {
                "off" => PqMode::Off,
                "hybrid" => PqMode::Hybrid,
                other => {
                    return Err(anyhow!(
                        "invalid RON_SDK_PQ_MODE: {other} (expected `off` or `hybrid`)"
                    ));
                }
            };
        }

        // Tor
        if let Some(v) = get("RON_SDK_TOR_SOCKS5_ADDR") {
            cfg.tor.socks5_addr = v.to_string();
        }

        // Final semantic pass.
        cfg.validate()?;
        Ok(cfg)
    }

    /// Convenience helper for tests/examples to override a handful of fields.
    pub fn with_overrides<F>(mut self, f: F) -> SdkConfig
    where
        F: FnOnce(&mut SdkConfig),
    {
        f(&mut self);
        self
    }
}

/// Parse a boolean env value.
///
/// Accepted truthy: `1`, `true`, `yes`, `on` (case-insensitive)  
/// Accepted falsy:  `0`, `false`, `no`, `off` (case-insensitive)
fn parse_bool(key: &str, raw: &str) -> AnyResult<bool> {
    let v = raw.to_ascii_lowercase();
    match v.as_str() {
        "1" | "true" | "yes" | "on" => Ok(true),
        "0" | "false" | "no" | "off" => Ok(false),
        _ => Err(anyhow!(
            "invalid {key}: {raw} (expected boolean like true/false)"
        )),
    }
}

/// Parse an integer millisecond value.
fn parse_ms(key: &str, raw: &str) -> AnyResult<Duration> {
    let ms: u64 = raw
        .parse()
        .map_err(|e| anyhow!("invalid {key}: {raw} (expected integer ms, err={e})"))?;
    Ok(Duration::from_millis(ms))
}

fn parse_f32(key: &str, raw: &str) -> AnyResult<f32> {
    raw.parse()
        .map_err(|e| anyhow!("invalid {key}: {raw} (expected f32, err={e})"))
}

fn parse_u32(key: &str, raw: &str) -> AnyResult<u32> {
    raw.parse()
        .map_err(|e| anyhow!("invalid {key}: {raw} (expected u32, err={e})"))
}

fn parse_usize(key: &str, raw: &str) -> AnyResult<usize> {
    raw.parse()
        .map_err(|e| anyhow!("invalid {key}: {raw} (expected usize, err={e})"))
}

```

### crates/ron-app-sdk/src/config/types.rs
<a id="crates-ron-app-sdk-src-config-types-rs"></a>

```rust
//! Config data types for ron-app-sdk.
//!
//! RO:WHAT — Pure data structs/enums for SDK configuration (no I/O).
//! RO:WHY  — Keeps `mod.rs` focused on helpers and env parsing; this file
//!           is just the shape + defaults of configuration.
//! RO:INTERACTS — Re-exported by `config::mod`; consumed across planes,
//!                retry helpers, and examples.
//! RO:INVARIANTS — Serializable with `serde`; defaults are safe/hardened;
//!                 no panics or external side effects.

use std::time::Duration;

use serde::{Deserialize, Serialize};

/// Wire-protocol transport flavor: direct TLS or Tor via SOCKS5.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Transport {
    /// Direct TLS over TCP (recommended default).
    Tls,
    /// Tor via SOCKS5 (arti/tor).
    Tor,
}

/// Jitter mode for exponential backoff.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Jitter {
    /// Full jitter: 0..base (random applied later).
    Full,
    /// No jitter: always use the base delay.
    None,
}

/// Log redaction posture for the SDK.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Redaction {
    /// Redact sensitive material where possible.
    Safe,
    /// Do not redact; more verbose but less private.
    None,
}

/// Post-quantum mode for edge → node connections.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum PqMode {
    Off,
    Hybrid,
}

/// Per-connection timeout knobs (excluding the global per-call deadline).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct Timeouts {
    /// Connect timeout for establishing a new transport connection.
    #[serde(with = "humantime_serde", default = "default_connect")]
    pub connect: Duration,
    /// Read timeout on an established connection.
    #[serde(with = "humantime_serde", default = "default_read")]
    pub read: Duration,
    /// Write timeout on an established connection.
    #[serde(with = "humantime_serde", default = "default_write")]
    pub write: Duration,
}

fn default_connect() -> Duration {
    Duration::from_secs(3)
}

fn default_read() -> Duration {
    Duration::from_secs(30)
}

fn default_write() -> Duration {
    Duration::from_secs(30)
}

impl Default for Timeouts {
    fn default() -> Self {
        Self {
            connect: default_connect(),
            read: default_read(),
            write: default_write(),
        }
    }
}

/// Retry/backoff configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct RetryCfg {
    /// Base delay for the first retry attempt.
    #[serde(with = "humantime_serde", default = "default_retry_base")]
    pub base: Duration,
    /// Multiplicative factor per attempt.
    #[serde(default = "default_retry_factor")]
    pub factor: f32,
    /// Cap on backoff delay.
    #[serde(with = "humantime_serde", default = "default_retry_cap")]
    pub cap: Duration,
    /// Maximum number of attempts (including the first).
    #[serde(default = "default_retry_max_attempts")]
    pub max_attempts: u32,
    /// Jitter mode.
    #[serde(default = "default_jitter")]
    pub jitter: Jitter,
}

fn default_retry_base() -> Duration {
    Duration::from_millis(100)
}

fn default_retry_factor() -> f32 {
    2.0
}

fn default_retry_cap() -> Duration {
    Duration::from_secs(5)
}

fn default_retry_max_attempts() -> u32 {
    5
}

fn default_jitter() -> Jitter {
    Jitter::Full
}

impl Default for RetryCfg {
    fn default() -> Self {
        Self {
            base: default_retry_base(),
            factor: default_retry_factor(),
            cap: default_retry_cap(),
            max_attempts: default_retry_max_attempts(),
            jitter: default_jitter(),
        }
    }
}

/// Idempotency tuning.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct IdemCfg {
    /// Whether to attach idempotency keys by default on mutations.
    #[serde(default = "default_idem_enabled")]
    pub enabled: bool,
    /// Optional key prefix to avoid PII in idempotency keys.
    pub key_prefix: Option<String>,
}

fn default_idem_enabled() -> bool {
    true
}

impl Default for IdemCfg {
    fn default() -> Self {
        Self {
            enabled: default_idem_enabled(),
            key_prefix: None,
        }
    }
}

/// In-memory client-side cache configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct CacheCfg {
    /// Whether the cache is enabled at all.
    #[serde(default)]
    pub enabled: bool,
    /// Maximum number of entries in the LRU.
    #[serde(default = "default_cache_entries")]
    pub max_entries: usize,
    /// TTL for each entry.
    #[serde(with = "humantime_serde", default = "default_cache_ttl")]
    pub ttl: Duration,
}

fn default_cache_entries() -> usize {
    1024
}

fn default_cache_ttl() -> Duration {
    Duration::from_secs(30)
}

impl Default for CacheCfg {
    fn default() -> Self {
        Self {
            enabled: false,
            max_entries: default_cache_entries(),
            ttl: default_cache_ttl(),
        }
    }
}

/// Tracing and metrics toggles.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct TracingCfg {
    /// Emit span events for SDK calls.
    #[serde(default)]
    pub spans: bool,
    /// Emit Prometheus-style metrics from the SDK.
    #[serde(default)]
    pub metrics: bool,
    /// Redaction posture.
    #[serde(default = "default_redaction")]
    pub redaction: Redaction,
}

fn default_redaction() -> Redaction {
    Redaction::Safe
}

impl Default for TracingCfg {
    fn default() -> Self {
        Self {
            spans: true,
            metrics: true,
            redaction: default_redaction(),
        }
    }
}

/// Tor-specific configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct TorCfg {
    /// SOCKS5 address for the local Tor daemon.
    #[serde(default = "default_tor_socks")]
    pub socks5_addr: String,
}

fn default_tor_socks() -> String {
    "127.0.0.1:9050".to_string()
}

impl Default for TorCfg {
    fn default() -> Self {
        Self {
            socks5_addr: default_tor_socks(),
        }
    }
}

/// Application-facing configuration for ron-app-sdk.
///
/// This struct is intentionally "boring": just data + serde. All env
/// parsing and validation lives in `config::mod`.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default, deny_unknown_fields)]
pub struct SdkConfig {
    /// Transport flavor (`tls` or `tor`).
    pub transport: Transport,
    /// Base gateway address (URL or `.onion`).
    pub gateway_addr: String,
    /// Overall per-call deadline (including retries).
    #[serde(with = "humantime_serde", default = "default_overall_timeout")]
    pub overall_timeout: Duration,
    /// Per-connection timeouts.
    pub timeouts: Timeouts,
    /// Retry/backoff tuning.
    pub retry: RetryCfg,
    /// Idempotency tuning.
    pub idempotency: IdemCfg,
    /// Client-side cache tuning.
    pub cache: CacheCfg,
    /// Tracing/metrics toggles.
    pub tracing: TracingCfg,
    /// Post-quantum mode.
    pub pq_mode: PqMode,
    /// Tor-specific configuration.
    pub tor: TorCfg,
}

fn default_overall_timeout() -> Duration {
    // README.md suggests 5000 ms as the baseline.
    Duration::from_millis(5000)
}

impl Default for SdkConfig {
    fn default() -> Self {
        Self {
            transport: Transport::Tls,
            gateway_addr: "http://127.0.0.1:8080".to_string(),
            overall_timeout: default_overall_timeout(),
            timeouts: Timeouts::default(),
            retry: RetryCfg::default(),
            idempotency: IdemCfg::default(),
            cache: CacheCfg::default(),
            tracing: TracingCfg::default(),
            pq_mode: PqMode::Off,
            tor: TorCfg::default(),
        }
    }
}

```

### crates/ron-app-sdk/src/context.rs
<a id="crates-ron-app-sdk-src-context-rs"></a>

```rust
//! RO:WHAT — Lightweight SDK context metadata.
//! RO:WHY  — Give callers a tiny “who am I talking to?” view without
//!           ever branching semantics based on profile (see I-1).
//! RO:INTERACTS — Constructed in `RonAppSdk::new`, may be enriched
//!                later when we add a real handshake.
//! RO:INVARIANTS —
//!   - No behavior decisions are made based on `NodeProfile`.
//!   - `amnesia` is a *hint* surfaced to hosts, not a control plane.

/// Logical deployment profile of the remote node.
///
/// This is intentionally small and matches the high-level Micronode /
/// Macronode split in the RON-CORE blueprints.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NodeProfile {
    /// Micronode profile (amnesia-friendly, edge-first).
    Micronode,
    /// Macronode profile (persistent overlay / services).
    Macronode,
}

/// Small, immutable view of SDK context.
///
/// Today this is constructed from configuration + (eventually) a small
/// handshake. It is **never** used to branch semantics — that’s the
/// whole point of invariant I-1 (profile parity).
#[derive(Debug, Clone, Copy)]
pub struct SdkContext {
    /// Reported/assumed node profile (Micronode/Macronode).
    pub profile: NodeProfile,
    /// Whether the remote node is currently in “amnesia mode”.
    ///
    /// For Micronodes this often maps to “RAM-only” posture; for
    /// Macronodes this may indicate a temporary override.
    pub amnesia: bool,
}

impl SdkContext {
    /// Construct a new SDK context.
    pub fn new(profile: NodeProfile, amnesia: bool) -> Self {
        Self { profile, amnesia }
    }

    /// Get the node profile (Micronode/Macronode).
    pub fn profile(&self) -> NodeProfile {
        self.profile
    }

    /// Whether the node is in amnesia posture.
    pub fn amnesia(&self) -> bool {
        self.amnesia
    }
}

```

### crates/ron-app-sdk/src/errors.rs
<a id="crates-ron-app-sdk-src-errors-rs"></a>

```rust
//! RO:WHAT — Error taxonomy for ron-app-sdk.
//! RO:WHY  — Give applications a small, stable set of error classes
//!           they can reason about (timeouts vs caps vs conflicts).
//! RO:INTERACTS — Used across all planes and the transport shim;
//!                mapping from HTTP/OAP/wire happens here.
//! RO:INVARIANTS —
//!   - Enum is `#[non_exhaustive]` per API.md.
//!   - Retry classification is centralized here (I-5/I-8).
//! RO:SECURITY — Messages are safe for logs; no secrets included.

use std::{error::Error, fmt, time::Duration};

/// Stable, non-exhaustive SDK error type.
///
/// This matches the shape laid out in `docs/API.md`. New variants may
/// be added over time, but existing ones will not be removed or
/// renamed without a SemVer bump.
#[non_exhaustive]
#[derive(Debug)]
pub enum SdkError {
    /// Overall deadline for the operation was exceeded.
    DeadlineExceeded,

    /// Underlying transport failed (TCP, DNS, etc.).
    Transport(std::io::ErrorKind),

    /// TLS handshake/verification error.
    Tls,

    /// Tor was requested but not available/usable.
    TorUnavailable,

    /// OAP/1 protocol or bounds violation (e.g., frame too large).
    OapViolation {
        /// Human-readable reason string (static).
        reason: &'static str,
    },

    /// Capability has expired (e.g., `nbf`/`exp` window).
    CapabilityExpired,

    /// Capability does not grant access to the requested resource.
    CapabilityDenied,

    /// Schema/validation error at the SDK boundary.
    ///
    /// Examples: invalid `AddrB3` string, wrong DTO shape, etc.
    SchemaViolation {
        /// Logical path (e.g., `"addr_b3"`, `"payload.body"`).
        path: String,
        /// Short description of what went wrong.
        detail: String,
    },

    /// Resource not found (404-style).
    NotFound,

    /// Conflict (409-style) — usually idempotency or version clash.
    Conflict,

    /// Rate-limited by the remote service.
    ///
    /// Optional `retry_after` allows well-behaved exponential backoff
    /// or respect for concrete `Retry-After` hints when present.
    RateLimited {
        retry_after: Option<Duration>,
    },

    /// Remote server error with raw status code.
    Server(u16),

    /// Catch-all for errors that don’t fit other variants yet.
    Unknown(String),
}

/// Coarse retry classification for SDK errors.
///
/// This keeps the retry/backoff logic in one place and lets callers
/// apply their own policies if they want something fancier.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RetryClass {
    /// Retrying *may* succeed (timeouts, 5xx, backpressure).
    Retriable,
    /// Retrying is not expected to help (caps, schema, conflicts).
    NoRetry,
}

impl SdkError {
    /// Create a schema violation error with structured fields.
    pub fn schema_violation(path: impl Into<String>, detail: impl Into<String>) -> Self {
        SdkError::SchemaViolation {
            path: path.into(),
            detail: detail.into(),
        }
    }

    /// Create a rate-limited error with optional retry hint.
    pub fn rate_limited(retry_after: Option<Duration>) -> Self {
        SdkError::RateLimited { retry_after }
    }

    /// Map an IO error into the transport bucket.
    pub fn from_io(err: std::io::Error) -> Self {
        SdkError::Transport(err.kind())
    }

    /// Classify this error for retry purposes.
    pub fn retry_class(&self) -> RetryClass {
        use RetryClass::{NoRetry, Retriable};

        match *self {
            SdkError::DeadlineExceeded => Retriable,
            SdkError::Transport(_) => Retriable,
            SdkError::RateLimited { .. } => Retriable,
            SdkError::Server(code) if (500..600).contains(&code) => Retriable,

            // Everything else we conservatively treat as non-retriable.
            SdkError::Tls
            | SdkError::TorUnavailable
            | SdkError::OapViolation { .. }
            | SdkError::CapabilityExpired
            | SdkError::CapabilityDenied
            | SdkError::SchemaViolation { .. }
            | SdkError::NotFound
            | SdkError::Conflict
            | SdkError::Server(_)
            | SdkError::Unknown(_) => NoRetry,
        }
    }

    /// Convenience helper.
    pub fn is_retriable(&self) -> bool {
        self.retry_class() == RetryClass::Retriable
    }
}

impl fmt::Display for SdkError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use SdkError::*;

        match self {
            DeadlineExceeded => write!(f, "deadline exceeded"),
            Transport(kind) => write!(f, "transport error ({kind:?})"),
            Tls => write!(f, "TLS error"),
            TorUnavailable => write!(f, "Tor transport unavailable"),
            OapViolation { reason } => write!(f, "OAP violation: {reason}"),
            CapabilityExpired => write!(f, "capability expired"),
            CapabilityDenied => write!(f, "capability denied"),
            SchemaViolation { path, detail } => {
                write!(f, "schema violation at `{path}`: {detail}")
            }
            NotFound => write!(f, "not found"),
            Conflict => write!(f, "conflict"),
            RateLimited { retry_after } => {
                if let Some(d) = retry_after {
                    write!(f, "rate limited (retry after {d:?})")
                } else {
                    write!(f, "rate limited")
                }
            }
            Server(code) => write!(f, "server error ({code})"),
            Unknown(msg) => write!(f, "unknown error: {msg}"),
        }
    }
}

impl Error for SdkError {}

```

### crates/ron-app-sdk/src/idempotency.rs
<a id="crates-ron-app-sdk-src-idempotency-rs"></a>

```rust
//! RO:WHAT — Idempotency key derivation + header mapping helpers.
//! RO:WHY  — Give applications a deterministic, low-PII way to derive
//!           idempotency keys for “logical operations” (governance I-G1).
//! RO:INTERACTS — Uses `crate::config::IdemCfg`; will be used by planes
//!                (storage/mailbox/index) and transport wrappers.
//! RO:INVARIANTS —
//!   - Never generates two different keys for the same logical op.
//!   - Stable across process restarts (pure function of inputs).
//!   - No randomness; no dependency on wall-clock time.
//!   - No PII baked into the key string when a prefix is used.
//! RO:METRICS — None directly (planes may emit counters per idempotent call).
//! RO:CONFIG — Reads `IdemCfg { enabled, key_prefix }`.
//! RO:SECURITY — Keys are opaque 64-bit fingerprints; callers should avoid
//!               embedding raw PII into the “logical_key” input.
//! RO:TEST — Unit tests in this module (determinism + collision sanity).

use std::collections::hash_map::DefaultHasher;
use std::fmt;
use std::hash::{Hash, Hasher};

use crate::config::IdemCfg;

/// Default HTTP header name for idempotency keys.
///
/// This is a *convention*, not a hard requirement. Some hosts may
/// prefer a different header name at the gateway level.
pub const IDEMPOTENCY_HEADER: &str = "Idempotency-Key";

/// Opaque idempotency key value.
///
/// Internally represented as a string, but we keep it wrapped so the
/// semantics remain clear and we can refine the format later without
/// breaking callers.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdempotencyKey(String);

impl IdempotencyKey {
    /// Access the underlying string.
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Consume and return the underlying string.
    pub fn into_string(self) -> String {
        self.0
    }

    /// Convenience helper to turn this key into a `(header_name, value)` pair.
    pub fn into_header(self) -> (String, String) {
        (IDEMPOTENCY_HEADER.to_string(), self.0)
    }
}

impl fmt::Display for IdempotencyKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

/// Derive an idempotency key for a logical operation.
///
/// Inputs:
/// - `cfg` — idempotency configuration (enable/disable, optional prefix).
/// - `method` — logical verb (e.g., "PUT", "POST"); case-insensitive.
/// - `endpoint` — stable endpoint identifier (path or logical name).
/// - `logical_key` — caller-defined identifier for the logical op
///   (e.g., order ID, manifest ID). May be `None` for simple cases.
///
/// Returns `None` when idempotency is disabled in config.
pub fn derive_idempotency_key(
    cfg: &IdemCfg,
    method: &str,
    endpoint: &str,
    logical_key: Option<&str>,
) -> Option<IdempotencyKey> {
    if !cfg.enabled {
        return None;
    }

    // Normalize inputs into a single logical string.
    let method_norm = method.to_ascii_uppercase();
    let endpoint_norm = endpoint.trim();

    let logical_norm = logical_key.unwrap_or("").trim();

    let fingerprint = stable_fingerprint(&format!(
        "{}\n{}\n{}",
        method_norm, endpoint_norm, logical_norm
    ));

    // Optional prefix helps keep keys non-PII even if logical_key has
    // some user-provided content.
    let prefix = cfg
        .key_prefix
        .as_deref()
        .unwrap_or("ron"); // short + recognizable.

    let key = format!("{prefix}_{fingerprint:016x}");
    Some(IdempotencyKey(key))
}

/// Internal helper — 64-bit stable fingerprint using the standard hasher.
///
/// This is *not* cryptographic and is not intended for security; it’s
/// just a low-collision, deterministic fingerprint for idempotency.
fn stable_fingerprint(input: &str) -> u64 {
    let mut h = DefaultHasher::new();
    input.hash(&mut h);
    h.finish()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn disabled_returns_none() {
        let cfg = IdemCfg {
            enabled: false,
            key_prefix: None,
        };
        let key = derive_idempotency_key(&cfg, "POST", "/storage/put", Some("abc"));
        assert!(key.is_none());
    }

    #[test]
    fn same_inputs_same_key() {
        let cfg = IdemCfg {
            enabled: true,
            key_prefix: Some("test".to_string()),
        };

        let a = derive_idempotency_key(&cfg, "POST", "/storage/put", Some("abc")).unwrap();
        let b = derive_idempotency_key(&cfg, "post", " /storage/put ", Some("abc")).unwrap();

        assert_eq!(a, b);
    }

    #[test]
    fn different_logical_key_changes_fingerprint() {
        let cfg = IdemCfg {
            enabled: true,
            key_prefix: Some("test".to_string()),
        };

        let a = derive_idempotency_key(&cfg, "POST", "/storage/put", Some("abc")).unwrap();
        let b = derive_idempotency_key(&cfg, "POST", "/storage/put", Some("def")).unwrap();

        assert_ne!(a, b);
    }
}

```

### crates/ron-app-sdk/src/lib.rs
<a id="crates-ron-app-sdk-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]
//! ron-app-sdk — Application SDK for RON-CORE.
//!
//! RO:WHAT — Tiny async client façade over Micronode/Macronode node
//!           surfaces (edge, storage, mailbox, index).
//! RO:WHY  — Give apps a boring, well-typed, capability-first client
//!           with consistent retries, deadlines, and DTO hygiene.
//! RO:INTERACTS —
//!   - `config` for `SdkConfig` + env loading/validation.
//!   - `transport` for OAP/1 calls (TLS/Tor).
//!   - `planes::*` for storage/edge/mailbox/index helpers.
//!   - `metrics`/`tracing` for observability hooks.
//! RO:INVARIANTS —
//!   - All outbound calls carry a capability (I-2).
//!   - No semantic branching on `NodeProfile` (I-1).
//!   - OAP frame cap is enforced in the transport layer (I-3).

pub mod cache;
pub mod config;
mod context;
pub mod errors;
mod idempotency;
pub mod metrics;
mod ready;
mod retry;
mod tracing;
pub mod transport;
mod types;

// Planes: defined as a nested module so we can keep each plane in a
// dedicated file under `src/planes/`.
pub mod planes {
    pub mod storage;
    pub mod edge;
    pub mod mailbox;
    pub mod index;
}

pub use context::{NodeProfile, SdkContext};
pub use errors::{RetryClass, SdkError};
pub use ready::{check_ready, ReadyReport};
pub use types::{
    Ack, AddrB3, ByteRange, Capability, IdemKey, IndexKey, Mail, MailInbox, Receipt,
};

pub use config::{
    CacheCfg, IdemCfg, Jitter, PqMode, Redaction, SdkConfig, Timeouts, TorCfg, TracingCfg,
    Transport,
};

pub use metrics::{NoopSdkMetrics, SdkMetrics};

use bytes::Bytes;
use std::time::Duration;

use context::NodeProfile as CtxProfile;
use transport::TransportHandle;

/// High-level async client façade for RON-CORE nodes.
///
/// Constructed from `SdkConfig` and a (future) handshake, and then
/// used to issue calls to the various planes (storage, edge, mailbox,
/// index) with consistent deadlines/retries/error handling.
pub struct RonAppSdk {
    transport: TransportHandle,
    ctx: SdkContext,
    metrics: Box<dyn SdkMetrics>,
}

impl RonAppSdk {
    /// Create a new SDK client from configuration.
    ///
    /// This validates the config and prepares internal handles. In
    /// future revisions it may perform a light handshake to fill in
    /// `SdkContext` with accurate profile/amnesia metadata.
    pub async fn new(cfg: SdkConfig) -> Result<RonAppSdk, SdkError> {
        // Fail-closed on invalid config.
        cfg.validate()
            .map_err(|err| SdkError::schema_violation("config", err.to_string()))?;

        let transport = TransportHandle::new(cfg);
        // Until a real handshake exists, assume Micronode + non-amnesia.
        let ctx = SdkContext::new(CtxProfile::Micronode, false);

        Ok(RonAppSdk {
            transport,
            ctx,
            metrics: Box::<NoopSdkMetrics>::default(),
        })
    }

    /// Expose the SDK context (profile + amnesia hint).
    pub fn context(&self) -> SdkContext {
        self.ctx
    }

    /// Get a reference to the metrics sink.
    pub fn metrics(&self) -> &dyn SdkMetrics {
        &*self.metrics
    }

    /// Mutably access the metrics sink.
    pub fn metrics_mut(&mut self) -> &mut dyn SdkMetrics {
        &mut *self.metrics
    }

    /// Replace the metrics sink with a custom implementation.
    pub fn set_metrics<M>(&mut self, metrics: M)
    where
        M: SdkMetrics + 'static,
    {
        self.metrics = Box::new(metrics);
    }

    // -------------- Mailbox plane --------------

    /// Send a message via the mailbox plane.
    pub async fn mailbox_send(
        &self,
        cap: Capability,
        msg: Mail,
        deadline: Duration,
        idem: Option<IdemKey>,
    ) -> Result<Receipt, SdkError> {
        planes::mailbox::mailbox_send(
            &self.transport,
            &*self.metrics,
            cap,
            msg,
            deadline,
            idem,
        )
        .await
    }

    /// Receive messages from the mailbox plane.
    pub async fn mailbox_recv(
        &self,
        cap: Capability,
        deadline: Duration,
    ) -> Result<Vec<MailInbox>, SdkError> {
        planes::mailbox::mailbox_recv(&self.transport, &*self.metrics, cap, deadline).await
    }

    /// Acknowledge mailbox messages.
    pub async fn mailbox_ack(
        &self,
        cap: Capability,
        ack: Receipt,
        deadline: Duration,
    ) -> Result<(), SdkError> {
        planes::mailbox::mailbox_ack(&self.transport, &*self.metrics, cap, ack, deadline)
            .await
    }

    // -------------- Edge plane --------------

    /// Fetch an edge resource with an optional byte range.
    pub async fn edge_get(
        &self,
        cap: Capability,
        path: &str,
        range: Option<ByteRange>,
        deadline: Duration,
    ) -> Result<Bytes, SdkError> {
        planes::edge::edge_get(&self.transport, &*self.metrics, cap, path, range, deadline)
            .await
    }

    // -------------- Storage plane --------------

    /// Perform a content-addressed GET from the storage plane.
    ///
    /// `addr_b3_hex` must be a `"b3:<64 hex>"` string; invalid values
    /// are reported as `SdkError::SchemaViolation`.
    pub async fn storage_get(
        &self,
        cap: Capability,
        addr_b3_hex: &str,
        deadline: Duration,
    ) -> Result<Bytes, SdkError> {
        let addr = AddrB3::parse(addr_b3_hex)
            .map_err(|err| SdkError::schema_violation("addr_b3", err.to_string()))?;

        planes::storage::storage_get(&self.transport, &*self.metrics, cap, &addr, deadline)
            .await
    }

    /// Perform a content-addressed PUT to the storage plane.
    pub async fn storage_put(
        &self,
        cap: Capability,
        blob: Bytes,
        deadline: Duration,
        idem: Option<IdemKey>,
    ) -> Result<AddrB3, SdkError> {
        planes::storage::storage_put(
            &self.transport,
            &*self.metrics,
            cap,
            blob,
            deadline,
            idem,
        )
        .await
    }

    // -------------- Index plane --------------

    /// Resolve a logical index key into a content address.
    pub async fn index_resolve(
        &self,
        cap: Capability,
        key: &IndexKey,
        deadline: Duration,
    ) -> Result<AddrB3, SdkError> {
        planes::index::index_resolve(&self.transport, &*self.metrics, cap, key, deadline)
            .await
    }
}

```

### crates/ron-app-sdk/src/metrics.rs
<a id="crates-ron-app-sdk-src-metrics-rs"></a>

```rust
//! RO:WHAT — Minimal metrics facade for SDK operations.
//! RO:WHY  — Give hosts a single, stable trait they can implement using
//!           Prometheus, OpenTelemetry, or their own metrics stack.
//! RO:INTERACTS — Intended to be threaded through planes (storage/edge/
//!                mailbox/index) and caches; default impl is no-op.
//! RO:INVARIANTS —
//!   - No global state; host controls concrete implementation.
//!   - No dependency on any metrics crate (Prometheus/Otel lives outside).
//!   - Low-cardinality labels: endpoints should be path-like, not per-ID.
//! RO:METRICS — Shape only; concrete counters/histograms are defined by hosts.
//! RO:CONFIG — Typically driven by `TracingCfg.metrics` and host config.
//! RO:SECURITY — Callers should avoid using PII-heavy label values.
//! RO:TEST — Basic unit tests for the no-op implementation.

/// High-level metrics trait for SDK operations.
///
/// Host applications can implement this trait using whatever metrics
/// framework they prefer. The SDK only cares about the *shape* of the
/// metrics, not how they are exported.
pub trait SdkMetrics: Send + Sync + 'static {
    /// Observe latency of a single SDK call (in milliseconds).
    ///
    /// `endpoint` should be a low-cardinality identifier such as a path
    /// (`/storage/put`) or logical name (`storage_put`).
    fn observe_latency(&self, endpoint: &str, success: bool, latency_ms: u64);

    /// Increment the retry counter for a given endpoint.
    fn inc_retry(&self, endpoint: &str);

    /// Increment a failure counter tagged with a coarse reason.
    fn inc_failure(&self, endpoint: &str, reason: &'static str);

    /// Count cache hits for SDK-level caches (if used).
    fn inc_cache_hit(&self, endpoint: &str);

    /// Count cache misses for SDK-level caches (if used).
    fn inc_cache_miss(&self, endpoint: &str);
}

/// No-op metrics implementation (default).
///
/// This is useful for tests, examples, and hosts that do not care about
/// metrics. All methods are intentionally zero-cost.
#[derive(Debug, Default, Clone, Copy)]
pub struct NoopSdkMetrics;

impl SdkMetrics for NoopSdkMetrics {
    #[inline]
    fn observe_latency(&self, _endpoint: &str, _success: bool, _latency_ms: u64) {
        // no-op
    }

    #[inline]
    fn inc_retry(&self, _endpoint: &str) {
        // no-op
    }

    #[inline]
    fn inc_failure(&self, _endpoint: &str, _reason: &'static str) {
        // no-op
    }

    #[inline]
    fn inc_cache_hit(&self, _endpoint: &str) {
        // no-op
    }

    #[inline]
    fn inc_cache_miss(&self, _endpoint: &str) {
        // no-op
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn noop_is_send_sync_static() {
        fn assert_bounds<T: SdkMetrics>() {}
        assert_bounds::<NoopSdkMetrics>();
    }
}

```

### crates/ron-app-sdk/src/planes/edge.rs
<a id="crates-ron-app-sdk-src-planes-edge-rs"></a>

```rust
//! RO:WHAT — Edge plane helpers (path + optional byte ranges).
//! RO:WHY  — Hide raw OAP details and present a simple interface for
//!           fetching edge assets via capabilities.
//! RO:INTERACTS — Will call into `TransportHandle::call_oap` once
//!                wired; uses `SdkMetrics` for latency/retry metrics.
//! RO:INVARIANTS —
//!   - Range requests are expressed with `ByteRange` from `ron-proto`.
//!   - Callers must supply a deadline per request.

use std::time::Duration;

use bytes::Bytes;

use crate::errors::SdkError;
use crate::metrics::SdkMetrics;
use crate::transport::TransportHandle;
use crate::types::{ByteRange, Capability};

/// Fetch an edge resource with an optional byte range.
pub async fn edge_get(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    path: &str,
    range: Option<ByteRange>,
    deadline: Duration,
) -> Result<Bytes, SdkError> {
    let _ = (transport, metrics, cap, path, range, deadline);
    todo!("edge_get not implemented yet");
}

```

### crates/ron-app-sdk/src/planes/index.rs
<a id="crates-ron-app-sdk-src-planes-index-rs"></a>

```rust
//! RO:WHAT — Index plane helpers (logical key → content address).
//! RO:WHY  — Provide a small, typed interface for resolving logical
//!           keys (names) to BLAKE3 content IDs.
//! RO:INTERACTS — Will call into `TransportHandle::call_oap` once
//!                wired; uses `SdkMetrics` for latency/retry metrics.
//! RO:INVARIANTS —
//!   - No mutation; this is a read-only plane at the SDK level.
//!   - Deadline is supplied per call by the host.

use std::time::Duration;

use crate::errors::SdkError;
use crate::metrics::SdkMetrics;
use crate::transport::TransportHandle;
use crate::types::{AddrB3, Capability, IndexKey};

/// Resolve a logical `IndexKey` into a content address (`AddrB3`).
pub async fn index_resolve(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    key: &IndexKey,
    deadline: Duration,
) -> Result<AddrB3, SdkError> {
    let _ = (transport, metrics, cap, key, deadline);
    todo!("index_resolve not implemented yet");
}

```

### crates/ron-app-sdk/src/planes/mailbox.rs
<a id="crates-ron-app-sdk-src-planes-mailbox-rs"></a>

```rust
//! RO:WHAT — Mailbox plane helpers (send/recv/ack trio).
//! RO:WHY  — Provide a simple at-least-once-style interface for
//!           application messaging, while leaving ordering and
//!           de-duplication policies to the host and higher layers.
//! RO:INTERACTS — Will call into `TransportHandle::call_oap` once
//!                wired; uses `SdkMetrics` for latency/retry metrics.
//! RO:INVARIANTS —
//!   - Idempotency keys (if any) are attached at the SDK level.
//!   - No persistence beyond what the remote mailbox service provides.

use std::time::Duration;

use crate::errors::SdkError;
use crate::metrics::SdkMetrics;
use crate::transport::TransportHandle;
use crate::types::{Capability, IdemKey, Mail, MailInbox, Receipt};

/// Send a message via the mailbox plane.
pub async fn mailbox_send(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    msg: Mail,
    deadline: Duration,
    idem: Option<IdemKey>,
) -> Result<Receipt, SdkError> {
    let _ = (transport, metrics, cap, msg, deadline, idem);
    todo!("mailbox_send not implemented yet");
}

/// Receive messages from the mailbox plane.
///
/// Concrete semantics (poll vs. long-poll vs. stream) are handled by
/// the underlying service; the SDK just exposes a batch-friendly DTO.
pub async fn mailbox_recv(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    deadline: Duration,
) -> Result<Vec<MailInbox>, SdkError> {
    let _ = (transport, metrics, cap, deadline);
    todo!("mailbox_recv not implemented yet");
}

/// Acknowledge mailbox messages by ID.
pub async fn mailbox_ack(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    receipt: Receipt,
    deadline: Duration,
) -> Result<(), SdkError> {
    let _ = (transport, metrics, cap, receipt, deadline);
    todo!("mailbox_ack not implemented yet");
}

```

### crates/ron-app-sdk/src/planes/mod.rs
<a id="crates-ron-app-sdk-src-planes-mod-rs"></a>

```rust
//! planes/mod.rs — re-exports for edge/storage/mailbox/index (scaffold).
pub mod storage;
pub mod edge;
pub mod mailbox;
pub mod index;
```

### crates/ron-app-sdk/src/planes/storage.rs
<a id="crates-ron-app-sdk-src-planes-storage-rs"></a>

```rust
//! RO:WHAT — Storage plane helpers (content-addressed GET/PUT).
//! RO:WHY  — Keep storage-specific behavior (addresses, verify,
//!           retries) out of the generic transport layer and the
//!           high-level `RonAppSdk` facade.
//! RO:INTERACTS — Will call into `TransportHandle::call_oap` once
//!                wired; uses `SdkMetrics` for latency/retry metrics.
//! RO:INVARIANTS —
//!   - Content addressed via `AddrB3`.
//!   - Single-call deadlines are enforced by the caller.
//!   - Idempotency keys are provided by higher layers.

use std::time::Duration;

use bytes::Bytes;

use crate::errors::SdkError;
use crate::metrics::SdkMetrics;
use crate::transport::TransportHandle;
use crate::types::{AddrB3, Capability, IdemKey};

/// Perform a content-addressed GET from the storage plane.
///
/// Rough facade for `GET /storage/{addr}` in the Micronode/Macronode
/// surface once wired.
pub async fn storage_get(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    addr: &AddrB3,
    deadline: Duration,
) -> Result<Bytes, SdkError> {
    let _ = (transport, metrics, cap, addr, deadline);
    todo!("storage_get not implemented yet");
}

/// Perform a content-addressed PUT to the storage plane.
///
/// The SDK is responsible for respecting idempotency configuration and
/// retry posture; terminal verification (re-read and BLAKE3 check) is
/// optional and may be added later.
pub async fn storage_put(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    blob: Bytes,
    deadline: Duration,
    idem: Option<IdemKey>,
) -> Result<AddrB3, SdkError> {
    let _ = (transport, metrics, cap, blob, deadline, idem);
    todo!("storage_put not implemented yet");
}

```

### crates/ron-app-sdk/src/ready.rs
<a id="crates-ron-app-sdk-src-ready-rs"></a>

```rust
//! RO:WHAT — Lightweight readiness probe for ron-app-sdk.
//! RO:WHY  — Give hosts a simple, synchronous way to ask “is this SDK
//!           configuration plausibly usable?” without performing any
//!           network I/O.
//! RO:INTERACTS — Uses `SdkConfig::validate()` plus some direct checks
//!                on transport profile (e.g., Tor SOCKS addr).
//! RO:INVARIANTS —
//!   - Purely in-process; no sockets, no DNS.
//!   - Never panics; all issues are reflected in `missing` + flags.
//! RO:SECURITY — Does not log or expose secrets; only high-level flags.

use crate::config::{SdkConfig, Transport};

/// Readiness summary for the SDK.
///
/// This is intentionally small and boring so host applications can
/// translate it into whatever readiness surface they prefer
/// (`/readyz`, health widgets, etc.).
#[derive(Debug, Clone)]
pub struct ReadyReport {
    /// `true` if `SdkConfig::validate()` succeeded.
    pub config_ok: bool,
    /// `true` if the selected transport profile is internally consistent.
    pub transport_ok: bool,
    /// For Tor profiles, whether the SOCKS endpoint is usable at the
    /// *config* level (non-empty); `None` when transport != Tor.
    pub tor_ok: Option<bool>,
    /// High-level reasons why readiness is not yet achieved.
    ///
    /// This is intentionally coarse (e.g., "config", "tor_socks5_addr")
    /// so it can be safely surfaced in logs and UIs.
    pub missing: Vec<&'static str>,
}

impl ReadyReport {
    /// Convenience getter: overall readiness.
    ///
    /// Hosts are free to apply stricter policies, but this is a
    /// sensible default: config + transport OK and Tor (if used) OK.
    pub fn is_ready(&self) -> bool {
        self.config_ok && self.transport_ok && self.tor_ok.unwrap_or(true)
    }
}

/// Evaluate SDK readiness based on configuration alone.
///
/// This does **not** attempt any network calls, TLS handshakes, or Tor
/// reachability tests. Those belong in higher-level smoke checks. Here
/// we only ask “would it even make sense to construct a client?”
pub fn check_ready(cfg: &SdkConfig) -> ReadyReport {
    let mut missing = Vec::new();

    // 1) Config validation (semantic invariants from CONFIG.md).
    let config_ok = cfg.validate().is_ok();
    if !config_ok {
        missing.push("config");
    }

    // 2) Transport profile.
    let mut transport_ok = true;
    let mut tor_ok = None;

    match cfg.transport {
        Transport::Tls => {
            // Nothing extra to check here for now — TLS reachability lives
            // in the underlying transport (ron-transport) and smoke tests.
        }
        Transport::Tor => {
            if cfg.tor.socks5_addr.trim().is_empty() {
                transport_ok = false;
                tor_ok = Some(false);
                missing.push("tor_socks5_addr");
            } else {
                tor_ok = Some(true);
            }
        }
    }

    ReadyReport {
        config_ok,
        transport_ok,
        tor_ok,
        missing,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{
        CacheCfg, IdemCfg, Jitter, PqMode, Redaction, RetryCfg, Timeouts, TorCfg, TracingCfg,
    };
    use std::time::Duration;

    fn baseline_cfg() -> SdkConfig {
        SdkConfig {
            transport: Transport::Tls,
            gateway_addr: "https://example.invalid".to_string(),
            overall_timeout: Duration::from_secs(30),
            timeouts: Timeouts {
                connect: Duration::from_secs(5),
                read: Duration::from_secs(10),
                write: Duration::from_secs(10),
            },
            retry: RetryCfg {
                base: Duration::from_millis(100),
                factor: 2.0,
                cap: Duration::from_secs(5),
                max_attempts: 3,
                jitter: Jitter::Full,
            },
            idempotency: IdemCfg {
                enabled: true,
                key_prefix: Some("test".to_string()),
            },
            cache: CacheCfg {
                enabled: false,
                max_entries: 0,
                ttl: Duration::from_secs(0),
            },
            tracing: TracingCfg {
                spans: true,
                metrics: true,
                redaction: Redaction::Safe,
            },
            pq_mode: PqMode::Off,
            tor: TorCfg {
                socks5_addr: String::new(),
            },
        }
    }

    #[test]
    fn tls_baseline_is_ready() {
        let cfg = baseline_cfg();
        let report = check_ready(&cfg);
        assert!(report.config_ok);
        assert!(report.transport_ok);
        assert_eq!(report.tor_ok, None);
        assert!(report.is_ready());
        assert!(report.missing.is_empty());
    }

    #[test]
    fn tor_without_socks_addr_is_not_ready() {
        let mut cfg = baseline_cfg();
        cfg.transport = Transport::Tor;
        cfg.tor.socks5_addr.clear();

        let report = check_ready(&cfg);

        // This is an invalid config (Tor + empty SOCKS addr),
        // so `config_ok` should be false.
        assert!(!report.config_ok);
        assert!(!report.transport_ok);
        assert_eq!(report.tor_ok, Some(false));
        assert!(!report.is_ready());
        assert!(report.missing.contains(&"config"));
        assert!(report.missing.contains(&"tor_socks5_addr"));
    }

    #[test]
    fn tor_with_socks_addr_becomes_ready() {
        let mut cfg = baseline_cfg();
        cfg.transport = Transport::Tor;
        cfg.tor.socks5_addr = "127.0.0.1:9050".to_string();

        let report = check_ready(&cfg);
        assert!(report.config_ok);
        assert!(report.transport_ok);
        assert_eq!(report.tor_ok, Some(true));
        assert!(report.is_ready());
    }
}

```

### crates/ron-app-sdk/src/retry.rs
<a id="crates-ron-app-sdk-src-retry-rs"></a>

```rust
//! Retry and backoff helpers for ron-app-sdk.
//!
//! RO:WHAT — Exponential backoff schedule helpers driven by `RetryCfg`.
//! RO:WHY  — Central place for retry math so all planes behave consistently.
//! RO:INTERACTS — Used by edge/storage/mailbox/index planes and examples.
//! RO:INVARIANTS — Pure functions; no I/O; no sleeping; jitter kept within
//!                 bounds (currently deterministic, ready for real jitter).

use std::time::Duration;

use crate::config::{Jitter, RetryCfg};

/// Compute the base (non-jittered) delay for a given attempt index.
///
/// `attempt` is zero-based: 0 → first retry, 1 → second, etc.
pub fn base_delay(cfg: &RetryCfg, attempt: u32) -> Duration {
    if attempt == 0 {
        return cfg.base;
    }

    let factor = cfg.factor.max(1.0) as f64;
    let base_ms = cfg.base.as_millis() as f64;
    let pow = factor.powi(attempt as i32);

    let mut ms = (base_ms * pow).round();
    let cap_ms = cfg.cap.as_millis() as f64;

    if ms > cap_ms {
        ms = cap_ms;
    }

    Duration::from_millis(ms as u64)
}

/// Apply jitter to a base delay.
///
/// For now `Jitter::Full` does not introduce randomness yet; it simply
/// returns the base delay. This keeps the implementation deterministic.
/// In a later revision we can introduce true full jitter using `rand`
/// once the dependency is wired and property tests are in place.
pub fn apply_jitter(base: Duration, jitter: Jitter) -> Duration {
    match jitter {
        Jitter::None => base,
        Jitter::Full => base,
    }
}

/// Iterator over retry delays according to the given configuration.
///
/// This does **not** sleep; callers are responsible for awaiting between
/// iterations.
pub fn backoff_schedule<'a>(cfg: &'a RetryCfg) -> impl Iterator<Item = Duration> + 'a {
    (0..cfg.max_attempts).map(move |attempt| {
        let base = base_delay(cfg, attempt);
        apply_jitter(base, cfg.jitter)
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn schedule_is_monotonic_and_capped() {
        let cfg = RetryCfg::default();
        let mut last = Duration::ZERO;
        for d in backoff_schedule(&cfg) {
            assert!(d >= last);
            assert!(d <= cfg.cap);
            last = d;
        }
    }
}

```

### crates/ron-app-sdk/src/tracing.rs
<a id="crates-ron-app-sdk-src-tracing-rs"></a>

```rust
//! RO:WHAT — Span/field helper utilities for SDK calls.
//! RO:WHY  — Keep span naming/redaction/correlation consistent across
//!           storage/edge/mailbox/index planes without hardwiring to
//!           any particular tracing backend.
//! RO:INTERACTS — Uses `TracingCfg` + `Redaction` from `config`; callers
//!                may translate `SpanFields` into actual `tracing` spans.
//! RO:INVARIANTS —
//!   - Does not depend on external tracing crates (pure data only).
//!   - Redaction rules centralized and testable.
//!   - Endpoint field is stable and low-cardinality (path-like).
//! RO:METRICS — None directly; fields are reused by metrics labels.
//! RO:CONFIG — Reads `TracingCfg { spans, metrics, redaction }`.
//! RO:SECURITY — Redaction mode aims to strip query strings and obvious
//!               identifiers from endpoints when `Redaction::Safe`.
//! RO:TEST — Unit tests for redaction + field shaping.

use std::borrow::Cow;
use std::time::Duration;

use crate::config::{Redaction, TracingCfg};

/// Data model for span fields that SDK callers may attach to a tracing span.
///
/// This keeps the *shape* of our tracing consistent without forcing a
/// particular tracing backend into the SDK crate.
#[derive(Debug, Clone)]
pub struct SpanFields<'a> {
    /// Stable endpoint identifier (e.g., `/storage/put`).
    pub endpoint: Cow<'a, str>,
    /// Retry attempt number (0 == first attempt).
    pub attempt: u32,
    /// Deadline in milliseconds from "now" when the call started.
    pub deadline_ms: u64,
    /// Optional correlation ID propagated from the caller.
    pub corr_id: Option<Cow<'a, str>>,
}

/// Convenience function to build span fields for an SDK call.
///
/// Callers can use this to populate a `tracing::Span`, log entry, or
/// metrics label set; the SDK itself remains backend-agnostic.
pub fn build_span_fields<'a>(
    cfg: &TracingCfg,
    endpoint: &'a str,
    attempt: u32,
    overall_deadline: Duration,
    corr_id: Option<&'a str>,
) -> Option<SpanFields<'a>> {
    if !cfg.spans {
        // Spans disabled at config level — callers can short-circuit.
        return None;
    }

    let endpoint_field = match cfg.redaction {
        Redaction::Safe => redact_endpoint(endpoint),
        Redaction::None => Cow::Borrowed(endpoint),
    };

    let deadline_ms = overall_deadline.as_millis() as u64;
    let corr_field = corr_id
        .map(|v| Cow::Owned(v.to_string()));

    Some(SpanFields {
        endpoint: endpoint_field,
        attempt,
        deadline_ms,
        corr_id: corr_field,
    })
}

/// Apply a conservative redaction policy to endpoint strings.
///
/// Current policy:
/// - Strip query strings (`?…`).
/// - Collapse multiple consecutive slashes.
/// - Leave path segments untouched (gateway should avoid PII in paths).
fn redact_endpoint(raw: &str) -> Cow<'_, str> {
    let mut s = raw;

    if let Some(idx) = raw.find('?') {
        s = &raw[..idx];
    }

    // Simple collapse of "//" → "/" to avoid noisy paths.
    if s.contains("//") {
        let collapsed = s
            .split('/')
            .filter(|seg| !seg.is_empty())
            .collect::<Vec<_>>()
            .join("/");
        Cow::Owned(format!("/{}", collapsed))
    } else {
        Cow::Borrowed(s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn spans_disabled_returns_none() {
        let cfg = TracingCfg {
            spans: false,
            metrics: true,
            redaction: Redaction::Safe,
        };

        let out = build_span_fields(&cfg, "/storage/put", 0, Duration::from_millis(5000), None);
        assert!(out.is_none());
    }

    #[test]
    fn strips_query_and_collapses_slashes() {
        let cfg = TracingCfg {
            spans: true,
            metrics: true,
            redaction: Redaction::Safe,
        };

        let out = build_span_fields(
            &cfg,
            "//storage//put?id=123&foo=bar",
            1,
            Duration::from_millis(1000),
            Some("corr-123"),
        )
        .unwrap();

        assert_eq!(out.endpoint.as_ref(), "/storage/put");
        assert_eq!(out.attempt, 1);
        assert_eq!(out.corr_id.as_deref(), Some("corr-123"));
    }

    #[test]
    fn redaction_none_keeps_query() {
        let cfg = TracingCfg {
            spans: true,
            metrics: true,
            redaction: Redaction::None,
        };

        let out = build_span_fields(
            &cfg,
            "/storage/put?id=123",
            0,
            Duration::from_millis(1000),
            None,
        )
        .unwrap();

        assert_eq!(out.endpoint.as_ref(), "/storage/put?id=123");
    }
}

```

### crates/ron-app-sdk/src/transport/mod.rs
<a id="crates-ron-app-sdk-src-transport-mod-rs"></a>

```rust
//! RO:WHAT — Thin transport adapter for ron-app-sdk.
//! RO:WHY  — Central place to enforce OAP/1 limits (1 MiB max frame)
//!           and apply per-call deadlines, independent of which
//!           concrete transport (TLS, Tor) is used beneath.
//! RO:INTERACTS — Will later wrap `ron-transport` client handles.
//! RO:INVARIANTS —
//!   - SDK is client-only; no server/listener code here.
//!   - All outbound calls will go through this module once wired.
//! RO:SECURITY — OAP frame cap is exposed as a constant; enforcement
//!               will be added when we hook transport up for real.

use std::time::Duration;

use crate::config::SdkConfig;
use crate::errors::SdkError;

/// Hard OAP/1 frame size cap (1 MiB).
///
/// Callers must ensure no single OAP DATA frame ever exceeds this
/// size. The transport adapter will enforce this once wired to
/// `ron-transport`.
pub const OAP_MAX_FRAME_BYTES: usize = 1024 * 1024;

/// Opaque handle for SDK transport.
///
/// For now this is just a wrapper around `SdkConfig`; once we hook it
/// to `ron-transport` this will hold the concrete client(s) for TLS
/// and Tor transport profiles.
#[derive(Debug, Clone)]
pub struct TransportHandle {
    cfg: SdkConfig,
}

impl TransportHandle {
    /// Construct a new handle from configuration.
    pub fn new(cfg: SdkConfig) -> Self {
        Self { cfg }
    }

    /// Access the underlying config.
    pub fn config(&self) -> &SdkConfig {
        &self.cfg
    }

    /// Perform a low-level OAP request.
    ///
    /// This is the entrypoint that plane modules (storage/edge/mailbox/
    /// index) will call once we wire real transport. For now, it is a
    /// stub so the SDK can compile and tests can develop against the
    /// type shape without needing a running Micronode/Macronode.
    pub async fn call_oap(
        &self,
        endpoint: &str,
        payload: &[u8],
        deadline: Duration,
    ) -> Result<Vec<u8>, SdkError> {
        let _ = (endpoint, payload, deadline);

        // NOTE: OAP frame cap + deadlines + PQ/Tor posture will be
        // enforced here when we integrate `ron-transport`. For now,
        // keep this as a `todo!()` so we don't accidentally ship a
        // half-implemented transport.
        todo!("transport wiring not implemented yet");
    }
}

```

### crates/ron-app-sdk/src/types.rs
<a id="crates-ron-app-sdk-src-types-rs"></a>

```rust
//! RO:WHAT — Public DTO surface for ron-app-sdk.
//! RO:WHY  — Give applications a single place to import capability,
//!           content-addressed IDs, mailbox types, etc., without having
//!           to depend on `ron-proto` directly.
//! RO:INTERACTS — Re-exports canonical DTOs from `ron-proto` and
//!                aliases the SDK’s own idempotency key type.
//! RO:INVARIANTS —
//!   - DTOs remain pure data (no I/O, no crypto).
//!   - Types here are stable and SemVer-protected via api-history.
//!   - We avoid stringly-typed IDs where possible.
//! RO:SECURITY — Capability types here are header-DTOs only; actual
//!               verification lives in auth services (ron-auth, etc.).

use crate::idempotency::IdempotencyKey;

// Re-export canonical DTOs from `ron-proto`.
pub use ron_proto::{
    Ack as MailboxAck,
    CapTokenHdr,
    ContentId,
    ManifestV1,
    NameRef,
    Recv as MailboxRecv,
    Send as MailboxSend,
};

/// Capability token header (macaroon-style claims, no signature).
pub type Capability = CapTokenHdr;

/// Canonical BLAKE3 content address used by storage/index planes.
pub type AddrB3 = ContentId;

/// Logical index key used by the index plane.
pub type IndexKey = NameRef;

/// SDK-level alias for idempotency keys (SDK-owned type).
pub type IdemKey = IdempotencyKey;

/// Mail payload used when *sending* via the mailbox plane.
pub type Mail = MailboxSend;

/// Mail payload delivered when *receiving* from the mailbox plane.
pub type MailInbox = MailboxRecv;

/// Receipt/acknowledgement from mailbox operations (canonical name).
pub type Receipt = MailboxAck;

/// Short alias matching the docs (`Ack`).
pub type Ack = Receipt;

/// Single byte range (inclusive start, inclusive end).
///
/// This mirrors the shape used in `svc-edge` but is defined locally so
/// the SDK does not have to depend on that crate.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ByteRange {
    /// Start offset.
    pub start: u64,
    /// End offset (inclusive).
    pub end: u64,
}

impl ByteRange {
    /// Length of the range in bytes, saturating.
    pub fn len(&self) -> u64 {
        self.end.saturating_sub(self.start) + 1
    }
}

```

### crates/ron-app-sdk/tests/i_10_semver_snapshot.rs
<a id="crates-ron-app-sdk-tests-i10semversnapshot-rs"></a>

```rust
// Invariant: public API snapshot honored (scaffold).
#[test] fn i_10_semver_snapshot_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_11_no_persistence.rs
<a id="crates-ron-app-sdk-tests-i11nopersistence-rs"></a>

```rust
// Invariant: no on-disk persistence (scaffold).
#[test] fn i_11_no_persistence_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_12_canon_deps.rs
<a id="crates-ron-app-sdk-tests-i12canondeps-rs"></a>

```rust
// Invariant: workspace pins / canon deps (scaffold).
#[test] fn i_12_canon_deps_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_1_profile_parity.rs
<a id="crates-ron-app-sdk-tests-i1profileparity-rs"></a>

```rust
// Invariant: profile parity across transports (scaffold).
#[test] fn i_1_profile_parity_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_2_caps_required.rs
<a id="crates-ron-app-sdk-tests-i2capsrequired-rs"></a>

```rust
// Invariant: capabilities required on mutations (scaffold).
#[test] fn i_2_caps_required_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_3_oap_bounds.rs
<a id="crates-ron-app-sdk-tests-i3oapbounds-rs"></a>

```rust
// Invariant: OAP/1 frame cap <= 1 MiB (scaffold).
#[test] fn i_3_oap_bounds_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_4_content_addressing.rs
<a id="crates-ron-app-sdk-tests-i4contentaddressing-rs"></a>

```rust
// Invariant: AddrB3 content addressing on PUTs (scaffold).
#[test] fn i_4_content_addressing_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_5_retries_deadlines.rs
<a id="crates-ron-app-sdk-tests-i5retriesdeadlines-rs"></a>

```rust
// Invariant: bounded retries + deadlines (scaffold).
#[test] fn i_5_retries_deadlines_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_6_dto_strictness.rs
<a id="crates-ron-app-sdk-tests-i6dtostrictness-rs"></a>

```rust
// Invariant: strict DTO parsing (deny_unknown_fields) (scaffold).
#[test] fn i_6_dto_strictness_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_7_transport_agnostic.rs
<a id="crates-ron-app-sdk-tests-i7transportagnostic-rs"></a>

```rust
// Invariant: transport-agnostic semantics (TLS vs Tor) (scaffold).
#[test] fn i_7_transport_agnostic_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_8_deadlines_everywhere.rs
<a id="crates-ron-app-sdk-tests-i8deadlineseverywhere-rs"></a>

```rust
// Invariant: deadlines on all external I/O (scaffold).
#[test] fn i_8_deadlines_everywhere_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/i_9_error_taxonomy.rs
<a id="crates-ron-app-sdk-tests-i9errortaxonomy-rs"></a>

```rust
// Invariant: error taxonomy mapping + retry classes (scaffold).
#[test] fn i_9_error_taxonomy_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/interop_vectors.rs
<a id="crates-ron-app-sdk-tests-interopvectors-rs"></a>

```rust
// Canonical interop vectors runner (scaffold).
#[test] fn interop_vectors_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/prop_oap_frames.rs
<a id="crates-ron-app-sdk-tests-propoapframes-rs"></a>

```rust
// Property test placeholder: frames near 1 MiB bound (scaffold).
#[test] fn prop_oap_frames_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/prop_retry_bounds.rs
<a id="crates-ron-app-sdk-tests-propretrybounds-rs"></a>

```rust
// Property test placeholder: retry sleeps sum < overall deadline (scaffold).
#[test] fn prop_retry_bounds_scaffold() { assert!(true); }
```

### crates/ron-app-sdk/tests/vectors/capability_example.json
<a id="crates-ron-app-sdk-tests-vectors-capabilityexample-json"></a>

```json
{"capability":"placeholder"}
```

### crates/ron-app-sdk/tests/vectors/oap1_min_req.json
<a id="crates-ron-app-sdk-tests-vectors-oap1minreq-json"></a>

```json
{"placeholder": true}
```

