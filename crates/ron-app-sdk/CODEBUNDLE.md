<!-- Generated by scripts/make_crate_codex.sh on 2025-11-16T15:35:08Z -->
# Code Bundle — `ron-app-sdk`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-app-sdk/.github/workflows/api-semver.yml](#crates-ron-app-sdk--github-workflows-api-semver-yml)
- [crates/ron-app-sdk/.github/workflows/ci.yml](#crates-ron-app-sdk--github-workflows-ci-yml)
- [crates/ron-app-sdk/.github/workflows/perf-guardrails.yml](#crates-ron-app-sdk--github-workflows-perf-guardrails-yml)
- [crates/ron-app-sdk/.github/workflows/render-mermaid.yml](#crates-ron-app-sdk--github-workflows-render-mermaid-yml)
- [crates/ron-app-sdk/Cargo.toml](#crates-ron-app-sdk-Cargo-toml)
- [crates/ron-app-sdk/benches/sdk_benches.rs](#crates-ron-app-sdk-benches-sdkbenches-rs)
- [crates/ron-app-sdk/examples/demo.rs](#crates-ron-app-sdk-examples-demo-rs)
- [crates/ron-app-sdk/fuzz/Cargo.toml](#crates-ron-app-sdk-fuzz-Cargo-toml)
- [crates/ron-app-sdk/fuzz/fuzz_targets/dto_roundtrip.rs](#crates-ron-app-sdk-fuzz-fuzztargets-dtoroundtrip-rs)
- [crates/ron-app-sdk/fuzz/fuzz_targets/oap_frame_parser.rs](#crates-ron-app-sdk-fuzz-fuzztargets-oapframeparser-rs)
- [crates/ron-app-sdk/rust-toolchain.toml](#crates-ron-app-sdk-rust-toolchain-toml)
- [crates/ron-app-sdk/scripts/gen_api_snapshot.sh](#crates-ron-app-sdk-scripts-genapisnapshot-sh)
- [crates/ron-app-sdk/scripts/smoke_sdk.sh](#crates-ron-app-sdk-scripts-smokesdk-sh)
- [crates/ron-app-sdk/src/cache/lru.rs](#crates-ron-app-sdk-src-cache-lru-rs)
- [crates/ron-app-sdk/src/cache/mod.rs](#crates-ron-app-sdk-src-cache-mod-rs)
- [crates/ron-app-sdk/src/config/mod.rs](#crates-ron-app-sdk-src-config-mod-rs)
- [crates/ron-app-sdk/src/config/types.rs](#crates-ron-app-sdk-src-config-types-rs)
- [crates/ron-app-sdk/src/context.rs](#crates-ron-app-sdk-src-context-rs)
- [crates/ron-app-sdk/src/errors.rs](#crates-ron-app-sdk-src-errors-rs)
- [crates/ron-app-sdk/src/idempotency.rs](#crates-ron-app-sdk-src-idempotency-rs)
- [crates/ron-app-sdk/src/lib.rs](#crates-ron-app-sdk-src-lib-rs)
- [crates/ron-app-sdk/src/metrics.rs](#crates-ron-app-sdk-src-metrics-rs)
- [crates/ron-app-sdk/src/planes/edge.rs](#crates-ron-app-sdk-src-planes-edge-rs)
- [crates/ron-app-sdk/src/planes/index.rs](#crates-ron-app-sdk-src-planes-index-rs)
- [crates/ron-app-sdk/src/planes/mailbox.rs](#crates-ron-app-sdk-src-planes-mailbox-rs)
- [crates/ron-app-sdk/src/planes/mod.rs](#crates-ron-app-sdk-src-planes-mod-rs)
- [crates/ron-app-sdk/src/planes/storage.rs](#crates-ron-app-sdk-src-planes-storage-rs)
- [crates/ron-app-sdk/src/ready.rs](#crates-ron-app-sdk-src-ready-rs)
- [crates/ron-app-sdk/src/retry.rs](#crates-ron-app-sdk-src-retry-rs)
- [crates/ron-app-sdk/src/tracing.rs](#crates-ron-app-sdk-src-tracing-rs)
- [crates/ron-app-sdk/src/transport/handle.rs](#crates-ron-app-sdk-src-transport-handle-rs)
- [crates/ron-app-sdk/src/transport/mapping.rs](#crates-ron-app-sdk-src-transport-mapping-rs)
- [crates/ron-app-sdk/src/transport/mod.rs](#crates-ron-app-sdk-src-transport-mod-rs)
- [crates/ron-app-sdk/src/types.rs](#crates-ron-app-sdk-src-types-rs)
- [crates/ron-app-sdk/tests/i_10_semver_snapshot.rs](#crates-ron-app-sdk-tests-i10semversnapshot-rs)
- [crates/ron-app-sdk/tests/i_11_no_persistence.rs](#crates-ron-app-sdk-tests-i11nopersistence-rs)
- [crates/ron-app-sdk/tests/i_12_canon_deps.rs](#crates-ron-app-sdk-tests-i12canondeps-rs)
- [crates/ron-app-sdk/tests/i_1_profile_parity.rs](#crates-ron-app-sdk-tests-i1profileparity-rs)
- [crates/ron-app-sdk/tests/i_2_caps_required.rs](#crates-ron-app-sdk-tests-i2capsrequired-rs)
- [crates/ron-app-sdk/tests/i_3_oap_bounds.rs](#crates-ron-app-sdk-tests-i3oapbounds-rs)
- [crates/ron-app-sdk/tests/i_4_content_addressing.rs](#crates-ron-app-sdk-tests-i4contentaddressing-rs)
- [crates/ron-app-sdk/tests/i_5_retries_deadlines.rs](#crates-ron-app-sdk-tests-i5retriesdeadlines-rs)
- [crates/ron-app-sdk/tests/i_6_dto_strictness.rs](#crates-ron-app-sdk-tests-i6dtostrictness-rs)
- [crates/ron-app-sdk/tests/i_7_transport_agnostic.rs](#crates-ron-app-sdk-tests-i7transportagnostic-rs)
- [crates/ron-app-sdk/tests/i_8_deadlines_everywhere.rs](#crates-ron-app-sdk-tests-i8deadlineseverywhere-rs)
- [crates/ron-app-sdk/tests/i_9_error_taxonomy.rs](#crates-ron-app-sdk-tests-i9errortaxonomy-rs)
- [crates/ron-app-sdk/tests/interop_vectors.rs](#crates-ron-app-sdk-tests-interopvectors-rs)
- [crates/ron-app-sdk/tests/prop_oap_frames.rs](#crates-ron-app-sdk-tests-propoapframes-rs)
- [crates/ron-app-sdk/tests/prop_retry_bounds.rs](#crates-ron-app-sdk-tests-propretrybounds-rs)
- [crates/ron-app-sdk/tests/support/mock_gateway.rs](#crates-ron-app-sdk-tests-support-mockgateway-rs)
- [crates/ron-app-sdk/tests/vectors/capability_example.json](#crates-ron-app-sdk-tests-vectors-capabilityexample-json)
- [crates/ron-app-sdk/tests/vectors/oap1_min_req.json](#crates-ron-app-sdk-tests-vectors-oap1minreq-json)

### crates/ron-app-sdk/.github/workflows/api-semver.yml
<a id="crates-ron-app-sdk--github-workflows-api-semver-yml"></a>

```yaml
name: api-semver
on: [pull_request]
jobs:
  semver:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "public-api check scaffold"
```

### crates/ron-app-sdk/.github/workflows/ci.yml
<a id="crates-ron-app-sdk--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
      - run: cargo fmt --all -- --check
      - run: cargo clippy -p ron-app-sdk2 -- -D warnings
      - run: cargo test -p ron-app-sdk2
```

### crates/ron-app-sdk/.github/workflows/perf-guardrails.yml
<a id="crates-ron-app-sdk--github-workflows-perf-guardrails-yml"></a>

```yaml
name: perf-guardrails
on:
  workflow_dispatch:
  schedule:
    - cron: "0 6 * * *"
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: cargo bench -p ron-app-sdk2 || true
```

### crates/ron-app-sdk/.github/workflows/render-mermaid.yml
<a id="crates-ron-app-sdk--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          mkdir -p docs/diagrams
          for f in $(git ls-files 'docs/diagrams/*.mmd'); do
            out="${f%.mmd}.svg"; mmdc -i "$f" -o "$out";
          done
```

### crates/ron-app-sdk/Cargo.toml
<a id="crates-ron-app-sdk-Cargo-toml"></a>

```toml
[package]
name = "ron-app-sdk"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RustyOnions application SDK (developer-facing client for RON-CORE)."
readme = "README.md"
repository = ""
publish = false

[lib]
path = "src/lib.rs"

[features]
# Default posture: direct TLS.
default = ["tls"]

# Transport toggles (we’ll wire actual deps as we add transport code).
tls = []
tor = []

# Optional extras we’ll hook up later (metrics, PQ hybrids, etc.).
metrics = []
pq = []
pq-hybrid = []

[dependencies]
# Error handling
anyhow = { workspace = true }

# Serialization
serde = { workspace = true, features = ["derive"] }
humantime-serde = { workspace = true }

# Canonical DTOs (capabilities, content IDs, mailbox, manifests, etc.)
ron-proto = { path = "../ron-proto" }

# Binary blob helper for plane APIs (edge/storage).
bytes = { version = "1.7", default-features = false }

# Async runtime + timers (used by retry/backoff in planes).
tokio = { workspace = true, features = ["macros", "rt-multi-thread", "time"] }

# JSON parsing for storage/edge/index/mailbox responses.
serde_json = { workspace = true }

# HTTP client used by TransportHandle (TLS path, rustls-based).
reqwest = { workspace = true, features = ["rustls-tls-native-roots", "json"] }

# Byte-friendly serde adapter for edge/get responses.
serde_bytes = { version = "0.11", default-features = false }

[dev-dependencies]
# Mini HTTP server for integration tests (mock gateway).
axum = { workspace = true, features = ["http1", "json", "tokio"] }

# Content addressing check (b3:hex).
blake3 = "1.5"

# Hex encoding for BLAKE3 digest.
hex = "0.4"

[package.metadata.docs]

```

### crates/ron-app-sdk/benches/sdk_benches.rs
<a id="crates-ron-app-sdk-benches-sdkbenches-rs"></a>

```rust
// Criterion benches placeholder (scaffold).
fn main() {
    println!("benches scaffold");
}

```

### crates/ron-app-sdk/examples/demo.rs
<a id="crates-ron-app-sdk-examples-demo-rs"></a>

```rust
//! Minimal demo for ron-app-sdk.
//!
//! RO:WHAT — Tiny example that exercises config loading, readiness
//!           checks, and constructing `RonAppSdk`.
//! RO:WHY  — Gives integrators a copy-paste starting point without
//!           requiring a running Micronode/Macronode or real gateway.
//! RO:NOTE — This example does *not* perform real plane calls yet,
//!           because the default `RON_SDK_GATEWAY_ADDR` in docs is
//!           usually `https://example.invalid`. It focuses on:
//!             - config-from-env
//!             - readiness (`check_ready`)
//!             - constructing the SDK client safely.

use ron_app_sdk::{check_ready, RonAppSdk, SdkConfig};

/// Run with something like:
///
/// ```bash
/// RON_SDK_GATEWAY_ADDR="https://example.invalid" \
/// RON_SDK_TRANSPORT="tls" \
/// RON_SDK_OVERALL_TIMEOUT_MS="30000" \
/// cargo run -p ron-app-sdk --example demo
/// ```
///
/// For real usage, point `RON_SDK_GATEWAY_ADDR` at a live Micronode /
/// Macronode gateway and provide a real capability when calling the
/// plane helpers (`storage_*`, `edge_get`, `mailbox_*`, `index_resolve`).
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1) Load config from environment.
    let cfg = SdkConfig::from_env()?;

    println!(
        "[demo] loaded config: transport={:?}, gateway_addr={}",
        cfg.transport, cfg.gateway_addr
    );

    // 2) Run in-process readiness check (no network I/O).
    let report = check_ready(&cfg);

    println!(
        "[demo] ready_report: config_ok={}, transport_ok={}, tor_ok={:?}, missing={:?}",
        report.config_ok, report.transport_ok, report.tor_ok, report.missing
    );

    if !report.is_ready() {
        eprintln!("[demo] SDK configuration is NOT ready; refusing to construct client");
        eprintln!("[demo] fix the above `missing` fields and try again.");
        return Ok(());
    }

    // 3) Construct the SDK client. This re-validates config and
    // prepares the internal transport handle.
    let sdk = RonAppSdk::new(cfg).await?;
    let ctx = sdk.context();

    println!(
        "[demo] SDK context: profile={:?}, amnesia={}",
        ctx.profile(),
        ctx.amnesia()
    );

    // 4) (Optional) Sketch of how plane calls will look — left as
    // comments so this example stays safe even when pointing at
    // example.invalid.
    //
    // use ron_app_sdk::types::{Capability, IdemKey};
    //
    // let cap: Capability = /* obtain from svc-passport / auth flow */;
    //
    // // Example: storage_put (with optional idempotency key)
    // let bytes = bytes::Bytes::from_static(b"hello world");
    // let idem = None::<IdemKey>;
    // let addr = sdk
    //     .storage_put(cap.clone(), bytes, std::time::Duration::from_secs(5), idem)
    //     .await?;
    // println!("[demo] stored blob at addr_b3={}", addr);
    //
    // // Example: storage_get
    // let fetched = sdk
    //     .storage_get(cap.clone(), &addr, std::time::Duration::from_secs(5))
    //     .await?;
    // println!("[demo] fetched {} bytes", fetched.len());

    println!("[demo] done (no plane calls issued)");

    Ok(())
}

```

### crates/ron-app-sdk/fuzz/Cargo.toml
<a id="crates-ron-app-sdk-fuzz-Cargo-toml"></a>

```toml
[workspace]
members = ["."]
```

### crates/ron-app-sdk/fuzz/fuzz_targets/dto_roundtrip.rs
<a id="crates-ron-app-sdk-fuzz-fuzztargets-dtoroundtrip-rs"></a>

```rust
// fuzz target placeholder: dto_roundtrip (scaffold)
fn main() {}
```

### crates/ron-app-sdk/fuzz/fuzz_targets/oap_frame_parser.rs
<a id="crates-ron-app-sdk-fuzz-fuzztargets-oapframeparser-rs"></a>

```rust
// fuzz target placeholder: oap_frame_parser (scaffold)
fn main() {}
```

### crates/ron-app-sdk/rust-toolchain.toml
<a id="crates-ron-app-sdk-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]
```

### crates/ron-app-sdk/scripts/gen_api_snapshot.sh
<a id="crates-ron-app-sdk-scripts-genapisnapshot-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# gen_api_snapshot.sh — run cargo public-api and save to docs/api-history (scaffold)
echo "api snapshot scaffold"
```

### crates/ron-app-sdk/scripts/smoke_sdk.sh
<a id="crates-ron-app-sdk-scripts-smokesdk-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# ron-app-sdk smoke: keep this crate honest without touching the rest
# of the workspace. Intended to be fast enough to run often.

echo "[STEP] fmt + clippy + unit tests"
cargo fmt -p ron-app-sdk
cargo clippy -p ron-app-sdk --no-deps -- -D warnings
cargo test  -p ron-app-sdk --lib

# NOTE: When we add a mock gateway + integration tests, extend this
# script with a small spawn/kill harness here (see NOTES.MD).
# For beta, unit tests are our DoD.

echo "[OK] ron-app-sdk smoke passed"

```

### crates/ron-app-sdk/src/cache/lru.rs
<a id="crates-ron-app-sdk-src-cache-lru-rs"></a>

```rust
//! RO:WHAT — Tiny, std-only LRU cache (size-bounded).
//! RO:WHY  — Provide a simple building block for SDK-local caches without
//!           pulling in an external LRU crate.
//! RO:INTERACTS — Wrapped by `cache::mod` to add TTL behavior and metrics.
//! RO:INVARIANTS —
//!   - Capacity is always >= 1.
//!   - Insertion is bounded: on overflow, the least-recently-used entry
//!     is evicted.
//!   - `get` and `insert` are O(n) (small n: max_entries from config).
//! RO:METRICS — None here; outer cache may emit hit/miss counters.
//! RO:CONFIG — Capacity supplied by `CacheCfg.max_entries`.
//! RO:SECURITY — In-memory only; no persistence.
//! RO:TEST — Unit tests in this module.

use std::collections::VecDeque;

/// Very small LRU cache backed by a `VecDeque`.
///
/// This is intentionally simple and does not attempt to be maximally
/// efficient; for typical SDK cache sizes (≈1k entries) an O(n) scan
/// is sufficient and keeps the implementation easy to audit.
#[derive(Debug)]
pub struct Lru<K, V> {
    capacity: usize,
    entries: VecDeque<(K, V)>,
}

impl<K, V> Lru<K, V> {
    /// Construct a new LRU with the given capacity.
    pub fn new(capacity: usize) -> Self {
        let cap = capacity.max(1);
        Self {
            capacity: cap,
            entries: VecDeque::with_capacity(cap),
        }
    }

    /// Current number of entries in the cache.
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Whether the cache is empty.
    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }
}

impl<K, V> Lru<K, V>
where
    K: Eq,
    V: Clone,
{
    /// Get a value by key, marking it as most-recently-used.
    ///
    /// Returns a cloned value. This keeps the implementation simple and
    /// avoids lifetime juggling while still being cheap for typical V.
    pub fn get(&mut self, key: &K) -> Option<V> {
        let mut hit_index = None;

        for (idx, (k, _)) in self.entries.iter().enumerate() {
            if k == key {
                hit_index = Some(idx);
                break;
            }
        }

        let idx = hit_index?;
        let (_, v) = &self.entries[idx];
        let value = v.clone();

        // Move the entry to the back if it wasn't already there.
        if idx + 1 != self.entries.len() {
            if let Some(entry) = self.entries.remove(idx) {
                self.entries.push_back(entry);
            }
        }

        Some(value)
    }

    /// Insert or replace a value.
    ///
    /// Returns the previous value for this key, if any.
    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
        // Remove existing entry if present.
        let mut old = None;
        let mut existing_index = None;

        for (idx, (k, _)) in self.entries.iter().enumerate() {
            if k == &key {
                existing_index = Some(idx);
                break;
            }
        }

        if let Some(idx) = existing_index {
            if let Some((_, v)) = self.entries.remove(idx) {
                old = Some(v);
            }
        }

        self.entries.push_back((key, value));

        // Enforce capacity.
        if self.entries.len() > self.capacity {
            let _ = self.entries.pop_front();
        }

        old
    }

    /// Remove a key from the cache, returning its value if present.
    pub fn remove(&mut self, key: &K) -> Option<V> {
        let mut index = None;
        for (idx, (k, _)) in self.entries.iter().enumerate() {
            if k == key {
                index = Some(idx);
                break;
            }
        }

        index.and_then(|idx| self.entries.remove(idx).map(|(_, v)| v))
    }
}

#[cfg(test)]
mod tests {
    use super::Lru;

    #[test]
    fn obeys_capacity_and_lru_order() {
        let mut lru = Lru::new(2);

        lru.insert("a", 1);
        lru.insert("b", 2);

        // Access "a" to make it most recent.
        assert_eq!(lru.get(&"a"), Some(1));

        // Insert "c" — should evict "b".
        lru.insert("c", 3);

        assert_eq!(lru.get(&"a"), Some(1));
        assert_eq!(lru.get(&"b"), None);
        assert_eq!(lru.get(&"c"), Some(3));
    }

    #[test]
    fn remove_works() {
        let mut lru = Lru::new(2);
        lru.insert("a", 1);
        lru.insert("b", 2);

        assert_eq!(lru.remove(&"a"), Some(1));
        assert_eq!(lru.get(&"a"), None);
        assert_eq!(lru.len(), 1);
    }
}

```

### crates/ron-app-sdk/src/cache/mod.rs
<a id="crates-ron-app-sdk-src-cache-mod-rs"></a>

```rust
//! RO:WHAT — Ephemeral TTL cache facade for SDK callers.
//! RO:WHY  — Provide a small, in-memory cache to hide repeated GETs or
//!           metadata lookups without ever touching disk (I-11 no-persistence).
//! RO:INTERACTS — Wraps `cache::lru::Lru`; driven by `CacheCfg` from config;
//!                may be used by storage/index planes later.
//! RO:INVARIANTS —
//!   - Obeys `CacheCfg.max_entries` (bounded size).
//!   - Per-entry TTL enforced on read; expired entries are evicted.
//!   - Purely in-memory, process-local; no serialization.
//! RO:METRICS — Places to hook cache hit/miss counters via `SdkMetrics`.
//! RO:CONFIG — Reads `CacheCfg { enabled, max_entries, ttl }`.
//! RO:SECURITY — Does not store secrets long-term; caller chooses what to
//!               cache. Amnesia mode may disable cache at a higher level.
//! RO:TEST — Unit tests in this module.

mod lru;

pub use lru::Lru;

use std::time::{Duration, Instant};

use crate::config::CacheCfg;

/// Internal wrapper storing value + insertion timestamp.
#[derive(Debug, Clone)]
struct Entry<V> {
    value: V,
    inserted_at: Instant,
}

impl<V> Entry<V> {
    fn new(value: V) -> Self {
        Self {
            value,
            inserted_at: Instant::now(),
        }
    }

    fn is_expired(&self, ttl: Duration) -> bool {
        self.inserted_at.elapsed() > ttl
    }
}

/// Simple TTL + size-bounded cache built on top of `Lru`.
///
/// Generic over key and value types. This is intended for relatively
/// small caches (hundreds to a few thousand entries).
#[derive(Debug)]
pub struct TtlCache<K, V> {
    cfg: CacheCfg,
    inner: Lru<K, Entry<V>>,
}

impl<K, V> TtlCache<K, V>
where
    K: Eq,
    V: Clone,
{
    /// Create a new cache from configuration.
    ///
    /// If `cfg.enabled` is false, callers should typically avoid creating
    /// the cache at all and treat this as a no-op.
    pub fn new(cfg: CacheCfg) -> Self {
        let cap = cfg.max_entries.max(1);
        Self {
            cfg,
            inner: Lru::new(cap),
        }
    }

    /// Access the underlying config.
    pub fn config(&self) -> &CacheCfg {
        &self.cfg
    }

    /// Look up a value by key, enforcing TTL.
    ///
    /// Returns `None` if the key is not present or the entry has expired.
    pub fn get(&mut self, key: &K) -> Option<V> {
        if !self.cfg.enabled {
            return None;
        }

        let ttl = self.cfg.ttl;
        if ttl.is_zero() {
            return None;
        }

        if let Some(entry) = self.inner.get(key) {
            if entry.is_expired(ttl) {
                // Evict expired entry.
                let _ = self.inner.remove(key);
                None
            } else {
                Some(entry.value)
            }
        } else {
            None
        }
    }

    /// Insert or replace a value for the given key.
    pub fn insert(&mut self, key: K, value: V) {
        if !self.cfg.enabled {
            return;
        }

        let entry = Entry::new(value);
        let _ = self.inner.insert(key, entry);
    }

    /// Remove an entry (if present).
    pub fn remove(&mut self, key: &K) {
        let _ = self.inner.remove(key);
    }

    /// Clear all entries.
    pub fn clear(&mut self) {
        // Reinitialize the LRU with the configured capacity.
        let cap = self.cfg.max_entries.max(1);
        self.inner = Lru::new(cap);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn cfg_enabled() -> CacheCfg {
        CacheCfg {
            enabled: true,
            max_entries: 2,
            ttl: Duration::from_millis(10),
        }
    }

    #[test]
    fn respects_enabled_flag() {
        let cfg = CacheCfg {
            enabled: false,
            max_entries: 2,
            ttl: Duration::from_secs(60),
        };

        let mut cache = TtlCache::new(cfg);
        cache.insert("a", 1);
        assert_eq!(cache.get(&"a"), None);
    }

    #[test]
    fn evicts_on_ttl() {
        let cfg = cfg_enabled();
        let mut cache = TtlCache::new(cfg);

        cache.insert("a", 1);
        assert_eq!(cache.get(&"a"), Some(1));

        std::thread::sleep(Duration::from_millis(15));
        assert_eq!(cache.get(&"a"), None);
    }

    #[test]
    fn respects_capacity_lru_behavior() {
        let cfg = CacheCfg {
            enabled: true,
            max_entries: 2,
            ttl: Duration::from_secs(60),
        };

        let mut cache = TtlCache::new(cfg);

        cache.insert("a", 1);
        cache.insert("b", 2);

        // Touch "a" to make it recently used.
        assert_eq!(cache.get(&"a"), Some(1));

        // Insert "c" — should evict "b".
        cache.insert("c", 3);

        assert_eq!(cache.get(&"a"), Some(1));
        assert_eq!(cache.get(&"b"), None);
        assert_eq!(cache.get(&"c"), Some(3));
    }
}

```

### crates/ron-app-sdk/src/config/mod.rs
<a id="crates-ron-app-sdk-src-config-mod-rs"></a>

```rust
//! High-level config helpers for ron-app-sdk.
//!
//! RO:WHAT — Glue for `SdkConfig`: validation + environment loader + helpers.
//! RO:WHY  — Central place for config rules so the rest of the SDK can stay
//!           boring (just read fields).
//! RO:INTERACTS — Used by `RonAppSdk::new`, examples, and tests; reads env
//!                via `SdkConfig::from_env()`.
//! RO:INVARIANTS — No panics; invalid configs surface as errors
//!                 (`anyhow::Result`); env parsing is explicit, no silent
//!                 fallbacks.

mod types;

pub use types::{
    CacheCfg, IdemCfg, Jitter, PqMode, Redaction, RetryCfg, SdkConfig, Timeouts, TorCfg,
    TracingCfg, Transport,
};

use std::{collections::HashMap, time::Duration};

use anyhow::{anyhow, bail, Result as AnyResult};

impl SdkConfig {
    /// Validate semantic invariants for this configuration.
    ///
    /// This is called automatically from `from_env` and should also be
    /// invoked by host apps that construct configs programmatically.
    pub fn validate(&self) -> AnyResult<()> {
        if self.gateway_addr.trim().is_empty() {
            bail!("gateway_addr must not be empty");
        }

        if self.retry.max_attempts == 0 {
            bail!("retry.max_attempts must be at least 1");
        }

        if self.retry.factor < 1.0 {
            bail!("retry.factor must be >= 1.0");
        }

        if self.retry.base.is_zero() {
            bail!("retry.base must be > 0");
        }

        if self.retry.cap < self.retry.base {
            bail!("retry.cap must be >= retry.base");
        }

        if self.overall_timeout < Duration::from_secs(1) {
            bail!("overall_timeout must be >= 1s");
        }

        if self.overall_timeout < self.timeouts.read || self.overall_timeout < self.timeouts.write {
            bail!("overall_timeout must be >= read/write timeouts");
        }

        if self.cache.enabled {
            if self.cache.max_entries == 0 {
                bail!("cache.max_entries must be >= 1 when cache.enabled=true");
            }
            if self.cache.ttl < Duration::from_secs(1) {
                bail!("cache.ttl must be >= 1s when cache.enabled=true");
            }
        }

        // PQ mode + Tor reachability checks can be extended later; for now
        // we just ensure the socks address is non-empty when Tor is chosen.
        if matches!(self.transport, Transport::Tor) && self.tor.socks5_addr.trim().is_empty() {
            bail!("tor.socks5_addr must not be empty when transport=tor");
        }

        Ok(())
    }

    /// Build a config from environment variables, with safe defaults.
    ///
    /// Mapping roughly follows `docs/CONFIG.md`:
    ///
    /// - `RON_SDK_TRANSPORT`              → `transport`
    /// - `RON_SDK_GATEWAY_ADDR`           → `gateway_addr`
    /// - `RON_SDK_OVERALL_TIMEOUT_MS`     → `overall_timeout`
    /// - `RON_SDK_CONNECT_TIMEOUT_MS`     → `timeouts.connect`
    /// - `RON_SDK_READ_TIMEOUT_MS`        → `timeouts.read`
    /// - `RON_SDK_WRITE_TIMEOUT_MS`       → `timeouts.write`
    /// - `RON_SDK_RETRY_BASE_MS`          → `retry.base`
    /// - `RON_SDK_RETRY_FACTOR`           → `retry.factor`
    /// - `RON_SDK_RETRY_CAP_MS`           → `retry.cap`
    /// - `RON_SDK_RETRY_MAX_ATTEMPTS`     → `retry.max_attempts`
    /// - `RON_SDK_RETRY_JITTER`           → `retry.jitter`
    /// - `RON_SDK_IDEM_ENABLED`           → `idempotency.enabled`
    /// - `RON_SDK_IDEM_PREFIX`            → `idempotency.key_prefix`
    /// - `RON_SDK_CACHE_ENABLED`          → `cache.enabled`
    /// - `RON_SDK_CACHE_MAX_ENTRIES`      → `cache.max_entries`
    /// - `RON_SDK_CACHE_TTL_MS`           → `cache.ttl`
    /// - `RON_SDK_TRACING_SPANS`          → `tracing.spans`
    /// - `RON_SDK_TRACING_METRICS`        → `tracing.metrics`
    /// - `RON_SDK_TRACING_REDACTION`      → `tracing.redaction`
    /// - `RON_SDK_PQ_MODE`                → `pq_mode`
    /// - `RON_SDK_TOR_SOCKS5_ADDR`        → `tor.socks5_addr`
    pub fn from_env() -> AnyResult<SdkConfig> {
        // FIX: pass `std::env::vars()` directly; it already implements
        // `IntoIterator<Item = (String, String)>`.
        Self::from_env_with(std::env::vars())
    }

    /// Testable helper behind `from_env` that works off an arbitrary map.
    pub(crate) fn from_env_with<I>(vars: I) -> AnyResult<SdkConfig>
    where
        I: IntoIterator<Item = (String, String)>,
    {
        let map: HashMap<_, _> = vars.into_iter().collect();
        let get = |key: &str| map.get(key).map(String::as_str);

        let mut cfg = SdkConfig::default();

        // Transport + gateway
        if let Some(v) = get("RON_SDK_TRANSPORT") {
            cfg.transport = match v.to_ascii_lowercase().as_str() {
                "tls" => Transport::Tls,
                "tor" => Transport::Tor,
                other => {
                    return Err(anyhow!(
                        "invalid RON_SDK_TRANSPORT: {other} (expected `tls` or `tor`)"
                    ));
                }
            };
        }

        if let Some(v) = get("RON_SDK_GATEWAY_ADDR") {
            cfg.gateway_addr = v.to_string();
        }

        // Timeouts (ms)
        if let Some(v) = get("RON_SDK_OVERALL_TIMEOUT_MS") {
            cfg.overall_timeout = parse_ms("RON_SDK_OVERALL_TIMEOUT_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_CONNECT_TIMEOUT_MS") {
            cfg.timeouts.connect = parse_ms("RON_SDK_CONNECT_TIMEOUT_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_READ_TIMEOUT_MS") {
            cfg.timeouts.read = parse_ms("RON_SDK_READ_TIMEOUT_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_WRITE_TIMEOUT_MS") {
            cfg.timeouts.write = parse_ms("RON_SDK_WRITE_TIMEOUT_MS", v)?;
        }

        // Retry
        if let Some(v) = get("RON_SDK_RETRY_BASE_MS") {
            cfg.retry.base = parse_ms("RON_SDK_RETRY_BASE_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_RETRY_FACTOR") {
            cfg.retry.factor = parse_f32("RON_SDK_RETRY_FACTOR", v)?;
        }

        if let Some(v) = get("RON_SDK_RETRY_CAP_MS") {
            cfg.retry.cap = parse_ms("RON_SDK_RETRY_CAP_MS", v)?;
        }

        if let Some(v) = get("RON_SDK_RETRY_MAX_ATTEMPTS") {
            cfg.retry.max_attempts = parse_u32("RON_SDK_RETRY_MAX_ATTEMPTS", v)?;
        }

        if let Some(v) = get("RON_SDK_RETRY_JITTER") {
            cfg.retry.jitter = match v.to_ascii_lowercase().as_str() {
                "full" => Jitter::Full,
                "none" => Jitter::None,
                other => {
                    return Err(anyhow!(
                        "invalid RON_SDK_RETRY_JITTER: {other} (expected `full` or `none`)"
                    ));
                }
            };
        }

        // Idempotency
        if let Some(v) = get("RON_SDK_IDEM_ENABLED") {
            cfg.idempotency.enabled = parse_bool("RON_SDK_IDEM_ENABLED", v)?;
        }

        if let Some(v) = get("RON_SDK_IDEM_PREFIX") {
            cfg.idempotency.key_prefix = if v.is_empty() {
                None
            } else {
                Some(v.to_string())
            };
        }

        // Cache
        if let Some(v) = get("RON_SDK_CACHE_ENABLED") {
            cfg.cache.enabled = parse_bool("RON_SDK_CACHE_ENABLED", v)?;
        }

        if let Some(v) = get("RON_SDK_CACHE_MAX_ENTRIES") {
            cfg.cache.max_entries = parse_usize("RON_SDK_CACHE_MAX_ENTRIES", v)?;
        }

        if let Some(v) = get("RON_SDK_CACHE_TTL_MS") {
            cfg.cache.ttl = parse_ms("RON_SDK_CACHE_TTL_MS", v)?;
        }

        // Tracing
        if let Some(v) = get("RON_SDK_TRACING_SPANS") {
            cfg.tracing.spans = parse_bool("RON_SDK_TRACING_SPANS", v)?;
        }

        if let Some(v) = get("RON_SDK_TRACING_METRICS") {
            cfg.tracing.metrics = parse_bool("RON_SDK_TRACING_METRICS", v)?;
        }

        if let Some(v) = get("RON_SDK_TRACING_REDACTION") {
            cfg.tracing.redaction = match v.to_ascii_lowercase().as_str() {
                "safe" => Redaction::Safe,
                "none" => Redaction::None,
                other => {
                    return Err(anyhow!(
                        "invalid RON_SDK_TRACING_REDACTION: {other} (expected `safe` or `none`)"
                    ));
                }
            };
        }

        // PQ mode
        if let Some(v) = get("RON_SDK_PQ_MODE") {
            cfg.pq_mode = match v.to_ascii_lowercase().as_str() {
                "off" => PqMode::Off,
                "hybrid" => PqMode::Hybrid,
                other => {
                    return Err(anyhow!(
                        "invalid RON_SDK_PQ_MODE: {other} (expected `off` or `hybrid`)"
                    ));
                }
            };
        }

        // Tor
        if let Some(v) = get("RON_SDK_TOR_SOCKS5_ADDR") {
            cfg.tor.socks5_addr = v.to_string();
        }

        // Final semantic pass.
        cfg.validate()?;
        Ok(cfg)
    }

    /// Convenience helper for tests/examples to override a handful of fields.
    pub fn with_overrides<F>(mut self, f: F) -> SdkConfig
    where
        F: FnOnce(&mut SdkConfig),
    {
        f(&mut self);
        self
    }
}

/// Parse a boolean env value.
///
/// Accepted truthy: `1`, `true`, `yes`, `on` (case-insensitive)  
/// Accepted falsy:  `0`, `false`, `no`, `off` (case-insensitive)
fn parse_bool(key: &str, raw: &str) -> AnyResult<bool> {
    let v = raw.to_ascii_lowercase();
    match v.as_str() {
        "1" | "true" | "yes" | "on" => Ok(true),
        "0" | "false" | "no" | "off" => Ok(false),
        _ => Err(anyhow!(
            "invalid {key}: {raw} (expected boolean like true/false)"
        )),
    }
}

/// Parse an integer millisecond value.
fn parse_ms(key: &str, raw: &str) -> AnyResult<Duration> {
    let ms: u64 = raw
        .parse()
        .map_err(|e| anyhow!("invalid {key}: {raw} (expected integer ms, err={e})"))?;
    Ok(Duration::from_millis(ms))
}

fn parse_f32(key: &str, raw: &str) -> AnyResult<f32> {
    raw.parse()
        .map_err(|e| anyhow!("invalid {key}: {raw} (expected f32, err={e})"))
}

fn parse_u32(key: &str, raw: &str) -> AnyResult<u32> {
    raw.parse()
        .map_err(|e| anyhow!("invalid {key}: {raw} (expected u32, err={e})"))
}

fn parse_usize(key: &str, raw: &str) -> AnyResult<usize> {
    raw.parse()
        .map_err(|e| anyhow!("invalid {key}: {raw} (expected usize, err={e})"))
}

```

### crates/ron-app-sdk/src/config/types.rs
<a id="crates-ron-app-sdk-src-config-types-rs"></a>

```rust
//! Config data types for ron-app-sdk.
//!
//! RO:WHAT — Pure data structs/enums for SDK configuration (no I/O).
//! RO:WHY  — Keeps `mod.rs` focused on helpers and env parsing; this file
//!           is just the shape + defaults of configuration.
//! RO:INTERACTS — Re-exported by `config::mod`; consumed across planes,
//!                retry helpers, and examples.
//! RO:INVARIANTS — Serializable with `serde`; defaults are safe/hardened;
//!                 no panics or external side effects.

use std::time::Duration;

use serde::{Deserialize, Serialize};

/// Wire-protocol transport flavor: direct TLS or Tor via SOCKS5.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Transport {
    /// Direct TLS over TCP (recommended default).
    Tls,
    /// Tor via SOCKS5 (arti/tor).
    Tor,
}

/// Jitter mode for exponential backoff.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Jitter {
    /// Full jitter: 0..base (random applied later).
    Full,
    /// No jitter: always use the base delay.
    None,
}

/// Log redaction posture for the SDK.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Redaction {
    /// Redact sensitive material where possible.
    Safe,
    /// Do not redact; more verbose but less private.
    None,
}

/// Post-quantum mode for edge → node connections.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum PqMode {
    Off,
    Hybrid,
}

/// Per-connection timeout knobs (excluding the global per-call deadline).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct Timeouts {
    /// Connect timeout for establishing a new transport connection.
    #[serde(with = "humantime_serde", default = "default_connect")]
    pub connect: Duration,
    /// Read timeout on an established connection.
    #[serde(with = "humantime_serde", default = "default_read")]
    pub read: Duration,
    /// Write timeout on an established connection.
    #[serde(with = "humantime_serde", default = "default_write")]
    pub write: Duration,
}

fn default_connect() -> Duration {
    Duration::from_secs(3)
}

fn default_read() -> Duration {
    Duration::from_secs(30)
}

fn default_write() -> Duration {
    Duration::from_secs(30)
}

impl Default for Timeouts {
    fn default() -> Self {
        Self {
            connect: default_connect(),
            read: default_read(),
            write: default_write(),
        }
    }
}

/// Retry/backoff configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct RetryCfg {
    /// Base delay for the first retry attempt.
    #[serde(with = "humantime_serde", default = "default_retry_base")]
    pub base: Duration,
    /// Multiplicative factor per attempt.
    #[serde(default = "default_retry_factor")]
    pub factor: f32,
    /// Cap on backoff delay.
    #[serde(with = "humantime_serde", default = "default_retry_cap")]
    pub cap: Duration,
    /// Maximum number of attempts (including the first).
    #[serde(default = "default_retry_max_attempts")]
    pub max_attempts: u32,
    /// Jitter mode.
    #[serde(default = "default_jitter")]
    pub jitter: Jitter,
}

fn default_retry_base() -> Duration {
    Duration::from_millis(100)
}

fn default_retry_factor() -> f32 {
    2.0
}

fn default_retry_cap() -> Duration {
    Duration::from_secs(5)
}

fn default_retry_max_attempts() -> u32 {
    5
}

fn default_jitter() -> Jitter {
    Jitter::Full
}

impl Default for RetryCfg {
    fn default() -> Self {
        Self {
            base: default_retry_base(),
            factor: default_retry_factor(),
            cap: default_retry_cap(),
            max_attempts: default_retry_max_attempts(),
            jitter: default_jitter(),
        }
    }
}

/// Idempotency tuning.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct IdemCfg {
    /// Whether to attach idempotency keys by default on mutations.
    #[serde(default = "default_idem_enabled")]
    pub enabled: bool,
    /// Optional key prefix to avoid PII in idempotency keys.
    pub key_prefix: Option<String>,
}

fn default_idem_enabled() -> bool {
    true
}

impl Default for IdemCfg {
    fn default() -> Self {
        Self {
            enabled: default_idem_enabled(),
            key_prefix: None,
        }
    }
}

/// In-memory client-side cache configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct CacheCfg {
    /// Whether the cache is enabled at all.
    #[serde(default)]
    pub enabled: bool,
    /// Maximum number of entries in the LRU.
    #[serde(default = "default_cache_entries")]
    pub max_entries: usize,
    /// TTL for each entry.
    #[serde(with = "humantime_serde", default = "default_cache_ttl")]
    pub ttl: Duration,
}

fn default_cache_entries() -> usize {
    1024
}

fn default_cache_ttl() -> Duration {
    Duration::from_secs(30)
}

impl Default for CacheCfg {
    fn default() -> Self {
        Self {
            enabled: false,
            max_entries: default_cache_entries(),
            ttl: default_cache_ttl(),
        }
    }
}

/// Tracing and metrics toggles.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct TracingCfg {
    /// Emit span events for SDK calls.
    #[serde(default)]
    pub spans: bool,
    /// Emit Prometheus-style metrics from the SDK.
    #[serde(default)]
    pub metrics: bool,
    /// Redaction posture.
    #[serde(default = "default_redaction")]
    pub redaction: Redaction,
}

fn default_redaction() -> Redaction {
    Redaction::Safe
}

impl Default for TracingCfg {
    fn default() -> Self {
        Self {
            spans: true,
            metrics: true,
            redaction: default_redaction(),
        }
    }
}

/// Tor-specific configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct TorCfg {
    /// SOCKS5 address for the local Tor daemon.
    #[serde(default = "default_tor_socks")]
    pub socks5_addr: String,
}

fn default_tor_socks() -> String {
    "127.0.0.1:9050".to_string()
}

impl Default for TorCfg {
    fn default() -> Self {
        Self {
            socks5_addr: default_tor_socks(),
        }
    }
}

/// Application-facing configuration for ron-app-sdk.
///
/// This struct is intentionally "boring": just data + serde. All env
/// parsing and validation lives in `config::mod`.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default, deny_unknown_fields)]
pub struct SdkConfig {
    /// Transport flavor (`tls` or `tor`).
    pub transport: Transport,
    /// Base gateway address (URL or `.onion`).
    pub gateway_addr: String,
    /// Overall per-call deadline (including retries).
    #[serde(with = "humantime_serde", default = "default_overall_timeout")]
    pub overall_timeout: Duration,
    /// Per-connection timeouts.
    pub timeouts: Timeouts,
    /// Retry/backoff tuning.
    pub retry: RetryCfg,
    /// Idempotency tuning.
    pub idempotency: IdemCfg,
    /// Client-side cache tuning.
    pub cache: CacheCfg,
    /// Tracing/metrics toggles.
    pub tracing: TracingCfg,
    /// Post-quantum mode.
    pub pq_mode: PqMode,
    /// Tor-specific configuration.
    pub tor: TorCfg,
}

fn default_overall_timeout() -> Duration {
    // README.md suggests 5000 ms as the baseline.
    Duration::from_millis(5000)
}

impl Default for SdkConfig {
    fn default() -> Self {
        Self {
            transport: Transport::Tls,
            gateway_addr: "http://127.0.0.1:8080".to_string(),
            overall_timeout: default_overall_timeout(),
            timeouts: Timeouts::default(),
            retry: RetryCfg::default(),
            idempotency: IdemCfg::default(),
            cache: CacheCfg::default(),
            tracing: TracingCfg::default(),
            pq_mode: PqMode::Off,
            tor: TorCfg::default(),
        }
    }
}

```

### crates/ron-app-sdk/src/context.rs
<a id="crates-ron-app-sdk-src-context-rs"></a>

```rust
//! RO:WHAT — Lightweight SDK context metadata.
//! RO:WHY  — Give callers a tiny “who am I talking to?” view without
//!           ever branching semantics based on profile (see I-1).
//! RO:INTERACTS — Constructed in `RonAppSdk::new`, may be enriched
//!                later when we add a real handshake.
//! RO:INVARIANTS —
//!   - No behavior decisions are made based on `NodeProfile`.
//!   - `amnesia` is a *hint* surfaced to hosts, not a control plane.

/// Logical deployment profile of the remote node.
///
/// This is intentionally small and matches the high-level Micronode /
/// Macronode split in the RON-CORE blueprints.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NodeProfile {
    /// Micronode profile (amnesia-friendly, edge-first).
    Micronode,
    /// Macronode profile (persistent overlay / services).
    Macronode,
}

/// Small, immutable view of SDK context.
///
/// Today this is constructed from configuration + (eventually) a small
/// handshake. It is **never** used to branch semantics — that’s the
/// whole point of invariant I-1 (profile parity).
#[derive(Debug, Clone, Copy)]
pub struct SdkContext {
    /// Reported/assumed node profile (Micronode/Macronode).
    pub profile: NodeProfile,
    /// Whether the remote node is currently in “amnesia mode”.
    ///
    /// For Micronodes this often maps to “RAM-only” posture; for
    /// Macronodes this may indicate a temporary override.
    pub amnesia: bool,
}

impl SdkContext {
    /// Construct a new SDK context.
    pub fn new(profile: NodeProfile, amnesia: bool) -> Self {
        Self { profile, amnesia }
    }

    /// Get the node profile (Micronode/Macronode).
    pub fn profile(&self) -> NodeProfile {
        self.profile
    }

    /// Whether the node is in amnesia posture.
    pub fn amnesia(&self) -> bool {
        self.amnesia
    }
}

```

### crates/ron-app-sdk/src/errors.rs
<a id="crates-ron-app-sdk-src-errors-rs"></a>

```rust
//! RO:WHAT — Error taxonomy for ron-app-sdk.
//! RO:WHY  — Give applications a small, stable set of error classes
//!           they can reason about (timeouts vs caps vs conflicts).
//! RO:INTERACTS — Used across all planes and the transport shim;
//!                mapping from HTTP/OAP/wire happens here.
//! RO:INVARIANTS —
//!   - Enum is `#[non_exhaustive]` per API.md.
//!   - Retry classification is centralized here (I-5/I-8).
//! RO:SECURITY — Messages are safe for logs; no secrets included.

use std::{error::Error, fmt, time::Duration};

/// Stable, non-exhaustive SDK error type.
///
/// This matches the shape laid out in `docs/API.md`. New variants may
/// be added over time, but existing ones will not be removed or
/// renamed without a SemVer bump.
#[non_exhaustive]
#[derive(Debug)]
pub enum SdkError {
    /// Overall deadline for the operation was exceeded.
    DeadlineExceeded,

    /// Underlying transport failed (TCP, DNS, etc.).
    Transport(std::io::ErrorKind),

    /// TLS handshake/verification error.
    Tls,

    /// Tor was requested but not available/usable.
    TorUnavailable,

    /// OAP/1 protocol or bounds violation (e.g., frame too large).
    OapViolation {
        /// Human-readable reason string (static).
        reason: &'static str,
    },

    /// Capability has expired (e.g., `nbf`/`exp` window).
    CapabilityExpired,

    /// Capability does not grant access to the requested resource.
    CapabilityDenied,

    /// Schema/validation error at the SDK boundary.
    ///
    /// Examples: invalid `AddrB3` string, wrong DTO shape, etc.
    SchemaViolation {
        /// Logical path (e.g., `"addr_b3"`, `"payload.body"`).
        path: String,
        /// Short description of what went wrong.
        detail: String,
    },

    /// Resource not found (404-style).
    NotFound,

    /// Conflict (409-style) — usually idempotency or version clash.
    Conflict,

    /// Rate-limited by the remote service.
    ///
    /// Optional `retry_after` allows well-behaved exponential backoff
    /// or respect for concrete `Retry-After` hints when present.
    RateLimited { retry_after: Option<Duration> },

    /// Remote server error with raw status code.
    Server(u16),

    /// Catch-all for errors that don’t fit other variants yet.
    Unknown(String),
}

/// Coarse retry classification for SDK errors.
///
/// This keeps the retry/backoff logic in one place and lets callers
/// apply their own policies if they want something fancier.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RetryClass {
    /// Retrying *may* succeed (timeouts, 5xx, backpressure).
    Retriable,
    /// Retrying is not expected to help (caps, schema, conflicts).
    NoRetry,
}

impl SdkError {
    /// Create a schema violation error with structured fields.
    pub fn schema_violation(path: impl Into<String>, detail: impl Into<String>) -> Self {
        SdkError::SchemaViolation {
            path: path.into(),
            detail: detail.into(),
        }
    }

    /// Create a rate-limited error with optional retry hint.
    pub fn rate_limited(retry_after: Option<Duration>) -> Self {
        SdkError::RateLimited { retry_after }
    }

    /// Map an IO error into the transport bucket.
    pub fn from_io(err: std::io::Error) -> Self {
        SdkError::Transport(err.kind())
    }

    /// Classify this error for retry purposes.
    pub fn retry_class(&self) -> RetryClass {
        use RetryClass::{NoRetry, Retriable};

        match *self {
            SdkError::DeadlineExceeded => Retriable,
            SdkError::Transport(_) => Retriable,
            SdkError::RateLimited { .. } => Retriable,
            SdkError::Server(code) if (500..600).contains(&code) => Retriable,

            // Everything else we conservatively treat as non-retriable.
            SdkError::Tls
            | SdkError::TorUnavailable
            | SdkError::OapViolation { .. }
            | SdkError::CapabilityExpired
            | SdkError::CapabilityDenied
            | SdkError::SchemaViolation { .. }
            | SdkError::NotFound
            | SdkError::Conflict
            | SdkError::Server(_)
            | SdkError::Unknown(_) => NoRetry,
        }
    }

    /// Convenience helper.
    pub fn is_retriable(&self) -> bool {
        self.retry_class() == RetryClass::Retriable
    }
}

impl fmt::Display for SdkError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use SdkError::*;

        match self {
            DeadlineExceeded => write!(f, "deadline exceeded"),
            Transport(kind) => write!(f, "transport error ({kind:?})"),
            Tls => write!(f, "TLS error"),
            TorUnavailable => write!(f, "Tor transport unavailable"),
            OapViolation { reason } => write!(f, "OAP violation: {reason}"),
            CapabilityExpired => write!(f, "capability expired"),
            CapabilityDenied => write!(f, "capability denied"),
            SchemaViolation { path, detail } => {
                write!(f, "schema violation at `{path}`: {detail}")
            }
            NotFound => write!(f, "not found"),
            Conflict => write!(f, "conflict"),
            RateLimited { retry_after } => {
                if let Some(d) = retry_after {
                    write!(f, "rate limited (retry after {d:?})")
                } else {
                    write!(f, "rate limited")
                }
            }
            Server(code) => write!(f, "server error ({code})"),
            Unknown(msg) => write!(f, "unknown error: {msg}"),
        }
    }
}

impl Error for SdkError {}

```

### crates/ron-app-sdk/src/idempotency.rs
<a id="crates-ron-app-sdk-src-idempotency-rs"></a>

```rust
//! RO:WHAT — Idempotency key derivation + header mapping helpers.
//! RO:WHY  — Give applications a deterministic, low-PII way to derive
//!           idempotency keys for “logical operations” (governance I-G1).
//! RO:INTERACTS — Uses `crate::config::IdemCfg`; will be used by planes
//!                (storage/mailbox/index) and transport wrappers.
//! RO:INVARIANTS —
//!   - Never generates two different keys for the same logical op.
//!   - Stable across process restarts (pure function of inputs).
//!   - No randomness; no dependency on wall-clock time.
//!   - No PII baked into the key string when a prefix is used.
//! RO:METRICS — None directly (planes may emit counters per idempotent call).
//! RO:CONFIG — Reads `IdemCfg { enabled, key_prefix }`.
//! RO:SECURITY — Keys are opaque 64-bit fingerprints; callers should avoid
//!               embedding raw PII into the “logical_key” input.
//! RO:TEST — Unit tests in this module (determinism + collision sanity).

use std::collections::hash_map::DefaultHasher;
use std::fmt;
use std::hash::{Hash, Hasher};

use crate::config::IdemCfg;

/// Default HTTP header name for idempotency keys.
///
/// This is a *convention*, not a hard requirement. Some hosts may
/// prefer a different header name at the gateway level.
pub const IDEMPOTENCY_HEADER: &str = "Idempotency-Key";

/// Opaque idempotency key value.
///
/// Semantically represented as a string, but we keep it wrapped so the
/// semantics remain clear and we can refine the format later without
/// breaking callers.
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct IdempotencyKey(String);

impl IdempotencyKey {
    /// Access the underlying string.
    #[inline]
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Consume and return the underlying string.
    #[inline]
    pub fn into_string(self) -> String {
        self.0
    }

    /// Convenience helper to turn this key into a `(header_name, value)` pair.
    #[inline]
    pub fn into_header(self) -> (String, String) {
        (IDEMPOTENCY_HEADER.to_string(), self.0)
    }
}

impl AsRef<str> for IdempotencyKey {
    #[inline]
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl fmt::Debug for IdempotencyKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Redact to avoid accidental key exposure in logs.
        f.debug_tuple("IdempotencyKey")
            .field(&"...redacted...")
            .finish()
    }
}

impl fmt::Display for IdempotencyKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

/// Derive an idempotency key for a logical operation.
///
/// Inputs:
/// - `cfg` — idempotency configuration (enable/disable, optional prefix).
/// - `method` — logical verb (e.g., "PUT", "POST"); case-insensitive.
/// - `endpoint` — stable endpoint identifier (path or logical name).
/// - `logical_key` — caller-defined identifier for the logical op
///   (e.g., order ID, manifest ID). May be `None` for simple cases.
///
/// Returns `None` when idempotency is disabled in config.
#[allow(dead_code)] // Public helper; may be used only by SDK consumers.
pub fn derive_idempotency_key(
    cfg: &IdemCfg,
    method: &str,
    endpoint: &str,
    logical_key: Option<&str>,
) -> Option<IdempotencyKey> {
    if !cfg.enabled {
        return None;
    }

    // Normalize inputs into a single logical string.
    let method_norm = method.to_ascii_uppercase();
    let endpoint_norm = endpoint.trim();
    let logical_norm = logical_key.unwrap_or("").trim();

    let fingerprint = stable_fingerprint(&format!(
        "{}\n{}\n{}",
        method_norm, endpoint_norm, logical_norm
    ));

    // Optional prefix helps keep keys non-PII even if logical_key has
    // some user-provided content.
    let prefix = cfg.key_prefix.as_deref().unwrap_or("ron"); // short + recognizable.

    let key = format!("{prefix}_{fingerprint:016x}");
    Some(IdempotencyKey(key))
}

/// Internal helper — 64-bit stable fingerprint using the standard hasher.
///
/// This is *not* cryptographic and is not intended for security; it’s
/// just a low-collision, deterministic fingerprint for idempotency.
#[allow(dead_code)] // Only used by `derive_idempotency_key` and tests.
fn stable_fingerprint(input: &str) -> u64 {
    let mut h = DefaultHasher::new();
    input.hash(&mut h);
    h.finish()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn disabled_returns_none() {
        let cfg = IdemCfg {
            enabled: false,
            key_prefix: None,
        };
        let key = derive_idempotency_key(&cfg, "POST", "/storage/put", Some("abc"));
        assert!(key.is_none());
    }

    #[test]
    fn same_inputs_same_key() {
        let cfg = IdemCfg {
            enabled: true,
            key_prefix: Some("test".to_string()),
        };

        let a = derive_idempotency_key(&cfg, "POST", "/storage/put", Some("abc")).unwrap();
        let b = derive_idempotency_key(&cfg, "post", " /storage/put ", Some("abc")).unwrap();

        assert_eq!(a, b);
        // also assert AsRef/Display behave
        assert_eq!(a.as_ref(), b.as_str());
        assert_eq!(a.to_string(), b.to_string());
    }

    #[test]
    fn different_logical_key_changes_fingerprint() {
        let cfg = IdemCfg {
            enabled: true,
            key_prefix: Some("test".to_string()),
        };

        let a = derive_idempotency_key(&cfg, "POST", "/storage/put", Some("abc")).unwrap();
        let b = derive_idempotency_key(&cfg, "POST", "/storage/put", Some("def")).unwrap();

        assert_ne!(a, b);
    }
}

```

### crates/ron-app-sdk/src/lib.rs
<a id="crates-ron-app-sdk-src-lib-rs"></a>

```rust
#![allow(clippy::doc_lazy_continuation, clippy::doc_overindented_list_items)]
#![forbid(unsafe_code)]
//! ron-app-sdk — Application SDK for RON-CORE.
//!
//! RO:WHAT — Tiny async client façade over Micronode/Macronode node
//!           surfaces (edge, storage, mailbox, index).
//! RO:WHY  — Give apps a boring, well-typed, capability-first client
//!           with consistent retries, deadlines, and DTO hygiene.
//! RO:INTERACTS —
//!   - `config` for `SdkConfig` + env loading/validation.
//!   - `transport` for OAP/1 calls (TLS/Tor).
//!   - `planes::*` for storage/edge/mailbox/index helpers.
//!   - `metrics`/`tracing` for observability hooks.
//! RO:INVARIANTS —
//!   - All outbound calls carry a capability (I-2).
//!   - No semantic branching on `NodeProfile` (I-1).
//!   - OAP frame cap is enforced in the transport layer (I-3).

pub mod cache;
pub mod config;
mod context;
pub mod errors;
mod idempotency;
pub mod metrics;
mod ready;
mod retry;
mod tracing;
pub mod transport;
mod types;

// Planes: defined as a nested module so we can keep each plane in a
// dedicated file under `src/planes/`.
pub mod planes {
    pub mod edge;
    pub mod index;
    pub mod mailbox;
    pub mod storage;
}

pub use context::{NodeProfile, SdkContext};
pub use errors::{RetryClass, SdkError};
pub use ready::{check_ready, ReadyReport};
pub use types::{Ack, AddrB3, ByteRange, Capability, IdemKey, IndexKey, Mail, MailInbox, Receipt};

pub use config::{
    CacheCfg, IdemCfg, Jitter, PqMode, Redaction, SdkConfig, Timeouts, TorCfg, TracingCfg,
    Transport,
};

pub use metrics::{NoopSdkMetrics, SdkMetrics};

use bytes::Bytes;
use std::time::Duration;

use context::NodeProfile as CtxProfile;
use transport::TransportHandle;

/// High-level async client façade for RON-CORE nodes.
///
/// Constructed from `SdkConfig` and a (future) handshake, and then
/// used to issue calls to the various planes (storage, edge, mailbox,
/// index) with consistent deadlines/retries/error handling.
pub struct RonAppSdk {
    transport: TransportHandle,
    ctx: SdkContext,
    metrics: Box<dyn SdkMetrics>,
}

impl RonAppSdk {
    /// Create a new SDK client from configuration.
    ///
    /// This validates the config and prepares internal handles. In
    /// future revisions it may perform a light handshake to fill in
    /// `SdkContext` with accurate profile/amnesia metadata.
    pub async fn new(cfg: SdkConfig) -> Result<RonAppSdk, SdkError> {
        // Fail-closed on invalid config.
        cfg.validate()
            .map_err(|err| SdkError::schema_violation("config", err.to_string()))?;

        let transport = TransportHandle::new(cfg);
        // Until a real handshake exists, assume Micronode + non-amnesia.
        let ctx = SdkContext::new(CtxProfile::Micronode, false);

        Ok(RonAppSdk {
            transport,
            ctx,
            metrics: Box::<NoopSdkMetrics>::default(),
        })
    }

    /// Expose the SDK context (profile + amnesia hint).
    pub fn context(&self) -> SdkContext {
        self.ctx
    }

    /// Get a reference to the metrics sink.
    pub fn metrics(&self) -> &dyn SdkMetrics {
        &*self.metrics
    }

    /// Mutably access the metrics sink.
    pub fn metrics_mut(&mut self) -> &mut dyn SdkMetrics {
        &mut *self.metrics
    }

    /// Replace the metrics sink with a custom implementation.
    pub fn set_metrics<M>(&mut self, metrics: M)
    where
        M: SdkMetrics + 'static,
    {
        self.metrics = Box::new(metrics);
    }

    // -------------- Mailbox plane --------------

    /// Send a message via the mailbox plane.
    pub async fn mailbox_send(
        &self,
        cap: Capability,
        msg: Mail,
        deadline: Duration,
        idem: Option<IdemKey>,
    ) -> Result<Receipt, SdkError> {
        planes::mailbox::mailbox_send(&self.transport, &*self.metrics, cap, msg, deadline, idem)
            .await
    }

    /// Receive messages from the mailbox plane.
    pub async fn mailbox_recv(
        &self,
        cap: Capability,
        deadline: Duration,
    ) -> Result<Vec<MailInbox>, SdkError> {
        planes::mailbox::mailbox_recv(&self.transport, &*self.metrics, cap, deadline).await
    }

    /// Acknowledge mailbox messages.
    pub async fn mailbox_ack(
        &self,
        cap: Capability,
        ack: Receipt,
        deadline: Duration,
    ) -> Result<(), SdkError> {
        planes::mailbox::mailbox_ack(&self.transport, &*self.metrics, cap, ack, deadline).await
    }

    // -------------- Edge plane --------------

    /// Fetch an edge resource with an optional byte range.
    pub async fn edge_get(
        &self,
        cap: Capability,
        path: &str,
        range: Option<ByteRange>,
        deadline: Duration,
    ) -> Result<Bytes, SdkError> {
        planes::edge::edge_get(&self.transport, &*self.metrics, cap, path, range, deadline).await
    }

    // -------------- Storage plane --------------

    /// Perform a content-addressed GET from the storage plane.
    ///
    /// `addr_b3_hex` must be a `"b3:<64 hex>"` string; invalid values
    /// are reported as `SdkError::SchemaViolation`.
    pub async fn storage_get(
        &self,
        cap: Capability,
        addr_b3_hex: &str,
        deadline: Duration,
    ) -> Result<Bytes, SdkError> {
        let addr = AddrB3::parse(addr_b3_hex)
            .map_err(|err| SdkError::schema_violation("addr_b3", err.to_string()))?;

        planes::storage::storage_get(&self.transport, &*self.metrics, cap, &addr, deadline).await
    }

    /// Perform a content-addressed PUT to the storage plane.
    pub async fn storage_put(
        &self,
        cap: Capability,
        blob: Bytes,
        deadline: Duration,
        idem: Option<IdemKey>,
    ) -> Result<AddrB3, SdkError> {
        planes::storage::storage_put(&self.transport, &*self.metrics, cap, blob, deadline, idem)
            .await
    }

    // -------------- Index plane --------------

    /// Resolve a logical index key into a content address.
    pub async fn index_resolve(
        &self,
        cap: Capability,
        key: &IndexKey,
        deadline: Duration,
    ) -> Result<AddrB3, SdkError> {
        planes::index::index_resolve(&self.transport, &*self.metrics, cap, key, deadline).await
    }
}

```

### crates/ron-app-sdk/src/metrics.rs
<a id="crates-ron-app-sdk-src-metrics-rs"></a>

```rust
//! RO:WHAT — Minimal metrics facade for SDK operations.
//! RO:WHY  — Give hosts a single, stable trait they can implement using
//!           Prometheus, OpenTelemetry, or their own metrics stack.
//! RO:INTERACTS — Intended to be threaded through planes (storage/edge/
//!                mailbox/index) and caches; default impl is no-op.
//! RO:INVARIANTS —
//!   - No global state; host controls concrete implementation.
//!   - No dependency on any metrics crate (Prometheus/Otel lives outside).
//!   - Low-cardinality labels: endpoints should be path-like, not per-ID.
//! RO:METRICS — Shape only; concrete counters/histograms are defined by hosts.
//! RO:CONFIG — Typically driven by `TracingCfg.metrics` and host config.
//! RO:SECURITY — Callers should avoid using PII-heavy label values.
//! RO:TEST — Basic unit tests for the no-op implementation.

/// High-level metrics trait for SDK operations.
///
/// Host applications can implement this trait using whatever metrics
/// framework they prefer. The SDK only cares about the *shape* of the
/// metrics, not how they are exported.
pub trait SdkMetrics: Send + Sync + 'static {
    /// Observe latency of a single SDK call (in milliseconds).
    ///
    /// `endpoint` should be a low-cardinality identifier such as a path
    /// (`/storage/put`) or logical name (`storage_put`).
    fn observe_latency(&self, endpoint: &str, success: bool, latency_ms: u64);

    /// Increment the retry counter for a given endpoint.
    fn inc_retry(&self, endpoint: &str);

    /// Increment a failure counter tagged with a coarse reason.
    fn inc_failure(&self, endpoint: &str, reason: &'static str);

    /// Count cache hits for SDK-level caches (if used).
    fn inc_cache_hit(&self, endpoint: &str);

    /// Count cache misses for SDK-level caches (if used).
    fn inc_cache_miss(&self, endpoint: &str);
}

/// No-op metrics implementation (default).
///
/// This is useful for tests, examples, and hosts that do not care about
/// metrics. All methods are intentionally zero-cost.
#[derive(Debug, Default, Clone, Copy)]
pub struct NoopSdkMetrics;

impl SdkMetrics for NoopSdkMetrics {
    #[inline]
    fn observe_latency(&self, _endpoint: &str, _success: bool, _latency_ms: u64) {
        // no-op
    }

    #[inline]
    fn inc_retry(&self, _endpoint: &str) {
        // no-op
    }

    #[inline]
    fn inc_failure(&self, _endpoint: &str, _reason: &'static str) {
        // no-op
    }

    #[inline]
    fn inc_cache_hit(&self, _endpoint: &str) {
        // no-op
    }

    #[inline]
    fn inc_cache_miss(&self, _endpoint: &str) {
        // no-op
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn noop_is_send_sync_static() {
        fn assert_bounds<T: SdkMetrics>() {}
        assert_bounds::<NoopSdkMetrics>();
    }
}

```

### crates/ron-app-sdk/src/planes/edge.rs
<a id="crates-ron-app-sdk-src-planes-edge-rs"></a>

```rust
//! RO:WHAT — Edge plane helpers (GET with optional byte range).
//! RO:WHY  — Range-aware fetch with strict range validation.
//! RO:INTERACTS — transport.call_oap_json.
//! RO:INVARIANTS — deadlines > 0; ranges validated (inclusive semantics).

use std::time::{Duration, Instant};

use bytes::Bytes;

use crate::errors::SdkError;
use crate::metrics::SdkMetrics;
use crate::transport::TransportHandle;
use crate::types::{ByteRange, Capability};

// Gateway endpoint.
const EP_EDGE_GET: &str = "/edge/get";

// Metric label.
const EDGE_GET_ENDPOINT: &str = "edge_get";

// ---------- DTOs ----------

#[derive(serde::Serialize)]
struct EdgeGetReq<'a> {
    cap: &'a Capability,
    path: &'a str,
    #[serde(skip_serializing_if = "Option::is_none")]
    range: Option<EdgeRange>,
}

#[derive(serde::Serialize)]
struct EdgeRange {
    start: u64,
    end: u64, // inclusive
}

#[derive(serde::Deserialize)]
#[serde(deny_unknown_fields)]
struct EdgeGetResp {
    #[serde(with = "serde_bytes")]
    blob: Vec<u8>,
}

// ---------- API ----------

pub async fn edge_get(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    path: &str,
    range: Option<ByteRange>,
    deadline: Duration,
) -> Result<Bytes, SdkError> {
    if deadline.is_zero() {
        return Err(SdkError::schema_violation(
            "edge_get.deadline",
            "deadline must be > 0",
        ));
    }

    // Validate range if provided.
    let range_json = if let Some(r) = range {
        if r.start > r.end {
            return Err(SdkError::schema_violation(
                "edge_get.range",
                "start must be <= end (inclusive semantics)",
            ));
        }
        Some(EdgeRange {
            start: r.start,
            end: r.end,
        })
    } else {
        None
    };

    let start = Instant::now();
    let payload = EdgeGetReq {
        cap: &cap,
        path,
        range: range_json,
    };

    let raw = transport
        .call_oap_json(EP_EDGE_GET, &payload, deadline)
        .await;
    let elapsed_ms = start.elapsed().as_millis() as u64;

    match raw {
        Ok(bytes) => {
            let parsed: EdgeGetResp = serde_json::from_slice(&bytes)
                .map_err(|e| SdkError::schema_violation("edge_get.body", e.to_string()))?;
            metrics.observe_latency(EDGE_GET_ENDPOINT, true, elapsed_ms);
            Ok(Bytes::from(parsed.blob))
        }
        Err(err) => {
            metrics.observe_latency(EDGE_GET_ENDPOINT, false, elapsed_ms);
            metrics.inc_failure(EDGE_GET_ENDPOINT, classify(&err));
            Err(err)
        }
    }
}

fn classify(err: &SdkError) -> &'static str {
    use SdkError::*;
    match err {
        DeadlineExceeded => "deadline",
        Transport(_) => "transport",
        TorUnavailable => "tor",
        Tls => "tls",
        OapViolation { .. } => "oap",
        CapabilityExpired | CapabilityDenied => "capability",
        SchemaViolation { .. } => "schema",
        NotFound => "not_found",
        Conflict => "conflict",
        RateLimited { .. } => "rate_limited",
        Server(_) => "server",
        Unknown(_) => "unknown",
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn byte_range_header_format_is_inclusive() {
        let r = ByteRange { start: 0, end: 9 };
        // inclusive means length is (end - start + 1)
        assert_eq!(r.len(), 10);
    }

    #[test]
    fn byte_range_validation_accepts_well_formed_range() {
        let r = ByteRange { start: 5, end: 7 };
        assert!(r.start <= r.end);
    }

    #[test]
    fn byte_range_validation_rejects_inverted_range() {
        let r = ByteRange { start: 8, end: 7 };
        assert!(r.start > r.end);
    }
}

```

### crates/ron-app-sdk/src/planes/index.rs
<a id="crates-ron-app-sdk-src-planes-index-rs"></a>

```rust
//! RO:WHAT — Index plane helpers (logical key → AddrB3 resolve).
//! RO:WHY  — Capability-first resolve with strict schema checks.
//! RO:INTERACTS — transport.call_oap_json.
//! RO:INVARIANTS — deadlines > 0; returned address must parse as AddrB3.

use std::time::{Duration, Instant};

use crate::errors::SdkError;
use crate::metrics::SdkMetrics;
use crate::transport::TransportHandle;
use crate::types::{AddrB3, Capability, IndexKey};

// Gateway endpoint.
const EP_INDEX_RESOLVE: &str = "/index/resolve";

// Metric label.
const INDEX_RESOLVE_ENDPOINT: &str = "index_resolve";

// ---------- DTOs ----------

#[derive(serde::Serialize)]
struct ResolveReq<'a> {
    cap: &'a Capability,
    key: &'a IndexKey,
}

#[derive(serde::Deserialize)]
#[serde(deny_unknown_fields)]
struct ResolveResp {
    addr_b3: String, // "b3:<hex64>"
}

// ---------- API ----------

pub async fn index_resolve(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    key: &IndexKey,
    deadline: Duration,
) -> Result<AddrB3, SdkError> {
    if deadline.is_zero() {
        // Keep metrics trait simple for beta: just latency + failure classification.
        metrics.observe_latency(INDEX_RESOLVE_ENDPOINT, false, 0);
        metrics.inc_failure(INDEX_RESOLVE_ENDPOINT, "index_resolve.deadline");
        return Err(SdkError::schema_violation(
            "index_resolve.deadline",
            "deadline must be > 0",
        ));
    }

    let started = Instant::now();
    let payload = ResolveReq { cap: &cap, key };

    // Serialize + transport.
    let raw = transport
        .call_oap_json(EP_INDEX_RESOLVE, &payload, deadline)
        .await;
    let elapsed_ms = started.elapsed().as_millis() as u64;

    match raw {
        Ok(bytes) => {
            // Parse body.
            let parsed: ResolveResp = match serde_json::from_slice(&bytes) {
                Ok(v) => v,
                Err(e) => {
                    metrics.observe_latency(INDEX_RESOLVE_ENDPOINT, false, elapsed_ms);
                    metrics.inc_failure(INDEX_RESOLVE_ENDPOINT, "index_resolve.body");
                    return Err(SdkError::schema_violation(
                        "index_resolve.body",
                        e.to_string(),
                    ));
                }
            };

            // Validate the returned address.
            let addr = AddrB3::parse(&parsed.addr_b3).map_err(|e| {
                metrics.observe_latency(INDEX_RESOLVE_ENDPOINT, false, elapsed_ms);
                metrics.inc_failure(INDEX_RESOLVE_ENDPOINT, "index_resolve.addr");
                SdkError::schema_violation("index_resolve.addr_b3", e.to_string())
            })?;

            metrics.observe_latency(INDEX_RESOLVE_ENDPOINT, true, elapsed_ms);
            Ok(addr)
        }
        Err(err) => {
            metrics.observe_latency(INDEX_RESOLVE_ENDPOINT, false, elapsed_ms);
            metrics.inc_failure(INDEX_RESOLVE_ENDPOINT, classify(&err));
            Err(err)
        }
    }
}

fn classify(err: &SdkError) -> &'static str {
    use SdkError::*;
    match err {
        DeadlineExceeded => "deadline",
        Transport(_) => "transport",
        TorUnavailable => "tor",
        Tls => "tls",
        OapViolation { .. } => "oap",
        CapabilityExpired | CapabilityDenied => "capability",
        SchemaViolation { .. } => "schema",
        NotFound => "not_found",
        Conflict => "conflict",
        RateLimited { .. } => "rate_limited",
        Server(_) => "server",
        Unknown(_) => "unknown",
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn dummy_compile_only() {
        // Keep a tiny test so the module is exercised without needing
        // helpers from other crates.
        let _ = (INDEX_RESOLVE_ENDPOINT, EP_INDEX_RESOLVE);
    }
}

```

### crates/ron-app-sdk/src/planes/mailbox.rs
<a id="crates-ron-app-sdk-src-planes-mailbox-rs"></a>

```rust
// REPLACE ENTIRE FILE with this version
//! RO:WHAT — Mailbox plane helpers (send/recv/ack trio).
//! RO:WHY  — Provide a simple at-least-once-style interface.
//! RO:NOTE — JSON-on-OAP for this increment; retries via transport.

use std::time::{Duration, Instant};

use crate::errors::SdkError;
use crate::metrics::SdkMetrics;
use crate::transport::TransportHandle;
use crate::types::{Capability, IdemKey, Mail, MailInbox, Receipt};

const MAILBOX_SEND_ENDPOINT: &str = "mailbox_send";
const MAILBOX_RECV_ENDPOINT: &str = "mailbox_recv";
const MAILBOX_ACK_ENDPOINT: &str = "mailbox_ack";

// Wire endpoints (gateway-facing).
const EP_SEND: &str = "/mb/send";
const EP_RECV: &str = "/mb/recv";
const EP_ACK: &str = "/mb/ack";

#[derive(serde::Serialize)]
struct SendReq<'a> {
    cap: &'a Capability,
    mail: &'a Mail,
    #[serde(skip_serializing_if = "Option::is_none")]
    idem: Option<&'a str>,
}

#[derive(serde::Deserialize)]
struct SendResp {
    receipt: Receipt,
}

#[derive(serde::Serialize)]
struct RecvReq<'a> {
    cap: &'a Capability,
}

#[derive(serde::Deserialize)]
struct RecvResp {
    inbox: Vec<MailInbox>,
}

#[derive(serde::Serialize)]
struct AckReq<'a> {
    cap: &'a Capability,
    receipt: &'a Receipt,
}

pub async fn mailbox_send(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    msg: Mail,
    deadline: Duration,
    idem: Option<IdemKey>,
) -> Result<Receipt, SdkError> {
    if deadline == Duration::from_millis(0) {
        return Err(SdkError::schema_violation(
            "mailbox_send.deadline",
            "deadline must be > 0",
        ));
    }

    let start = Instant::now();
    let payload = SendReq {
        cap: &cap,
        mail: &msg,
        // FIX: borrow the inner &str via IdemKey::as_str()
        idem: idem.as_ref().map(|k| k.as_str()),
    };

    let raw = transport.call_oap_json(EP_SEND, &payload, deadline).await;
    let elapsed_ms = start.elapsed().as_millis() as u64;

    match raw {
        Ok(bytes) => {
            let parsed: SendResp = serde_json::from_slice(&bytes)
                .map_err(|e| SdkError::schema_violation("mailbox_send.body", e.to_string()))?;
            metrics.observe_latency(MAILBOX_SEND_ENDPOINT, true, elapsed_ms);
            Ok(parsed.receipt)
        }
        Err(err) => {
            metrics.observe_latency(MAILBOX_SEND_ENDPOINT, false, elapsed_ms);
            metrics.inc_failure(MAILBOX_SEND_ENDPOINT, classify(&err));
            Err(err)
        }
    }
}

pub async fn mailbox_recv(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    deadline: Duration,
) -> Result<Vec<MailInbox>, SdkError> {
    if deadline == Duration::from_millis(0) {
        return Err(SdkError::schema_violation(
            "mailbox_recv.deadline",
            "deadline must be > 0",
        ));
    }

    let start = Instant::now();
    let payload = RecvReq { cap: &cap };

    let raw = transport.call_oap_json(EP_RECV, &payload, deadline).await;
    let elapsed_ms = start.elapsed().as_millis() as u64;

    match raw {
        Ok(bytes) => {
            let parsed: RecvResp = serde_json::from_slice(&bytes)
                .map_err(|e| SdkError::schema_violation("mailbox_recv.body", e.to_string()))?;
            metrics.observe_latency(MAILBOX_RECV_ENDPOINT, true, elapsed_ms);
            Ok(parsed.inbox)
        }
        Err(err) => {
            metrics.observe_latency(MAILBOX_RECV_ENDPOINT, false, elapsed_ms);
            metrics.inc_failure(MAILBOX_RECV_ENDPOINT, classify(&err));
            Err(err)
        }
    }
}

pub async fn mailbox_ack(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    receipt: Receipt,
    deadline: Duration,
) -> Result<(), SdkError> {
    if deadline == Duration::from_millis(0) {
        return Err(SdkError::schema_violation(
            "mailbox_ack.deadline",
            "deadline must be > 0",
        ));
    }

    let start = Instant::now();
    let payload = AckReq {
        cap: &cap,
        receipt: &receipt,
    };

    let res = transport.call_oap_json(EP_ACK, &payload, deadline).await;
    let elapsed_ms = start.elapsed().as_millis() as u64;

    match res {
        Ok(_) => {
            metrics.observe_latency(MAILBOX_ACK_ENDPOINT, true, elapsed_ms);
            Ok(())
        }
        Err(err) => {
            metrics.observe_latency(MAILBOX_ACK_ENDPOINT, false, elapsed_ms);
            metrics.inc_failure(MAILBOX_ACK_ENDPOINT, classify(&err));
            Err(err)
        }
    }
}

fn classify(err: &SdkError) -> &'static str {
    use SdkError::*;
    match err {
        DeadlineExceeded => "deadline",
        Transport(_) => "transport",
        TorUnavailable => "tor",
        Tls => "tls",
        OapViolation { .. } => "oap",
        CapabilityExpired | CapabilityDenied => "capability",
        SchemaViolation { .. } => "schema",
        NotFound => "not_found",
        Conflict => "conflict",
        RateLimited { .. } => "rate_limited",
        Server(_) => "server",
        Unknown(_) => "unknown",
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::SdkConfig;
    use crate::metrics::NoopSdkMetrics;

    fn dummy_capability() -> Capability {
        Capability {
            subject: "test-subject".to_string(),
            scope: "test-scope".to_string(),
            issued_at: 0,
            expires_at: u64::MAX,
            caveats: Vec::new(),
        }
    }

    fn dummy_mail() -> Mail {
        Mail {
            msg_id: "msg-1".to_string(),
            to: "dest".to_string(),
            kind: "test-kind".to_string(),
            payload: Vec::new(),
            idempotency_key: None,
        }
    }

    fn dummy_receipt() -> Receipt {
        Receipt {
            msg_id: "ack-1".to_string(),
            ok: true,
            error: None,
        }
    }

    #[tokio::test]
    async fn mailbox_send_rejects_zero_deadline() {
        let transport = TransportHandle::new(SdkConfig::default());
        let metrics = NoopSdkMetrics;
        let cap = dummy_capability();
        let mail = dummy_mail();

        let err = mailbox_send(
            &transport,
            &metrics,
            cap,
            mail,
            Duration::from_millis(0),
            None,
        )
        .await
        .unwrap_err();
        match err {
            SdkError::SchemaViolation { path, .. } => assert_eq!(path, "mailbox_send.deadline"),
            other => panic!("unexpected error: {other:?}"),
        }
    }

    #[tokio::test]
    async fn mailbox_recv_rejects_zero_deadline() {
        let transport = TransportHandle::new(SdkConfig::default());
        let metrics = NoopSdkMetrics;
        let cap = dummy_capability();

        let err = mailbox_recv(&transport, &metrics, cap, Duration::ZERO)
            .await
            .unwrap_err();
        match err {
            SdkError::SchemaViolation { path, .. } => assert_eq!(path, "mailbox_recv.deadline"),
            other => panic!("unexpected error: {other:?}"),
        }
    }

    #[tokio::test]
    async fn mailbox_ack_rejects_zero_deadline() {
        let transport = TransportHandle::new(SdkConfig::default());
        let metrics = NoopSdkMetrics;
        let cap = dummy_capability();
        let receipt = dummy_receipt();

        let err = mailbox_ack(&transport, &metrics, cap, receipt, Duration::ZERO)
            .await
            .unwrap_err();
        match err {
            SdkError::SchemaViolation { path, .. } => assert_eq!(path, "mailbox_ack.deadline"),
            other => panic!("unexpected error: {other:?}"),
        }
    }
}

```

### crates/ron-app-sdk/src/planes/mod.rs
<a id="crates-ron-app-sdk-src-planes-mod-rs"></a>

```rust
//! planes/mod.rs — re-exports for edge/storage/mailbox/index (scaffold).
pub mod storage;
pub mod edge;
pub mod mailbox;
pub mod index;
```

### crates/ron-app-sdk/src/planes/storage.rs
<a id="crates-ron-app-sdk-src-planes-storage-rs"></a>

```rust
//! RO:WHAT — Storage plane helpers for content-addressed blobs.
//! RO:WHY  — Give SDK users a boring `get/put` API on top of OAP/1 and
//!           capabilities, with size caps and error taxonomy handled here.
//! RO:INTERACTS — Delegates to `TransportHandle::call_oap` and uses
//!                `SdkMetrics` for latency/failure tracking.
//! RO:INVARIANTS —
//!   - All calls require a `Capability`; no anonymous storage access.
//!   - Requests larger than `OAP_MAX_FRAME_BYTES` are rejected client-side.
//!   - Errors are surfaced as `SdkError` (no panics).
//! RO:METRICS — Uses `SdkMetrics` with low-cardinality endpoints
//!              (`"storage_get"`, `"storage_put"`).
//! RO:CONFIG — Size cap is enforced via `OAP_MAX_FRAME_BYTES`; deadlines
//!             are per-call and must be supplied by the caller.
//! RO:SECURITY — Capability header must already encode macaroon-style
//!               restrictions; we do not log capability contents.
//! RO:TEST HOOKS — Unit tests here; integration/interop tests live under
//!                  `tests/i_*` once we wire real transport.

use std::time::{Duration, Instant};

use bytes::Bytes;

use crate::errors::SdkError;
use crate::metrics::SdkMetrics;
use crate::transport::{TransportHandle, OAP_MAX_FRAME_BYTES};
use crate::types::{AddrB3, Capability};

/// Optional idempotency key type alias (from `idempotency.rs`).
pub type IdemKey = crate::idempotency::IdempotencyKey;

/// Logical metric endpoints for this plane.
const STORAGE_GET_ENDPOINT: &str = "storage_get";
const STORAGE_PUT_ENDPOINT: &str = "storage_put";

/// Fetch a blob by content ID.
///
/// Thin wrapper:
/// - Validates the deadline is non-zero.
/// - Delegates to `TransportHandle::call_oap`.
/// - Emits latency + failure metrics.
///
/// Transport currently treats `endpoint` as a logical path and maps
/// it to concrete HTTP. We use `/o/<b3>` for reads (raw bytes body).
pub async fn storage_get(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    addr: &AddrB3,
    deadline: Duration,
) -> Result<Bytes, SdkError> {
    if deadline.is_zero() {
        return Err(SdkError::schema_violation(
            "storage_get.deadline",
            "deadline must be > 0",
        ));
    }

    let start = Instant::now();
    let endpoint = format!("/o/{}", addr.as_str());

    // Capability threading is a TODO for the transport layer. For now
    // it is validated at the gateway; we avoid logging cap contents.
    let _ = cap;

    let result = transport.call_oap(&endpoint, &[], deadline).await;
    let elapsed_ms = start.elapsed().as_millis() as u64;

    match result {
        Ok(body) => {
            metrics.observe_latency(STORAGE_GET_ENDPOINT, true, elapsed_ms);
            Ok(Bytes::from(body))
        }
        Err(err) => {
            metrics.observe_latency(STORAGE_GET_ENDPOINT, false, elapsed_ms);
            metrics.inc_failure(STORAGE_GET_ENDPOINT, classify_error(&err));
            Err(err)
        }
    }
}

/// Store a blob and return its content ID (`AddrB3`).
///
/// Behavior:
/// - Rejects payloads larger than `OAP_MAX_FRAME_BYTES`.
/// - Delegates to transport (`POST /put`) returning plain-text `b3:...`.
/// - Parses/validates `AddrB3`.
/// - Emits latency + failure metrics.
///
/// Idempotency:
/// - `idem_key` is forwarded once the wire header is finalized. For now
///   it’s accepted but not yet serialized on the wire.
pub async fn storage_put(
    transport: &TransportHandle,
    metrics: &dyn SdkMetrics,
    cap: Capability,
    blob: Bytes,
    deadline: Duration,
    idem_key: Option<IdemKey>,
) -> Result<AddrB3, SdkError> {
    if deadline.is_zero() {
        return Err(SdkError::schema_violation(
            "storage_put.deadline",
            "deadline must be > 0",
        ));
    }

    // Enforce the OAP frame cap at the SDK boundary.
    if blob.len() > OAP_MAX_FRAME_BYTES {
        return Err(SdkError::OapViolation {
            reason: "payload-too-large",
        });
    }

    let start = Instant::now();
    let endpoint = "/put";

    // TODO: pass capability + idempotency key in OAP headers once the
    // client transport supports it. Keep them out of logs.
    let _ = cap;
    let _ = idem_key;

    let result = transport
        .call_oap(endpoint, blob.as_ref(), deadline)
        .await
        .and_then(|body| parse_addr_b3_from_body(&body));

    let elapsed_ms = start.elapsed().as_millis() as u64;

    match result {
        Ok(addr) => {
            metrics.observe_latency(STORAGE_PUT_ENDPOINT, true, elapsed_ms);
            Ok(addr)
        }
        Err(err) => {
            metrics.observe_latency(STORAGE_PUT_ENDPOINT, false, elapsed_ms);
            metrics.inc_failure(STORAGE_PUT_ENDPOINT, classify_error(&err));
            Err(err)
        }
    }
}

/// Try to parse an `AddrB3` from the gateway response body (plain text).
///
/// Accepts canonical `b3:<64 hex>`; returns `SchemaViolation` if the
/// body is not valid UTF-8 or not a valid address string.
fn parse_addr_b3_from_body(body: &[u8]) -> Result<AddrB3, SdkError> {
    let s = std::str::from_utf8(body).map_err(|_| {
        SdkError::schema_violation("storage_put.body", "response was not valid UTF-8")
    })?;
    let trimmed = s.trim();
    AddrB3::parse(trimmed).map_err(|_| {
        SdkError::schema_violation(
            "storage_put.body",
            "response did not contain a valid AddrB3",
        )
    })
}

/// Map an error into a coarse, low-cardinality reason string for metrics.
fn classify_error(err: &SdkError) -> &'static str {
    use crate::errors::RetryClass;
    use SdkError::*;

    match err {
        DeadlineExceeded => "deadline",
        Transport(_) => "transport",
        TorUnavailable => "tor",
        Tls => "tls",
        OapViolation { .. } => "oap",
        CapabilityExpired | CapabilityDenied => "capability",
        SchemaViolation { .. } => "schema",
        NotFound => "not_found",
        Conflict => "conflict",
        RateLimited { .. } => "rate_limited",
        Server(_) => "server",
        Unknown(_) => match err.retry_class() {
            RetryClass::Retriable => "unknown_retriable",
            RetryClass::NoRetry => "unknown_permanent",
        },
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;

    use bytes::Bytes;

    use crate::config::SdkConfig;
    use crate::metrics::NoopSdkMetrics;
    use crate::transport::TransportHandle;

    fn dummy_capability() -> Capability {
        Capability {
            subject: "test-subject".to_string(),
            scope: "test-scope".to_string(),
            issued_at: 0,
            expires_at: u64::MAX,
            caveats: Vec::new(),
        }
    }

    #[tokio::test]
    async fn storage_put_rejects_payload_larger_than_oap_cap() {
        let cfg = SdkConfig::default();
        let transport = TransportHandle::new(cfg);
        let metrics = NoopSdkMetrics;
        let cap = dummy_capability();

        // One byte over cap → client-side failure.
        let oversized = Bytes::from(vec![0u8; OAP_MAX_FRAME_BYTES + 1]);
        let deadline = Duration::from_secs(1);

        let err = storage_put(&transport, &metrics, cap, oversized, deadline, None)
            .await
            .expect_err("expected OapViolation for oversized payload");

        match err {
            SdkError::OapViolation { reason } => assert_eq!(reason, "payload-too-large"),
            other => panic!("expected OapViolation, got {:?}", other),
        }
    }

    #[test]
    fn parse_addr_b3_rejects_garbage() {
        let body = b"not-a-valid-b3-id";
        let err = parse_addr_b3_from_body(body).expect_err("should reject invalid CID");
        match err {
            SdkError::SchemaViolation { path, .. } => assert_eq!(path, "storage_put.body"),
            other => panic!("expected SchemaViolation, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn storage_get_rejects_zero_deadline() {
        let cfg = SdkConfig::default();
        let transport = TransportHandle::new(cfg);
        let metrics = NoopSdkMetrics;
        let cap = dummy_capability();
        let addr =
            AddrB3::parse("b3:0000000000000000000000000000000000000000000000000000000000000000")
                .unwrap();

        let err = storage_get(&transport, &metrics, cap, &addr, Duration::ZERO)
            .await
            .expect_err("deadline=0 must fail");

        match err {
            SdkError::SchemaViolation { path, .. } => assert_eq!(path, "storage_get.deadline"),
            other => panic!("expected SchemaViolation, got {:?}", other),
        }
    }
}

```

### crates/ron-app-sdk/src/ready.rs
<a id="crates-ron-app-sdk-src-ready-rs"></a>

```rust
//! RO:WHAT — Lightweight readiness probe for ron-app-sdk.
//! RO:WHY  — Give hosts a simple, synchronous way to ask “is this SDK
//!           configuration plausibly usable?” without performing any
//!           network I/O.
//! RO:INTERACTS — Uses `SdkConfig::validate()` plus some direct checks
//!                on transport profile (e.g., Tor SOCKS addr).
//! RO:INVARIANTS —
//!   - Purely in-process; no sockets, no DNS.
//!   - Never panics; all issues are reflected in `missing` + flags.
//! RO:SECURITY — Does not log or expose secrets; only high-level flags.

use crate::config::{SdkConfig, Transport};

/// Readiness summary for the SDK.
///
/// This is intentionally small and boring so host applications can
/// translate it into whatever readiness surface they prefer
/// (`/readyz`, health widgets, etc.).
#[derive(Debug, Clone)]
pub struct ReadyReport {
    /// `true` if `SdkConfig::validate()` succeeded.
    pub config_ok: bool,
    /// `true` if the selected transport profile is internally consistent.
    pub transport_ok: bool,
    /// For Tor profiles, whether the SOCKS endpoint is usable at the
    /// *config* level (non-empty); `None` when transport != Tor.
    pub tor_ok: Option<bool>,
    /// High-level reasons why readiness is not yet achieved.
    ///
    /// This is intentionally coarse (e.g., "config", "tor_socks5_addr")
    /// so it can be safely surfaced in logs and UIs.
    pub missing: Vec<&'static str>,
}

impl ReadyReport {
    /// Convenience getter: overall readiness.
    ///
    /// Hosts are free to apply stricter policies, but this is a
    /// sensible default: config + transport OK and Tor (if used) OK.
    pub fn is_ready(&self) -> bool {
        self.config_ok && self.transport_ok && self.tor_ok.unwrap_or(true)
    }
}

/// Evaluate SDK readiness based on configuration alone.
///
/// This does **not** attempt any network calls, TLS handshakes, or Tor
/// reachability tests. Those belong in higher-level smoke checks. Here
/// we only ask “would it even make sense to construct a client?”
pub fn check_ready(cfg: &SdkConfig) -> ReadyReport {
    let mut missing = Vec::new();

    // 1) Config validation (semantic invariants from CONFIG.md).
    let config_ok = cfg.validate().is_ok();
    if !config_ok {
        missing.push("config");
    }

    // 2) Transport profile.
    let mut transport_ok = true;
    let mut tor_ok = None;

    match cfg.transport {
        Transport::Tls => {
            // Nothing extra to check here for now — TLS reachability lives
            // in the underlying transport (ron-transport) and smoke tests.
        }
        Transport::Tor => {
            if cfg.tor.socks5_addr.trim().is_empty() {
                transport_ok = false;
                tor_ok = Some(false);
                missing.push("tor_socks5_addr");
            } else {
                tor_ok = Some(true);
            }
        }
    }

    ReadyReport {
        config_ok,
        transport_ok,
        tor_ok,
        missing,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{
        CacheCfg, IdemCfg, Jitter, PqMode, Redaction, RetryCfg, Timeouts, TorCfg, TracingCfg,
    };
    use std::time::Duration;

    fn baseline_cfg() -> SdkConfig {
        SdkConfig {
            transport: Transport::Tls,
            gateway_addr: "https://example.invalid".to_string(),
            overall_timeout: Duration::from_secs(30),
            timeouts: Timeouts {
                connect: Duration::from_secs(5),
                read: Duration::from_secs(10),
                write: Duration::from_secs(10),
            },
            retry: RetryCfg {
                base: Duration::from_millis(100),
                factor: 2.0,
                cap: Duration::from_secs(5),
                max_attempts: 3,
                jitter: Jitter::Full,
            },
            idempotency: IdemCfg {
                enabled: true,
                key_prefix: Some("test".to_string()),
            },
            cache: CacheCfg {
                enabled: false,
                max_entries: 0,
                ttl: Duration::from_secs(0),
            },
            tracing: TracingCfg {
                spans: true,
                metrics: true,
                redaction: Redaction::Safe,
            },
            pq_mode: PqMode::Off,
            tor: TorCfg {
                socks5_addr: String::new(),
            },
        }
    }

    #[test]
    fn tls_baseline_is_ready() {
        let cfg = baseline_cfg();
        let report = check_ready(&cfg);
        assert!(report.config_ok);
        assert!(report.transport_ok);
        assert_eq!(report.tor_ok, None);
        assert!(report.is_ready());
        assert!(report.missing.is_empty());
    }

    #[test]
    fn tor_without_socks_addr_is_not_ready() {
        let mut cfg = baseline_cfg();
        cfg.transport = Transport::Tor;
        cfg.tor.socks5_addr.clear();

        let report = check_ready(&cfg);

        // This is an invalid config (Tor + empty SOCKS addr),
        // so `config_ok` should be false.
        assert!(!report.config_ok);
        assert!(!report.transport_ok);
        assert_eq!(report.tor_ok, Some(false));
        assert!(!report.is_ready());
        assert!(report.missing.contains(&"config"));
        assert!(report.missing.contains(&"tor_socks5_addr"));
    }

    #[test]
    fn tor_with_socks_addr_becomes_ready() {
        let mut cfg = baseline_cfg();
        cfg.transport = Transport::Tor;
        cfg.tor.socks5_addr = "127.0.0.1:9050".to_string();

        let report = check_ready(&cfg);
        assert!(report.config_ok);
        assert!(report.transport_ok);
        assert_eq!(report.tor_ok, Some(true));
        assert!(report.is_ready());
    }
}

```

### crates/ron-app-sdk/src/retry.rs
<a id="crates-ron-app-sdk-src-retry-rs"></a>

```rust
//! Retry and backoff helpers for ron-app-sdk.
//!
//! RO:WHAT — Exponential backoff schedule helpers driven by `RetryCfg`.
//! RO:WHY  — Central place for retry math so all planes behave consistently.
//! RO:INTERACTS — Used by edge/storage/mailbox/index planes and examples.
//! RO:INVARIANTS — Pure functions; no I/O; no sleeping; jitter kept within
//!                 bounds (currently deterministic, ready for real jitter).

use std::time::Duration;

use crate::config::{Jitter, RetryCfg};

/// Compute the base (non-jittered) delay for a given attempt index.
///
/// `attempt` is zero-based: 0 → first retry, 1 → second, etc.
pub fn base_delay(cfg: &RetryCfg, attempt: u32) -> Duration {
    if attempt == 0 {
        return cfg.base;
    }

    let factor = cfg.factor.max(1.0) as f64;
    let base_ms = cfg.base.as_millis() as f64;
    let pow = factor.powi(attempt as i32);

    let mut ms = (base_ms * pow).round();
    let cap_ms = cfg.cap.as_millis() as f64;

    if ms > cap_ms {
        ms = cap_ms;
    }

    Duration::from_millis(ms as u64)
}

/// Apply jitter to a base delay.
///
/// For now `Jitter::Full` does not introduce randomness yet; it simply
/// returns the base delay. This keeps the implementation deterministic.
/// In a later revision we can introduce true full jitter using `rand`
/// once the dependency is wired and property tests are in place.
pub fn apply_jitter(base: Duration, jitter: Jitter) -> Duration {
    match jitter {
        Jitter::None => base,
        Jitter::Full => base,
    }
}

/// Iterator over retry delays according to the given configuration.
///
/// This does **not** sleep; callers are responsible for awaiting between
/// iterations.
pub fn backoff_schedule<'a>(cfg: &'a RetryCfg) -> impl Iterator<Item = Duration> + 'a {
    (0..cfg.max_attempts).map(move |attempt| {
        let base = base_delay(cfg, attempt);
        apply_jitter(base, cfg.jitter)
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn schedule_is_monotonic_and_capped() {
        let cfg = RetryCfg::default();
        let mut last = Duration::ZERO;
        for d in backoff_schedule(&cfg) {
            assert!(d >= last);
            assert!(d <= cfg.cap);
            last = d;
        }
    }
}

```

### crates/ron-app-sdk/src/tracing.rs
<a id="crates-ron-app-sdk-src-tracing-rs"></a>

```rust
//! RO:WHAT — Span/field helper utilities for SDK calls.
//! RO:WHY  — Keep span naming/redaction/correlation consistent across
//!           storage/edge/mailbox/index planes without hardwiring to
//!           any particular tracing backend.
//! RO:INTERACTS — Uses `TracingCfg` + `Redaction` from `config`; callers
//!                may translate `SpanFields` into actual `tracing` spans.
//! RO:INVARIANTS —
//!   - Does not depend on external tracing crates (pure data only).
//!   - Redaction rules centralized and testable.
//!   - Endpoint field is stable and low-cardinality (path-like).
//! RO:METRICS — None directly; fields are reused by metrics labels.
//! RO:CONFIG — Reads `TracingCfg { spans, metrics, redaction }`.
//! RO:SECURITY — Redaction mode aims to strip query strings and obvious
//!               identifiers from endpoints when `Redaction::Safe`.
//! RO:TEST — Unit tests for redaction + field shaping.

use std::borrow::Cow;
use std::time::Duration;

use crate::config::{Redaction, TracingCfg};

/// Data model for span fields that SDK callers may attach to a tracing span.
///
/// This keeps the *shape* of our tracing consistent without forcing a
/// particular tracing backend into the SDK crate.
#[allow(dead_code)] // Public DTO; may be constructed only by hosts.
#[derive(Debug, Clone)]
pub struct SpanFields<'a> {
    /// Stable endpoint identifier (e.g., `/storage/put`).
    pub endpoint: Cow<'a, str>,
    /// Retry attempt number (0 == first attempt).
    pub attempt: u32,
    /// Deadline in milliseconds from "now" when the call started.
    pub deadline_ms: u64,
    /// Optional correlation ID propagated from the caller.
    pub corr_id: Option<Cow<'a, str>>,
}

/// Convenience function to build span fields for an SDK call.
///
/// Callers can use this to populate a `tracing::Span`, log entry, or
/// metrics label set; the SDK itself remains backend-agnostic.
#[allow(dead_code)] // Public helper; may be used only by SDK consumers.
pub fn build_span_fields<'a>(
    cfg: &TracingCfg,
    endpoint: &'a str,
    attempt: u32,
    overall_deadline: Duration,
    corr_id: Option<&'a str>,
) -> Option<SpanFields<'a>> {
    if !cfg.spans {
        // Spans disabled at config level — callers can short-circuit.
        return None;
    }

    let endpoint_field = match cfg.redaction {
        Redaction::Safe => redact_endpoint(endpoint),
        Redaction::None => Cow::Borrowed(endpoint),
    };

    let deadline_ms = overall_deadline.as_millis() as u64;
    let corr_field = corr_id.map(|v| Cow::Owned(v.to_string()));

    Some(SpanFields {
        endpoint: endpoint_field,
        attempt,
        deadline_ms,
        corr_id: corr_field,
    })
}

/// Apply a conservative redaction policy to endpoint strings.
///
/// Current policy:
/// - Strip query strings (`?…`).
/// - Collapse multiple consecutive slashes.
/// - Leave path segments untouched (gateway should avoid PII in paths).
#[allow(dead_code)] // Used by `build_span_fields` and tests.
fn redact_endpoint(raw: &str) -> Cow<'_, str> {
    let mut s = raw;

    if let Some(idx) = raw.find('?') {
        s = &raw[..idx];
    }

    // Simple collapse of "//" → "/" to avoid noisy paths.
    if s.contains("//") {
        let collapsed = s
            .split('/')
            .filter(|seg| !seg.is_empty())
            .collect::<Vec<_>>()
            .join("/");
        Cow::Owned(format!("/{}", collapsed))
    } else {
        Cow::Borrowed(s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn spans_disabled_returns_none() {
        let cfg = TracingCfg {
            spans: false,
            metrics: true,
            redaction: Redaction::Safe,
        };

        let out = build_span_fields(&cfg, "/storage/put", 0, Duration::from_millis(5000), None);
        assert!(out.is_none());
    }

    #[test]
    fn strips_query_and_collapses_slashes() {
        let cfg = TracingCfg {
            spans: true,
            metrics: true,
            redaction: Redaction::Safe,
        };

        let out = build_span_fields(
            &cfg,
            "/storage//put?id=123&foo=bar",
            0,
            Duration::from_millis(1000),
            None,
        )
        .unwrap();

        // Query stripped, duplicate slash collapsed.
        assert_eq!(out.endpoint.as_ref(), "/storage/put");
    }

    #[test]
    fn redaction_none_keeps_query() {
        let cfg = TracingCfg {
            spans: true,
            metrics: true,
            redaction: Redaction::None,
        };

        let out = build_span_fields(
            &cfg,
            "/storage/put?id=123",
            0,
            Duration::from_millis(1000),
            None,
        )
        .unwrap();

        // With `Redaction::None`, endpoint is preserved verbatim.
        assert_eq!(out.endpoint.as_ref(), "/storage/put?id=123");
    }
}

```

### crates/ron-app-sdk/src/transport/handle.rs
<a id="crates-ron-app-sdk-src-transport-handle-rs"></a>

```rust
//! RO:WHAT — Transport handle + retry wrapper for ron-app-sdk.
//! RO:WHY  — Central place to enforce OAP/1 limits (1 MiB max frame)
//!           and apply per-call deadlines/retries, independent of
//!           concrete transport flavor (TLS/Tor).
//! RO:INTERACTS — Uses crate::config::{SdkConfig, Transport},
//!                crate::errors::{SdkError, RetryClass},
//!                crate::retry::backoff_schedule, and reqwest for HTTPS;
//!                called by planes::{storage, edge, mailbox, index}.
//! RO:INVARIANTS — client-only (no listeners); no lock across `.await`;
//!                 OAP_MAX_FRAME_BYTES enforced before network I/O;
//!                 outer deadlines respected including backoff sleeps.
//! RO:METRICS — planes record metrics around these calls; this module
//!              itself is metric-agnostic.
//! RO:CONFIG — reads SdkConfig.transport/gateway_addr/overall_timeout/
//!             timeouts/retry.
//! RO:SECURITY — TLS verification delegated to reqwest+rustls;
//!               capability headers/payloads are supplied by planes;
//!               no secrets logged here.
//! RO:TEST — local unit tests for size/deadline behavior; integration
//!           invariants in `tests/i_3_oap_bounds.rs` and
//!           `tests/i_5_retries_deadlines.rs` once fully wired.

use std::{cmp, time::Duration};

use tokio::time::{sleep, Instant};

use crate::config::{SdkConfig, Transport as TransportKind};
use crate::errors::{RetryClass, SdkError};
use crate::retry::backoff_schedule;

use super::mapping::{map_http_status, map_reqwest_error};

/// Hard OAP/1 frame size cap (1 MiB).
///
/// Callers must ensure no single OAP DATA frame ever exceeds this
/// size. The transport adapter enforces this before any network I/O
/// is attempted, so oversized payloads fail fast client-side.
pub const OAP_MAX_FRAME_BYTES: usize = 1024 * 1024;

/// Opaque handle for SDK transport.
///
/// For now this wraps `SdkConfig` and builds a `reqwest::Client`
/// per-call. Once we wire in a richer OAP client or connection
/// pooling, this type is where that will live.
#[derive(Debug, Clone)]
pub struct TransportHandle {
    cfg: SdkConfig,
}

impl TransportHandle {
    /// Construct a new handle from configuration.
    ///
    /// This is intentionally infallible so that `RonAppSdk::new` can
    /// stay simple; any construction errors for the underlying HTTP
    /// client are surfaced at call time as `SdkError`.
    pub fn new(cfg: SdkConfig) -> Self {
        Self { cfg }
    }

    /// Access the underlying configuration.
    pub fn config(&self) -> &SdkConfig {
        &self.cfg
    }

    /// Convenience: serialize `value` as JSON and send via OAP POST.
    ///
    /// This helper centralizes JSON encoding so planes can remain thin.
    pub async fn call_oap_json<T: serde::Serialize>(
        &self,
        endpoint: &str,
        value: &T,
        deadline: Duration,
    ) -> Result<Vec<u8>, SdkError> {
        let body = serde_json::to_vec(value)
            .map_err(|e| SdkError::Unknown(format!("json encode failed: {e}")))?;
        self.call_oap(endpoint, &body, deadline).await
    }

    /// Perform a single low-level OAP request over the configured transport.
    ///
    /// This method:
    /// - Enforces `OAP_MAX_FRAME_BYTES` at the SDK boundary.
    /// - Honors `SdkConfig::transport` (currently: TLS only; Tor is
    ///   fail-fast with `SdkError::TorUnavailable`).
    /// - Clamps the per-call `deadline` by `SdkConfig::overall_timeout`.
    /// - Maps HTTP status codes + reqwest errors into `SdkError`.
    ///
    /// It does **not** perform retries; see `call_oap_with_retry` for
    /// the higher-level wrapper that uses `RetryCfg` + `RetryClass`.
    pub async fn call_oap(
        &self,
        endpoint: &str,
        payload: &[u8],
        deadline: Duration,
    ) -> Result<Vec<u8>, SdkError> {
        // Enforce OAP/1 max frame cap at SDK boundary.
        if payload.len() > OAP_MAX_FRAME_BYTES {
            return Err(SdkError::OapViolation {
                reason: "oap payload exceeds OAP_MAX_FRAME_BYTES (1 MiB)",
            });
        }

        // Tor transport is not wired yet; fail-fast with a stable error.
        if matches!(self.cfg.transport, TransportKind::Tor) {
            return Err(SdkError::TorUnavailable);
        }

        // Clamp the per-call deadline by the config-level overall timeout.
        let cfg_deadline = self.cfg.overall_timeout;
        let effective_deadline = cmp::min(deadline, cfg_deadline);
        if effective_deadline.is_zero() {
            return Err(SdkError::DeadlineExceeded);
        }

        // Build the full URL: <gateway_addr>/<endpoint>.
        let base = self.cfg.gateway_addr.trim_end_matches('/');
        let path = endpoint.trim_start_matches('/');
        let url = format!("{base}/{path}");

        // Minimal HTTP client; we keep it per-call for now to keep
        // `TransportHandle::new` infallible. We can pool this later.
        let client = reqwest::Client::builder()
            .connect_timeout(self.cfg.timeouts.connect)
            .timeout(effective_deadline)
            .build()
            .map_err(map_reqwest_error)?;

        let resp = client
            .post(&url)
            .body(payload.to_vec())
            .send()
            .await
            .map_err(map_reqwest_error)?;

        let status = resp.status();

        if !status.is_success() {
            // Extract Retry-After if present (for 429).
            let retry_after = if status == reqwest::StatusCode::TOO_MANY_REQUESTS {
                resp.headers()
                    .get(reqwest::header::RETRY_AFTER)
                    .and_then(|v| v.to_str().ok())
                    .and_then(|s| s.parse::<u64>().ok())
                    .map(Duration::from_secs)
            } else {
                None
            };

            return Err(map_http_status(status, retry_after));
        }

        let body = resp.bytes().await.map_err(map_reqwest_error)?;
        Ok(body.to_vec())
    }

    /// Perform an OAP request with retries and deadline awareness.
    ///
    /// Behavior:
    /// - Uses `RetryCfg` from `SdkConfig` to drive exponential backoff.
    /// - Uses `SdkError::retry_class()` to decide which failures are
    ///   safe to retry.
    /// - Enforces an **outer** deadline equal to
    ///   `min(deadline, overall_timeout)`, including sleep.
    /// - Respects `max_attempts` (including the initial attempt).
    ///
    /// This is the helper that plane modules should normally call.
    pub async fn call_oap_with_retry(
        &self,
        endpoint: &str,
        payload: &[u8],
        deadline: Duration,
    ) -> Result<Vec<u8>, SdkError> {
        let outer_deadline = cmp::min(deadline, self.cfg.overall_timeout);
        if outer_deadline.is_zero() {
            return Err(SdkError::DeadlineExceeded);
        }

        let start = Instant::now();
        let retry_cfg = &self.cfg.retry;

        // Attempt 0 is the initial attempt (no backoff before it).
        let mut attempt: u32 = 0;

        loop {
            let elapsed = start.elapsed();
            if elapsed >= outer_deadline {
                return Err(SdkError::DeadlineExceeded);
            }

            let remaining = outer_deadline.saturating_sub(elapsed);

            match self.call_oap(endpoint, payload, remaining).await {
                Ok(bytes) => return Ok(bytes),
                Err(err) => {
                    // If this isn't retriable, bail immediately.
                    if !matches!(err.retry_class(), RetryClass::Retriable) {
                        return Err(err);
                    }

                    // `max_attempts` is total attempts including the first.
                    let max_attempts = if retry_cfg.max_attempts == 0 {
                        1
                    } else {
                        retry_cfg.max_attempts
                    };

                    // We've already done `attempt + 1` attempts (initial + retries so far).
                    if attempt + 1 >= max_attempts {
                        return Err(err);
                    }

                    // Compute backoff for this retry attempt.
                    let delay = backoff_schedule(retry_cfg)
                        .nth(attempt as usize)
                        .unwrap_or(retry_cfg.cap);

                    let sleep_dur = cmp::min(delay, outer_deadline.saturating_sub(start.elapsed()));

                    if !sleep_dur.is_zero() {
                        sleep(sleep_dur).await;
                    }
                    attempt += 1;
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{
        CacheCfg, IdemCfg, PqMode, RetryCfg, SdkConfig, Timeouts, TorCfg, TracingCfg,
        Transport as TransportKind,
    };

    fn dummy_config() -> SdkConfig {
        SdkConfig {
            transport: TransportKind::Tls,
            gateway_addr: "http://127.0.0.1:8080".to_string(),
            overall_timeout: Duration::from_millis(5000),
            timeouts: Timeouts::default(),
            retry: RetryCfg::default(),
            idempotency: IdemCfg::default(),
            cache: CacheCfg::default(),
            tracing: TracingCfg::default(),
            pq_mode: PqMode::Off,
            tor: TorCfg::default(),
        }
    }

    /// Oversized payloads must fail fast without network I/O.
    #[tokio::test]
    async fn rejects_payload_larger_than_oap_cap() {
        let cfg = dummy_config();
        let handle = TransportHandle::new(cfg);
        let payload = vec![0u8; OAP_MAX_FRAME_BYTES + 1];

        let res = handle
            .call_oap("healthz", &payload, Duration::from_secs(1))
            .await;

        assert!(matches!(res, Err(SdkError::OapViolation { .. })));
    }

    /// Zero deadlines must be rejected up front.
    #[tokio::test]
    async fn deadline_zero_fails_fast() {
        let cfg = dummy_config();
        let handle = TransportHandle::new(cfg);
        let payload: [u8; 0] = [];

        let res = handle.call_oap("healthz", &payload, Duration::ZERO).await;

        assert!(matches!(res, Err(SdkError::DeadlineExceeded)));
    }

    /// Outer deadline should stop retries rather than looping forever.
    #[tokio::test]
    async fn outer_deadline_limits_retries() {
        let mut cfg = dummy_config();
        cfg.overall_timeout = Duration::from_millis(10);
        cfg.retry.max_attempts = 10;
        let handle = TransportHandle::new(cfg);

        let payload: [u8; 0] = [];
        let res = handle
            .call_oap_with_retry("healthz", &payload, Duration::ZERO)
            .await;

        assert!(matches!(res, Err(SdkError::DeadlineExceeded)));
    }
}

```

### crates/ron-app-sdk/src/transport/mapping.rs
<a id="crates-ron-app-sdk-src-transport-mapping-rs"></a>

```rust
//! RO:WHAT — HTTP / reqwest → SdkError mapping helpers.
//! RO:WHY  — Keep `TransportHandle` focused on deadlines/backoff and
//!           centralize wire-to-taxonomy mapping here.
//! RO:INTERACTS — Used only from `transport::handle`; consults
//!                `crate::errors::SdkError` and reqwest error/status APIs.
//! RO:INVARIANTS — never panic; unknown statuses/errors become
//!                 `SdkError::Unknown` with human-readable message;
//!                 timeouts map to `Transport(std::io::ErrorKind::TimedOut)`.
//! RO:METRICS — none directly; higher layers may aggregate by error type.
//! RO:CONFIG — none (pure helpers).
//! RO:SECURITY — messages are safe for logs; no secrets included.
//! RO:TEST — local unit tests for representative mappings.

use std::{io::ErrorKind, time::Duration};

use crate::errors::SdkError;

/// Map an HTTP status code into the stable `SdkError` taxonomy.
///
/// This follows the mapping table in `ALL_DOCS.md` (error taxonomy
/// section) so that callers can rely on consistent semantics across
/// transports and services.
pub(crate) fn map_http_status(
    status: reqwest::StatusCode,
    retry_after: Option<Duration>,
) -> SdkError {
    use reqwest::StatusCode;

    match status {
        StatusCode::NOT_FOUND => SdkError::NotFound,
        StatusCode::CONFLICT => SdkError::Conflict,
        StatusCode::UNAUTHORIZED => SdkError::CapabilityExpired,
        StatusCode::FORBIDDEN => SdkError::CapabilityDenied,
        StatusCode::TOO_MANY_REQUESTS => SdkError::RateLimited { retry_after },
        s if s.is_server_error() => SdkError::Server(s.as_u16()),
        s => SdkError::Unknown(format!("unexpected http status: {s}")),
    }
}

/// Map reqwest errors into the stable `SdkError` taxonomy.
///
/// We deliberately distinguish transport-level timeouts and generic
/// I/O failures from "overall deadline exceeded", which is handled
/// explicitly in the retry wrapper.
pub(crate) fn map_reqwest_error(err: reqwest::Error) -> SdkError {
    if err.is_timeout() {
        return SdkError::Transport(ErrorKind::TimedOut);
    }

    // Heuristic TLS detection based on error text; the underlying
    // `reqwest`/`rustls` error types are not stable across versions.
    let msg = err.to_string();
    let lower = msg.to_lowercase();
    if lower.contains("tls") || lower.contains("certificate") || lower.contains("ssl") {
        return SdkError::Tls;
    }

    if err.is_connect() || err.is_request() || err.is_body() {
        return SdkError::Transport(ErrorKind::Other);
    }

    SdkError::Unknown(msg)
}

#[cfg(test)]
mod tests {
    use super::*;
    use reqwest::StatusCode;

    #[test]
    fn http_status_mapping_basic() {
        assert!(matches!(
            map_http_status(StatusCode::NOT_FOUND, None),
            SdkError::NotFound
        ));
        assert!(matches!(
            map_http_status(StatusCode::CONFLICT, None),
            SdkError::Conflict
        ));
        assert!(matches!(
            map_http_status(StatusCode::TOO_MANY_REQUESTS, Some(Duration::from_secs(1))),
            SdkError::RateLimited { .. }
        ));
        assert!(matches!(
            map_http_status(StatusCode::INTERNAL_SERVER_ERROR, None),
            SdkError::Server(500)
        ));
    }
}

```

### crates/ron-app-sdk/src/transport/mod.rs
<a id="crates-ron-app-sdk-src-transport-mod-rs"></a>

```rust
//! RO:WHAT — Transport module root for ron-app-sdk.
//! RO:WHY  — Split the transport adapter into smaller focused files
//!           (handle + HTTP/error mapping) while keeping a stable API.
//! RO:INTERACTS — crate::config, crate::errors, crate::retry; used by
//!                plane modules (storage, edge, mailbox, index).
//! RO:INVARIANTS — client-only; no server/listener code; all outbound
//!                 calls go through `TransportHandle`; OAP frame cap
//!                 re-exported as `OAP_MAX_FRAME_BYTES`.
//! RO:METRICS — metrics are recorded in planes; this module stays
//!              metric-agnostic.
//! RO:CONFIG — reads SdkConfig fields (transport, gateway_addr,
//!             overall_timeout, timeouts, retry) via `TransportHandle`.
//! RO:SECURITY — TLS/Tor configuration only; macaroon capabilities are
//!               handled at higher layers (planes).
//! RO:TEST — unit tests live in submodules; integration tests under
//!           `tests/i_*` exercise invariants end-to-end.

mod handle;
mod mapping;

pub use handle::{TransportHandle, OAP_MAX_FRAME_BYTES};

```

### crates/ron-app-sdk/src/types.rs
<a id="crates-ron-app-sdk-src-types-rs"></a>

```rust
//! RO:WHAT — Public DTO surface for ron-app-sdk.
//! RO:WHY  — One stable place to import capability, content IDs,
//!           mailbox DTOs, and SDK-local aliases, without depending
//!           on `ron-proto` directly.
//! RO:INTERACTS — Re-exports canonical DTOs from `ron-proto` and
//!                aliases SDK types like `IdemKey`.
//! RO:INVARIANTS — DTOs remain pure data; no I/O or crypto.
//! RO:SECURITY — Capability is a header DTO only; verification lives
//!               in services like ron-auth.

use crate::idempotency::IdempotencyKey;

// Re-export canonical DTOs from `ron-proto`.
#[allow(unused_imports)] // Intentionally surfaced for callers even if not used here yet.
pub use ron_proto::{
    Ack as MailboxAck, // canonical mailbox receipt
    CapTokenHdr,       // capability header (macaroon-style)
    ContentId,         // BLAKE3 content address
    ManifestV1,        // exposed for future SDK callers
    NameRef,           // index key (logical name/alias)
    Recv as MailboxRecv,
    Send as MailboxSend,
};

/// Capability token header (macaroon-style claims, no signature).
pub type Capability = CapTokenHdr;

/// Canonical BLAKE3 content address used by storage/index planes.
pub type AddrB3 = ContentId;

/// Logical index key used by the index plane.
pub type IndexKey = NameRef;

/// SDK-level alias for idempotency keys (SDK-owned type).
pub type IdemKey = IdempotencyKey;

/// Mail payload used when *sending* via the mailbox plane.
pub type Mail = MailboxSend;

/// Mail payload delivered when *receiving* from the mailbox plane.
pub type MailInbox = MailboxRecv;

/// Receipt/acknowledgement from mailbox operations (canonical name).
pub type Receipt = MailboxAck;

/// Short alias matching the docs (`Ack`).
pub type Ack = Receipt;

/// Byte range used by the edge plane (inclusive start, inclusive end).
///
/// Defined locally so the SDK doesn’t depend on svc-edge.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ByteRange {
    /// Start offset.
    pub start: u64,
    /// End offset (inclusive).
    pub end: u64,
}

impl ByteRange {
    /// Inclusive length; `{ start: 0, end: 9 }` → `10`.
    pub fn len(&self) -> u64 {
        self.end.saturating_sub(self.start) + 1
    }

    /// Returns true if the range is logically empty.
    ///
    /// In normal usage, ranges should be validated so `start <= end`;
    /// this treats any inverted range as empty to satisfy the usual
    /// `len`/`is_empty` contract.
    pub fn is_empty(&self) -> bool {
        self.end < self.start
    }
}

#[cfg(test)]
mod tests {
    use super::ByteRange;

    #[test]
    fn byte_range_len_is_inclusive() {
        let r = ByteRange { start: 0, end: 9 };
        assert_eq!(r.len(), 10);
    }

    #[test]
    fn byte_range_is_empty_for_inverted_ranges() {
        let r = ByteRange { start: 10, end: 5 };
        assert!(r.is_empty());
    }
}

```

### crates/ron-app-sdk/tests/i_10_semver_snapshot.rs
<a id="crates-ron-app-sdk-tests-i10semversnapshot-rs"></a>

```rust
// Invariant: public API snapshot honored (scaffold).
#[test]
fn i_10_semver_snapshot_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_11_no_persistence.rs
<a id="crates-ron-app-sdk-tests-i11nopersistence-rs"></a>

```rust
// Invariant: no on-disk persistence (scaffold).
#[test]
fn i_11_no_persistence_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_12_canon_deps.rs
<a id="crates-ron-app-sdk-tests-i12canondeps-rs"></a>

```rust
// Invariant: workspace pins / canon deps (scaffold).
#[test]
fn i_12_canon_deps_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_1_profile_parity.rs
<a id="crates-ron-app-sdk-tests-i1profileparity-rs"></a>

```rust
// Invariant: profile parity across transports (scaffold).
#[test]
fn i_1_profile_parity_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_2_caps_required.rs
<a id="crates-ron-app-sdk-tests-i2capsrequired-rs"></a>

```rust
// Invariant: capabilities required on mutations (scaffold).
#[test]
fn i_2_caps_required_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_3_oap_bounds.rs
<a id="crates-ron-app-sdk-tests-i3oapbounds-rs"></a>

```rust
// Invariant: OAP/1 frame cap <= 1 MiB (scaffold).
#[test]
fn i_3_oap_bounds_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_4_content_addressing.rs
<a id="crates-ron-app-sdk-tests-i4contentaddressing-rs"></a>

```rust
//! I-4 — Content-addressing roundtrip against a mock gateway.
//!
//! RO:WHAT — Spins up a tiny Axum server that exposes just enough of the
//!           gateway surface for `storage_put` / `storage_get` to work.
//! RO:WHY  — Proves the SDK can:
//!             - speak OAP over HTTP to a gateway-like surface,
//!             - roundtrip blobs via content-addressed IDs (`b3:<hex>`),
//!             - honour the `SdkConfig` / `Transport` wiring.
//! RO:INVARIANTS —
//!   - Address format is `b3:<64 hex>`.
//!   - Returned digest matches `blake3(blob)`.
//!   - `storage_get` returns the exact blob we stored.

use std::{
    collections::HashMap,
    net::SocketAddr,
    sync::{Arc, Mutex},
    time::Duration,
};

use axum::{
    body::Bytes as BodyBytes,
    extract::{Path, State},
    http::StatusCode,
    routing::post,
    Router,
};
use bytes::Bytes;
use tokio::net::TcpListener;

use blake3;
use hex;

use ron_app_sdk::{check_ready, Capability, RonAppSdk, SdkConfig, Timeouts, Transport};

/// In-memory CAS store keyed by `b3:<hex>` strings.
///
/// We only need this inside the test to emulate the gateway's storage plane.
type Store = Arc<Mutex<HashMap<String, Vec<u8>>>>;

/// Construct a very simple capability token for tests.
///
/// We don't care about real macaroon semantics here — just that the SDK can
/// serialize and send a `Capability` header.
fn mk_cap() -> Capability {
    // These fields mirror the simple header used elsewhere in tests.
    // No real validation happens in this mock; the transport currently
    // treats capabilities as opaque.
    let now: u64 = 1_700_000_000;
    Capability {
        subject: "itest-user".to_string(),
        scope: "storage:rw".to_string(),
        issued_at: now,
        expires_at: now + 3600,
        caveats: Vec::new(),
    }
}

/// Handler for `POST /put`.
///
/// - Body: raw blob bytes.
/// - Response: `b3:<hex>` as UTF-8 text.
async fn handle_storage_put(State(store): State<Store>, body: BodyBytes) -> (StatusCode, String) {
    let blob = body.to_vec();
    let digest = blake3::hash(&blob);
    let addr = format!("b3:{}", hex::encode(digest.as_bytes()));

    {
        let mut guard = store.lock().expect("store mutex poisoned");
        guard.insert(addr.clone(), blob);
    }

    (StatusCode::OK, addr)
}

/// Handler for `POST /o/:addr`.
///
/// - Body: ignored (SDK sends an empty body for `storage_get`).
/// - Response: raw bytes for the given content address, or 404 if missing.
async fn handle_storage_get(
    State(store): State<Store>,
    Path(addr): Path<String>,
) -> (StatusCode, Bytes) {
    let maybe = {
        let guard = store.lock().expect("store mutex poisoned");
        guard.get(&addr).cloned()
    };

    match maybe {
        Some(buf) => (StatusCode::OK, Bytes::from(buf)),
        None => (StatusCode::NOT_FOUND, Bytes::new()),
    }
}

/// Spin up a minimal Axum-based mock gateway.
///
/// Returns:
///   - `base_url` suitable for `SdkConfig.gateway_addr` (e.g. `http://127.0.0.1:12345`)
///   - shared `Store` so the test can peek into the server-side CAS
///   - join handle for the server task (we just let it run for the test lifetime)
async fn spawn_mock_gateway() -> (String, Store, tokio::task::JoinHandle<()>) {
    let store: Store = Arc::new(Mutex::new(HashMap::new()));

    // Endpoints chosen to match `planes::storage`:
    // - storage_put → POST /put
    // - storage_get → POST /o/{addr}
    let app = Router::new()
        .route("/put", post(handle_storage_put))
        .route("/o/:addr", post(handle_storage_get))
        .with_state(store.clone());

    let listener = TcpListener::bind("127.0.0.1:0")
        .await
        .expect("bind mock gateway");
    let addr: SocketAddr = listener.local_addr().expect("local_addr");
    let base_url = format!("http://{}", addr);

    let server = tokio::spawn(async move {
        axum::serve(listener, app)
            .await
            .expect("mock gateway server failed");
    });

    (base_url, store, server)
}

#[tokio::test]
async fn oap_content_addressing_roundtrip() {
    // 1) Start the mock gateway.
    let (base_url, store, _server) = spawn_mock_gateway().await;

    // 2) Build an SDK config that points at the mock gateway.
    //
    // We keep it close to the default posture but override:
    //   - gateway_addr
    //   - timeouts
    let mut cfg = SdkConfig::default();
    cfg.gateway_addr = base_url;
    cfg.transport = Transport::Tls;
    cfg.timeouts = Timeouts {
        connect: Duration::from_millis(500),
        read: Duration::from_millis(1_000),
        write: Duration::from_millis(1_000),
    };
    cfg.overall_timeout = Duration::from_millis(5_000);

    // 3) Ready check: prove config + transport wiring are sane.
    let ready = check_ready(&cfg);
    assert!(ready.is_ready(), "SDK ready check failed: {:?}", ready);

    // 4) Instantiate the SDK.
    let sdk = RonAppSdk::new(cfg).await.expect("construct RonAppSdk");

    let cap = mk_cap();
    let deadline = Duration::from_millis(1_000);

    // 5) PUT a blob via the storage plane.
    let blob = Bytes::from_static(b"hello-oap-content-addressing");
    let addr = sdk
        .storage_put(cap.clone(), blob.clone(), deadline, None)
        .await
        .expect("storage_put should succeed");

    // Ensure address format is `b3:<64 hex>`.
    let addr_str = addr.as_str();
    assert!(
        addr_str.starts_with("b3:"),
        "content address should start with 'b3:', got {addr_str}",
    );
    let hex_part = &addr_str[3..];
    assert_eq!(
        hex_part.len(),
        64,
        "digest hex should be 64 chars, got {}",
        hex_part.len()
    );

    // Verify digest matches blake3(blob).
    let expected_hex = hex::encode(blake3::hash(&blob).as_bytes());
    assert_eq!(
        hex_part, expected_hex,
        "content ID digest did not match BLAKE3(blob)"
    );

    // 6) Peek into the mock gateway's store and ensure it has the blob.
    {
        let guard = store.lock().expect("store mutex poisoned");
        let stored = guard
            .get(addr_str)
            .expect("mock gateway did not store blob");
        assert_eq!(
            stored.as_slice(),
            blob.as_ref(),
            "server-side blob mismatch"
        );
    }

    // 7) GET the blob back via the storage plane.
    let roundtrip = sdk
        .storage_get(cap, addr_str, deadline)
        .await
        .expect("storage_get should succeed");

    assert_eq!(
        roundtrip.as_ref(),
        blob.as_ref(),
        "roundtrip blob mismatch"
    );
}

```

### crates/ron-app-sdk/tests/i_5_retries_deadlines.rs
<a id="crates-ron-app-sdk-tests-i5retriesdeadlines-rs"></a>

```rust
// Invariant: bounded retries + deadlines (scaffold).
#[test]
fn i_5_retries_deadlines_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_6_dto_strictness.rs
<a id="crates-ron-app-sdk-tests-i6dtostrictness-rs"></a>

```rust
// Invariant: strict DTO parsing (deny_unknown_fields) (scaffold).
#[test]
fn i_6_dto_strictness_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_7_transport_agnostic.rs
<a id="crates-ron-app-sdk-tests-i7transportagnostic-rs"></a>

```rust
// Invariant: transport-agnostic semantics (TLS vs Tor) (scaffold).
#[test]
fn i_7_transport_agnostic_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_8_deadlines_everywhere.rs
<a id="crates-ron-app-sdk-tests-i8deadlineseverywhere-rs"></a>

```rust
// Invariant: deadlines on all external I/O (scaffold).
#[test]
fn i_8_deadlines_everywhere_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/i_9_error_taxonomy.rs
<a id="crates-ron-app-sdk-tests-i9errortaxonomy-rs"></a>

```rust
// Invariant: error taxonomy mapping + retry classes (scaffold).
#[test]
fn i_9_error_taxonomy_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/interop_vectors.rs
<a id="crates-ron-app-sdk-tests-interopvectors-rs"></a>

```rust
// Canonical interop vectors runner (scaffold).
#[test]
fn interop_vectors_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/prop_oap_frames.rs
<a id="crates-ron-app-sdk-tests-propoapframes-rs"></a>

```rust
// Property test placeholder: frames near 1 MiB bound (scaffold).
#[test]
fn prop_oap_frames_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/prop_retry_bounds.rs
<a id="crates-ron-app-sdk-tests-propretrybounds-rs"></a>

```rust
// Property test placeholder: retry sleeps sum < overall deadline (scaffold).
#[test]
fn prop_retry_bounds_scaffold() {
    assert!(true);
}

```

### crates/ron-app-sdk/tests/support/mock_gateway.rs
<a id="crates-ron-app-sdk-tests-support-mockgateway-rs"></a>

```rust
//! Test support: minimal Axum gateway that accepts any OAP-ish POST and
//! returns controlled JSON bodies / statuses for client-side verification.
//!
//! RO:WHY — Lets us prove end-to-end OAP calls (happy path + error mapping)
//! without coupling tests to real services.
//! RO:INVARIANTS —
//! - Binds ephemeral 127.0.0.1:0 and exposes its chosen port.
//! - Wildcard POST /*path; handlers can branch by request path.
//! - Helpers to reply with fixed JSON bodies that match planes' expectations.

use axum::{
    body::Bytes as AxumBytes,
    extract::{Path, State},
    http::{HeaderMap, StatusCode},
    response::{IntoResponse, Response},
    routing::post,
    Json, Router,
};
use serde::{Deserialize, Serialize};
use std::{net::SocketAddr, sync::Arc};
use tokio::net::TcpListener;

#[derive(Clone, Default)]
pub struct AppState {
    // You can stash toggles/fixtures here if needed later
}

#[derive(Serialize, Deserialize)]
struct BlobResp<'a> {
    // Using serde_bytes encoding semantics on client; here we just send base64 via serde_json.
    blob: &'a [u8],
}

#[derive(Serialize, Deserialize)]
struct PutResp<'a> {
    addr_b3: &'a str,
}

pub struct Running {
    pub addr: SocketAddr,
    _state: Arc<AppState>,
    _task: tokio::task::JoinHandle<()>,
}

pub async fn start() -> Running {
    let state = Arc::new(AppState::default());

    // Wildcard POST endpoint
    let app = Router::new()
        .route("/*path", post(handle_post))
        .with_state(state.clone());

    let listener = TcpListener::bind(("127.0.0.1", 0)).await.unwrap();
    let addr = listener.local_addr().unwrap();

    let task = tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, app).await {
            eprintln!("[mock-gateway] serve error: {err}");
        }
    });

    Running {
        addr,
        _state: state,
        _task: task,
    }
}

async fn handle_post(
    State(_state): State<Arc<AppState>>,
    Path(path): Path<String>,
    headers: HeaderMap,
    body: AxumBytes,
) -> Response {
    // Basic "capability present" check — we don't validate value here.
    let cap_present = headers
        .keys()
        .any(|k| k.as_str().eq_ignore_ascii_case("cap"));

    // Exercise size-cap response if body is absurdly huge (we still accept; client enforces cap itself).
    let _bytes_len = body.len();

    // Route-based canned replies, matching planes documented in carry-over notes.
    match path.as_str() {
        // Storage GET returns {"blob": <bytes>}
        p if p.ends_with("/storage/get") => {
            if !cap_present {
                return (StatusCode::UNAUTHORIZED, "missing cap").into_response();
            }
            let resp = BlobResp { blob: b"hello-oap" };
            (StatusCode::OK, Json(resp)).into_response()
        }
        // Storage PUT returns {"addr_b3":"b3:<64 hex>"}
        p if p.ends_with("/storage/put") => {
            if !cap_present {
                return (StatusCode::UNAUTHORIZED, "missing cap").into_response();
            }
            let resp = PutResp {
                addr_b3: "b3:0000000000000000000000000000000000000000000000000000000000000000",
            };
            (StatusCode::OK, Json(resp)).into_response()
        }
        // Edge GET returns {"blob": <bytes>}
        p if p.ends_with("/edge/get") => {
            if !cap_present {
                return (StatusCode::UNAUTHORIZED, "missing cap").into_response();
            }
            let resp = BlobResp { blob: b"edge-bytes" };
            (StatusCode::OK, Json(resp)).into_response()
        }
        // Index resolve returns {"addr_b3": "..."}
        p if p.ends_with("/index/resolve") => {
            if !cap_present {
                return (StatusCode::UNAUTHORIZED, "missing cap").into_response();
            }
            let resp = PutResp {
                addr_b3: "b3:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            };
            (StatusCode::OK, Json(resp)).into_response()
        }
        // Unknown path → 404 (to test mapping)
        _ => (StatusCode::NOT_FOUND, "no route").into_response(),
    }
}

```

### crates/ron-app-sdk/tests/vectors/capability_example.json
<a id="crates-ron-app-sdk-tests-vectors-capabilityexample-json"></a>

```json
{"capability":"placeholder"}
```

### crates/ron-app-sdk/tests/vectors/oap1_min_req.json
<a id="crates-ron-app-sdk-tests-vectors-oap1minreq-json"></a>

```json
{"placeholder": true}
```

