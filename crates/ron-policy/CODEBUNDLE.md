<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:44:52Z -->
# Code Bundle — `ron-policy`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-policy/.cargo/config.toml](#crates-ron-policy--cargo-config-toml)
- [crates/ron-policy/.github/workflows/policy.yml](#crates-ron-policy--github-workflows-policy-yml)
- [crates/ron-policy/Cargo.toml](#crates-ron-policy-Cargo-toml)
- [crates/ron-policy/benches/eval_throughput.rs](#crates-ron-policy-benches-evalthroughput-rs)
- [crates/ron-policy/deny.toml](#crates-ron-policy-deny-toml)
- [crates/ron-policy/examples/minimal_allow_deny.rs](#crates-ron-policy-examples-minimalallowdeny-rs)
- [crates/ron-policy/examples/ron_policy_cli.rs](#crates-ron-policy-examples-ronpolicycli-rs)
- [crates/ron-policy/fuzz/Cargo.toml](#crates-ron-policy-fuzz-Cargo-toml)
- [crates/ron-policy/fuzz/fuzz_targets/fuzz_bundle_parse.rs](#crates-ron-policy-fuzz-fuzztargets-fuzzbundleparse-rs)
- [crates/ron-policy/fuzz/fuzz_targets/fuzz_eval.rs](#crates-ron-policy-fuzz-fuzztargets-fuzzeval-rs)
- [crates/ron-policy/rust-toolchain.toml](#crates-ron-policy-rust-toolchain-toml)
- [crates/ron-policy/schema/policybundle.schema.json](#crates-ron-policy-schema-policybundle-schema-json)
- [crates/ron-policy/scripts/ci_invariants.sh](#crates-ron-policy-scripts-ciinvariants-sh)
- [crates/ron-policy/src/ctx/clock.rs](#crates-ron-policy-src-ctx-clock-rs)
- [crates/ron-policy/src/ctx/mod.rs](#crates-ron-policy-src-ctx-mod-rs)
- [crates/ron-policy/src/ctx/normalize.rs](#crates-ron-policy-src-ctx-normalize-rs)
- [crates/ron-policy/src/engine/eval.rs](#crates-ron-policy-src-engine-eval-rs)
- [crates/ron-policy/src/engine/index.rs](#crates-ron-policy-src-engine-index-rs)
- [crates/ron-policy/src/engine/metrics.rs](#crates-ron-policy-src-engine-metrics-rs)
- [crates/ron-policy/src/engine/mod.rs](#crates-ron-policy-src-engine-mod-rs)
- [crates/ron-policy/src/engine/obligations.rs](#crates-ron-policy-src-engine-obligations-rs)
- [crates/ron-policy/src/engine/reason.rs](#crates-ron-policy-src-engine-reason-rs)
- [crates/ron-policy/src/errors.rs](#crates-ron-policy-src-errors-rs)
- [crates/ron-policy/src/explain/mod.rs](#crates-ron-policy-src-explain-mod-rs)
- [crates/ron-policy/src/explain/trace.rs](#crates-ron-policy-src-explain-trace-rs)
- [crates/ron-policy/src/features.rs](#crates-ron-policy-src-features-rs)
- [crates/ron-policy/src/lib.rs](#crates-ron-policy-src-lib-rs)
- [crates/ron-policy/src/model.rs](#crates-ron-policy-src-model-rs)
- [crates/ron-policy/src/parse/json.rs](#crates-ron-policy-src-parse-json-rs)
- [crates/ron-policy/src/parse/mod.rs](#crates-ron-policy-src-parse-mod-rs)
- [crates/ron-policy/src/parse/toml.rs](#crates-ron-policy-src-parse-toml-rs)
- [crates/ron-policy/src/parse/validate.rs](#crates-ron-policy-src-parse-validate-rs)
- [crates/ron-policy/tests/golden_reasons.rs](#crates-ron-policy-tests-goldenreasons-rs)
- [crates/ron-policy/tests/helpers/bundle_load.rs](#crates-ron-policy-tests-helpers-bundleload-rs)
- [crates/ron-policy/tests/unit_churn_protection.rs](#crates-ron-policy-tests-unitchurnprotection-rs)
- [crates/ron-policy/tests/unit_eu_only.rs](#crates-ron-policy-tests-uniteuonly-rs)
- [crates/ron-policy/tests/unit_eval_determinism.rs](#crates-ron-policy-tests-unitevaldeterminism-rs)
- [crates/ron-policy/tests/unit_first_match_wins.rs](#crates-ron-policy-tests-unitfirstmatchwins-rs)
- [crates/ron-policy/tests/unit_large_body_default_deny.rs](#crates-ron-policy-tests-unitlargebodydefaultdeny-rs)
- [crates/ron-policy/tests/unit_method_matrix.rs](#crates-ron-policy-tests-unitmethodmatrix-rs)
- [crates/ron-policy/tests/unit_model_serde_strict.rs](#crates-ron-policy-tests-unitmodelserdestrict-rs)
- [crates/ron-policy/tests/unit_tags_all.rs](#crates-ron-policy-tests-unittagsall-rs)
- [crates/ron-policy/tests/unit_tighten_only.rs](#crates-ron-policy-tests-unittightenonly-rs)
- [crates/ron-policy/tests/vectors/body_too_large.json](#crates-ron-policy-tests-vectors-bodytoolarge-json)
- [crates/ron-policy/tests/vectors/decompress_guard.json](#crates-ron-policy-tests-vectors-decompressguard-json)
- [crates/ron-policy/tests/vectors/deny_region.json](#crates-ron-policy-tests-vectors-denyregion-json)
- [crates/ron-policy/tests/vectors/eu_only.json](#crates-ron-policy-tests-vectors-euonly-json)
- [crates/ron-policy/tests/vectors/large_body_default_deny.json](#crates-ron-policy-tests-vectors-largebodydefaultdeny-json)
- [crates/ron-policy/tests/vectors/method_matrix.json](#crates-ron-policy-tests-vectors-methodmatrix-json)
- [crates/ron-policy/tests/vectors/tags_all.json](#crates-ron-policy-tests-vectors-tagsall-json)

### crates/ron-policy/.cargo/config.toml
<a id="crates-ron-policy--cargo-config-toml"></a>

```toml
[build]
rustflags = ["-Dwarnings"]

[target.'cfg(all())']
rustdocflags = ["-Dwarnings"]

```

### crates/ron-policy/.github/workflows/policy.yml
<a id="crates-ron-policy--github-workflows-policy-yml"></a>

```yaml
name: ron-policy2
on:
  pull_request:
  push:
    branches: [ main ]
jobs:
  placeholder:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "CI placeholder for ron-policy2 (lint/tests/deny/benches/fuzz to be added)."

```

### crates/ron-policy/Cargo.toml
<a id="crates-ron-policy-Cargo-toml"></a>

```toml
[package]
name = "ron-policy"
version = "0.1.0-beta.1"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Declarative policy engine for RustyOnions (deny-by-default, quotas, geo, residency, reasons/obligations)"
repository = "https://example.invalid/RustyOnions"
authors = ["RustyOnions Contributors"]
rust-version = "1.78"

[lib]
name = "ron_policy"
path = "src/lib.rs"

[features]
# Tight JSON/TOML parsing with #[serde(deny_unknown_fields)] everywhere.
strict = []
# Avoids time dependencies in core; enables std::time-based clock by default.
default = ["strict"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"
thiserror = "1.0"
bytes = "1.7"
prometheus = "0.14"
regex = "1.10"
# NOTE: we migrated metrics statics to std::sync::LazyLock, so once_cell is no longer needed.

[dev-dependencies]
criterion = "0.5"
insta = { version = "1.43", features = ["json"] }
rand = "0.9"
pico-args = "0.5"        # for examples/ron_policy_cli.rs

[package.metadata.cargo-udeps.ignore]
normal = ["prometheus"]

[[bench]]
name = "eval_throughput"
harness = false

# Explicitly list the CLI example so it builds with dev-deps.
[[example]]
name = "ron_policy_cli"
path = "examples/ron_policy_cli.rs"

# Minimal example runs without extra deps; auto-discovery also works,
# but we keep it explicit for clarity.
[[example]]
name = "minimal_allow_deny"
path = "examples/minimal_allow_deny.rs"

```

### crates/ron-policy/benches/eval_throughput.rs
<a id="crates-ron-policy-benches-evalthroughput-rs"></a>

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

fn bench_eval(c: &mut Criterion) {
    let bundle = load_json(include_bytes!("../tests/vectors/deny_region.json")).unwrap();
    let ev = Evaluator::new(&bundle).unwrap();
    let clock = SystemClock::default();

    c.bench_function("eval:get/us", |b| {
        b.iter(|| {
            let ctx = Context::builder()
                .tenant("t")
                .method("GET")
                .region("US")
                .build(&clock);
            let d = ev.evaluate(&ctx).unwrap();
            black_box(d);
        })
    });
}

criterion_group!(benches, bench_eval);
criterion_main!(benches);

```

### crates/ron-policy/deny.toml
<a id="crates-ron-policy-deny-toml"></a>

```toml
# RO:WHAT — cargo-deny policy aligned to workspace gates
[advisories]
ignore = []

[bans]
multiple-versions = "deny"

[sources]
unknown-registry = "deny"
unknown-git = "deny"

[licenses]
unlicensed = "deny"
allow = [
  "MIT",
  "Apache-2.0",
  "Unicode-3.0",
  "Unicode-DFS-2016",
  "CC0-1.0",
  "CDLA-Permissive-2.0",
  "OpenSSL"
]

```

### crates/ron-policy/examples/minimal_allow_deny.rs
<a id="crates-ron-policy-examples-minimalallowdeny-rs"></a>

```rust
//! RO:WHAT — Minimal usage example: parse bundle → evaluate context → print result.
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

fn main() {
    let bundle = load_json(
        br#"{
        "version":1,
        "rules":[
            {"id":"deny-fl","when":{"region":"US-FL"},"action":"deny","reason":"geo block"},
            {"id":"allow","when":{},"action":"allow","reason":"open"}
        ]
    }"#,
    )
    .unwrap();

    let ev = Evaluator::new(&bundle).unwrap();
    let ctx = Context::builder()
        .tenant("acme")
        .method("GET")
        .region("US")
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();
    println!("effect={:?} reason={:?}", d.effect, d.reason);
}

```

### crates/ron-policy/examples/ron_policy_cli.rs
<a id="crates-ron-policy-examples-ronpolicycli-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::{load_json, load_toml, Context, Evaluator};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = pico_args::Arguments::from_env();

    let bundle: String = args.value_from_str("--bundle")?;
    let tenant: String = args
        .opt_value_from_str("--tenant")?
        .unwrap_or_else(|| "*".into());
    let method: String = args
        .opt_value_from_str("--method")?
        .unwrap_or_else(|| "*".into());
    let region: String = args
        .opt_value_from_str("--region")?
        .unwrap_or_else(|| "*".into());
    let body: u64 = args.opt_value_from_str("--body")?.unwrap_or(0);

    // Collect repeated flags: --tag paid --tag verified ...
    // Note: values_from_str<A, T>(...) — we specify T and let A be inferred via `_`.
    let tags: Vec<String> = args
        .values_from_str::<_, String>("--tag")
        .unwrap_or_default();

    let bytes = std::fs::read(&bundle)?;
    let bundle_val = if bundle.ends_with(".json") {
        load_json(&bytes)?
    } else if bundle.ends_with(".toml") {
        load_toml(&bytes)?
    } else {
        return Err("bundle must be .json or .toml".into());
    };

    let ev = Evaluator::new(&bundle_val)?;
    let mut b = Context::builder()
        .tenant(tenant)
        .method(method)
        .region(region)
        .body_bytes(body);
    for t in tags {
        b = b.tag(t);
    }
    let ctx = b.build(&SystemClock);

    let d = ev.evaluate(&ctx)?;
    println!("effect={:?} reason={:?}", d.effect, d.reason);
    println!("trace={:?}", d.trace.steps);
    Ok(())
}

```

### crates/ron-policy/fuzz/Cargo.toml
<a id="crates-ron-policy-fuzz-Cargo-toml"></a>

```toml
[package]
name = "ron-policy-fuzz"
version = "0.1.0"
publish = false
edition = "2021"

[package.metadata]
cargo-fuzz = true

[dependencies]
libfuzzer-sys = "0.4"
serde_json = "1.0"
toml = "0.8"
ron-policy = { path = ".." }

[[bin]]
name = "fuzz_bundle_parse"
path = "fuzz_targets/fuzz_bundle_parse.rs"

[[bin]]
name = "fuzz_eval"
path = "fuzz_targets/fuzz_eval.rs"

```

### crates/ron-policy/fuzz/fuzz_targets/fuzz_bundle_parse.rs
<a id="crates-ron-policy-fuzz-fuzztargets-fuzzbundleparse-rs"></a>

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;
use ron_policy::{load_json, load_toml};

fuzz_target!(|data: &[u8]| {
    let _ = load_json(data);
    let _ = load_toml(data);
});

```

### crates/ron-policy/fuzz/fuzz_targets/fuzz_eval.rs
<a id="crates-ron-policy-fuzz-fuzztargets-fuzzeval-rs"></a>

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;
use ron_policy::{load_json, Evaluator, Context, ctx::clock::SystemClock};

fuzz_target!(|data: &[u8]| {
    if let Ok(b) = load_json(data) {
        if let Ok(ev) = Evaluator::new(&b) {
            let c = Context::builder().tenant("t").method("GET").region("US").build(&SystemClock);
            let _ = ev.evaluate(&c);
        }
    }
});

```

### crates/ron-policy/rust-toolchain.toml
<a id="crates-ron-policy-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/ron-policy/schema/policybundle.schema.json
<a id="crates-ron-policy-schema-policybundle-schema-json"></a>

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "PolicyBundle",
  "type": "object",
  "required": ["version", "rules"],
  "additionalProperties": false,
  "properties": {
    "version": { "type": "integer", "minimum": 1 },
    "meta": { "type": "object", "additionalProperties": { "type": "string" } },
    "defaults": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "default_action": { "enum": ["allow", "deny"] },
        "max_body_bytes": { "type": "integer", "minimum": 0, "maximum": 1048576 }
      }
    },
    "rules": {
      "type": "array",
      "items": { "$ref": "#/definitions/rule" }
    }
  },
  "definitions": {
    "rule": {
      "type": "object",
      "required": ["id", "when", "action"],
      "additionalProperties": false,
      "properties": {
        "id": { "type": "string", "minLength": 1 },
        "when": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "tenant": { "type": "string" },
            "method": { "type": "string" },
            "region": { "type": "string" },
            "max_body_bytes": { "type": "integer", "minimum": 0, "maximum": 1048576 },
            "require_tags_all": { "type": "array", "items": { "type": "string" } }
          }
        },
        "action": { "enum": ["allow", "deny"] },
        "obligations": {
          "type": "array",
          "items": { "$ref": "#/definitions/obligation" }
        },
        "reason": { "type": "string" }
      }
    },
    "obligation": {
      "type": "object",
      "required": ["kind"],
      "additionalProperties": false,
      "properties": {
        "kind": { "type": "string" },
        "params": { "type": "object", "additionalProperties": { "type": "string" } }
      }
    }
  }
}

```

### crates/ron-policy/scripts/ci_invariants.sh
<a id="crates-ron-policy-scripts-ciinvariants-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Fast CI invariants for ron-policy (fmt, clippy, tests)
# RO:INVARIANTS — no magic sleeps; fail fast on errors
set -euo pipefail
cargo fmt -p ron-policy -- --check
cargo clippy -p ron-policy --no-deps -- -D warnings
cargo test -p ron-policy

```

### crates/ron-policy/src/ctx/clock.rs
<a id="crates-ron-policy-src-ctx-clock-rs"></a>

```rust
//! RO:WHAT — Clock trait for deterministic tests and prod time access.
//!
//! RO:WHY  — Keep engine free of direct time deps; easy to mock.

pub trait Clock {
    fn now_ms(&self) -> u64;
}

#[derive(Default)]
pub struct SystemClock;

impl Clock for SystemClock {
    fn now_ms(&self) -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        let ms = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis();
        u64::try_from(ms).unwrap_or(u64::MAX)
    }
}

```

### crates/ron-policy/src/ctx/mod.rs
<a id="crates-ron-policy-src-ctx-mod-rs"></a>

```rust
//! RO:WHAT — Evaluation context types (normalized request facts) and clock trait.
//!
//! RO:WHY  — Deterministic, testable evaluation independent of actual services.
//!
//! RO:INTERACTS — `engine::eval` (consumes `Context`), `ctx::{normalize,clock}`

pub mod clock;
pub mod normalize;

use std::collections::BTreeSet;

/// Minimal context the engine needs to decide.
#[derive(Debug, Clone)]
pub struct Context {
    pub tenant: String,
    pub method: String,
    pub region: String,
    pub body_bytes: u64,
    pub tags: BTreeSet<String>,
    pub now_ms: u64,
}

impl Context {
    #[must_use]
    pub fn builder() -> normalize::ContextBuilder {
        normalize::ContextBuilder::default()
    }
}

```

### crates/ron-policy/src/ctx/normalize.rs
<a id="crates-ron-policy-src-ctx-normalize-rs"></a>

```rust
//! RO:WHAT — Builders and normalizers to construct a `Context` safely.
//!
//! RO:WHY  — Avoid ad-hoc normalization in callers; ensure consistent casing and defaults.

use super::clock::Clock;
use super::Context;
use std::collections::BTreeSet;

#[derive(Default)]
pub struct ContextBuilder {
    tenant: Option<String>,
    method: Option<String>,
    region: Option<String>,
    body_bytes: Option<u64>,
    tags: BTreeSet<String>,
}

impl ContextBuilder {
    #[must_use]
    pub fn tenant(mut self, t: impl Into<String>) -> Self {
        self.tenant = Some(t.into());
        self
    }

    #[must_use]
    pub fn method(mut self, m: impl Into<String>) -> Self {
        self.method = Some(m.into());
        self
    }

    #[must_use]
    pub fn region(mut self, r: impl Into<String>) -> Self {
        self.region = Some(r.into());
        self
    }

    #[must_use]
    pub const fn body_bytes(mut self, n: u64) -> Self {
        self.body_bytes = Some(n);
        self
    }

    #[must_use]
    pub fn tag(mut self, t: impl Into<String>) -> Self {
        self.tags.insert(t.into().to_ascii_lowercase());
        self
    }

    pub fn build<C: Clock>(self, clock: &C) -> Context {
        Context {
            tenant: self.tenant.unwrap_or_else(|| "*".to_string()),
            method: self
                .method
                .map_or_else(|| "*".to_string(), |s| s.to_ascii_uppercase()),
            region: self.region.unwrap_or_else(|| "*".to_string()),
            body_bytes: self.body_bytes.unwrap_or(0),
            tags: self.tags,
            now_ms: clock.now_ms(),
        }
    }
}

```

### crates/ron-policy/src/engine/eval.rs
<a id="crates-ron-policy-src-engine-eval-rs"></a>

```rust
//! RO:WHAT — Core evaluation logic producing a Decision + Trace.
//!
//! RO:WHY  — Deterministic, explainable allow/deny with reasons and obligations.

use super::{index::RuleIndex, metrics, obligations::ObligationSet};
use crate::{
    errors::Error,
    explain::trace::{DecisionTrace, TraceStep},
    model::{Action, PolicyBundle, Rule},
    Context,
};
use std::time::Instant;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DecisionEffect {
    Allow,
    Deny,
}

#[derive(Debug, Clone)]
pub struct Decision {
    pub effect: DecisionEffect,
    pub obligations: ObligationSet,
    pub reason: Option<String>,
    pub trace: DecisionTrace,
}

pub struct Evaluator<'a> {
    bundle: &'a PolicyBundle,
    index: RuleIndex<'a>,
}

impl<'a> Evaluator<'a> {
    /// Construct an evaluator over a validated bundle.
    ///
    /// # Errors
    ///
    /// Currently infallible; reserved for future index build errors.
    pub fn new(bundle: &'a PolicyBundle) -> Result<Self, Error> {
        Ok(Self {
            index: RuleIndex::build(bundle),
            bundle,
        })
    }

    /// Evaluate a decision for `ctx`.
    ///
    /// # Errors
    ///
    /// Returns `Error::Eval` if evaluation cannot complete (reserved; not used today).
    pub fn evaluate(&self, ctx: &Context) -> Result<Decision, Error> {
        metrics::REQUESTS_TOTAL.inc();
        let t0 = Instant::now();

        let mut trace = DecisionTrace::default();
        let mut obligations = ObligationSet::default();

        // Hard guard: body cap from defaults first.
        if let Some(max) = self.bundle.defaults.max_body_bytes {
            if ctx.body_bytes > max {
                metrics::REJECTED_TOTAL
                    .with_label_values(&["body_too_large"])
                    .inc();
                trace
                    .steps
                    .push(TraceStep::note("defaults.max_body_bytes", "exceeded"));
                metrics::EVAL_LATENCY_SECONDS.observe(t0.elapsed().as_secs_f64());
                return Ok(Decision {
                    effect: DecisionEffect::Deny,
                    obligations,
                    reason: Some("body too large (defaults)".into()),
                    trace,
                });
            }
        }

        // Candidate rules restricted by method (and then checked fully).
        // `ctx.method` is already uppercased by the builder; reuse it to avoid alloc.
        let method: &str = &ctx.method;
        for r in self.index.candidates(method) {
            if rule_matches(r, ctx) {
                if matches!(r.action, Action::Deny) {
                    metrics::REJECTED_TOTAL
                        .with_label_values(&["rule_deny"])
                        .inc();
                }
                obligations.extend(&r.obligations);
                trace.steps.push(TraceStep::rule_hit(
                    &r.id,
                    r.reason.as_deref().unwrap_or(""),
                ));
                metrics::EVAL_LATENCY_SECONDS.observe(t0.elapsed().as_secs_f64());
                return Ok(Decision {
                    effect: match r.action {
                        Action::Allow => DecisionEffect::Allow,
                        Action::Deny => DecisionEffect::Deny,
                    },
                    obligations,
                    reason: r.reason.clone(),
                    trace,
                });
            }
            // Miss path (the `if` branch returns on hit).
            trace.steps.push(TraceStep::rule_miss(&r.id));
        }

        // No matches → default action (deny-by-default if unspecified)
        let effect = self.bundle.defaults.default_action.unwrap_or(Action::Deny);

        if matches!(effect, Action::Deny) {
            metrics::REJECTED_TOTAL
                .with_label_values(&["default_deny"])
                .inc();
        }

        metrics::EVAL_LATENCY_SECONDS.observe(t0.elapsed().as_secs_f64());
        Ok(Decision {
            effect: match effect {
                Action::Allow => DecisionEffect::Allow,
                Action::Deny => DecisionEffect::Deny,
            },
            obligations,
            reason: Some("default".into()),
            trace,
        })
    }
}

fn rule_matches(r: &Rule, ctx: &Context) -> bool {
    if let Some(t) = &r.when.tenant {
        if t != "*" && t != &ctx.tenant {
            return false;
        }
    }
    if let Some(m) = &r.when.method {
        if m != "*" && m.to_ascii_uppercase() != ctx.method {
            return false;
        }
    }
    if let Some(g) = &r.when.region {
        if g != "*" && g != &ctx.region {
            return false;
        }
    }
    if let Some(n) = r.when.max_body_bytes {
        if ctx.body_bytes > n {
            return false;
        }
    }
    if !r.when.require_tags_all.is_empty() {
        for tag in &r.when.require_tags_all {
            if !ctx.tags.contains(&tag.to_ascii_lowercase()) {
                return false;
            }
        }
    }
    true
}

```

### crates/ron-policy/src/engine/index.rs
<a id="crates-ron-policy-src-engine-index-rs"></a>

```rust
//! RO:WHAT — In-memory index to accelerate rule lookup by HTTP method.
//!
//! RO:WHY  — Avoid scanning all rules; common case is method-restricted rules.
//!
//! RO:INVARIANTS — Keys are uppercased method names or "*".

use crate::model::{PolicyBundle, Rule};
use std::collections::BTreeMap;

pub struct RuleIndex<'a> {
    by_method: BTreeMap<String, Vec<&'a Rule>>,
}

impl<'a> RuleIndex<'a> {
    /// Build an index from a validated `PolicyBundle`.
    ///
    /// # Errors
    ///
    /// Currently infallible; reserved for future index-build errors.
    #[must_use]
    pub fn build(bundle: &'a PolicyBundle) -> Self {
        let mut by_method: BTreeMap<String, Vec<&'a Rule>> = BTreeMap::new();
        for r in &bundle.rules {
            // clippy(map_unwrap_or): use map_or_else
            let key = r
                .when
                .method
                .as_ref()
                .map_or_else(|| "*".to_string(), |s| s.to_ascii_uppercase());
            by_method.entry(key).or_default().push(r);
        }
        Self { by_method }
    }

    /// Return candidates for a given (already UPPERCASED) method,
    /// falling back to "*" rules as well.
    pub fn candidates(&'a self, method: &str) -> impl Iterator<Item = &'a Rule> + 'a {
        // Avoid map/unwrap and redundant closures; iterate directly.
        self.by_method
            .get(method)
            .into_iter()
            .flat_map(|v| v.iter().copied())
            .chain(
                self.by_method
                    .get("*")
                    .into_iter()
                    .flat_map(|v| v.iter().copied()),
            )
    }
}

```

### crates/ron-policy/src/engine/metrics.rs
<a id="crates-ron-policy-src-engine-metrics-rs"></a>

```rust
//! RO:WHAT — Prometheus metrics for policy evaluations.
//!
//! RO:INVARIANTS — register once; use default registry.

use prometheus::{
    register_histogram, register_int_counter, register_int_counter_vec, Histogram, HistogramOpts,
    IntCounter, IntCounterVec, Opts,
};

pub static REQUESTS_TOTAL: std::sync::LazyLock<IntCounter> = std::sync::LazyLock::new(|| {
    register_int_counter!(Opts::new("policy_requests_total", "Policy evaluations")).unwrap()
});

pub static REJECTED_TOTAL: std::sync::LazyLock<IntCounterVec> = std::sync::LazyLock::new(|| {
    register_int_counter_vec!(
        Opts::new("policy_rejected_total", "Total rejects by reason"),
        &["reason"]
    )
    .unwrap()
});

pub static EVAL_LATENCY_SECONDS: std::sync::LazyLock<Histogram> = std::sync::LazyLock::new(|| {
    register_histogram!(HistogramOpts::new(
        "policy_eval_latency_seconds",
        "Evaluation latency"
    ))
    .unwrap()
});

```

### crates/ron-policy/src/engine/mod.rs
<a id="crates-ron-policy-src-engine-mod-rs"></a>

```rust
//! RO:WHAT — Policy evaluation engine modules.
pub mod eval;
pub mod index;
pub mod metrics;
pub mod obligations;
pub mod reason;

```

### crates/ron-policy/src/engine/obligations.rs
<a id="crates-ron-policy-src-engine-obligations-rs"></a>

```rust
//! RO:WHAT — Obligation handling (logical; no side effects here).
//! RO:WHY  — Services will interpret obligations; engine just aggregates.

use crate::model::Obligation;

#[derive(Debug, Clone, Default)]
pub struct ObligationSet {
    pub items: Vec<Obligation>,
}

impl ObligationSet {
    pub fn extend(&mut self, more: &[Obligation]) {
        self.items.extend_from_slice(more);
    }
}

```

### crates/ron-policy/src/engine/reason.rs
<a id="crates-ron-policy-src-engine-reason-rs"></a>

```rust
//! RO:WHAT — Machine+human readable reasons for decisions.

#[derive(Debug, Clone)]
pub struct Reason {
    pub code: &'static str,
    pub message: String,
}

impl Reason {
    pub fn new(code: &'static str, message: impl Into<String>) -> Self {
        Self {
            code,
            message: message.into(),
        }
    }
}

```

### crates/ron-policy/src/errors.rs
<a id="crates-ron-policy-src-errors-rs"></a>

```rust
//! RO:WHAT — Error taxonomy for ron-policy.
//!
//! RO:WHY  — Stable, deterministic error envelope for services/tests.
//!
//! RO:INTERACTS — `parse::{json,toml,validate}`, `engine::eval`
//!
//! RO:INVARIANTS — human-safe messages; no leaking secrets
//!
//! RO:TEST — unit tests exercise all variants

use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("parse error: {0}")]
    Parse(String),
    #[error("validation error: {0}")]
    Validation(String),
    #[error("evaluation error: {0}")]
    Eval(String),
}

```

### crates/ron-policy/src/explain/mod.rs
<a id="crates-ron-policy-src-explain-mod-rs"></a>

```rust
//! RO:WHAT — Explainability surface (trace).
pub mod trace;

```

### crates/ron-policy/src/explain/trace.rs
<a id="crates-ron-policy-src-explain-trace-rs"></a>

```rust
//! RO:WHAT — Structured trace steps for explain/debug/audit.

#[derive(Debug, Clone, Default)]
pub struct DecisionTrace {
    pub steps: Vec<TraceStep>,
}

#[derive(Debug, Clone)]
pub enum TraceStep {
    Note { key: String, msg: String },
    RuleHit { id: String, reason: String },
    RuleMiss { id: String },
}

impl DecisionTrace {
    pub fn note(key: impl Into<String>, msg: impl Into<String>) -> Self {
        let mut d = Self::default();
        d.steps.push(TraceStep::Note {
            key: key.into(),
            msg: msg.into(),
        });
        d
    }
}

impl TraceStep {
    pub fn note(key: impl Into<String>, msg: impl Into<String>) -> Self {
        Self::Note {
            key: key.into(),
            msg: msg.into(),
        }
    }
    pub fn rule_hit(id: impl Into<String>, reason: impl Into<String>) -> Self {
        Self::RuleHit {
            id: id.into(),
            reason: reason.into(),
        }
    }
    pub fn rule_miss(id: impl Into<String>) -> Self {
        Self::RuleMiss { id: id.into() }
    }
}

```

### crates/ron-policy/src/features.rs
<a id="crates-ron-policy-src-features-rs"></a>

```rust
//! RO:WHAT — Feature switches (placeholder for future toggles).
//!
//! RO:WHY  — Keep public surface stable while allowing internal perf/security opts.
//!
//! RO:INTERACTS — N/A today
//!
//! RO:INVARIANTS — default = strict parsing on

#[allow(dead_code)]
pub const STRICT: bool = cfg!(feature = "strict");

```

### crates/ron-policy/src/lib.rs
<a id="crates-ron-policy-src-lib-rs"></a>

```rust
//! RO:WHAT — ron-policy public API: load/validate bundles and evaluate decisions.
//!
//! RO:WHY  — Pillar 2 (Policy & Governance); Concerns: SEC/GOV. Deny-by-default guardrail.
//!
//! RO:INTERACTS — model, `parse::{json,toml,validate}`, `engine::{eval,index,obligations,metrics}`, `explain::trace`
//!
//! RO:INVARIANTS — DTOs are strict; no locks across `.await`; OAP caps: frame=1 MiB, chunk≈64 KiB (context only)
//!
//! RO:METRICS — `requests_total`, `rejected_total{reason}`, `eval_latency_seconds`
//!
//! RO:CONFIG — none (pure library); amnesia has no persistence here
//!
//! RO:SECURITY — capability enforcement happens in services; this crate only decides allow/deny
//!
//! RO:TEST — unit tests under `tests/*.rs`; bench: `benches/eval_throughput.rs`

#![forbid(unsafe_code)]
#![deny(clippy::all, clippy::pedantic, clippy::nursery)]

pub mod errors;
pub mod features;
pub mod model;

pub mod ctx;
pub mod engine;
pub mod explain;
pub mod parse;

pub use ctx::Context;
pub use engine::eval::{Decision, DecisionEffect, Evaluator};
pub use explain::trace::{DecisionTrace, TraceStep};
pub use model::{Action, Obligation, PolicyBundle, Rule, RuleCondition};

/// Convenience: load a bundle from JSON bytes.
///
/// # Errors
///
/// Returns `Error::Parse` on malformed JSON or `Error::Validation` if the
/// resulting `PolicyBundle` violates invariants.
pub fn load_json(bytes: &[u8]) -> Result<PolicyBundle, errors::Error> {
    let bundle = parse::json::from_slice(bytes)?;
    parse::validate::validate(&bundle)?;
    Ok(bundle)
}

/// Convenience: load a bundle from TOML bytes.
///
/// # Errors
///
/// Returns `Error::Parse` on malformed TOML or `Error::Validation` if the
/// resulting `PolicyBundle` violates invariants.
pub fn load_toml(bytes: &[u8]) -> Result<PolicyBundle, errors::Error> {
    let bundle = parse::toml::from_slice(bytes)?;
    parse::validate::validate(&bundle)?;
    Ok(bundle)
}

```

### crates/ron-policy/src/model.rs
<a id="crates-ron-policy-src-model-rs"></a>

```rust
//! RO:WHAT — Policy model (DTOs): `PolicyBundle`, Rule, Conditions, Actions, Obligations.
//!
//! RO:WHY  — DTO hygiene: `#[serde(deny_unknown_fields)]` so policies are explicit and auditable.
//!
//! RO:INTERACTS — parse loaders, engine eval, explain trace
//!
//! RO:INVARIANTS — deny-by-default; stable enums; versioned bundle

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct PolicyBundle {
    pub version: u32,
    /// Optional metadata bag (stringly typed, for governance/notes).
    #[serde(default)]
    pub meta: BTreeMap<String, String>,
    /// Global defaults. If `default_action` is omitted -> deny-by-default.
    #[serde(default)]
    pub defaults: Defaults,
    /// Rules are evaluated in order; first match wins (unless `strategy` overrides).
    #[serde(default)]
    pub rules: Vec<Rule>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct Defaults {
    #[serde(default)]
    pub default_action: Option<Action>,
    /// Max request body the engine expects callers to allow before evaluation (bytes).
    #[serde(default)]
    pub max_body_bytes: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Rule {
    pub id: String,
    pub when: RuleCondition,
    pub action: Action,
    #[serde(default)]
    pub obligations: Vec<Obligation>,
    /// Optional human-readable reason to surface if this rule triggers.
    #[serde(default)]
    pub reason: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct RuleCondition {
    /// Tenant or "*" for any.
    #[serde(default)]
    pub tenant: Option<String>,
    /// Method verb (e.g., "GET", "PUT") or "*" for any.
    #[serde(default)]
    pub method: Option<String>,
    /// Region/Geo (e.g., "US", "EU", "US-CA", "US-FL") or "*" for any.
    #[serde(default)]
    pub region: Option<String>,
    /// If present, deny if `body_bytes` exceeds this.
    #[serde(default)]
    pub max_body_bytes: Option<u64>,
    /// Arbitrary tags (all must be present in context if specified).
    #[serde(default)]
    pub require_tags_all: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Obligation {
    /// Name (e.g., "add-header", "mask-field", "log-audit")
    pub kind: String,
    /// Arbitrary parameters.
    #[serde(default)]
    pub params: BTreeMap<String, String>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "lowercase")]
pub enum Action {
    Allow,
    #[default]
    Deny,
}

```

### crates/ron-policy/src/parse/json.rs
<a id="crates-ron-policy-src-parse-json-rs"></a>

```rust
//! RO:WHAT — JSON loader for `PolicyBundle` (strict).
//!
//! RO:INVARIANTS — `deny_unknown_fields` enforced by DTOs.

use crate::{errors::Error, model::PolicyBundle};

/// Parse a `PolicyBundle` from JSON bytes.
///
/// # Errors
///
/// Returns `Error::Parse` if the input is not valid JSON for `PolicyBundle`.
pub fn from_slice(bytes: &[u8]) -> Result<PolicyBundle, Error> {
    serde_json::from_slice::<PolicyBundle>(bytes).map_err(|e| Error::Parse(e.to_string()))
}

```

### crates/ron-policy/src/parse/mod.rs
<a id="crates-ron-policy-src-parse-mod-rs"></a>

```rust
//! RO:WHAT — Parse entry points and validation.
pub mod json;
pub mod toml;
pub mod validate;

```

### crates/ron-policy/src/parse/toml.rs
<a id="crates-ron-policy-src-parse-toml-rs"></a>

```rust
//! RO:WHAT — TOML loader for `PolicyBundle` (strict).

use crate::{errors::Error, model::PolicyBundle};

/// Parse a `PolicyBundle` from TOML bytes.
///
/// # Errors
///
/// Returns `Error::Parse` if the input is not valid UTF-8 or not valid TOML for `PolicyBundle`.
pub fn from_slice(bytes: &[u8]) -> Result<PolicyBundle, Error> {
    let s = std::str::from_utf8(bytes).map_err(|e| Error::Parse(e.to_string()))?;
    toml::from_str::<PolicyBundle>(s).map_err(|e| Error::Parse(e.to_string()))
}

```

### crates/ron-policy/src/parse/validate.rs
<a id="crates-ron-policy-src-parse-validate-rs"></a>

```rust
//! RO:WHAT — Structural validation for `PolicyBundle`.
//!
//! Returns early with human-readable reasons on invariant violations.

use crate::{errors::Error, model::PolicyBundle};
use std::collections::BTreeSet;

/// Validate a `PolicyBundle` for basic invariants (e.g., duplicate IDs, body caps).
///
/// # Errors
///
/// Returns `Error::Validation` if the bundle violates invariants (e.g., duplicate rule IDs,
/// empty IDs, or caps exceeding 1 MiB).
pub fn validate(b: &PolicyBundle) -> Result<(), Error> {
    if b.version == 0 {
        return Err(Error::Validation("version must be ≥ 1".into()));
    }

    let mut ids = BTreeSet::<&str>::new();
    for r in &b.rules {
        if r.id.trim().is_empty() {
            return Err(Error::Validation("rule.id must be non-empty".into()));
        }
        if !ids.insert(&r.id) {
            return Err(Error::Validation(format!("duplicate rule id: {}", r.id)));
        }
        if let Some(n) = r.when.max_body_bytes {
            if n > 1_048_576 {
                // 1 MiB guard per Hardening blueprint
                return Err(Error::Validation(format!(
                    "rule {} max_body_bytes > 1MiB",
                    r.id
                )));
            }
        }
    }
    if let Some(n) = b.defaults.max_body_bytes {
        if n > 1_048_576 {
            return Err(Error::Validation("defaults.max_body_bytes > 1MiB".into()));
        }
    }
    Ok(())
}

```

### crates/ron-policy/tests/golden_reasons.rs
<a id="crates-ron-policy-tests-goldenreasons-rs"></a>

```rust
use ron_policy::engine::eval::DecisionEffect;
use ron_policy::explain::trace::TraceStep;
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

#[test]
fn explain_trace_is_stable() {
    let b = load_json(include_bytes!("vectors/decompress_guard.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();
    let ctx = Context::builder()
        .tenant("t")
        .method("PUT")
        .region("US")
        .body_bytes(512)
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();

    assert!(matches!(d.effect, DecisionEffect::Deny));
    assert_eq!(d.reason.as_deref(), Some("per-rule cap"));
    assert_eq!(d.trace.steps.len(), 1);
    match &d.trace.steps[0] {
        TraceStep::RuleHit { id, reason } => {
            assert_eq!(id, "deny-large-put");
            assert_eq!(reason, "per-rule cap");
        }
        other => panic!("unexpected trace step: {other:?}"),
    }
}

```

### crates/ron-policy/tests/helpers/bundle_load.rs
<a id="crates-ron-policy-tests-helpers-bundleload-rs"></a>

```rust
//! Helper to load test vectors.

use ron_policy::{load_json, PolicyBundle};

pub fn load_vector(name: &str) -> PolicyBundle {
    let path = format!("tests/vectors/{}", name);
    let bytes = std::fs::read(path).expect("read vector");
    load_json(&bytes).expect("parse bundle")
}

```

### crates/ron-policy/tests/unit_churn_protection.rs
<a id="crates-ron-policy-tests-unitchurnprotection-rs"></a>

```rust
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

#[test]
fn rule_deny_region() {
    let b = load_json(include_bytes!("vectors/deny_region.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();
    let ctx = Context::builder()
        .tenant("any")
        .method("GET")
        .region("US-FL")
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();
    assert!(matches!(
        d.effect,
        ron_policy::engine::eval::DecisionEffect::Deny
    ));
}

```

### crates/ron-policy/tests/unit_eu_only.rs
<a id="crates-ron-policy-tests-uniteuonly-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::engine::eval::{DecisionEffect, Evaluator};
use ron_policy::{load_json, Context};

#[test]
fn eu_allows_us_denies() {
    let b = load_json(include_bytes!("vectors/eu_only.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();

    let eu = Context::builder()
        .tenant("t")
        .method("GET")
        .region("EU")
        .build(&SystemClock);
    let us = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .build(&SystemClock);

    let de = ev.evaluate(&eu).unwrap();
    assert!(matches!(de.effect, DecisionEffect::Allow));
    assert_eq!(de.reason.as_deref(), Some("eu residency"));

    let du = ev.evaluate(&us).unwrap();
    assert!(matches!(du.effect, DecisionEffect::Deny));
    assert_eq!(du.reason.as_deref(), Some("default"));
}

```

### crates/ron-policy/tests/unit_eval_determinism.rs
<a id="crates-ron-policy-tests-unitevaldeterminism-rs"></a>

```rust
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

#[test]
fn deterministic_default_deny() {
    let bundle = load_json(br#"{"version":1,"rules":[]}"#).unwrap();
    let clock = SystemClock::default();
    let ctx = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .build(&clock);
    let ev = Evaluator::new(&bundle).unwrap();
    let d = ev.evaluate(&ctx).unwrap();
    assert!(matches!(
        d.effect,
        ron_policy::engine::eval::DecisionEffect::Deny
    ));
}

```

### crates/ron-policy/tests/unit_first_match_wins.rs
<a id="crates-ron-policy-tests-unitfirstmatchwins-rs"></a>

```rust
use ron_policy::{PolicyBundle, Rule, RuleCondition, Action};
use ron_policy::engine::eval::{Evaluator, DecisionEffect};
use ron_policy::{parse, Context};
use ron_policy::ctx::clock::SystemClock;

#[test]
fn first_match_wins_and_default_applies() {
    // Bundle: two overlapping allows for GET; no catch-all rule.
    // Expectations:
    //  - GET hits the *first* allow rule and returns immediately ("first").
    //  - POST has no matching rule and falls back to defaults ("default" deny).
    let b = PolicyBundle {
        version: 1,
        defaults: Default::default(), // default_action = None -> deny by default
        meta: Default::default(),
        rules: vec![
            Rule {
                id: "allow-1".into(),
                when: RuleCondition {
                    tenant: None,
                    method: Some("GET".into()),
                    region: None,
                    max_body_bytes: None,
                    require_tags_all: vec![],
                },
                action: Action::Allow,
                obligations: vec![],
                reason: Some("first".into()),
            },
            Rule {
                id: "allow-2".into(),
                when: RuleCondition {
                    tenant: None,
                    method: Some("GET".into()),
                    region: None,
                    max_body_bytes: None,
                    require_tags_all: vec![],
                },
                action: Action::Allow,
                obligations: vec![],
                reason: Some("second".into()),
            },
            // NOTE: No deny-fallback "*" rule here; we want POST to fall through to defaults.
        ],
    };

    parse::validate::validate(&b).unwrap();
    let ev = Evaluator::new(&b).unwrap();

    let getc = Context::builder().tenant("t").method("GET").region("US").build(&SystemClock);
    let postc = Context::builder().tenant("t").method("POST").region("US").build(&SystemClock);

    let d_get = ev.evaluate(&getc).unwrap();
    assert!(matches!(d_get.effect, DecisionEffect::Allow));
    assert_eq!(d_get.reason.as_deref(), Some("first"));

    let d_post = ev.evaluate(&postc).unwrap();
    assert!(matches!(d_post.effect, DecisionEffect::Deny));
    assert_eq!(d_post.reason.as_deref(), Some("default"));
}

```

### crates/ron-policy/tests/unit_large_body_default_deny.rs
<a id="crates-ron-policy-tests-unitlargebodydefaultdeny-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::engine::eval::{DecisionEffect, Evaluator};
use ron_policy::{load_json, Context};

#[test]
fn large_body_defaults_trips_deny() {
    let b = load_json(include_bytes!("vectors/large_body_default_deny.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();
    let ctx = Context::builder()
        .tenant("t")
        .method("PUT")
        .region("US")
        .body_bytes(512 * 1024)
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();
    assert!(matches!(d.effect, DecisionEffect::Deny));
    assert_eq!(d.reason.as_deref(), Some("body too large (defaults)"));
}

```

### crates/ron-policy/tests/unit_method_matrix.rs
<a id="crates-ron-policy-tests-unitmethodmatrix-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::engine::eval::{DecisionEffect, Evaluator};
use ron_policy::{load_json, Context};

#[test]
fn method_matrix_behaves() {
    let b = load_json(include_bytes!("vectors/method_matrix.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();

    let getc = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .build(&SystemClock);
    let putc = Context::builder()
        .tenant("t")
        .method("PUT")
        .region("US")
        .build(&SystemClock);
    let postc = Context::builder()
        .tenant("t")
        .method("POST")
        .region("US")
        .build(&SystemClock);

    let d_get = ev.evaluate(&getc).unwrap();
    assert!(matches!(d_get.effect, DecisionEffect::Allow));
    assert_eq!(d_get.reason.as_deref(), Some("get ok"));

    let d_put = ev.evaluate(&putc).unwrap();
    assert!(matches!(d_put.effect, DecisionEffect::Deny));
    assert_eq!(d_put.reason.as_deref(), Some("put blocked"));

    let d_post = ev.evaluate(&postc).unwrap();
    assert!(matches!(d_post.effect, DecisionEffect::Deny));
    assert_eq!(d_post.reason.as_deref(), Some("default"));
}

```

### crates/ron-policy/tests/unit_model_serde_strict.rs
<a id="crates-ron-policy-tests-unitmodelserdestrict-rs"></a>

```rust
use ron_policy::load_json;

#[test]
fn strict_deny_unknown_fields() {
    // Unknown field "oops" should be rejected.
    let bad = br#"{"version":1,"oops":true,"rules":[]}"#;
    let err = load_json(bad).unwrap_err();
    let msg = format!("{err}");
    assert!(msg.contains("validation error") || msg.contains("parse error"));
}

#[test]
fn round_trip_minimal() {
    let good = br#"{"version":1,"rules":[]}"#;
    let b = load_json(good).unwrap();
    assert_eq!(b.version, 1);
}

```

### crates/ron-policy/tests/unit_tags_all.rs
<a id="crates-ron-policy-tests-unittagsall-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::engine::eval::{DecisionEffect, Evaluator};
use ron_policy::{load_json, Context};

#[test]
fn all_required_tags_must_exist() {
    let b = load_json(include_bytes!("vectors/tags_all.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();

    let ok = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .tag("paid")
        .tag("verified")
        .build(&SystemClock);

    let missing_one = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .tag("paid")
        .build(&SystemClock);

    let d1 = ev.evaluate(&ok).unwrap();
    assert!(matches!(d1.effect, DecisionEffect::Allow));
    assert_eq!(d1.reason.as_deref(), Some("all-required-tags-present"));

    let d2 = ev.evaluate(&missing_one).unwrap();
    assert!(matches!(d2.effect, DecisionEffect::Deny));
    assert_eq!(d2.reason.as_deref(), Some("default"));
}

```

### crates/ron-policy/tests/unit_tighten_only.rs
<a id="crates-ron-policy-tests-unittightenonly-rs"></a>

```rust
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

#[test]
fn defaults_cap_applies() {
    let b = load_json(
        br#"{
        "version":1,
        "defaults":{"max_body_bytes": 10},
        "rules":[]
    }"#,
    )
    .unwrap();
    let ev = Evaluator::new(&b).unwrap();
    let ctx = Context::builder()
        .tenant("a")
        .method("PUT")
        .region("US")
        .body_bytes(11)
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();
    assert!(matches!(
        d.effect,
        ron_policy::engine::eval::DecisionEffect::Deny
    ));
}

```

### crates/ron-policy/tests/vectors/body_too_large.json
<a id="crates-ron-policy-tests-vectors-bodytoolarge-json"></a>

```json
{
  "version": 1,
  "defaults": { "max_body_bytes": 1024 },
  "rules": [
    { "id": "allow-gets", "when": { "method": "GET" }, "action": "allow" }
  ]
}

```

### crates/ron-policy/tests/vectors/decompress_guard.json
<a id="crates-ron-policy-tests-vectors-decompressguard-json"></a>

```json
{
  "version": 1,
  "rules": [
    {
      "id": "deny-large-put",
      "when": { "method": "PUT", "max_body_bytes": 512 },
      "action": "deny",
      "reason": "per-rule cap"
    },
    { "id": "allow-others", "when": {}, "action": "allow" }
  ]
}

```

### crates/ron-policy/tests/vectors/deny_region.json
<a id="crates-ron-policy-tests-vectors-denyregion-json"></a>

```json
{
  "version": 1,
  "rules": [
    {
      "id": "deny-us-fl",
      "when": { "region": "US-FL" },
      "action": "deny",
      "reason": "region denied"
    },
    {
      "id": "allow-rest",
      "when": {},
      "action": "allow",
      "reason": "fallback allow"
    }
  ]
}

```

### crates/ron-policy/tests/vectors/eu_only.json
<a id="crates-ron-policy-tests-vectors-euonly-json"></a>

```json
{
  "version": 1,
  "defaults": { "default_action": "deny" },
  "rules": [
    { "id": "allow-eu", "when": { "region": "EU" }, "action": "allow", "reason": "eu residency" }
  ]
}

```

### crates/ron-policy/tests/vectors/large_body_default_deny.json
<a id="crates-ron-policy-tests-vectors-largebodydefaultdeny-json"></a>

```json
{
  "version": 1,
  "defaults": { "max_body_bytes": 262144 },
  "rules": []
}

```

### crates/ron-policy/tests/vectors/method_matrix.json
<a id="crates-ron-policy-tests-vectors-methodmatrix-json"></a>

```json
{
  "version": 1,
  "rules": [
    { "id": "allow-get", "when": { "method": "GET" }, "action": "allow", "reason": "get ok" },
    { "id": "deny-put",  "when": { "method": "PUT" }, "action": "deny",  "reason": "put blocked" }
  ]
}

```

### crates/ron-policy/tests/vectors/tags_all.json
<a id="crates-ron-policy-tests-vectors-tagsall-json"></a>

```json
{
  "version": 1,
  "defaults": { "default_action": "deny" },
  "rules": [
    {
      "id": "allow-paid-verified",
      "when": { "require_tags_all": ["paid", "verified"] },
      "action": "allow",
      "reason": "all-required-tags-present"
    }
  ]
}

```

