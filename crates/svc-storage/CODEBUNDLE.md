<!-- Generated by scripts/make_crate_codex.sh on 2025-10-29T06:19:34Z -->
# Code Bundle — `svc-storage`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-storage/.github/workflows/ci.yml](#crates-svc-storage--github-workflows-ci-yml)
- [crates/svc-storage/.github/workflows/concurrency-guardrails.yml](#crates-svc-storage--github-workflows-concurrency-guardrails-yml)
- [crates/svc-storage/.github/workflows/contract-apis.yml](#crates-svc-storage--github-workflows-contract-apis-yml)
- [crates/svc-storage/.github/workflows/coverage.yml](#crates-svc-storage--github-workflows-coverage-yml)
- [crates/svc-storage/.github/workflows/perf.yml](#crates-svc-storage--github-workflows-perf-yml)
- [crates/svc-storage/.github/workflows/quantum.yml](#crates-svc-storage--github-workflows-quantum-yml)
- [crates/svc-storage/.github/workflows/redteam-fuzz.yml](#crates-svc-storage--github-workflows-redteam-fuzz-yml)
- [crates/svc-storage/.github/workflows/render-mermaid.yml](#crates-svc-storage--github-workflows-render-mermaid-yml)
- [crates/svc-storage/Cargo.toml](#crates-svc-storage-Cargo-toml)
- [crates/svc-storage/benches/etag_range.rs](#crates-svc-storage-benches-etagrange-rs)
- [crates/svc-storage/benches/read_path.rs](#crates-svc-storage-benches-readpath-rs)
- [crates/svc-storage/benches/write_path.rs](#crates-svc-storage-benches-writepath-rs)
- [crates/svc-storage/configs/pq-hybrid.toml](#crates-svc-storage-configs-pq-hybrid-toml)
- [crates/svc-storage/configs/profiles/macronode.toml](#crates-svc-storage-configs-profiles-macronode-toml)
- [crates/svc-storage/configs/profiles/micronode.toml](#crates-svc-storage-configs-profiles-micronode-toml)
- [crates/svc-storage/configs/svc-storage.example.toml](#crates-svc-storage-configs-svc-storage-example-toml)
- [crates/svc-storage/configs/validate.sh](#crates-svc-storage-configs-validate-sh)
- [crates/svc-storage/rust-toolchain.toml](#crates-svc-storage-rust-toolchain-toml)
- [crates/svc-storage/scripts/smoke_storage.sh](#crates-svc-storage-scripts-smokestorage-sh)
- [crates/svc-storage/src/amnesia.rs](#crates-svc-storage-src-amnesia-rs)
- [crates/svc-storage/src/auth/macaroon.rs](#crates-svc-storage-src-auth-macaroon-rs)
- [crates/svc-storage/src/auth/mod.rs](#crates-svc-storage-src-auth-mod-rs)
- [crates/svc-storage/src/bus.rs](#crates-svc-storage-src-bus-rs)
- [crates/svc-storage/src/config.rs](#crates-svc-storage-src-config-rs)
- [crates/svc-storage/src/errors.rs](#crates-svc-storage-src-errors-rs)
- [crates/svc-storage/src/http/error.rs](#crates-svc-storage-src-http-error-rs)
- [crates/svc-storage/src/http/extractors.rs](#crates-svc-storage-src-http-extractors-rs)
- [crates/svc-storage/src/http/middleware.rs](#crates-svc-storage-src-http-middleware-rs)
- [crates/svc-storage/src/http/mod.rs](#crates-svc-storage-src-http-mod-rs)
- [crates/svc-storage/src/http/routes/get_object.rs](#crates-svc-storage-src-http-routes-getobject-rs)
- [crates/svc-storage/src/http/routes/head_object.rs](#crates-svc-storage-src-http-routes-headobject-rs)
- [crates/svc-storage/src/http/routes/health.rs](#crates-svc-storage-src-http-routes-health-rs)
- [crates/svc-storage/src/http/routes/metrics.rs](#crates-svc-storage-src-http-routes-metrics-rs)
- [crates/svc-storage/src/http/routes/mod.rs](#crates-svc-storage-src-http-routes-mod-rs)
- [crates/svc-storage/src/http/routes/post_object.rs](#crates-svc-storage-src-http-routes-postobject-rs)
- [crates/svc-storage/src/http/routes/put_object.rs](#crates-svc-storage-src-http-routes-putobject-rs)
- [crates/svc-storage/src/http/routes/ready.rs](#crates-svc-storage-src-http-routes-ready-rs)
- [crates/svc-storage/src/http/routes/version.rs](#crates-svc-storage-src-http-routes-version-rs)
- [crates/svc-storage/src/http/server.rs](#crates-svc-storage-src-http-server-rs)
- [crates/svc-storage/src/lib.rs](#crates-svc-storage-src-lib-rs)
- [crates/svc-storage/src/main.rs](#crates-svc-storage-src-main-rs)
- [crates/svc-storage/src/metrics.rs](#crates-svc-storage-src-metrics-rs)
- [crates/svc-storage/src/policy/economics.rs](#crates-svc-storage-src-policy-economics-rs)
- [crates/svc-storage/src/policy/mod.rs](#crates-svc-storage-src-policy-mod-rs)
- [crates/svc-storage/src/policy/quotas.rs](#crates-svc-storage-src-policy-quotas-rs)
- [crates/svc-storage/src/policy/residency.rs](#crates-svc-storage-src-policy-residency-rs)
- [crates/svc-storage/src/prelude.rs](#crates-svc-storage-src-prelude-rs)
- [crates/svc-storage/src/readiness.rs](#crates-svc-storage-src-readiness-rs)
- [crates/svc-storage/src/storage/cache.rs](#crates-svc-storage-src-storage-cache-rs)
- [crates/svc-storage/src/storage/cas.rs](#crates-svc-storage-src-storage-cas-rs)
- [crates/svc-storage/src/storage/compression.rs](#crates-svc-storage-src-storage-compression-rs)
- [crates/svc-storage/src/storage/erasure.rs](#crates-svc-storage-src-storage-erasure-rs)
- [crates/svc-storage/src/storage/fs.rs](#crates-svc-storage-src-storage-fs-rs)
- [crates/svc-storage/src/storage/hedged.rs](#crates-svc-storage-src-storage-hedged-rs)
- [crates/svc-storage/src/storage/io.rs](#crates-svc-storage-src-storage-io-rs)
- [crates/svc-storage/src/storage/mod.rs](#crates-svc-storage-src-storage-mod-rs)
- [crates/svc-storage/src/storage/placement.rs](#crates-svc-storage-src-storage-placement-rs)
- [crates/svc-storage/src/storage/pq_envelope.rs](#crates-svc-storage-src-storage-pqenvelope-rs)
- [crates/svc-storage/src/storage/repair.rs](#crates-svc-storage-src-storage-repair-rs)
- [crates/svc-storage/src/storage/replication.rs](#crates-svc-storage-src-storage-replication-rs)
- [crates/svc-storage/src/tls/mod.rs](#crates-svc-storage-src-tls-mod-rs)
- [crates/svc-storage/src/tls/pq.rs](#crates-svc-storage-src-tls-pq-rs)
- [crates/svc-storage/src/tls/server_config.rs](#crates-svc-storage-src-tls-serverconfig-rs)
- [crates/svc-storage/src/types.rs](#crates-svc-storage-src-types-rs)
- [crates/svc-storage/src/uds/mod.rs](#crates-svc-storage-src-uds-mod-rs)
- [crates/svc-storage/src/uds/peercred.rs](#crates-svc-storage-src-uds-peercred-rs)
- [crates/svc-storage/src/uds/server.rs](#crates-svc-storage-src-uds-server-rs)
- [crates/svc-storage/src/version.rs](#crates-svc-storage-src-version-rs)
- [crates/svc-storage/testing/integration/error_caps.rs](#crates-svc-storage-testing-integration-errorcaps-rs)
- [crates/svc-storage/testing/integration/http_get_head_put.rs](#crates-svc-storage-testing-integration-httpgetheadput-rs)
- [crates/svc-storage/testing/integration/profile_matrix.rs](#crates-svc-storage-testing-integration-profilematrix-rs)
- [crates/svc-storage/testing/integration/range_tests.rs](#crates-svc-storage-testing-integration-rangetests-rs)
- [crates/svc-storage/testing/performance/compare_baselines.sh](#crates-svc-storage-testing-performance-comparebaselines-sh)
- [crates/svc-storage/testing/performance/run_load.sh](#crates-svc-storage-testing-performance-runload-sh)
- [crates/svc-storage/testing/performance/scripts/media_facet.sh](#crates-svc-storage-testing-performance-scripts-mediafacet-sh)

### crates/svc-storage/.github/workflows/ci.yml
<a id="crates-svc-storage--github-workflows-ci-yml"></a>

```yaml
name: CI
on: [push, pull_request]
jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
          components: rustfmt, clippy
      - run: cargo fmt --all --check
      - run: cargo clippy --all-targets -- -D warnings
      - run: cargo test --all --locked

```

### crates/svc-storage/.github/workflows/concurrency-guardrails.yml
<a id="crates-svc-storage--github-workflows-concurrency-guardrails-yml"></a>

```yaml
name: Concurrency Guardrails
on:
  workflow_dispatch: {}
jobs:
  guardrails:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Loom/sanitizers hooks placeholder."

```

### crates/svc-storage/.github/workflows/contract-apis.yml
<a id="crates-svc-storage--github-workflows-contract-apis-yml"></a>

```yaml
name: Contract APIs
on: [push, pull_request]
jobs:
  openapi-diff:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check OpenAPI present
        run: test -f crates/svc-storage2/docs/openapi/svc-storage.yaml

```

### crates/svc-storage/.github/workflows/coverage.yml
<a id="crates-svc-storage--github-workflows-coverage-yml"></a>

```yaml
name: Coverage
on:
  workflow_dispatch: {}
jobs:
  coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Coverage gate ≥85% placeholder."

```

### crates/svc-storage/.github/workflows/perf.yml
<a id="crates-svc-storage--github-workflows-perf-yml"></a>

```yaml
name: Perf
on:
  workflow_dispatch: {}
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Perf rig placeholder (range-heavy profile)."

```

### crates/svc-storage/.github/workflows/quantum.yml
<a id="crates-svc-storage--github-workflows-quantum-yml"></a>

```yaml
name: Quantum Matrix
on:
  workflow_dispatch: {}
jobs:
  pq-matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        feature: ["", "pq-hybrid"]
    steps:
      - uses: actions/checkout@v4
      - run: echo "PQ matrix smoke: ${{ matrix.feature }}"

```

### crates/svc-storage/.github/workflows/redteam-fuzz.yml
<a id="crates-svc-storage--github-workflows-redteam-fuzz-yml"></a>

```yaml
name: Redteam Fuzz
on:
  workflow_dispatch: {}
jobs:
  fuzz:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Fuzz targets placeholder (range/decomp/addr)."

```

### crates/svc-storage/.github/workflows/render-mermaid.yml
<a id="crates-svc-storage--github-workflows-render-mermaid-yml"></a>

```yaml
name: Render Mermaid
on:
  workflow_dispatch: {}
jobs:
  render:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Render arch/sequence/state diagrams placeholder."

```

### crates/svc-storage/Cargo.toml
<a id="crates-svc-storage-Cargo-toml"></a>

```toml
[package]
name = "svc-storage"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[features]
# HTTP + metrics enabled by default (matches smoke script expectations)
default = ["http", "metrics"]

# Marker features; metrics wires in prometheus
http = []
metrics = ["dep:prometheus"]

# future: "tls", "uds", "pq-hybrid"

[dependencies]
# ==== HTTP stack ====
# Axum server features explicitly enabled (required for axum::serve)
axum = { version = "0.7.9", default-features = false, features = ["tokio", "http1", "http2", "json"] }
axum-extra = { version = "0.9", features = ["typed-header"] }   # TypedHeader (Range, etc.)
headers = "0.4"                                                 # Range/ETag helpers
http = "1"
hyper = "1"
tower-http = { version = "0.6.6", features = ["trace", "compression-full", "decompression-gzip", "cors", "util"] }
mime = "0.3"

# ==== Async/runtime ====
# ADD: "net" so tokio::net::TcpListener is available here
tokio = { version = "1.47.1", features = ["rt-multi-thread", "macros", "fs", "io-util", "signal", "net"] }
tokio-util = { version = "0.7", features = ["io"] }
bytes = "1.6"

# ==== Serde / utils ====
serde = { version = "1", features = ["derive"] }
serde_json = "1"
anyhow = "1"
thiserror = "1"
once_cell = "1.19"
parking_lot = "0.12"
arc-swap = "1.7"
async-trait = "0.1"
base64 = "0.22"
time = { version = "0.3", features = ["formatting"] }

# ==== Observability ====
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }
prometheus = { version = "0.14", optional = true }  # gated by `metrics` feature

# ==== Content addressing / helpers ====
blake3 = "1.5"
hex = "0.4"

# ==== RON crates (workspace paths) ====
ron-kernel = { path = "../ron-kernel" }
ron-metrics = { path = "../ron-metrics" }
ron-proto  = { path = "../ron-proto" }
ron-naming = { path = "../ron-naming" }

[dev-dependencies]
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls-native-roots", "http2", "json"] }
tokio   = { version = "1.47.1", features = ["rt-multi-thread", "macros"] }

```

### crates/svc-storage/benches/etag_range.rs
<a id="crates-svc-storage-benches-etagrange-rs"></a>

```rust
// Criterion bench: conditional GET + Range (scaffold)

```

### crates/svc-storage/benches/read_path.rs
<a id="crates-svc-storage-benches-readpath-rs"></a>

```rust
// Criterion bench: read path p95 (scaffold)

```

### crates/svc-storage/benches/write_path.rs
<a id="crates-svc-storage-benches-writepath-rs"></a>

```rust
// Criterion bench: write path p95 (scaffold)

```

### crates/svc-storage/configs/pq-hybrid.toml
<a id="crates-svc-storage-configs-pq-hybrid-toml"></a>

```toml
# Enable PQ-hybrid transport/auth envelopes
pq_hybrid = true

```

### crates/svc-storage/configs/profiles/macronode.toml
<a id="crates-svc-storage-configs-profiles-macronode-toml"></a>

```toml
# Macronode defaults: persistent, replication ready
amnesia = false
chunk_bytes = "64KiB"

```

### crates/svc-storage/configs/profiles/micronode.toml
<a id="crates-svc-storage-configs-profiles-micronode-toml"></a>

```toml
# Micronode defaults: single-tenant, amnesia ON
amnesia = true
chunk_bytes = "64KiB"

```

### crates/svc-storage/configs/svc-storage.example.toml
<a id="crates-svc-storage-configs-svc-storage-example-toml"></a>

```toml
bind = "127.0.0.1:5303"
data_dir = "./data/storage"
read_timeout_ms = 5000
write_timeout_ms = 5000
max_body_bytes = 1048576
amnesia = false

```

### crates/svc-storage/configs/validate.sh
<a id="crates-svc-storage-configs-validate-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "Validating TOML configs (lightweight placeholder)..."
for f in *.toml profiles/*.toml 2>/dev/null; do
  if [ -f "$f" ]; then
    echo "OK: $f"
  fi
done

```

### crates/svc-storage/rust-toolchain.toml
<a id="crates-svc-storage-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/svc-storage/scripts/smoke_storage.sh
<a id="crates-svc-storage-scripts-smokestorage-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# --- config (overridable via env) ---
BIN="${BIN:-svc-storage}"
ADDR="${ADDR:-127.0.0.1:5303}"          # address the server should bind to
WAIT_SECS="${WAIT_SECS:-20}"            # max seconds to wait for server up
LOG_FILE="${LOG_FILE:-/tmp/${BIN}.log}" # server stdout/stderr
CARGO_FEATURES="${CARGO_FEATURES:-}"    # e.g. "--features metrics"

say()  { printf '%s\n' "$*"; }
fail() { printf '❌ %s\n' "$*" >&2; exit 1; }

# --- find repo root by walking up until we see a workspace Cargo.toml ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
find_repo_root() {
  local d="${SCRIPT_DIR}"
  while :; do
    if [ -f "${d}/Cargo.toml" ] && grep -q '^\[workspace\]' "${d}/Cargo.toml"; then
      printf '%s\n' "${d}"
      return 0
    fi
    local parent
    parent="$(dirname "${d}")"
    [ "${parent}" = "${d}" ] && break
    d="${parent}"
  done
  # Fallback: use current working dir (should still work if we're inside the repo)
  printf '%s\n' "$(pwd)"
}
REPO_ROOT="$(find_repo_root)"
cd "${REPO_ROOT}"

# --- build ---
say "building ${BIN}…"
cargo build -p "${BIN}" >/dev/null

# --- start server ---
: > "${LOG_FILE}"
say "starting ${BIN} at ${ADDR}… (logs: ${LOG_FILE})"
RUST_LOG="${RUST_LOG:-info}" \
ADDR="${ADDR}" \
cargo run -p "${BIN}" ${CARGO_FEATURES} >"${LOG_FILE}" 2>&1 &
SERVER_PID=$!

cleanup() {
  if kill -0 "${SERVER_PID}" 2>/dev/null; then
    kill "${SERVER_PID}" 2>/dev/null || true
    wait "${SERVER_PID}" 2>/dev/null || true
  fi
}
trap cleanup EXIT

# --- wait for HTTP to be responsive ---
say "waiting for http://${ADDR}…"
UP=0
end_at=$(( $(date +%s) + WAIT_SECS ))
while (( $(date +%s) < end_at )); do
  # Prefer /healthz if present; otherwise any HTTP status on / indicates the server is up.
  HC="$(curl -s -o /dev/null -w '%{http_code}' "http://${ADDR}/healthz" || true)"
  if [[ "${HC}" == "200" ]]; then
    say "✅ ${BIN} is up (GET /healthz -> 200)"
    UP=1; break
  fi
  ROOTC="$(curl -s -o /dev/null -w '%{http_code}' "http://${ADDR}/" || true)"
  if [[ "${ROOTC}" =~ ^[1-5][0-9]{2}$ ]]; then
    say "✅ ${BIN} is up (GET / -> ${ROOTC})"
    UP=1; break
  fi
  if ! kill -0 "${SERVER_PID}" 2>/dev/null; then
    fail "${BIN} failed to start (process exited)
---- server log ----
$(tail -n +1 "${LOG_FILE}")"
  fi
  sleep 0.2
done

if [[ "${UP}" != "1" ]]; then
  fail "timed out waiting for ${BIN}
---- server log ----
$(tail -n 200 "${LOG_FILE}")"
fi

# --- tests ---
PASS=0; FAIL=0; SKIP=0
_step() { printf "\n-- %s --\n" "$*"; }

# 1) PUT object
_step "PUT object"
CID=$(echo -n "hello world" | curl -sS -X PUT --data-binary @- "http://${ADDR}/o" | jq -r .cid)
if [[ -n "${CID:-}" && "${CID}" == b3:* ]]; then
  say "✅ PUT returned cid=${CID}"; ((PASS++))
else
  say "❌ PUT failed (cid='${CID:-}')" ; ((FAIL++))
fi

# 2) HEAD object (expect 200, length=11, etag present)
_step "HEAD object"
H="$(curl -sSI "http://${ADDR}/o/${CID}")" || true
echo "${H}" | grep -q "^HTTP/.* 200"       && { say "✅ HEAD 200"; ((PASS++)); } || { say "❌ HEAD not 200"; ((FAIL++)); }
echo "${H}" | grep -iq "^Content-Length: 11" && { say "✅ HEAD Content-Length=11"; ((PASS++)); } || { say "❌ HEAD missing/incorrect Content-Length"; ((FAIL++)); }
echo "${H}" | grep -iq "^ETag:"            && { say "✅ HEAD ETag present"; ((PASS++)); } || { say "❌ HEAD missing ETag"; ((FAIL++)); }

# 3) GET full
_step "GET full"
BODY="$(curl -s "http://${ADDR}/o/${CID}")"
[[ "${BODY}" == "hello world" ]] && { say "✅ GET full body matches"; ((PASS++)); } || { say "❌ GET full body mismatch: '${BODY}'"; ((FAIL++)); }

# 4) Range GET
_step "Range GET bytes=0-4"
RANGE_BODY="$(curl -s -H 'Range: bytes=0-4' -i "http://${ADDR}/o/${CID}")"
echo "${RANGE_BODY}" | head -n1 | grep -q "206" && { say "✅ Range GET 206"; ((PASS++)); } || { say "❌ Range GET not 206"; ((FAIL++)); }
echo "${RANGE_BODY}" | tail -n1 | grep -q "^hello$" && { say "✅ Range body matches 'hello'"; ((PASS++)); } || { say "❌ Range body mismatch: '$(echo "${RANGE_BODY}" | tail -n1)'"; ((FAIL++)); }

# 5) GET unknown -> 404
_step "GET unknown"
UNKNOWN_CODE="$(curl -s -o /dev/null -w '%{http_code}' "http://${ADDR}/o/b3:deadbeef")"
[[ "${UNKNOWN_CODE}" == "404" ]] && { say "✅ GET unknown cid -> 404"; ((PASS++)); } || { say "❌ GET unknown returned ${UNKNOWN_CODE}"; ((FAIL++)); }

# 6) metrics (optional)
_step "metrics"
METRIC_CODE="$(curl -s -o /dev/null -w '%{http_code}' "http://${ADDR}/metrics" || true)"
if [[ "${METRIC_CODE}" == "200" ]]; then
  say "✅ /metrics OK"; ((PASS++))
else
  say "⏭️  /metrics not mounted (code=${METRIC_CODE}); skipping"; ((SKIP++))
fi

# --- summary ---
echo "---- summary ----"
echo "PASS=${PASS} FAIL=${FAIL} SKIP=${SKIP}"
if (( FAIL == 0 )); then
  echo "all good ✅"
else
  echo "some checks failed ❌"
  echo "---- server log (tail) ----"
  tail -n 200 "${LOG_FILE}" || true
  exit 1
fi

```

### crates/svc-storage/src/amnesia.rs
<a id="crates-svc-storage-src-amnesia-rs"></a>

```rust
//! Amnesia toggle (stub used by scripts & future policy flow).

#[allow(dead_code)]
pub struct Amnesia(pub bool);

#[allow(dead_code)]
impl Amnesia {
    pub fn is_on(&self) -> bool {
        self.0
    }
}

```

### crates/svc-storage/src/auth/macaroon.rs
<a id="crates-svc-storage-src-auth-macaroon-rs"></a>

```rust
//! RO:WHAT — Minimal macaroon-ish token + Axum extractor, signed with keyed BLAKE3.
//! RO:WHY  — Gate write endpoints without heavy deps or external KMS.
//! RO:NOTE — If `RON_STORAGE_MACAROON_SECRET` is unset, extractor is permissive (dev mode).

use axum::{
    async_trait,
    extract::FromRequestParts,
    http::{header, request::Parts, StatusCode},
    response::{IntoResponse, Response},
};
use base64::engine::general_purpose::URL_SAFE_NO_PAD as B64;
use base64::Engine;

#[derive(Debug)]
pub enum MacaroonError {
    Missing,
    Malformed,
    Expired,
    BadSig,
    Internal,
}

impl IntoResponse for MacaroonError {
    fn into_response(self) -> Response {
        let (code, msg) = match self {
            MacaroonError::Missing => (StatusCode::UNAUTHORIZED, "missing authorization"),
            MacaroonError::Malformed => (StatusCode::UNAUTHORIZED, "malformed authorization"),
            MacaroonError::Expired => (StatusCode::UNAUTHORIZED, "token expired"),
            MacaroonError::BadSig => (StatusCode::FORBIDDEN, "bad signature"),
            MacaroonError::Internal => (StatusCode::INTERNAL_SERVER_ERROR, "auth internal"),
        };
        (code, msg).into_response()
    }
}

#[derive(Debug, Clone)]
pub struct MacaroonClaims {
    pub issued_at: u64,
    pub expires_at: u64,
}

/// 32-byte key from env (base64url, no padding). None => dev/permissive.
fn secret_from_env() -> Option<[u8; 32]> {
    let raw = std::env::var("RON_STORAGE_MACAROON_SECRET").ok()?;
    let mut key = [0u8; 32];
    let decoded = B64.decode(raw).ok()?;
    if decoded.len() != 32 {
        return None;
    }
    key.copy_from_slice(&decoded);
    Some(key)
}

fn leeway_from_env() -> u64 {
    std::env::var("RON_STORAGE_MACAROON_LEEWAY")
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(60)
}

fn now_unix() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs()
}

/// Token inner text: `v=1;ts=<u64>;exp=<u64>;sig=<hex>`
fn parse_token_fields(token: &str) -> Option<(u64, u64, &str)> {
    let mut v = None;
    let mut ts = None;
    let mut exp = None;
    let mut sig = None;
    for part in token.split(';') {
        let (k, val) = part.split_once('=')?;
        match k {
            "v" if val == "1" => v = Some(1u8),
            "ts" => ts = val.parse::<u64>().ok(),
            "exp" => exp = val.parse::<u64>().ok(),
            "sig" => sig = Some(val),
            _ => {}
        }
    }
    match (v, ts, exp, sig) {
        (Some(_), Some(ts), Some(exp), Some(sig)) => Some((ts, exp, sig)),
        _ => None,
    }
}

/// BLAKE3 keyed MAC as lowercase hex string.
fn mac_hex(key: &[u8; 32], msg: &str) -> String {
    let mac = blake3::keyed_hash(key, msg.as_bytes());
    mac.to_hex().to_string()
}

fn verify_impl_with_header(authz: &str) -> Result<MacaroonClaims, MacaroonError> {
    // Accept "Macaroon ..." or "Bearer ..."
    let token = authz
        .strip_prefix("Macaroon ")
        .or_else(|| authz.strip_prefix("Bearer "))
        .ok_or(MacaroonError::Malformed)?;

    let decoded = B64.decode(token).map_err(|_| MacaroonError::Malformed)?;
    let text = std::str::from_utf8(&decoded).map_err(|_| MacaroonError::Malformed)?;

    let (ts, exp, sig_hex) = parse_token_fields(text).ok_or(MacaroonError::Malformed)?;
    let now = now_unix();
    let leeway = leeway_from_env();

    if exp + leeway < now {
        return Err(MacaroonError::Expired);
    }
    if ts > now + 24 * 3600 {
        return Err(MacaroonError::Malformed);
    }

    // Canonical string to MAC
    let msg = format!("v=1|ts={}|exp={}", ts, exp);

    let key = secret_from_env().ok_or(MacaroonError::Internal)?;
    let expect = mac_hex(&key, &msg);

    // Constant-time-ish comparison
    if expect.len() != sig_hex.len() {
        return Err(MacaroonError::BadSig);
    }
    let mut diff = 0u8;
    for (a, b) in expect.as_bytes().iter().zip(sig_hex.as_bytes()) {
        diff |= a ^ b;
    }
    if diff != 0 {
        return Err(MacaroonError::BadSig);
    }

    Ok(MacaroonClaims {
        issued_at: ts,
        expires_at: exp,
    })
}

#[async_trait]
impl<S> FromRequestParts<S> for MacaroonClaims
where
    S: Send + Sync,
{
    type Rejection = MacaroonError;

    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        // DEV-PERMISSIVE PATH: if no secret is configured, allow even with no header.
        if secret_from_env().is_none() {
            let n = now_unix();
            return Ok(MacaroonClaims {
                issued_at: n,
                expires_at: n + 300,
            });
        }

        // ENFORCED PATH: secret is configured -> require header and verify.
        let auth = parts
            .headers
            .get(header::AUTHORIZATION)
            .ok_or(MacaroonError::Missing)?;
        let auth = auth.to_str().map_err(|_| MacaroonError::Malformed)?;
        verify_impl_with_header(auth)
    }
}

```

### crates/svc-storage/src/auth/mod.rs
<a id="crates-svc-storage-src-auth-mod-rs"></a>

```rust
//! RO:WHAT — Authentication surface for svc-storage (macaroon-style, keyed BLAKE3).

mod macaroon;
pub use macaroon::MacaroonClaims;
// Keep helpers private until we wire a mint script or tests:
// pub use macaroon::{mint_for, MacaroonError};

```

### crates/svc-storage/src/bus.rs
<a id="crates-svc-storage-src-bus-rs"></a>

```rust
//! RO:WHAT — Bus glue to the kernel (optional for events).
//! RO:WHY — Publish Health/ConfigUpdated later if needed.
//! RO:INTERACTS — ron-kernel Bus API.

#[allow(unused)]
pub struct BusGlue;

```

### crates/svc-storage/src/config.rs
<a id="crates-svc-storage-src-config-rs"></a>

```rust
//! RO:WHAT — Configuration for svc-storage.
//! RO:ENV  —
//!   RON_STORAGE_ADDR        (default "127.0.0.1:5303")
//!   RON_STORAGE_DATA_DIR    (default "./data/storage")
//!   RON_STORAGE_MAX_BODY    (bytes, default 64 MiB)

use anyhow::Context;
use std::net::SocketAddr;
use std::path::PathBuf;
use std::str::FromStr;
use std::time::Duration;

pub struct Config {
    pub http_addr: SocketAddr,
    pub data_dir: PathBuf,
    pub max_body_bytes: u64,
}

impl Config {
    pub fn from_env() -> anyhow::Result<Self> {
        let http_addr_str =
            std::env::var("RON_STORAGE_ADDR").unwrap_or_else(|_| "127.0.0.1:5303".to_string());
        let http_addr = SocketAddr::from_str(&http_addr_str)
            .with_context(|| format!("invalid RON_STORAGE_ADDR: {}", http_addr_str))?;

        let data_dir = std::env::var("RON_STORAGE_DATA_DIR")
            .map(PathBuf::from)
            .unwrap_or_else(|_| PathBuf::from("./data/storage"));

        let max_body_bytes = std::env::var("RON_STORAGE_MAX_BODY")
            .ok()
            .and_then(|s| s.parse::<u64>().ok())
            .unwrap_or(64 * 1024 * 1024);

        Ok(Self {
            http_addr,
            data_dir,
            max_body_bytes,
        })
    }

    pub fn read_timeout(&self) -> Duration {
        Duration::from_secs(30)
    }
    pub fn write_timeout(&self) -> Duration {
        Duration::from_secs(30)
    }
}

```

### crates/svc-storage/src/errors.rs
<a id="crates-svc-storage-src-errors-rs"></a>

```rust
//! Error taxonomy for svc-storage.

use thiserror::Error;

#[derive(Error, Debug)]
pub enum StorageError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("object not found")]
    NotFound,

    #[error("bad address format")]
    BadAddress,

    #[error("range not satisfiable")]
    RangeNotSatisfiable,

    #[error("request body too large")]
    CapacityExceeded,

    #[error("integrity check failed")]
    IntegrityFailed,
}

```

### crates/svc-storage/src/http/error.rs
<a id="crates-svc-storage-src-http-error-rs"></a>

```rust
//! Map StorageError -> HTTP responses.

use axum::{http::StatusCode, response::IntoResponse, Json};
use serde_json::json;

use crate::errors::StorageError;

pub fn into_response(err: StorageError) -> impl IntoResponse {
    let (status, code) = match err {
        StorageError::NotFound => (StatusCode::NOT_FOUND, "not_found"),
        StorageError::BadAddress => (StatusCode::BAD_REQUEST, "bad_address"),
        StorageError::RangeNotSatisfiable => {
            (StatusCode::RANGE_NOT_SATISFIABLE, "range_not_satisfiable")
        }
        StorageError::CapacityExceeded => (StatusCode::PAYLOAD_TOO_LARGE, "capacity_exceeded"),
        StorageError::IntegrityFailed => (StatusCode::BAD_REQUEST, "integrity_failed"),
        StorageError::Io(_) => (StatusCode::INTERNAL_SERVER_ERROR, "io_error"),
    };

    (
        status,
        Json(json!({
            "title": code,
            "status": status.as_u16(),
            "detail": err.to_string()
        })),
    )
}

```

### crates/svc-storage/src/http/extractors.rs
<a id="crates-svc-storage-src-http-extractors-rs"></a>

```rust
//! RO:WHAT — Shared app state (Storage handle) for route handlers.
//! RO:WHY  — Axum 0.7 needs state to be Send + Sync + 'static.

use crate::storage::DynStorage;

#[derive(Clone)]
pub struct AppState {
    pub store: DynStorage, // Arc<dyn Storage + Send + Sync + 'static>
}

```

### crates/svc-storage/src/http/middleware.rs
<a id="crates-svc-storage-src-http-middleware-rs"></a>

```rust
//! Placeholder middleware (future: enforce ready before heavy ops).

use axum::response::Response;
use std::sync::Arc;

use crate::readiness::Readiness;

#[allow(dead_code)]
pub async fn require_ready(_ready: Arc<Readiness>) -> Response {
    // stub: in future, check readiness and short-circuit with 503
    Response::new(axum::body::Body::empty())
}

```

### crates/svc-storage/src/http/mod.rs
<a id="crates-svc-storage-src-http-mod-rs"></a>

```rust
//! RO:WHAT — HTTP surface (extractors, routes, server) for svc-storage.
pub mod error;
pub mod extractors;
pub mod middleware;
pub mod routes;
pub mod server;

```

### crates/svc-storage/src/http/routes/get_object.rs
<a id="crates-svc-storage-src-http-routes-getobject-rs"></a>

```rust
use axum::http::{HeaderMap, HeaderValue, StatusCode};
use axum::{
    extract::{Path, State},
    response::{IntoResponse, Response},
};

use crate::http::extractors::AppState;

fn parse_range_bytes(range_header: &str, total_len: u64) -> Option<(u64, u64)> {
    // Support the simple form used by our smoke test: "bytes=START-END"
    // Also accept "bytes=START-" and "bytes=-SUFFIX".
    let s = range_header.trim();
    if !s.starts_with("bytes=") {
        return None;
    }
    let spec = &s[6..];
    // Only support a single range
    if let Some((a, b)) = spec.split_once('-') {
        match (a.trim(), b.trim()) {
            // bytes=START-END
            (a, b) if !a.is_empty() && !b.is_empty() => {
                let start: u64 = a.parse().ok()?;
                let end: u64 = b.parse().ok()?;
                if start <= end && end < total_len {
                    Some((start, end))
                } else {
                    None
                }
            }
            // bytes=START-
            (a, b) if !a.is_empty() && b.is_empty() => {
                let start: u64 = a.parse().ok()?;
                if start < total_len {
                    Some((start, total_len.saturating_sub(1)))
                } else {
                    None
                }
            }
            // bytes=-SUFFIX  (last N bytes)
            (a, b) if a.is_empty() && !b.is_empty() => {
                let suffix: u64 = b.parse().ok()?;
                if suffix == 0 {
                    None
                } else if suffix >= total_len {
                    Some((0, total_len.saturating_sub(1)))
                } else {
                    Some((total_len - suffix, total_len - 1))
                }
            }
            _ => None,
        }
    } else {
        None
    }
}

pub async fn handler(
    State(app): State<AppState>,
    Path(cid): Path<String>,
    headers_in: HeaderMap,
) -> Response {
    // HEAD meta first (for both full and range)
    let meta = match app.store.head(&cid).await {
        Ok(m) => m,
        Err(_) => return (StatusCode::NOT_FOUND, ()).into_response(),
    };

    // Optional Range: parse manually so we don't depend on headers crate API quirks
    if let Some(hv) = headers_in.get(axum::http::header::RANGE) {
        if let Ok(hs) = hv.to_str() {
            if let Some((start, end_inclusive)) = parse_range_bytes(hs, meta.len) {
                match app.store.get_range(&cid, start, end_inclusive).await {
                    Ok((chunk, _total_len)) => {
                        let mut headers = HeaderMap::new();
                        headers.insert(
                            axum::http::header::ETAG,
                            HeaderValue::from_str(&meta.etag).unwrap(),
                        );
                        headers.insert(
                            axum::http::header::CONTENT_LENGTH,
                            HeaderValue::from_str(&chunk.len().to_string()).unwrap(),
                        );
                        headers.insert(
                            axum::http::header::CONTENT_RANGE,
                            HeaderValue::from_str(&format!(
                                "bytes {start}-{end_inclusive}/{}",
                                meta.len
                            ))
                            .unwrap(),
                        );
                        return (StatusCode::PARTIAL_CONTENT, headers, chunk).into_response();
                    }
                    Err(_) => return (StatusCode::NOT_FOUND, ()).into_response(),
                }
            } else {
                return (StatusCode::RANGE_NOT_SATISFIABLE, ()).into_response();
            }
        }
    }

    // Full body
    match app.store.get_full(&cid).await {
        Ok(bytes) => {
            let mut headers = HeaderMap::new();
            headers.insert(
                axum::http::header::ETAG,
                HeaderValue::from_str(&meta.etag).unwrap(),
            );
            headers.insert(
                axum::http::header::CONTENT_LENGTH,
                HeaderValue::from_str(&meta.len.to_string()).unwrap(),
            );
            (StatusCode::OK, headers, bytes).into_response()
        }
        Err(_) => (StatusCode::NOT_FOUND, ()).into_response(),
    }
}

```

### crates/svc-storage/src/http/routes/head_object.rs
<a id="crates-svc-storage-src-http-routes-headobject-rs"></a>

```rust
use axum::http::{HeaderMap, HeaderValue, StatusCode};
use axum::{
    extract::{Path, State},
    response::IntoResponse,
};

use crate::http::extractors::AppState;

pub async fn handler(State(app): State<AppState>, Path(cid): Path<String>) -> impl IntoResponse {
    match app.store.head(&cid).await {
        Ok(meta) => {
            let mut headers = HeaderMap::new();
            headers.insert(
                axum::http::header::ETAG,
                HeaderValue::from_str(&meta.etag).unwrap_or(HeaderValue::from_static("")),
            );
            headers.insert(
                axum::http::header::CONTENT_LENGTH,
                HeaderValue::from_str(&meta.len.to_string()).unwrap(),
            );
            (StatusCode::OK, headers).into_response()
        }
        Err(_) => (StatusCode::NOT_FOUND, ()).into_response(),
    }
}

```

### crates/svc-storage/src/http/routes/health.rs
<a id="crates-svc-storage-src-http-routes-health-rs"></a>

```rust
use axum::response::IntoResponse;
use http::StatusCode;

use crate::http::extractors::AppState;
use axum::Extension;

pub async fn handler(_: Extension<AppState>) -> impl IntoResponse {
    StatusCode::OK
}

```

### crates/svc-storage/src/http/routes/metrics.rs
<a id="crates-svc-storage-src-http-routes-metrics-rs"></a>

```rust
use axum::http::{HeaderMap, HeaderValue, StatusCode};
use axum::response::IntoResponse;
use prometheus::{Encoder, TextEncoder};

pub async fn handler() -> impl IntoResponse {
    let encoder = TextEncoder::new();
    let mut buf = Vec::new();
    if let Err(e) = encoder.encode(&prometheus::gather(), &mut buf) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("encode error: {e}"),
        )
            .into_response();
    }
    let mut headers = HeaderMap::new();
    headers.insert(
        axum::http::header::CONTENT_TYPE,
        HeaderValue::from_static("text/plain; version=0.0.4"),
    );
    (StatusCode::OK, headers, buf).into_response()
}

```

### crates/svc-storage/src/http/routes/mod.rs
<a id="crates-svc-storage-src-http-routes-mod-rs"></a>

```rust
//! RO:WHAT — Route module fanout for svc-storage.
pub mod get_object;
pub mod head_object;
pub mod health;
pub mod metrics;
pub mod post_object;
pub mod put_object;
pub mod ready;
pub mod version;

```

### crates/svc-storage/src/http/routes/post_object.rs
<a id="crates-svc-storage-src-http-routes-postobject-rs"></a>

```rust
use crate::http::extractors::AppState;
use axum::{
    extract::State,
    response::{IntoResponse, Response},
};

pub async fn handler(State(app): State<AppState>, body: bytes::Bytes) -> Response {
    super::put_object::handler(State(app), body)
        .await
        .into_response()
}

```

### crates/svc-storage/src/http/routes/put_object.rs
<a id="crates-svc-storage-src-http-routes-putobject-rs"></a>

```rust
use axum::{extract::State, response::IntoResponse, Json};
use blake3;
use serde::Serialize;

use crate::http::extractors::AppState;

#[derive(Serialize)]
struct PutResp {
    cid: String,
}

pub async fn handler(State(app): State<AppState>, body: bytes::Bytes) -> impl IntoResponse {
    // Compute b3 content id from the body (exactly what your script expects)
    let digest = blake3::hash(&body).to_hex().to_string();
    let cid = format!("b3:{digest}");

    // Store full body
    if let Err(e) = app.store.put(&cid, body).await {
        return (
            axum::http::StatusCode::INTERNAL_SERVER_ERROR,
            format!("put failed: {e}"),
        )
            .into_response();
    }

    (axum::http::StatusCode::OK, Json(PutResp { cid })).into_response()
}

```

### crates/svc-storage/src/http/routes/ready.rs
<a id="crates-svc-storage-src-http-routes-ready-rs"></a>

```rust
use axum::response::IntoResponse;
use http::StatusCode;

use crate::http::extractors::AppState;
use axum::Extension;

pub async fn handler(_: Extension<AppState>) -> impl IntoResponse {
    StatusCode::OK
}

```

### crates/svc-storage/src/http/routes/version.rs
<a id="crates-svc-storage-src-http-routes-version-rs"></a>

```rust
//! RO:WHAT — /version handler for svc-storage.
//! RO:WHY  — Operational introspection endpoint.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

use crate::version::version_string;

#[derive(Serialize)]
struct VersionDto {
    version: String,
}

pub async fn handler() -> impl IntoResponse {
    Json(VersionDto {
        version: version_string(),
    })
}

```

### crates/svc-storage/src/http/server.rs
<a id="crates-svc-storage-src-http-server-rs"></a>

```rust
//! HTTP server wiring for svc-storage.
//! RO:WHAT  — Build Axum router and run the server task.
//! RO:WHY   — Handlers extract State<AppState>, so Router’s state is AppState.
//! RO:INVARIANTS — Unknown → 404; Range GET → 206; strong ETag; state is Send+Sync+'static.

use std::net::SocketAddr;

use axum::{
    routing::{get, head, put},
    Router,
};
use tracing::{error, info};

use crate::http::extractors::AppState;
#[cfg(feature = "metrics")]
use crate::http::routes::metrics;
use crate::http::routes::version;
use crate::http::routes::{get_object, head_object, put_object};

/// Build a router whose state type is **AppState** (because handlers use State<AppState>).
pub fn build_router() -> Router<AppState> {
    let api = Router::new()
        .route("/o", put(put_object::handler))
        .route(
            "/o/:cid",
            head(head_object::handler).get(get_object::handler),
        )
        .route("/version", get(version::handler));

    #[cfg(feature = "metrics")]
    let api = api.route("/metrics", get(metrics::handler));

    let app = Router::new().merge(api);

    info!("mount: PUT /o; HEAD/GET /o/:cid; GET /version{}", {
        #[cfg(feature = "metrics")]
        {
            "; GET /metrics"
        }
        #[cfg(not(feature = "metrics"))]
        {
            ""
        }
    });

    app
}

pub async fn serve_http(addr: SocketAddr, state: AppState) -> anyhow::Result<()> {
    let listener = tokio::net::TcpListener::bind(addr).await?;
    info!("svc-storage listening on {addr}");

    // build_router() -> Router<AppState>, so with_state expects an AppState value
    let app = build_router().with_state(state);

    // Router<AppState> → MakeService, which axum::serve expects
    let make_svc = app.into_make_service();

    axum::serve(listener, make_svc)
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    Ok(())
}

async fn shutdown_signal() {
    if let Err(e) = tokio::signal::ctrl_c().await {
        error!("shutdown signal failed: {e}");
    }
}

```

### crates/svc-storage/src/lib.rs
<a id="crates-svc-storage-src-lib-rs"></a>

```rust
//! svc-storage library entry — exposes modules to the bin target.
//! RO:WHAT  — Crate root and module exposes.
//! RO:WHY   — Keep bin thin; organize HTTP and storage layers cleanly.

#![forbid(unsafe_code)]

pub mod errors;
pub mod readiness;
pub mod storage;
pub mod types;
pub mod version;

pub mod http {
    pub mod error;
    pub mod extractors;
    pub mod middleware;
    pub mod routes {
        pub mod get_object;
        pub mod head_object;
        pub mod health;
        pub mod metrics;
        pub mod post_object; // present for completeness; not mounted by default
        pub mod put_object;
        pub mod ready;
        pub mod version;
    }
    pub mod server;
}

```

### crates/svc-storage/src/main.rs
<a id="crates-svc-storage-src-main-rs"></a>

```rust
use std::{net::SocketAddr, sync::Arc};

use svc_storage::http::{extractors::AppState, server::serve_http};
use svc_storage::storage::{MemoryStorage, Storage};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let addr: SocketAddr = std::env::var("ADDR")
        .unwrap_or_else(|_| "127.0.0.1:5303".to_string())
        .parse()?;

    // In-memory store for smoke tests; pluggable later.
    let store: Arc<dyn Storage> = Arc::new(MemoryStorage::default());
    let state = AppState { store };

    // Handle the Result so clippy’s unused_must_use stays green.
    if let Err(e) = serve_http(addr, state).await {
        eprintln!("server error: {e:#}");
        std::process::exit(1);
    }
    Ok(())
}

```

### crates/svc-storage/src/metrics.rs
<a id="crates-svc-storage-src-metrics-rs"></a>

```rust
//! RO:WHAT — Prometheus metrics for svc-storage.

use once_cell::sync::Lazy;
use prometheus::{Histogram, HistogramOpts, IntCounterVec, Opts, Registry};

pub static REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);

pub static REQUEST_LATENCY_SECONDS: Lazy<Histogram> = Lazy::new(|| {
    let o = HistogramOpts::new("storage_request_latency_seconds", "HTTP request latency");
    let h = Histogram::with_opts(o).unwrap();
    REGISTRY.register(Box::new(h.clone())).ok();
    h
});

pub static REJECTED_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    let o = Opts::new("storage_rejected_total", "Rejected requests by reason");
    let c = IntCounterVec::new(o, &["reason"]).unwrap();
    REGISTRY.register(Box::new(c.clone())).ok();
    c
});

pub static INTEGRITY_FAIL_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    let o = Opts::new("storage_integrity_fail_total", "Integrity check failures");
    let c = IntCounterVec::new(o, &["path"]).unwrap();
    REGISTRY.register(Box::new(c.clone())).ok();
    c
});

```

### crates/svc-storage/src/policy/economics.rs
<a id="crates-svc-storage-src-policy-economics-rs"></a>

```rust
// Policy module: economics (read-only settlement signals; scaffold)

```

### crates/svc-storage/src/policy/mod.rs
<a id="crates-svc-storage-src-policy-mod-rs"></a>

```rust
// Policy module (scaffold)

```

### crates/svc-storage/src/policy/quotas.rs
<a id="crates-svc-storage-src-policy-quotas-rs"></a>

```rust
// Policy module: quotas (scaffold)

```

### crates/svc-storage/src/policy/residency.rs
<a id="crates-svc-storage-src-policy-residency-rs"></a>

```rust
// Policy module: residency (scaffold)

```

### crates/svc-storage/src/prelude.rs
<a id="crates-svc-storage-src-prelude-rs"></a>

```rust
//! Intentionally minimal prelude for future shared imports.
//! Keep empty to avoid `unused_imports` under `-D warnings`.

```

### crates/svc-storage/src/readiness.rs
<a id="crates-svc-storage-src-readiness-rs"></a>

```rust
use std::sync::atomic::{AtomicBool, Ordering};

#[derive(Debug, Default)]
pub struct Readiness {
    config_loaded: AtomicBool,
    listeners_bound: AtomicBool,
}

impl Readiness {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn set_config_loaded(&self, v: bool) {
        self.config_loaded.store(v, Ordering::Relaxed);
    }

    pub fn set_listeners_bound(&self, v: bool) {
        self.listeners_bound.store(v, Ordering::Relaxed);
    }

    /// Minimal health: all invariants that should be up even when not "ready".
    pub fn health_ok(&self) -> bool {
        // For now, "healthy" if the process is running; later include store checks.
        true
    }

    /// Ready when config is loaded and listeners are bound.
    pub fn all_ready(&self) -> bool {
        self.config_loaded.load(Ordering::Relaxed) && self.listeners_bound.load(Ordering::Relaxed)
    }
}

```

### crates/svc-storage/src/storage/cache.rs
<a id="crates-svc-storage-src-storage-cache-rs"></a>

```rust
//! RO:WHAT — In-memory CAS (Micronode amnesia).

use super::{HeadMeta, Storage};
use crate::{errors::StorageError, prelude::*};
use std::collections::HashMap;

#[derive(Debug, Default)]
pub struct MemoryStorage {
    inner: Mutex<HashMap<String, Bytes>>,
}

#[async_trait::async_trait]
impl Storage for MemoryStorage {
    async fn put_bytes(&self, bytes: Bytes) -> Result<HeadMeta, StorageError> {
        let mut hasher = blake3::Hasher::new();
        hasher.update(&bytes);
        let cid = format!("b3:{}", hasher.finalize().to_hex());
        let mut g = self.inner.lock();
        g.entry(cid.clone()).or_insert(bytes.clone());
        Ok(HeadMeta {
            cid: cid.clone(),
            size: bytes.len() as u64,
            etag: format!("\"{}\"", cid),
        })
    }

    async fn has(&self, cid: &str) -> Result<bool, StorageError> {
        Ok(self.inner.lock().contains_key(cid))
    }

    async fn head(&self, cid: &str) -> Result<HeadMeta, StorageError> {
        let g = self.inner.lock();
        let b = g.get(cid).ok_or(StorageError::NotFound)?;
        Ok(HeadMeta {
            cid: cid.to_string(),
            size: b.len() as u64,
            etag: format!("\"{}\"", cid),
        })
    }

    async fn get_full(&self, cid: &str) -> Result<Bytes, StorageError> {
        let g = self.inner.lock();
        let b = g.get(cid).ok_or(StorageError::NotFound)?;
        Ok(b.clone())
    }

    async fn get_range(
        &self,
        cid: &str,
        start: u64,
        end_inclusive: u64,
    ) -> Result<(Bytes, u64), StorageError> {
        let g = self.inner.lock();
        let b = g.get(cid).ok_or(StorageError::NotFound)?;
        let len = b.len() as u64;
        if start >= len || end_inclusive >= len || start > end_inclusive {
            return Err(StorageError::RangeNotSatisfiable);
        }
        let s = start as usize;
        let e = end_inclusive as usize + 1;
        Ok((b.slice(s..e), len))
    }
}

```

### crates/svc-storage/src/storage/cas.rs
<a id="crates-svc-storage-src-storage-cas-rs"></a>

```rust
// Storage module: cas (scaffold)

```

### crates/svc-storage/src/storage/compression.rs
<a id="crates-svc-storage-src-storage-compression-rs"></a>

```rust
// Storage module: compression (scaffold)

```

### crates/svc-storage/src/storage/erasure.rs
<a id="crates-svc-storage-src-storage-erasure-rs"></a>

```rust
// Storage module: erasure (scaffold)

```

### crates/svc-storage/src/storage/fs.rs
<a id="crates-svc-storage-src-storage-fs-rs"></a>

```rust
//! Filesystem-backed storage for svc-storage.

use std::path::{Path, PathBuf};

use axum::body::Bytes;
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncSeekExt, AsyncWriteExt};

use crate::{errors::StorageError, types::HeadMeta};

/// Simple filesystem store rooted at `root/`.
pub struct FsStorage {
    root: PathBuf,
}

impl FsStorage {
    pub async fn new(root: PathBuf) -> anyhow::Result<Self> {
        if !root.exists() {
            fs::create_dir_all(&root).await?;
        }
        Ok(Self { root })
    }

    fn is_valid_b3_cid(cid: &str) -> bool {
        // "b3:" + 64 lowercase hex nybbles
        if let Some(rest) = cid.strip_prefix("b3:") {
            rest.len() == 64 && rest.bytes().all(|b| matches!(b, b'0'..=b'9' | b'a'..=b'f'))
        } else {
            false
        }
    }

    fn path_for(&self, cid: &str) -> Result<PathBuf, StorageError> {
        if !Self::is_valid_b3_cid(cid) {
            return Err(StorageError::BadRequest("invalid cid".into()));
        }
        Ok(self.root.join(cid))
    }

    async fn write_all_atomic(path: &Path, data: &[u8]) -> std::io::Result<()> {
        let tmp = path.with_extension("tmp");
        {
            let mut f = fs::File::create(&tmp).await?;
            f.write_all(data).await?;
            f.flush().await?;
        }
        // Replace temp with final
        // On all platforms tokio::fs::rename overwrites if allowed by OS.
        fs::rename(&tmp, path).await?;
        Ok(())
    }
}

#[async_trait::async_trait]
impl crate::storage::Storage for FsStorage {
    async fn put_bytes(&self, bytes: Bytes) -> Result<HeadMeta, StorageError> {
        // Compute BLAKE3 CID
        let hash = blake3::hash(&bytes);
        let cid = format!("b3:{}", hash.to_hex());
        let len = bytes.len() as u64;

        let path = self.path_for(&cid)?;
        if !path.exists() {
            Self::write_all_atomic(&path, &bytes)
                .await
                .map_err(StorageError::Io)?;
        }

        Ok(HeadMeta { cid, len })
    }

    async fn has(&self, cid: &str) -> Result<bool, StorageError> {
        let path = self.path_for(cid)?;
        Ok(path.exists())
    }

    async fn head(&self, cid: &str) -> Result<HeadMeta, StorageError> {
        let path = self.path_for(cid)?;
        let meta = fs::metadata(&path).await.map_err(|e| {
            if e.kind() == std::io::ErrorKind::NotFound {
                StorageError::NotFound
            } else {
                StorageError::Io(e)
            }
        })?;
        Ok(HeadMeta {
            cid: cid.to_string(),
            len: meta.len(),
        })
    }

    async fn get_full(&self, cid: &str) -> Result<Bytes, StorageError> {
        let path = self.path_for(cid)?;
        let mut f = fs::File::open(&path).await.map_err(|e| {
            if e.kind() == std::io::ErrorKind::NotFound {
                StorageError::NotFound
            } else {
                StorageError::Io(e)
            }
        })?;

        let mut buf = Vec::new();
        f.read_to_end(&mut buf).await.map_err(StorageError::Io)?;
        Ok(Bytes::from(buf))
    }

    async fn get_range(
        &self,
        cid: &str,
        start: u64,
        end_inclusive: u64,
    ) -> Result<(Bytes, u64), StorageError> {
        let path = self.path_for(cid)?;
        let meta = fs::metadata(&path).await.map_err(|e| {
            if e.kind() == std::io::ErrorKind::NotFound {
                StorageError::NotFound
            } else {
                StorageError::Io(e)
            }
        })?;
        let total = meta.len();
        if start > end_inclusive || end_inclusive >= total {
            return Err(StorageError::BadRequest("invalid range".into()));
        }

        let mut f = fs::File::open(&path).await.map_err(StorageError::Io)?;
        let span = (end_inclusive - start + 1) as usize;
        let mut buf = vec![0u8; span];

        f.seek(std::io::SeekFrom::Start(start))
            .await
            .map_err(StorageError::Io)?;
        f.read_exact(&mut buf).await.map_err(StorageError::Io)?;

        Ok((Bytes::from(buf), total))
    }
}

```

### crates/svc-storage/src/storage/hedged.rs
<a id="crates-svc-storage-src-storage-hedged-rs"></a>

```rust
// Storage module: hedged (scaffold)

```

### crates/svc-storage/src/storage/io.rs
<a id="crates-svc-storage-src-storage-io-rs"></a>

```rust
//! Range validation helpers (kept minimal – routes/impls already check).

use crate::errors::StorageError;

#[allow(dead_code)]
pub fn validate_range(start: u64, end_inclusive: u64, total: u64) -> Result<(), StorageError> {
    if start > end_inclusive || end_inclusive >= total {
        return Err(StorageError::RangeNotSatisfiable);
    }
    Ok(())
}

```

### crates/svc-storage/src/storage/mod.rs
<a id="crates-svc-storage-src-storage-mod-rs"></a>

```rust
// RO:WHAT  — Storage trait + simple in-memory impl for smoke/local dev.
// RO:WHY   — Keep the trait object-safe (handlers hold Arc<dyn Storage>).
// RO:INVARIANTS — CID is content-addressed; NotFound on missing keys; range bounds clamped by caller.

use std::{collections::HashMap, sync::Arc};

use axum::body::Bytes;
use parking_lot::RwLock;

use crate::errors::StorageError;

#[derive(Debug, Clone)]
pub struct HeadMeta {
    pub len: u64,
    pub etag: String,
}

pub type Result<T, E = StorageError> = std::result::Result<T, E>;

#[async_trait::async_trait]
pub trait Storage: Send + Sync + 'static {
    async fn put(&self, cid: &str, data: Bytes) -> Result<()>;

    #[allow(dead_code)]
    async fn exists(&self, cid: &str) -> Result<bool>;

    async fn head(&self, cid: &str) -> Result<HeadMeta>;

    #[allow(dead_code)]
    async fn get_full(&self, cid: &str) -> Result<Bytes>;

    /// Returns (bytes, total_len). Caller provides inclusive range.
    async fn get_range(&self, cid: &str, start: u64, end_inclusive: u64) -> Result<(Bytes, u64)>;
}

/// A simple in-memory storage for smoke tests and local development.
pub struct MemoryStorage {
    inner: RwLock<HashMap<String, Bytes>>,
}

impl MemoryStorage {
    pub fn new() -> Self {
        Self {
            inner: RwLock::new(HashMap::new()),
        }
    }
}

impl Default for MemoryStorage {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait::async_trait]
impl Storage for MemoryStorage {
    async fn put(&self, cid: &str, data: Bytes) -> Result<()> {
        let mut map = self.inner.write();
        map.insert(cid.to_string(), data);
        Ok(())
    }

    #[allow(dead_code)]
    async fn exists(&self, cid: &str) -> Result<bool> {
        let map = self.inner.read();
        Ok(map.contains_key(cid))
    }

    async fn head(&self, cid: &str) -> Result<HeadMeta> {
        let map = self.inner.read();
        let v = map.get(cid).ok_or(StorageError::NotFound)?;
        let len = v.len() as u64;
        // Strong ETag (content hash).
        let etag = format!("\"{}\"", blake3::hash(v).to_hex());
        Ok(HeadMeta { len, etag })
    }

    async fn get_full(&self, cid: &str) -> Result<Bytes> {
        let map = self.inner.read();
        let v = map.get(cid).ok_or(StorageError::NotFound)?;
        Ok(v.clone())
    }

    async fn get_range(&self, cid: &str, start: u64, end_inclusive: u64) -> Result<(Bytes, u64)> {
        let map = self.inner.read();
        let v = map.get(cid).ok_or(StorageError::NotFound)?;
        let total_len = v.len() as u64;

        // Clamp defensively; inclusive end.
        let s = (start as usize).min(v.len());
        let e = (end_inclusive as usize).min(v.len().saturating_sub(1));
        let s = s.min(e);

        // Zero-copy slice.
        let out = v.slice(s..=e);
        Ok((out, total_len))
    }
}

// Convenience so other modules can hold Arc<dyn Storage>.
pub type DynStorage = Arc<dyn Storage + Send + Sync + 'static>;

```

### crates/svc-storage/src/storage/placement.rs
<a id="crates-svc-storage-src-storage-placement-rs"></a>

```rust
// Storage module: placement (scaffold)

```

### crates/svc-storage/src/storage/pq_envelope.rs
<a id="crates-svc-storage-src-storage-pqenvelope-rs"></a>

```rust
// Storage module: pq_envelope (scaffold)

```

### crates/svc-storage/src/storage/repair.rs
<a id="crates-svc-storage-src-storage-repair-rs"></a>

```rust
// Storage module: repair (scaffold)

```

### crates/svc-storage/src/storage/replication.rs
<a id="crates-svc-storage-src-storage-replication-rs"></a>

```rust
// Storage module: replication (scaffold)

```

### crates/svc-storage/src/tls/mod.rs
<a id="crates-svc-storage-src-tls-mod-rs"></a>

```rust
// TLS module (scaffold)

```

### crates/svc-storage/src/tls/pq.rs
<a id="crates-svc-storage-src-tls-pq-rs"></a>

```rust
// Feature-gated PQ-hybrid suite selection (design stub, scaffold)

```

### crates/svc-storage/src/tls/server_config.rs
<a id="crates-svc-storage-src-tls-serverconfig-rs"></a>

```rust
// Build tokio_rustls::rustls::ServerConfig (TLS 1.3) (scaffold)

```

### crates/svc-storage/src/types.rs
<a id="crates-svc-storage-src-types-rs"></a>

```rust
use serde::Serialize;

/// Response body for a successful PUT.
#[derive(Debug, Clone, Serialize)]
pub struct PutResponse {
    pub cid: String,
}

```

### crates/svc-storage/src/uds/mod.rs
<a id="crates-svc-storage-src-uds-mod-rs"></a>

```rust
// UDS module (scaffold)

```

### crates/svc-storage/src/uds/peercred.rs
<a id="crates-svc-storage-src-uds-peercred-rs"></a>

```rust
// SO_PEERCRED extraction/validation (scaffold)

```

### crates/svc-storage/src/uds/server.rs
<a id="crates-svc-storage-src-uds-server-rs"></a>

```rust
// UDS listener wiring (scaffold)

```

### crates/svc-storage/src/version.rs
<a id="crates-svc-storage-src-version-rs"></a>

```rust
//! RO:WHAT — Crate version/commit surface for svc-storage.
//! RO:WHY  — Used by /version and logs for precise diagnostics.
//! RO:INVARIANTS — Always returns a stable ASCII string; safe to expose publicly.

pub fn version_string() -> String {
    // Prefer build-time env if present; fall back to Cargo package version.
    let pkg = env!("CARGO_PKG_VERSION");
    let name = env!("CARGO_PKG_NAME");
    let git = option_env!("GIT_COMMIT_HASH").unwrap_or("unknown");
    let build = option_env!("BUILD_TS").unwrap_or("unknown");
    format!("{name} {pkg} (git:{git}, built:{build})")
}

```

### crates/svc-storage/testing/integration/error_caps.rs
<a id="crates-svc-storage-testing-integration-errorcaps-rs"></a>

```rust
// Integration: 413/429/503 + decompression guard (scaffold)

```

### crates/svc-storage/testing/integration/http_get_head_put.rs
<a id="crates-svc-storage-testing-integration-httpgetheadput-rs"></a>

```rust
// Integration: GET/HEAD/PUT/POST round-trips (scaffold)

```

### crates/svc-storage/testing/integration/profile_matrix.rs
<a id="crates-svc-storage-testing-integration-profilematrix-rs"></a>

```rust
// Runs test suites against micronode/macronode profiles (scaffold)

```

### crates/svc-storage/testing/integration/range_tests.rs
<a id="crates-svc-storage-testing-integration-rangetests-rs"></a>

```rust
// Integration: Range semantics, 416 taxonomy (scaffold)

```

### crates/svc-storage/testing/performance/compare_baselines.sh
<a id="crates-svc-storage-testing-performance-comparebaselines-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "Compare perf baselines placeholder"

```

### crates/svc-storage/testing/performance/run_load.sh
<a id="crates-svc-storage-testing-performance-runload-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "Run perf load placeholder"

```

### crates/svc-storage/testing/performance/scripts/media_facet.sh
<a id="crates-svc-storage-testing-performance-scripts-mediafacet-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "Media facet load profile placeholder"

```

