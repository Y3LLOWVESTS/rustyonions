<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:44:10Z -->
# Code Bundle — `svc-overlay`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-overlay/.devcontainer/devcontainer.json](#crates-svc-overlay--devcontainer-devcontainer-json)
- [crates/svc-overlay/.github/workflows/ci.yml](#crates-svc-overlay--github-workflows-ci-yml)
- [crates/svc-overlay/.github/workflows/concurrency-guardrails.yml](#crates-svc-overlay--github-workflows-concurrency-guardrails-yml)
- [crates/svc-overlay/.github/workflows/contract-apis.yml](#crates-svc-overlay--github-workflows-contract-apis-yml)
- [crates/svc-overlay/.github/workflows/render-mermaid.yml](#crates-svc-overlay--github-workflows-render-mermaid-yml)
- [crates/svc-overlay/Cargo.toml](#crates-svc-overlay-Cargo-toml)
- [crates/svc-overlay/benches/handshake.rs](#crates-svc-overlay-benches-handshake-rs)
- [crates/svc-overlay/benches/oap_codec.rs](#crates-svc-overlay-benches-oapcodec-rs)
- [crates/svc-overlay/build.rs](#crates-svc-overlay-build-rs)
- [crates/svc-overlay/examples/libapi_embed.rs](#crates-svc-overlay-examples-libapiembed-rs)
- [crates/svc-overlay/examples/oap_client.rs](#crates-svc-overlay-examples-oapclient-rs)
- [crates/svc-overlay/examples/pq_embed.rs](#crates-svc-overlay-examples-pqembed-rs)
- [crates/svc-overlay/fuzz/fuzz_targets/gossip_lane.rs](#crates-svc-overlay-fuzz-fuzztargets-gossiplane-rs)
- [crates/svc-overlay/fuzz/fuzz_targets/oap_frame_parse.rs](#crates-svc-overlay-fuzz-fuzztargets-oapframeparse-rs)
- [crates/svc-overlay/scripts/roundtrip_overlay.sh](#crates-svc-overlay-scripts-roundtripoverlay-sh)
- [crates/svc-overlay/scripts/smoke_overlay.sh](#crates-svc-overlay-scripts-smokeoverlay-sh)
- [crates/svc-overlay/scripts/soak_overlay.sh](#crates-svc-overlay-scripts-soakoverlay-sh)
- [crates/svc-overlay/src/admin/health.rs](#crates-svc-overlay-src-admin-health-rs)
- [crates/svc-overlay/src/admin/metrics.rs](#crates-svc-overlay-src-admin-metrics-rs)
- [crates/svc-overlay/src/admin/mod.rs](#crates-svc-overlay-src-admin-mod-rs)
- [crates/svc-overlay/src/admin/ready.rs](#crates-svc-overlay-src-admin-ready-rs)
- [crates/svc-overlay/src/admin/version.rs](#crates-svc-overlay-src-admin-version-rs)
- [crates/svc-overlay/src/api/mod.rs](#crates-svc-overlay-src-api-mod-rs)
- [crates/svc-overlay/src/auth/macaroon.rs](#crates-svc-overlay-src-auth-macaroon-rs)
- [crates/svc-overlay/src/auth/mod.rs](#crates-svc-overlay-src-auth-mod-rs)
- [crates/svc-overlay/src/bootstrap.rs](#crates-svc-overlay-src-bootstrap-rs)
- [crates/svc-overlay/src/cli.rs](#crates-svc-overlay-src-cli-rs)
- [crates/svc-overlay/src/config.rs](#crates-svc-overlay-src-config-rs)
- [crates/svc-overlay/src/conn/error.rs](#crates-svc-overlay-src-conn-error-rs)
- [crates/svc-overlay/src/conn/mod.rs](#crates-svc-overlay-src-conn-mod-rs)
- [crates/svc-overlay/src/conn/reader.rs](#crates-svc-overlay-src-conn-reader-rs)
- [crates/svc-overlay/src/conn/supervisor.rs](#crates-svc-overlay-src-conn-supervisor-rs)
- [crates/svc-overlay/src/conn/tx.rs](#crates-svc-overlay-src-conn-tx-rs)
- [crates/svc-overlay/src/conn/writer.rs](#crates-svc-overlay-src-conn-writer-rs)
- [crates/svc-overlay/src/errors.rs](#crates-svc-overlay-src-errors-rs)
- [crates/svc-overlay/src/gossip/engine.rs](#crates-svc-overlay-src-gossip-engine-rs)
- [crates/svc-overlay/src/gossip/mod.rs](#crates-svc-overlay-src-gossip-mod-rs)
- [crates/svc-overlay/src/gossip/types.rs](#crates-svc-overlay-src-gossip-types-rs)
- [crates/svc-overlay/src/lib.rs](#crates-svc-overlay-src-lib-rs)
- [crates/svc-overlay/src/limits.rs](#crates-svc-overlay-src-limits-rs)
- [crates/svc-overlay/src/listener/mod.rs](#crates-svc-overlay-src-listener-mod-rs)
- [crates/svc-overlay/src/listener/plain.rs](#crates-svc-overlay-src-listener-plain-rs)
- [crates/svc-overlay/src/listener/ron.rs](#crates-svc-overlay-src-listener-ron-rs)
- [crates/svc-overlay/src/main.rs](#crates-svc-overlay-src-main-rs)
- [crates/svc-overlay/src/observe.rs](#crates-svc-overlay-src-observe-rs)
- [crates/svc-overlay/src/pq/mod.rs](#crates-svc-overlay-src-pq-mod-rs)
- [crates/svc-overlay/src/pq/negotiate.rs](#crates-svc-overlay-src-pq-negotiate-rs)
- [crates/svc-overlay/src/protocol/cbor.rs](#crates-svc-overlay-src-protocol-cbor-rs)
- [crates/svc-overlay/src/protocol/error.rs](#crates-svc-overlay-src-protocol-error-rs)
- [crates/svc-overlay/src/protocol/flags.rs](#crates-svc-overlay-src-protocol-flags-rs)
- [crates/svc-overlay/src/protocol/handshake.rs](#crates-svc-overlay-src-protocol-handshake-rs)
- [crates/svc-overlay/src/protocol/mod.rs](#crates-svc-overlay-src-protocol-mod-rs)
- [crates/svc-overlay/src/protocol/oap.rs](#crates-svc-overlay-src-protocol-oap-rs)
- [crates/svc-overlay/src/readiness/mod.rs](#crates-svc-overlay-src-readiness-mod-rs)
- [crates/svc-overlay/src/readiness/sampler.rs](#crates-svc-overlay-src-readiness-sampler-rs)
- [crates/svc-overlay/src/shutdown.rs](#crates-svc-overlay-src-shutdown-rs)
- [crates/svc-overlay/src/supervisor.rs](#crates-svc-overlay-src-supervisor-rs)
- [crates/svc-overlay/src/transport/mod.rs](#crates-svc-overlay-src-transport-mod-rs)
- [crates/svc-overlay/src/transport/quic.rs](#crates-svc-overlay-src-transport-quic-rs)
- [crates/svc-overlay/src/transport/tls.rs](#crates-svc-overlay-src-transport-tls-rs)
- [crates/svc-overlay/src/transport/tor.rs](#crates-svc-overlay-src-transport-tor-rs)
- [crates/svc-overlay/src/tuning.rs](#crates-svc-overlay-src-tuning-rs)
- [crates/svc-overlay/src/types.rs](#crates-svc-overlay-src-types-rs)
- [crates/svc-overlay/tests/http_contract.rs](#crates-svc-overlay-tests-httpcontract-rs)
- [crates/svc-overlay/tests/integration/oap_session_handshake.rs](#crates-svc-overlay-tests-integration-oapsessionhandshake-rs)
- [crates/svc-overlay/tests/integration/overlay_admin_roundtrip.rs](#crates-svc-overlay-tests-integration-overlayadminroundtrip-rs)
- [crates/svc-overlay/tests/integration/overlay_oap_streaming.rs](#crates-svc-overlay-tests-integration-overlayoapstreaming-rs)
- [crates/svc-overlay/tests/interop_vectors.rs](#crates-svc-overlay-tests-interopvectors-rs)
- [crates/svc-overlay/tests/loom/loom_overlay.rs](#crates-svc-overlay-tests-loom-loomoverlay-rs)
- [crates/svc-overlay/tests/metrics_schema.rs](#crates-svc-overlay-tests-metricsschema-rs)
- [crates/svc-overlay/tests/pq_negotiation.rs](#crates-svc-overlay-tests-pqnegotiation-rs)
- [crates/svc-overlay/tests/readiness_under_pressure.rs](#crates-svc-overlay-tests-readinessunderpressure-rs)

### crates/svc-overlay/.devcontainer/devcontainer.json
<a id="crates-svc-overlay--devcontainer-devcontainer-json"></a>

```json
{
  "name": "svc-overlay",
  "image": "mcr.microsoft.com/devcontainers/rust:1-1.80-bookworm",
  "features": {},
  "customizations": {
    "vscode": {
      "extensions": ["rust-lang.rust-analyzer", "serayuzgur.crates"]
    }
  },
  "postCreateCommand": "cargo fetch"
}

```

### crates/svc-overlay/.github/workflows/ci.yml
<a id="crates-svc-overlay--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy,rustfmt
      - name: Build
        run: cargo build -p svc-overlay
      - name: Clippy (deny warnings)
        run: cargo clippy -p svc-overlay -- -D warnings
      - name: Test
        run: cargo test -p svc-overlay --all-features
      - name: Doc tests
        run: cargo test -p svc-overlay --doc
      - name: Cargo deny
        run: cargo deny check
      - name: Cargo audit
        run: cargo install cargo-audit || true
      - name: Audit vulnerabilities
        run: cargo audit
      - name: Coverage (floor 85%)
        run: echo "(hook up your coverage tool here and fail below 85%)"

```

### crates/svc-overlay/.github/workflows/concurrency-guardrails.yml
<a id="crates-svc-overlay--github-workflows-concurrency-guardrails-yml"></a>

```yaml
name: concurrency-guardrails
on: [push, pull_request]
jobs:
  loom:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Loom interleavings
        run: RUSTFLAGS='--cfg loom' cargo test -p svc-overlay --test loom_overlay

```

### crates/svc-overlay/.github/workflows/contract-apis.yml
<a id="crates-svc-overlay--github-workflows-contract-apis-yml"></a>

```yaml
name: contract-apis
on: [push, pull_request]
jobs:
  public-api-and-schemas:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Cargo public-api
        run: |
          cargo install cargo-public-api || true
          cargo public-api -p svc-overlay > public-api.txt || true
      - name: Diff api-history snapshots
        run: echo "(compare against docs/api-history/svc-overlay/*)" 

```

### crates/svc-overlay/.github/workflows/render-mermaid.yml
<a id="crates-svc-overlay--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          mkdir -p docs
          for f in $(git ls-files '*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out"
          done

```

### crates/svc-overlay/Cargo.toml
<a id="crates-svc-overlay-Cargo-toml"></a>

```toml
[package]
name = "svc-overlay"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false
description = "RustyOnions overlay service: sessions & gossip (no DHT)"
readme = "README.md"

[features]
libapi = []
tls = ["dep:tokio-rustls"]   # enable TLS wiring when we hook it up
pq  = []                     # placeholder for future PQ handshake toggle
quic = []                    # placeholder for future QUIC
# Flip this to use the ron-transport adapter path (default build = plain TCP)
use_ron_transport = ["dep:ron-transport"]

[dependencies]
anyhow = "1.0.86"
thiserror = "1.0.63"
tokio = { version = "1.47.1", features = ["rt-multi-thread","macros","signal","time","sync","io-util"] }
tracing = "0.1.40"
tracing-subscriber = { version = "0.3.18", features = ["env-filter","fmt","json"] }
axum = { version = "0.7.9", features = ["http1","http2","json"] }   # no "tokio" feature here
hyper = "1.4.1"
prometheus = "0.14.0"
serde = { version = "1.0.214", features = ["derive"] }
serde_json = "1.0.132"
bytes = "1.7.1"
base64 = "0.22.1"
hex = "0.4.3"
sha2 = "0.10.8"
parking_lot = "0.12.3"
tokio-rustls = { version = "0.26.2", optional = true }
futures = "0.3.31"
bitflags = "2.6.0"

# Observability used by src/observe.rs
metrics = "0.24.1"
metrics-exporter-prometheus = "0.15.3"
once_cell = "1.19.0"

# Local workspace crates
ron-metrics   = { path = "../ron-metrics" }
ron-proto     = { path = "../ron-proto" }
ron-kernel    = { path = "../ron-kernel" }

# Optional transport (enabled by feature `use_ron_transport`)
ron-transport = { path = "../ron-transport", optional = true }

[dev-dependencies]
tokio = { version = "1.47.1", features = ["rt","macros","time"] }

```

### crates/svc-overlay/benches/handshake.rs
<a id="crates-svc-overlay-benches-handshake-rs"></a>

```rust
/*! handshake.rs — microbench placeholders
- Control-plane handshake latency; PQ-hybrid delta vs classic.
*/

```

### crates/svc-overlay/benches/oap_codec.rs
<a id="crates-svc-overlay-benches-oapcodec-rs"></a>

```rust
/*! oap_codec.rs — microbench placeholders
- Benchmarks for frame encode/decode at 1 KiB / 64 KiB / 1 MiB.
*/

```

### crates/svc-overlay/build.rs
<a id="crates-svc-overlay-build-rs"></a>

```rust
// RO:WHAT
//   Inject GIT_SHA and BUILD_TS envs for /version.
// RO:WHY
//   Make /version useful in dev and CI without runtime shelling.

use std::process::Command;

fn main() {
    // Best-effort short SHA
    if let Ok(out) = Command::new("git")
        .args(["rev-parse", "--short=12", "HEAD"])
        .output()
    {
        if out.status.success() {
            if let Ok(sha) = String::from_utf8(out.stdout) {
                println!("cargo:rustc-env=GIT_SHA={}", sha.trim());
            }
        }
    }
    // UTC-ish timestamp using std
    use std::time::{SystemTime, UNIX_EPOCH};
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    println!("cargo:rustc-env=BUILD_TS=unix:{now}");

    // Re-run on HEAD changes
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs");
}

```

### crates/svc-overlay/examples/libapi_embed.rs
<a id="crates-svc-overlay-examples-libapiembed-rs"></a>

```rust
//! Minimal client: dial localhost, do OAP/1 hello, send one DATA frame, read echo.
//! Run with: cargo run -p svc-overlay --example libapi_embed

use anyhow::Result;
use bytes::{Bytes, BytesMut};
use std::time::Duration;
use tokio::io::AsyncReadExt;
use tokio::net::TcpStream;

use svc_overlay::conn::writer::write_frame;
use svc_overlay::protocol::flags::Caps;
use svc_overlay::protocol::handshake::handshake;
use svc_overlay::protocol::oap::{try_parse_frame, Frame, FrameKind};

#[tokio::main]
async fn main() -> Result<()> {
    // Quick logger
    if std::env::var_os("RUST_LOG").is_none() {
        std::env::set_var("RUST_LOG", "info");
    }
    tracing_subscriber::fmt::init();

    // 1) Connect to the overlay's temporary listener.
    let addr = "127.0.0.1:9700";
    tracing::info!("dialing {addr}");
    let mut sock = TcpStream::connect(addr).await?;
    tracing::info!("connected; performing OAP/1 handshake");

    // 2) Symmetric OAP/1 hello.
    let caps = Caps::GOSSIP_V1;
    let neg = handshake(&mut sock, caps, Duration::from_secs(3)).await?;
    tracing::info!("negotiated: ver={}, caps={:?}", neg.version, neg.caps);

    // 3) Send a single DATA frame.
    let payload = Bytes::from_static(b"hello, overlay!");
    let frame = Frame {
        kind: FrameKind::Data,
        payload: payload.clone(),
    };
    let mut scratch = BytesMut::with_capacity(1024);
    write_frame(&mut sock, &frame, &mut scratch).await?;
    tracing::info!("sent one DATA frame; waiting for echo");

    // 4) Read back echo and print.
    let mut inbuf = BytesMut::with_capacity(4096);
    loop {
        // Try parse any buffered frames first.
        if let Some(f) = try_parse_frame(&mut inbuf)? {
            if let FrameKind::Data = f.kind {
                let text = String::from_utf8_lossy(&f.payload);
                println!("echo from overlay: {}", text);
                break;
            }
        }
        // Need more bytes.
        let n = sock.read_buf(&mut inbuf).await?;
        if n == 0 {
            anyhow::bail!("server closed before echo");
        }
    }

    Ok(())
}

```

### crates/svc-overlay/examples/oap_client.rs
<a id="crates-svc-overlay-examples-oapclient-rs"></a>

```rust
use anyhow::{anyhow, Result};
use bytes::BytesMut;
use std::net::SocketAddr;
use std::time::Duration;
use tokio::io::AsyncReadExt;
use tokio::net::TcpStream;

use svc_overlay::conn::writer::write_frame;
use svc_overlay::protocol::flags::Caps;
use svc_overlay::protocol::handshake::handshake;
use svc_overlay::protocol::oap::{try_parse_frame, Frame, FrameKind};

#[tokio::main]
async fn main() -> Result<()> {
    let addr: SocketAddr = std::env::var("OVERLAY_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:9700".into())
        .parse()?;

    eprintln!("[client] connecting to {}", addr);
    let mut sock = TcpStream::connect(addr).await?;

    // Handshake to match server
    let caps = Caps::GOSSIP_V1;
    let neg = handshake(&mut sock, caps, Duration::from_secs(3)).await?;
    eprintln!(
        "[client] negotiated version={} caps={:?}",
        neg.version, neg.caps
    );

    // Send one Data frame and verify echo
    let mut outbuf = BytesMut::with_capacity(1024);
    let mut inbuf = BytesMut::with_capacity(1024);

    let payload = b"hello-overlay";
    let frame = Frame {
        kind: FrameKind::Data,
        payload: payload.as_slice().into(),
    };
    write_frame(&mut sock, &frame, &mut outbuf).await?;

    loop {
        while let Some(f) = try_parse_frame(&mut inbuf)? {
            if let FrameKind::Data = f.kind {
                if f.payload.as_ref() == payload {
                    eprintln!("[client] got echo OK");
                    return Ok(());
                } else {
                    return Err(anyhow!("unexpected payload {:?}", f.payload));
                }
            }
        }
        let n = sock.read_buf(&mut inbuf).await?;
        if n == 0 {
            return Err(anyhow!("server closed before echo"));
        }
    }
}

```

### crates/svc-overlay/examples/pq_embed.rs
<a id="crates-svc-overlay-examples-pqembed-rs"></a>

```rust
/*! pq_embed.rs — example placeholder
Demonstrates enabling transport-level PQ hybrid posture via feature flags.
*/

```

### crates/svc-overlay/fuzz/fuzz_targets/gossip_lane.rs
<a id="crates-svc-overlay-fuzz-fuzztargets-gossiplane-rs"></a>

```rust
// fuzz target placeholder: gossip lane scheduler/backpressure\n
```

### crates/svc-overlay/fuzz/fuzz_targets/oap_frame_parse.rs
<a id="crates-svc-overlay-fuzz-fuzztargets-oapframeparse-rs"></a>

```rust
// fuzz target placeholder: OAP envelope parsing edge cases\n
```

### crates/svc-overlay/scripts/roundtrip_overlay.sh
<a id="crates-svc-overlay-scripts-roundtripoverlay-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT
#   Launch svc-overlay, run the OAP client N times, scrape metrics, teardown.
# RO:USAGE
#   chmod +x crates/svc-overlay/scripts/roundtrip_overlay.sh
#   crates/svc-overlay/scripts/roundtrip_overlay.sh 3

set -euo pipefail

RUNS="${1:-3}"
ADMIN_ADDR="${ADMIN_ADDR:-127.0.0.1:9600}"
OVERLAY_ADDR="${OVERLAY_ADDR:-127.0.0.1:9700}"
RUST_LOG="${RUST_LOG:-svc_overlay=info}"

log(){ printf '[roundtrip] %s\n' "$*" >&2; }

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

log "fmt + clippy"
cargo fmt -p svc-overlay
cargo clippy -p svc-overlay --no-deps -- -D warnings

log "building server + oap_client example (only)"
cargo build -p svc-overlay --example oap_client

RUN_LOG="target/svc-overlay.roundtrip.log"
: > "$RUN_LOG"
log "launching svc-overlay (logs → $RUN_LOG)"
RUST_LOG="$RUST_LOG" cargo run -p svc-overlay >"$RUN_LOG" 2>&1 &
SVC_PID=$!

cleanup(){
  set +e
  if kill -0 "$SVC_PID" >/dev/null 2>&1; then
    log "stopping svc-overlay (pid $SVC_PID)"
    kill "$SVC_PID" || true
    sleep 0.3
    kill -9 "$SVC_PID" 2>/dev/null || true
  fi
}
trap cleanup EXIT INT TERM

log "waiting for admin @ http://$ADMIN_ADDR/healthz"
for i in {1..60}; do
  curl -sf "http://$ADMIN_ADDR/healthz" >/dev/null && break
  sleep 0.2
  [[ $i -eq 60 ]] && { log "timeout waiting for admin"; tail -n 120 "$RUN_LOG" || true; exit 1; }
done

# Also wait for TCP port to accept (macOS-friendly: use nc -z)
HOST="${OVERLAY_ADDR%:*}"
PORT="${OVERLAY_ADDR##*:}"
log "waiting for overlay TCP ${HOST}:${PORT}"
for i in {1..60}; do
  if nc -z "$HOST" "$PORT" >/dev/null 2>&1; then
    break
  fi
  sleep 0.2
  [[ $i -eq 60 ]] && { log "timeout waiting for overlay TCP"; tail -n 120 "$RUN_LOG" || true; exit 1; }
done

show_metrics(){
  curl -sSf "http://$ADMIN_ADDR/metrics" \
    | grep -E 'overlay_build_info|overlay_sessions_active|overlay_(accept_latency_seconds|frames_in_total|frames_out_total|bytes_in_total|bytes_out_total)' \
    || true
}

log "baseline metrics"
show_metrics

for n in $(seq 1 "$RUNS"); do
  log "client run $n/$RUNS"
  OVERLAY_ADDR="$OVERLAY_ADDR" cargo run -q -p svc-overlay --example oap_client || {
    log "client failed on run $n"
    tail -n 120 "$RUN_LOG" || true
    exit 1
  }
done

log "post-runs metrics"
show_metrics

log "recent server logs:"
tail -n 120 "$RUN_LOG" || true

log "done"

```

### crates/svc-overlay/scripts/smoke_overlay.sh
<a id="crates-svc-overlay-scripts-smokeoverlay-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT
#   One-button smoke test for svc-overlay:
#     - fmt + clippy
#     - launch svc-overlay (background)
#     - wait for admin /healthz
#     - open a few test sockets (nc)
#     - scrape metrics (gauge + histogram)
#     - clean shutdown
#
# RO:USAGE
#   chmod +x crates/svc-overlay/scripts/smoke_overlay.sh
#   crates/svc-overlay/scripts/smoke_overlay.sh
#
# RO:CONFIG
#   ADMIN_ADDR:  admin HTTP bind (default 127.0.0.1:9600)
#   OVERLAY_ADDR: overlay TCP bind (default 127.0.0.1:9700)
#   RUST_LOG: set logging for the run (default svc_overlay=info)

set -euo pipefail

ADMIN_ADDR="${ADMIN_ADDR:-127.0.0.1:9600}"
OVERLAY_ADDR="${OVERLAY_ADDR:-127.0.0.1:9700}"
RUST_LOG="${RUST_LOG:-svc_overlay=info}"

log() { printf '[smoke] %s\n' "$*" >&2; }

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

log "fmt + clippy"
cargo fmt -p svc-overlay
cargo clippy -p svc-overlay --no-deps -- -D warnings

RUN_LOG="target/svc-overlay.smoke.log"
: > "$RUN_LOG"

log "launching svc-overlay (logs → $RUN_LOG)"
RUST_LOG="$RUST_LOG" cargo run -p svc-overlay >"$RUN_LOG" 2>&1 &
SVC_PID=$!

cleanup() {
  set +e
  if kill -0 "$SVC_PID" >/dev/null 2>&1; then
    log "stopping svc-overlay (pid $SVC_PID)"
    kill "$SVC_PID" || true
    sleep 0.5
    kill -9 "$SVC_PID" 2>/dev/null || true
  fi
}
trap cleanup EXIT INT TERM

# Wait for /healthz
log "waiting for admin to be up at http://$ADMIN_ADDR/healthz"
for i in {1..60}; do
  if curl -sf "http://$ADMIN_ADDR/healthz" >/dev/null; then
    log "admin is up"
    break
  fi
  sleep 0.25
  if ! kill -0 "$SVC_PID" >/dev/null 2>&1; then
    log "svc-overlay terminated unexpectedly"
    tail -n 200 "$RUN_LOG" >&2 || true
    exit 1
  fi
  if [[ $i -eq 60 ]]; then
    log "timeout waiting for admin"
    tail -n 200 "$RUN_LOG" >&2 || true
    exit 1
  fi
done

# Helper to show key metrics
show_metrics() {
  curl -sSf "http://$ADMIN_ADDR/metrics" \
  | grep -E 'overlay_build_info|overlay_sessions_active|overlay_accept_latency_seconds_(count|sum)' \
  || true
}

log "initial metrics snapshot"
show_metrics

# Function to open a short-lived socket (which will handshake-timeout in ~3s)
short_socket() {
  # Use a subshell so we can background it cleanly
  (
    # macOS/BSD nc: -w <secs> is a write timeout; best effort: just sleep then exit
    # We want the server to see an accept and then a timeout/close
    exec nc "$(cut -d: -f1 <<<"$OVERLAY_ADDR")" "$(cut -d: -f2 <<<"$OVERLAY_ADDR")"
  ) &
  NC_PID=$!
  sleep 3.2
  kill -INT "$NC_PID" 2>/dev/null || true
  wait "$NC_PID" 2>/dev/null || true
}

# Function to open a long socket so we can watch the gauge at 1
long_socket_open() {
  (
    exec nc "$(cut -d: -f1 <<<"$OVERLAY_ADDR")" "$(cut -d: -f2 <<<"$OVERLAY_ADDR")"
  ) &
  echo $!
}

log "opening one long-lived socket to demonstrate overlay_sessions_active=1"
LONG_PID="$(long_socket_open)"
sleep 0.2
show_metrics

log "closing long-lived socket"
kill -INT "$LONG_PID" 2>/dev/null || true
wait "$LONG_PID" 2>/dev/null || true
sleep 0.2
show_metrics

log "opening two short-lived sockets to tick the latency histogram"
short_socket
show_metrics
short_socket
show_metrics

log "final metrics snapshot"
show_metrics

log "tail of runtime logs:"
tail -n 40 "$RUN_LOG" || true

log "done"

```

### crates/svc-overlay/scripts/soak_overlay.sh
<a id="crates-svc-overlay-scripts-soakoverlay-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# RO:WHAT  — Lightweight soak/chaos for svc-overlay echo path.
# RO:USAGE — ./crates/svc-overlay/scripts/soak_overlay.sh [seconds] [concurrency]
#            Defaults: 30s, 16 clients
# RO:NOTE  — Uses the existing oap_client example via the roundtrip driver.

DURATION="${1:-30}"
CONCURRENCY="${2:-16}"

echo "[soak] duration=${DURATION}s concurrency=${CONCURRENCY}"
echo "[soak] RON_OVERLAY_TX_WATERMARK=${RON_OVERLAY_TX_WATERMARK:-<default>} RON_OVERLAY_HANDSHAKE_MS=${RON_OVERLAY_HANDSHAKE_MS:-<default>}"

# Ensure server is up
if ! curl -fsS http://127.0.0.1:9600/healthz >/dev/null ; then
  echo "[soak] server not up on 127.0.0.1:9600 — start it first (e.g., cargo run -p svc-overlay)"
  exit 1
fi

# Warm baseline metrics
echo "[soak] baseline overlay_* sample:"
curl -fsS http://127.0.0.1:9600/metrics | rg '^overlay_' | head -n 20 || true

echo "[soak] kicking off clients…"
end=$(( SECONDS + DURATION ))
i=0
fails=0

run_client() {
  # Same client path the roundtrip script uses
  target/debug/examples/oap_client 127.0.0.1:9700 >/dev/null 2>&1 || return 1
  return 0
}

# Fire-and-forget workers
while [ $SECONDS -lt $end ]; do
  for _ in $(seq 1 "$CONCURRENCY"); do
    run_client & pid=$!
    pids+=("$pid")
  done
  # Reap in batches
  for p in "${pids[@]:-}"; do
    if ! wait "$p"; then
      fails=$((fails+1))
    fi
  done
  unset pids
  i=$((i+CONCURRENCY))
done

echo "[soak] completed launches: ${i}, failures: ${fails}"

echo "[soak] post-run overlay_* sample:"
curl -fsS http://127.0.0.1:9600/metrics | rg '^overlay_' | head -n 50 || true

echo "[soak] readiness snapshot:"
curl -fsS http://127.0.0.1:9600/readyz | jq .

```

### crates/svc-overlay/src/admin/health.rs
<a id="crates-svc-overlay-src-admin-health-rs"></a>

```rust
//! /healthz — liveness only (process loop tick).

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct Health {
    alive: bool,
}

pub async fn healthz() -> impl IntoResponse {
    Json(Health { alive: true })
}

```

### crates/svc-overlay/src/admin/metrics.rs
<a id="crates-svc-overlay-src-admin-metrics-rs"></a>

```rust
//! RO:WHAT
//!   Prometheus exporter for /metrics backed by the default registry.
//!
//! RO:WHY
//!   Self-initialize overlay metrics and build_info so the endpoint is never empty.
//!
//! RO:INTERACTS
//!   - Other modules bump overlay metrics via `overlay_metrics::*`.
//!
//! RO:INVARIANTS
//!   - Single global registry; encode errors return 500; no panics.

use axum::{
    http::{header, StatusCode},
    response::IntoResponse,
};
use once_cell::sync::Lazy;
use prometheus::{
    Encoder, Histogram, HistogramOpts, IntCounterVec, IntGauge, IntGaugeVec, Opts, Registry,
    TextEncoder,
};
use tracing::warn;

static GLOBAL_REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);

fn ensure_registered() {
    let _ = &*OVERLAY_SESSIONS_ACTIVE;
    let _ = &*OVERLAY_ACCEPT_LATENCY_SECONDS;
    let _ = &*BUILD_INFO;
    let _ = &*OVERLAY_HANDSHAKE_FAIL_TOTAL;
    let _ = &*OVERLAY_PEER_TX_DROPPED_TOTAL;
    let _ = &*OVERLAY_PEER_TX_DEPTH;
    let _ = &*OVERLAY_CONN_LIFETIME_SECONDS;
}

static OVERLAY_SESSIONS_ACTIVE: Lazy<IntGauge> = Lazy::new(|| {
    let g = IntGauge::with_opts(Opts::new(
        "overlay_sessions_active",
        "Current number of active overlay sessions",
    ))
    .expect("gauge");
    GLOBAL_REGISTRY
        .register(Box::new(g.clone()))
        .expect("register overlay_sessions_active");
    g
});

static OVERLAY_ACCEPT_LATENCY_SECONDS: Lazy<Histogram> = Lazy::new(|| {
    let h = Histogram::with_opts(
        HistogramOpts::new(
            "overlay_accept_latency_seconds",
            "Time from accept to handshake start",
        )
        .buckets(vec![
            0.00005, 0.0001, 0.0002, 0.0005, 0.001, 0.002, 0.005, 0.01,
        ]),
    )
    .expect("histogram");
    GLOBAL_REGISTRY
        .register(Box::new(h.clone()))
        .expect("register overlay_accept_latency_seconds");
    h
});

static OVERLAY_CONN_LIFETIME_SECONDS: Lazy<Histogram> = Lazy::new(|| {
    let h = Histogram::with_opts(HistogramOpts::new(
        "overlay_conn_lifetime_seconds",
        "Lifetime of a connection (from handshake ok to close)",
    ))
    .expect("histogram");
    GLOBAL_REGISTRY
        .register(Box::new(h.clone()))
        .expect("register overlay_conn_lifetime_seconds");
    h
});

static OVERLAY_HANDSHAKE_FAIL_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    let c = IntCounterVec::new(
        Opts::new(
            "overlay_handshake_fail_total",
            "Handshake failures by reason",
        ),
        &["reason"],
    )
    .expect("counter");
    GLOBAL_REGISTRY
        .register(Box::new(c.clone()))
        .expect("register overlay_handshake_fail_total");
    c
});

static OVERLAY_PEER_TX_DROPPED_TOTAL: Lazy<IntGauge> = Lazy::new(|| {
    let g = IntGauge::with_opts(Opts::new(
        "overlay_peer_dropped_total",
        "Total frames dropped due to full per-peer TX queue (process lifetime)",
    ))
    .expect("gauge");
    GLOBAL_REGISTRY
        .register(Box::new(g.clone()))
        .expect("register overlay_peer_dropped_total");
    g
});

static OVERLAY_PEER_TX_DEPTH: Lazy<IntGauge> = Lazy::new(|| {
    let g = IntGauge::with_opts(Opts::new(
        "overlay_peer_queue_depth",
        "Current per-peer TX queue depth (most recent writer task)",
    ))
    .expect("gauge");
    GLOBAL_REGISTRY
        .register(Box::new(g.clone()))
        .expect("register overlay_peer_queue_depth");
    g
});

static BUILD_INFO: Lazy<IntGaugeVec> = Lazy::new(|| {
    let v = IntGaugeVec::new(
        Opts::new(
            "overlay_build_info",
            "Build info for svc-overlay (value is always 1)",
        ),
        &["version", "git"],
    )
    .expect("gauge vec");
    GLOBAL_REGISTRY
        .register(Box::new(v.clone()))
        .expect("register overlay_build_info");
    v
});

pub mod overlay_metrics {
    use super::*;
    pub fn ensure() {
        super::ensure_registered();
    }
    pub fn inc_sessions_active() {
        OVERLAY_SESSIONS_ACTIVE.inc();
    }
    pub fn dec_sessions_active() {
        OVERLAY_SESSIONS_ACTIVE.dec();
    }
    pub fn accept_latency_seconds(v: f64) {
        OVERLAY_ACCEPT_LATENCY_SECONDS.observe(v);
    }
    pub fn conn_lifetime_seconds(v: f64) {
        OVERLAY_CONN_LIFETIME_SECONDS.observe(v);
    }
    pub fn handshake_fail(reason: &'static str) {
        OVERLAY_HANDSHAKE_FAIL_TOTAL
            .with_label_values(&[reason])
            .inc();
    }
    pub fn set_build_info(version: &'static str, git: &'static str) {
        BUILD_INFO.with_label_values(&[version, git]).set(1);
    }
    pub fn set_peer_tx_depth(depth: usize) {
        OVERLAY_PEER_TX_DEPTH.set(depth as i64);
    }
    pub fn inc_peer_tx_dropped() {
        OVERLAY_PEER_TX_DROPPED_TOTAL.inc();
    }

    // NEW: lightweight getters for the sampler.
    pub fn get_peer_tx_depth() -> i64 {
        OVERLAY_PEER_TX_DEPTH.get()
    }
    pub fn get_sessions_active() -> i64 {
        OVERLAY_SESSIONS_ACTIVE.get()
    }
}

/// GET /metrics — Prometheus exposition format
pub async fn handle_metrics() -> impl IntoResponse {
    ensure_registered();

    let mut buf = Vec::with_capacity(64 * 1024);
    let encoder = TextEncoder::new();
    let metrics = prometheus::gather();
    if let Err(e) = encoder.encode(&metrics, &mut buf) {
        warn!(error=?e, "failed to encode prometheus metrics");
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            [("content-type", "text/plain")],
            "encode failed",
        )
            .into_response();
    }

    (
        StatusCode::OK,
        [(header::CONTENT_TYPE.as_str(), encoder.format_type())],
        buf,
    )
        .into_response()
}

```

### crates/svc-overlay/src/admin/mod.rs
<a id="crates-svc-overlay-src-admin-mod-rs"></a>

```rust
//! RO:WHAT
//!   Admin plane: router(), ReadyProbe gates, /healthz, /readyz, /version, /metrics.
//! RO:WHY
//!   Matches bootstrap’s expected API (router(probe, ver), ReadyProbe::set(..)).
//! RO:INVARIANTS
//!   - Truthful readiness: 200 only when all gates are satisfied.
//!   - Cheap atomics; /readyz lists missing gates when not ready.

use axum::{extract::State, response::IntoResponse, routing::get, Json, Router};
use serde::Serialize;
use std::net::SocketAddr;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

pub mod metrics;
pub use metrics::handle_metrics;

pub mod version;
pub use version::{current_build_info, BuildInfo};

/// Readiness gates container (Arc so we can clone into tasks).
#[derive(Clone)]
pub struct ReadyProbe(Arc<ReadyInner>);

struct ReadyInner {
    listeners_bound: AtomicBool,
    metrics_bound: AtomicBool,
    cfg_loaded: AtomicBool,
    queues_ok: AtomicBool,
    shed_rate_ok: AtomicBool,
    fd_headroom: AtomicBool,
}

/// Mutable view used by `ReadyProbe::set` to emulate your original closure API.
#[derive(Default)]
pub struct ReadyState {
    pub listeners_bound: bool,
    pub metrics_bound: bool,
    pub cfg_loaded: bool,
    pub queues_ok: bool,
    pub shed_rate_ok: bool,
    pub fd_headroom: bool,
}

impl Default for ReadyProbe {
    fn default() -> Self {
        Self::new()
    }
}

impl ReadyProbe {
    pub fn new() -> Self {
        Self(Arc::new(ReadyInner {
            listeners_bound: AtomicBool::new(false),
            metrics_bound: AtomicBool::new(false),
            cfg_loaded: AtomicBool::new(false),
            queues_ok: AtomicBool::new(true),
            shed_rate_ok: AtomicBool::new(true),
            fd_headroom: AtomicBool::new(true),
        }))
    }

    #[inline]
    pub fn set_listeners_bound(&self, v: bool) {
        self.0.listeners_bound.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_metrics_bound(&self, v: bool) {
        self.0.metrics_bound.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_cfg_loaded(&self, v: bool) {
        self.0.cfg_loaded.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_queues_ok(&self, v: bool) {
        self.0.queues_ok.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_shed_rate_ok(&self, v: bool) {
        self.0.shed_rate_ok.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_fd_headroom(&self, v: bool) {
        self.0.fd_headroom.store(v, Ordering::Relaxed);
    }

    /// API compatibility shim for prior `probe.set(|s| s.<gate> = ..).await` usage.
    /// This is `async` to match call sites; it performs stores immediately.
    pub async fn set<F>(&self, f: F)
    where
        F: FnOnce(&mut ReadyState),
    {
        // snapshot
        let mut st = ReadyState {
            listeners_bound: self.0.listeners_bound.load(Ordering::Relaxed),
            metrics_bound: self.0.metrics_bound.load(Ordering::Relaxed),
            cfg_loaded: self.0.cfg_loaded.load(Ordering::Relaxed),
            queues_ok: self.0.queues_ok.load(Ordering::Relaxed),
            shed_rate_ok: self.0.shed_rate_ok.load(Ordering::Relaxed),
            fd_headroom: self.0.fd_headroom.load(Ordering::Relaxed),
        };
        // mutate
        f(&mut st);
        // store
        self.0
            .listeners_bound
            .store(st.listeners_bound, Ordering::Relaxed);
        self.0
            .metrics_bound
            .store(st.metrics_bound, Ordering::Relaxed);
        self.0.cfg_loaded.store(st.cfg_loaded, Ordering::Relaxed);
        self.0.queues_ok.store(st.queues_ok, Ordering::Relaxed);
        self.0
            .shed_rate_ok
            .store(st.shed_rate_ok, Ordering::Relaxed);
        self.0.fd_headroom.store(st.fd_headroom, Ordering::Relaxed);
    }

    fn snapshot(&self) -> Gates {
        Gates {
            listeners_bound: self.0.listeners_bound.load(Ordering::Relaxed),
            metrics_bound: self.0.metrics_bound.load(Ordering::Relaxed),
            cfg_loaded: self.0.cfg_loaded.load(Ordering::Relaxed),
            queues_ok: self.0.queues_ok.load(Ordering::Relaxed),
            shed_rate_ok: self.0.shed_rate_ok.load(Ordering::Relaxed),
            fd_headroom: self.0.fd_headroom.load(Ordering::Relaxed),
        }
    }
}

#[derive(Clone)]
pub struct AdminState {
    pub probe: ReadyProbe,
    pub build: BuildInfo,
}

#[derive(Serialize)]
struct Health {
    alive: bool,
}

async fn handle_healthz() -> Json<Health> {
    Json(Health { alive: true })
}

#[derive(Serialize)]
struct ReadyBody<'a> {
    ready: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    missing: Option<&'a [&'a str]>,
}

#[derive(Default)]
struct Gates {
    listeners_bound: bool,
    metrics_bound: bool,
    cfg_loaded: bool,
    queues_ok: bool,
    shed_rate_ok: bool,
    fd_headroom: bool,
}

impl Gates {
    fn all_ready(&self) -> bool {
        self.listeners_bound
            && self.metrics_bound
            && self.cfg_loaded
            && self.queues_ok
            && self.shed_rate_ok
            && self.fd_headroom
    }
    fn missing(&self) -> Vec<&'static str> {
        let mut v = Vec::with_capacity(6);
        if !self.listeners_bound {
            v.push("listeners_bound");
        }
        if !self.metrics_bound {
            v.push("metrics_bound");
        }
        if !self.cfg_loaded {
            v.push("cfg_loaded");
        }
        if !self.queues_ok {
            v.push("queues_ok");
        }
        if !self.shed_rate_ok {
            v.push("shed_rate_ok");
        }
        if !self.fd_headroom {
            v.push("fd_headroom");
        }
        v
    }
}

async fn handle_readyz(State(state): State<AdminState>) -> impl IntoResponse {
    use axum::http::StatusCode;
    let snap = state.probe.snapshot();
    if snap.all_ready() {
        (
            StatusCode::OK,
            Json(ReadyBody {
                ready: true,
                missing: None,
            }),
        )
            .into_response()
    } else {
        let miss = snap.missing();
        (
            StatusCode::SERVICE_UNAVAILABLE,
            Json(ReadyBody {
                ready: false,
                missing: Some(&miss),
            }),
        )
            .into_response()
    }
}

/// Build the admin router with state and handlers (what bootstrap expects).
pub fn router(probe: ReadyProbe, build: BuildInfo) -> Router {
    let state = AdminState { probe, build };
    Router::new()
        .route("/healthz", get(handle_healthz))
        .route("/readyz", get(handle_readyz))
        .route("/version", get(version::handle_version))
        .route("/metrics", get(metrics::handle_metrics))
        .with_state(state)
}

/// Helper to run the admin plane on an address.
pub async fn serve_admin(
    bind: SocketAddr,
    probe: ReadyProbe,
    build: BuildInfo,
) -> anyhow::Result<()> {
    let app = router(probe, build);
    let listener = tokio::net::TcpListener::bind(bind).await?;
    tracing::info!(addr=?bind, "admin server listening");
    axum::serve(listener, app).await?;
    Ok(())
}

```

### crates/svc-overlay/src/admin/ready.rs
<a id="crates-svc-overlay-src-admin-ready-rs"></a>

```rust
//! /readyz — truthful readiness gate. JSON schema kept stable.

use axum::{extract::State, response::IntoResponse, Json};
use serde::Serialize;
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Clone, Default)]
pub struct ReadyProbe(Arc<RwLock<ReadyState>>);

#[derive(Default, Clone)]
pub struct ReadyState {
    pub listeners_bound: bool,
    pub metrics_bound: bool,
    pub cfg_loaded: bool,
    pub queues_ok: bool,
    pub shed_rate_ok: bool,
    pub fd_headroom: bool,
    pub pq_ready: Option<bool>,
    pub tor_bootstrap: Option<bool>,
}

impl ReadyProbe {
    pub fn new() -> Self {
        Self::default()
    }

    pub async fn set<F: FnOnce(&mut ReadyState)>(&self, f: F) {
        let mut g = self.0.write().await;
        f(&mut g);
    }

    pub async fn snapshot(&self) -> ReadyState {
        self.0.read().await.clone()
    }
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct ReadyResp {
    ready: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    degraded: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    missing: Option<Vec<&'static str>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    retry_after: Option<u64>,
}

#[inline]
fn need(flag: bool, name: &'static str, out: &mut Vec<&'static str>) {
    if !flag {
        out.push(name);
    }
}

/// Axum handler for `/readyz`.
pub async fn readyz(State(probe): State<ReadyProbe>) -> impl IntoResponse {
    let s = probe.snapshot().await;
    let mut missing = Vec::new();

    need(s.listeners_bound, "listeners_bound", &mut missing);
    need(s.metrics_bound, "metrics_bound", &mut missing);
    need(s.cfg_loaded, "cfg_loaded", &mut missing);
    need(s.queues_ok, "queues_ok", &mut missing);
    need(s.shed_rate_ok, "shed_rate_ok", &mut missing);
    need(s.fd_headroom, "fd_headroom", &mut missing);
    if let Some(false) = s.pq_ready {
        missing.push("pq_ready");
    }
    if let Some(false) = s.tor_bootstrap {
        missing.push("tor_bootstrap");
    }

    if missing.is_empty() {
        (
            axum::http::StatusCode::OK,
            Json(ReadyResp {
                ready: true,
                degraded: None,
                missing: None,
                retry_after: None,
            }),
        )
    } else {
        (
            axum::http::StatusCode::SERVICE_UNAVAILABLE,
            Json(ReadyResp {
                ready: false,
                degraded: Some(true),
                missing: Some(missing),
                retry_after: Some(5),
            }),
        )
    }
}

```

### crates/svc-overlay/src/admin/version.rs
<a id="crates-svc-overlay-src-admin-version-rs"></a>

```rust
//! RO:WHAT
//!   Build metadata surface (type + handler) for /version.
//! RO:WHY
//!   Bootstrap expects `BuildInfo` and `admin::router(probe, ver)`.
//! RO:INVARIANTS
//!   - Safe if git/build envs are missing (fall back to "unknown").

use axum::{extract::State, response::IntoResponse, Json};
use serde::Serialize;

/// Static build metadata carried in admin state.
#[derive(Clone, Copy, Serialize)]
pub struct BuildInfo {
    pub version: &'static str,
    pub git: &'static str,
    pub build: &'static str,
    pub features: &'static [&'static str],
}

/// Construct BuildInfo from compile-time env (fallbacks allowed).
pub fn current_build_info() -> BuildInfo {
    BuildInfo {
        version: env!("CARGO_PKG_VERSION"),
        git: option_env!("GIT_SHA").unwrap_or("unknown"),
        build: option_env!("BUILD_TS").unwrap_or("unknown"),
        features: &[
            // e.g., "tls", "quic", "pq", "amnesia"
        ],
    }
}

/// GET /version — returns the build info from AdminState.
pub async fn handle_version(State(state): State<crate::admin::AdminState>) -> impl IntoResponse {
    Json(state.build)
}

```

### crates/svc-overlay/src/api/mod.rs
<a id="crates-svc-overlay-src-api-mod-rs"></a>

```rust
//! RO:WHAT — Minimal lib API surface (feature `libapi`)
#![allow(dead_code)]
use anyhow::Result;
use crate::{config::Config, readiness::HealthGate, bootstrap::start_runtime};

#[cfg(feature = "libapi")]
pub struct OverlayHandle(pub(crate) crate::supervisor::OverlayRuntime);

#[cfg(feature = "libapi")]
pub async fn spawn(cfg: Config) -> Result<OverlayHandle> {
    let hg = HealthGate::new();
    let rt = start_runtime(cfg, hg).await?;
    Ok(OverlayHandle(rt))
}

#[cfg(feature = "libapi")]
impl OverlayHandle {
    pub async fn shutdown(self) -> Result<()> { self.0.shutdown().await }
}

```

### crates/svc-overlay/src/auth/macaroon.rs
<a id="crates-svc-overlay-src-auth-macaroon-rs"></a>

```rust
//! RO:WHAT — Macaroon-based capability checks (stub)
#![allow(dead_code)]
pub fn verify_capability(_cap: &str) -> bool {
    true
}

```

### crates/svc-overlay/src/auth/mod.rs
<a id="crates-svc-overlay-src-auth-mod-rs"></a>

```rust
//! RO:WHAT — AuthN/Z surface
pub mod macaroon;

```

### crates/svc-overlay/src/bootstrap.rs
<a id="crates-svc-overlay-src-bootstrap-rs"></a>

```rust
//! Boot wiring for tracing + admin server.

use crate::admin::version::BuildInfo;
use crate::admin::{self, ReadyProbe};
use axum::Router;
use std::net::SocketAddr;
use tokio::net::TcpListener;
use tracing::{info, Level};
use tracing_subscriber::{fmt, EnvFilter};

pub struct AdminServer {
    pub addr: SocketAddr,
    handle: tokio::task::JoinHandle<anyhow::Result<()>>,
}

impl AdminServer {
    pub async fn spawn(
        bind: SocketAddr,
        probe: ReadyProbe,
        ver: BuildInfo,
    ) -> anyhow::Result<Self> {
        let app: Router = admin::router(probe, ver);
        let listener = TcpListener::bind(bind).await?;
        let addr = listener.local_addr()?;
        let handle = tokio::spawn(async move {
            axum::serve(listener, app).await?;
            Ok::<_, anyhow::Error>(())
        });
        info!("admin server listening on {}", addr);
        Ok(Self { addr, handle })
    }

    pub async fn join(self) -> anyhow::Result<()> {
        self.handle.await??;
        Ok(())
    }
}

/// Install JSON tracing with an env-filter override.
/// Example: `RUST_LOG=svc-overlay=debug,axum=warn`
pub fn init_tracing(default_level: &str) {
    let filter =
        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(default_level));
    fmt()
        .with_max_level(Level::INFO)
        .with_env_filter(filter)
        .json()
        .with_current_span(true)
        .with_span_list(true)
        .flatten_event(true)
        .init();
}

/// Start the minimal gossip engine and register the global publish hook.
/// Returns the spawned worker task so supervisors can hold/join it.
pub fn start_gossip_engine(capacity: usize) -> tokio::task::JoinHandle<()> {
    let (gossip, task) = crate::gossip::GossipEngine::start(capacity);
    gossip.install_global();
    info!("gossip engine online (cap={})", capacity);
    task
}

```

### crates/svc-overlay/src/cli.rs
<a id="crates-svc-overlay-src-cli-rs"></a>

```rust
//! RO:WHAT — CLI surface (env-first, minimal flags placeholder)
#![allow(dead_code)]
pub struct Cli {}
impl Cli {
    pub fn parse() -> Self {
        Self {}
    }
}

```

### crates/svc-overlay/src/config.rs
<a id="crates-svc-overlay-src-config-rs"></a>

```rust
//! RO:WHAT — Config loader/validator
use anyhow::{anyhow, bail, Result};
use std::{net::SocketAddr, time::Duration};

#[derive(Clone, Debug)]
pub struct Admin {
    pub http_addr: SocketAddr,
    pub metrics_addr: SocketAddr,
}

#[derive(Clone, Debug)]
pub struct TransportCfg {
    pub addr: SocketAddr,
    pub name: &'static str,
    pub read_timeout: Duration,
    pub idle_timeout: Duration,
    pub max_conns: usize,
    // TLS/QUIC/Tor knobs can be added here and mapped to ron-transport features
}

#[derive(Clone, Debug)]
pub struct Config {
    pub admin: Admin,
    pub transport: TransportCfg,
    pub oap_max_frame: usize,
    pub send_window_frames: u32,
    pub recv_window_frames: u32,
    pub amnesia: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            admin: Admin {
                http_addr: "127.0.0.1:9600".parse().unwrap(),
                metrics_addr: "127.0.0.1:9601".parse().unwrap(),
            },
            transport: TransportCfg {
                addr: "127.0.0.1:9700".parse().unwrap(),
                name: "svc-overlay",
                read_timeout: Duration::from_secs(5),
                idle_timeout: Duration::from_secs(30),
                max_conns: 1024,
            },
            oap_max_frame: 1 << 20,
            send_window_frames: 16,
            recv_window_frames: 16,
            amnesia: false,
        }
    }
}

impl Config {
    /// Minimal env loader; expand per your CONFIG.MD later.
    pub fn from_env_and_cli() -> Result<Self> {
        let mut c = Self::default();
        if let Ok(addr) = std::env::var("SVC_OVERLAY_HTTP_ADDR") {
            c.admin.http_addr = addr.parse().map_err(|e| anyhow!("bad http addr: {e}"))?;
        }
        if let Ok(addr) = std::env::var("SVC_OVERLAY_METRICS_ADDR") {
            c.admin.metrics_addr = addr.parse().map_err(|e| anyhow!("bad metrics addr: {e}"))?;
        }
        if let Ok(addr) = std::env::var("SVC_OVERLAY_LISTEN_ADDR") {
            c.transport.addr = addr.parse().map_err(|e| anyhow!("bad listen addr: {e}"))?;
        }
        if let Ok(n) = std::env::var("SVC_OVERLAY_MAX_CONNS") {
            c.transport.max_conns = n.parse().map_err(|e| anyhow!("bad max conns: {e}"))?;
        }
        c.validate()?;
        Ok(c)
    }

    pub fn validate(&self) -> Result<()> {
        if self.oap_max_frame == 0 || self.oap_max_frame > (1 << 20) {
            bail!("oap_max_frame must be 1..=1MiB");
        }
        if self.transport.max_conns == 0 {
            bail!("transport.max_conns must be > 0");
        }
        Ok(())
    }
}

```

### crates/svc-overlay/src/conn/error.rs
<a id="crates-svc-overlay-src-conn-error-rs"></a>

```rust
//! RO:WHAT — Connection-level errors.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum ConnError {
    #[error("io: {0}")]
    Io(#[from] std::io::Error),

    #[error(transparent)]
    Proto(#[from] crate::protocol::error::ProtoError),
}

pub type ConnResult<T> = Result<T, ConnError>;

```

### crates/svc-overlay/src/conn/mod.rs
<a id="crates-svc-overlay-src-conn-mod-rs"></a>

```rust
//! RO:WHAT — Connection tasks (reader/writer queues and supervision)

pub mod error;
pub mod reader;
pub mod supervisor;
pub mod tx;
pub mod writer;

```

### crates/svc-overlay/src/conn/reader.rs
<a id="crates-svc-overlay-src-conn-reader-rs"></a>

```rust
//! RO:WHAT — Read loop: accumulates bytes, decodes OAP frames.

use bytes::BytesMut;
use tokio::io::{AsyncRead, AsyncReadExt};
use tracing::{debug, trace};

use super::error::ConnResult;
use crate::protocol::oap::{try_parse_frame, FrameKind}; // <- keep only ConnResult

/// Blocking-ish read loop that parses frames and logs; returns on EOF or error.
/// Transport-agnostic: any AsyncRead works (TCP/TLS/QUIC streams that implement it).
pub async fn run_reader<R>(mut rd: R) -> ConnResult<()>
where
    R: AsyncRead + Unpin,
{
    let mut buf = BytesMut::with_capacity(8 * 1024);

    loop {
        // Try parse any already-buffered frames first.
        while let Some(frame) = try_parse_frame(&mut buf)? {
            match frame.kind {
                FrameKind::Data => {
                    debug!(len = frame.payload.len(), "oap/data frame");
                }
                FrameKind::Ctrl => {
                    debug!(len = frame.payload.len(), "oap/ctrl frame");
                }
            }
            trace!(buf_len = buf.len(), "post-parse buffer");
        }

        // Refill buffer. read_buf appends into BytesMut.
        let n = rd.read_buf(&mut buf).await?;
        if n == 0 {
            // EOF
            return Ok(());
        }
        trace!(read = n, buf_len = buf.len(), "read bytes");
    }
}

```

### crates/svc-overlay/src/conn/supervisor.rs
<a id="crates-svc-overlay-src-conn-supervisor-rs"></a>

```rust
//! RO:WHAT — Per-connection supervisor (stub)
#![allow(dead_code)]

```

### crates/svc-overlay/src/conn/tx.rs
<a id="crates-svc-overlay-src-conn-tx-rs"></a>

```rust
//! RO:WHAT — Bounded per-connection TX queue with single-writer task.
//! RO:WHY  — Enforces single-writer discipline and exposes queue depth/drops.
//! RO:INTERACTS — conn::writer::write_frame, admin::metrics::overlay_metrics
//! RO:INVARIANTS — one writer per connection; bounded mpsc; no locks across .await
//! RO:METRICS — overlay_peer_queue_depth, overlay_peer_dropped_total
//! RO:TEST — covered indirectly by roundtrip; unit tests can enqueue/close

use bytes::BytesMut;
use tokio::io::AsyncWrite;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;
use tracing::{debug, warn};

use crate::admin::metrics::overlay_metrics;
use crate::protocol::oap::Frame;

/// Message to the writer task.
pub enum TxMsg {
    Frame(Frame),
    Close,
}

/// Handle to enqueue frames for a single connection.
#[derive(Clone)]
pub struct TxSender {
    tx: mpsc::Sender<TxMsg>,
}

impl TxSender {
    pub fn capacity(&self) -> usize {
        self.tx.capacity()
    }

    pub fn try_send(&self, frame: Frame) -> Result<(), Frame> {
        match self.tx.try_send(TxMsg::Frame(frame)) {
            Ok(_) => {
                overlay_metrics::set_peer_tx_depth(self.tx.max_capacity() - self.tx.capacity());
                Ok(())
            }
            Err(mpsc::error::TrySendError::Full(TxMsg::Frame(f))) => {
                overlay_metrics::inc_peer_tx_dropped();
                Err(f)
            }
            Err(mpsc::error::TrySendError::Closed(TxMsg::Frame(f))) => Err(f),
            Err(_) => unreachable!("only Frame variants used here"),
        }
    }

    pub async fn send(&self, frame: Frame) -> Result<(), Frame> {
        // Avoid use-after-move by staging in an Option.
        let mut slot = Some(frame);
        match self.tx.send(TxMsg::Frame(slot.take().unwrap())).await {
            Ok(_) => {
                overlay_metrics::set_peer_tx_depth(self.tx.max_capacity() - self.tx.capacity());
                Ok(())
            }
            Err(mpsc::error::SendError(TxMsg::Frame(f))) => Err(f),
            Err(_) => unreachable!("only Frame variants used here"),
        }
    }
}

/// Spawn a writer task which OWNS the AsyncWrite half (single-writer discipline).
pub fn spawn_writer<W>(mut wr: W, bound: usize) -> (TxSender, JoinHandle<()>)
where
    W: AsyncWrite + Unpin + Send + 'static,
{
    let (tx, mut rx) = mpsc::channel::<TxMsg>(bound);
    let handle = tokio::spawn(async move {
        let mut scratch = BytesMut::with_capacity(8 * 1024);
        while let Some(msg) = rx.recv().await {
            match msg {
                TxMsg::Frame(frame) => {
                    if let Err(e) =
                        crate::conn::writer::write_frame(&mut wr, &frame, &mut scratch).await
                    {
                        warn!(error=?e, "writer: write failed — closing");
                        break;
                    }
                    overlay_metrics::set_peer_tx_depth(rx.max_capacity() - rx.capacity());
                }
                TxMsg::Close => {
                    debug!("writer: close requested");
                    break;
                }
            }
        }
    });
    (TxSender { tx }, handle)
}

```

### crates/svc-overlay/src/conn/writer.rs
<a id="crates-svc-overlay-src-conn-writer-rs"></a>

```rust
//! RO:WHAT — Writer helpers: encode frames and flush.

use bytes::BytesMut;
use tokio::io::{AsyncWrite, AsyncWriteExt};

use super::error::ConnResult;
use crate::protocol::oap::Frame; // <- keep only ConnResult

/// Encode a frame into a scratch buffer and write it out atomically.
pub async fn write_frame<W>(wr: &mut W, frame: &Frame, scratch: &mut BytesMut) -> ConnResult<()>
where
    W: AsyncWrite + Unpin,
{
    scratch.clear();
    frame.encode_to(scratch)?;
    wr.write_all(scratch).await?;
    wr.flush().await?;
    Ok(())
}

```

### crates/svc-overlay/src/errors.rs
<a id="crates-svc-overlay-src-errors-rs"></a>

```rust
//! RO:WHAT — Error taxonomy
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("protocol: {0}")]
    Protocol(String),
}

```

### crates/svc-overlay/src/gossip/engine.rs
<a id="crates-svc-overlay-src-gossip-engine-rs"></a>

```rust
//! RO:WHAT — Minimal gossip engine: bounded ingress queue + background worker.
//! RO:WHY  — Provide a place to route/process `Data` frames beyond the echo demo.
//! RO:INVARIANTS — Non-blocking publish; backpressure via bounded channel; best-effort drop on full.

use bytes::Bytes;
use once_cell::sync::OnceCell;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;
use tracing::{debug, warn};

/// Global publishing hook (optional). Listener can publish without holding an Engine instance.
static GLOBAL_TX: OnceCell<mpsc::Sender<Bytes>> = OnceCell::new();

#[derive(Clone)]
pub struct GossipEngine {
    tx: mpsc::Sender<Bytes>,
}

impl GossipEngine {
    /// Start the engine with bounded capacity and spawn the worker task.
    pub fn start(capacity: usize) -> (Self, JoinHandle<()>) {
        let (tx, mut rx) = mpsc::channel::<Bytes>(capacity);
        let me = Self { tx: tx.clone() };

        let task = tokio::spawn(async move {
            // Minimal worker: log and count. Later: route, dedupe, fanout.
            while let Some(msg) = rx.recv().await {
                debug!(len = msg.len(), "gossip: received message");
                metrics::counter!("gossip_ingress_total").increment(1);
                metrics::counter!("gossip_ingress_bytes_total").increment(msg.len() as u64);
                // TODO: plumb to per-topic queues or peers.
            }
            // Channel closed → shutdown path.
            warn!("gossip: worker exiting (channel closed)");
        });

        (me, task)
    }

    /// Install this engine as the global publisher target.
    pub fn install_global(&self) {
        let _ = GLOBAL_TX.set(self.tx.clone());
    }

    /// Try to publish a message (drops if queue is full).
    pub fn try_publish(&self, msg: Bytes) -> bool {
        match self.tx.try_send(msg) {
            Ok(()) => true,
            Err(mpsc::error::TrySendError::Full(_)) => {
                metrics::counter!("gossip_dropped_total", "reason" => "full").increment(1);
                false
            }
            Err(mpsc::error::TrySendError::Closed(_)) => {
                metrics::counter!("gossip_dropped_total", "reason" => "closed").increment(1);
                false
            }
        }
    }
}

/// Publish through the global hook (if installed).
pub fn publish(msg: Bytes) -> bool {
    if let Some(tx) = GLOBAL_TX.get() {
        match tx.try_send(msg) {
            Ok(()) => {
                metrics::counter!("gossip_ingress_total").increment(1);
                true
            }
            Err(mpsc::error::TrySendError::Full(_)) => {
                metrics::counter!("gossip_dropped_total", "reason" => "full").increment(1);
                false
            }
            Err(mpsc::error::TrySendError::Closed(_)) => {
                metrics::counter!("gossip_dropped_total", "reason" => "closed").increment(1);
                false
            }
        }
    } else {
        metrics::counter!("gossip_dropped_total", "reason" => "unset").increment(1);
        false
    }
}

```

### crates/svc-overlay/src/gossip/mod.rs
<a id="crates-svc-overlay-src-gossip-mod-rs"></a>

```rust
//! RO:WHAT — Gossip module
pub mod engine;
pub use engine::{publish, GossipEngine};
pub mod types;

```

### crates/svc-overlay/src/gossip/types.rs
<a id="crates-svc-overlay-src-gossip-types-rs"></a>

```rust
//! RO:WHAT — Gossip types
#![allow(dead_code)]
use bytes::Bytes;
pub type GossipMsg = Bytes;

```

### crates/svc-overlay/src/lib.rs
<a id="crates-svc-overlay-src-lib-rs"></a>

```rust
//! RO:WHAT — Library entry for svc-overlay
#![forbid(unsafe_code)]

pub mod admin;
pub mod auth;
pub mod bootstrap;
pub mod cli;
pub mod config;
pub mod conn;
pub mod errors;
pub mod gossip;
pub mod limits;
pub mod listener;
pub mod observe;
pub mod pq;
pub mod protocol;
pub mod readiness;
pub mod shutdown;
pub mod supervisor;
pub mod transport;
pub mod tuning;
pub mod types;

use tracing_subscriber::{fmt, EnvFilter};

pub fn init_tracing() {
    let filter = EnvFilter::from_default_env().add_directive(
        "svc_overlay=info"
            .parse()
            .unwrap_or_else(|_| "info".parse().unwrap()),
    );
    let _ = fmt()
        .with_env_filter(filter)
        .json()
        .flatten_event(true)
        .try_init();
}

```

### crates/svc-overlay/src/limits.rs
<a id="crates-svc-overlay-src-limits-rs"></a>

```rust
//! RO:WHAT — Service limits (constants)
pub const MAX_FRAME_BYTES: usize = 1 << 20; // 1 MiB

```

### crates/svc-overlay/src/listener/mod.rs
<a id="crates-svc-overlay-src-listener-mod-rs"></a>

```rust
//! RO:WHAT — Listener module entry.
//! RO:WHY  — Keep a single listener implementation in `plain.rs` that delegates
//!           transport concerns to `crate::transport` (facade).
//! RO:CFG  — No cfgs here. The `use_ron_transport` feature is implemented in
//!           the transport facade, not at the listener boundary.

pub mod plain;

// Re-export the public API expected by bootstrap.
pub use plain::{spawn_listener, ListenerHandle};

```

### crates/svc-overlay/src/listener/plain.rs
<a id="crates-svc-overlay-src-listener-plain-rs"></a>

```rust
//! RO:WHAT — Overlay listener using transport facade + metrics.
//! RO:NEXT — When `transport` facade switches to ron-transport, no changes needed here.
//! RO:INVARIANTS — one writer per connection; bounded queue; no locks across .await

use crate::admin::metrics::overlay_metrics;
use crate::admin::ReadyProbe;
use crate::config::Config;
use crate::conn::tx::spawn_writer;
use crate::gossip::publish;
use crate::protocol::flags::Caps;
use crate::protocol::handshake::handshake;
use crate::protocol::oap::{try_parse_frame, Frame, FrameKind};
use crate::transport::{bind_listener, TransportStream};
use crate::tuning; // <— NEW

use anyhow::Result;
use bytes::BytesMut;
use std::net::SocketAddr;
use std::time::Instant;
use tokio::io::AsyncReadExt;
use tokio::net::tcp::OwnedReadHalf;
use tokio::task::JoinHandle;
use tokio::time::Duration;
use tracing::{error, info, trace, warn, Instrument};

pub struct ListenerHandle {
    addr: SocketAddr,
    task: JoinHandle<()>,
}

impl ListenerHandle {
    pub fn addr(&self) -> SocketAddr {
        self.addr
    }
    pub async fn shutdown(self) -> Result<()> {
        self.task.abort();
        Ok(())
    }
}

/// Observe "accept → handshake start" latency even if early-return happens.
struct AcceptTimer {
    start: Instant,
    observed: bool,
}
impl AcceptTimer {
    fn start() -> Self {
        Self {
            start: Instant::now(),
            observed: false,
        }
    }
    fn observe_once(&mut self) {
        if !self.observed {
            overlay_metrics::accept_latency_seconds(self.start.elapsed().as_secs_f64());
            self.observed = true;
        }
    }
}
impl Drop for AcceptTimer {
    fn drop(&mut self) {
        self.observe_once();
    }
}

pub async fn spawn_listener(cfg: &Config, probe: &ReadyProbe) -> Result<ListenerHandle> {
    let (listener, addr) = bind_listener(cfg.transport.addr).await?;
    info!(%addr, "overlay listener bound");
    probe.set(|s| s.listeners_bound = true).await;

    // Readiness sampler — flips `queues_ok` based on TX queue depth.
    let probe_clone = probe.clone();
    tokio::spawn(async move {
        loop {
            let depth = overlay_metrics::get_peer_tx_depth();
            let active = overlay_metrics::get_sessions_active();
            let watermark = tuning::tx_queue_watermark(); // <— NEW
            let ok = if active > 0 { depth < watermark } else { true };
            probe_clone.set(|s| s.queues_ok = ok).await;
            tokio::time::sleep(Duration::from_millis(200)).await;
        }
    });

    let task = tokio::spawn(async move {
        loop {
            match listener.accept().await {
                Ok((stream, peer)) => {
                    metrics::counter!("overlay_connections_total").increment(1);
                    overlay_metrics::inc_sessions_active();
                    tokio::spawn(handle_conn(peer, stream).in_current_span());
                }
                Err(e) => {
                    warn!(error=?e, "accept failed");
                    tokio::time::sleep(Duration::from_millis(50)).await;
                }
            }
        }
    });

    Ok(ListenerHandle { addr, task })
}

async fn handle_conn(peer: SocketAddr, mut stream: TransportStream) {
    let mut accept_timer = AcceptTimer::start();

    // Handshake on the unified stream first (before splitting).
    {
        use tokio::io::{AsyncRead, AsyncWrite};

        trait HandshakeBorrow {
            type Dyn: AsyncRead + AsyncWrite + Unpin;
            fn as_io_mut(&mut self) -> &mut Self::Dyn;
        }
        impl HandshakeBorrow for TransportStream {
            type Dyn = tokio::net::TcpStream;
            fn as_io_mut(&mut self) -> &mut Self::Dyn {
                &mut self.inner
            }
        }

        let caps = Caps::GOSSIP_V1;
        let tmo = tuning::handshake_timeout(); // <— NEW
        let _neg = match tokio::time::timeout(
            tmo,
            handshake(
                <TransportStream as HandshakeBorrow>::as_io_mut(&mut stream),
                caps,
                tmo,
            ),
        )
        .await
        {
            Ok(Ok(n)) => {
                accept_timer.observe_once();
                info!(%peer, ver = n.version, caps = ?n.caps, "conn: negotiated");
                n
            }
            Ok(Err(_e)) => {
                overlay_metrics::handshake_fail("io");
                warn!(%peer, "conn: handshake failed");
                overlay_metrics::dec_sessions_active();
                return;
            }
            Err(_elapsed) => {
                overlay_metrics::handshake_fail("timeout");
                warn!(%peer, "conn: handshake timeout");
                overlay_metrics::dec_sessions_active();
                return;
            }
        };
    }

    // Split into owned halves; writer task owns the write half.
    let (mut rd, wr) = stream.into_split();
    let (tx, _writer_task) = spawn_writer(wr, 128);

    // Reader loop: parse frames; echo Data via bounded TX; publish demo gossip.
    let mut inbuf = BytesMut::with_capacity(8 * 1024);
    let start_ok = Instant::now();

    async fn read_more(rd: &mut OwnedReadHalf, buf: &mut BytesMut) -> std::io::Result<usize> {
        rd.read_buf(buf).await
    }

    loop {
        // Drain any complete frames already in the buffer.
        while let Some(frame) = match try_parse_frame(&mut inbuf) {
            Ok(f) => f,
            Err(e) => {
                warn!(%peer, error=?e, "conn: frame parse error");
                overlay_metrics::dec_sessions_active();
                return;
            }
        } {
            match frame.kind {
                FrameKind::Data => {
                    publish(frame.payload.clone());
                    let echo = Frame {
                        kind: FrameKind::Data,
                        payload: frame.payload,
                    };
                    // On backpressure, drop and record.
                    if tx.try_send(echo).is_err() {
                        overlay_metrics::inc_peer_tx_dropped();
                    }
                }
                FrameKind::Ctrl => {
                    // TODO: handle control frames when defined
                }
            }
        }

        // Refill buffer from reader
        match read_more(&mut rd, &mut inbuf).await {
            Ok(0) => {
                let secs = start_ok.elapsed().as_secs_f64();
                overlay_metrics::conn_lifetime_seconds(secs);
                info!(%peer, dt_ms = (secs * 1000.0) as u64, "conn: closed");
                overlay_metrics::dec_sessions_active();
                return;
            }
            Ok(n) => {
                trace!(%peer, read = n, buf_len = inbuf.len(), "read bytes");
            }
            Err(e) => {
                error!(%peer, error=?e, "conn: read error");
                overlay_metrics::dec_sessions_active();
                return;
            }
        }
    }
}

```

### crates/svc-overlay/src/listener/ron.rs
<a id="crates-svc-overlay-src-listener-ron-rs"></a>

```rust
//! RO:WHAT — ron-transport listener (placeholder).
//! RO:NEXT — Replace delegation with real spawn using ron-transport once stream handoff API is set.

use crate::admin::ReadyProbe;
use crate::config::Config;
use anyhow::Result;

// For now, delegate to plain listener so enabling the feature doesn't break runtime.
// We keep the same public surface (spawn_listener, ListenerHandle).
pub(super) use super::plain::{spawn_listener, ListenerHandle};

```

### crates/svc-overlay/src/main.rs
<a id="crates-svc-overlay-src-main-rs"></a>

```rust
//! Binary entry: parse config, init tracing, run admin + overlay runtime.

use svc_overlay::admin::version::BuildInfo;
use svc_overlay::admin::ReadyProbe;
use svc_overlay::bootstrap;
use svc_overlay::config::Config;
use svc_overlay::supervisor::OverlayRuntime;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1) Config
    let cfg = Config::from_env_and_cli()?;
    cfg.validate()?;

    // 2) Tracing
    bootstrap::init_tracing("info");

    // 3) Admin server
    let probe = ReadyProbe::new();
    // Early boot truth; listener flips listeners_bound later.
    probe
        .set(|s| {
            s.metrics_bound = true; // Keep true: exporter can be added later
            s.cfg_loaded = true;
            s.listeners_bound = false;
            s.queues_ok = true;
            s.shed_rate_ok = true;
            s.fd_headroom = true;
        })
        .await;

    let build = BuildInfo {
        version: env!("CARGO_PKG_VERSION"),
        git: option_env!("GIT_SHA").unwrap_or("unknown"),
        build: option_env!("BUILD_TS").unwrap_or("unknown"),
        features: &[],
    };

    let admin = bootstrap::AdminServer::spawn(cfg.admin.http_addr, probe.clone(), build).await?;

    // 4) Overlay runtime (bind temporary TCP listener -> flips /readyz green)
    let overlay = OverlayRuntime::start(cfg.clone(), probe.clone()).await?;

    // 5) Wait until admin server exits (CTRL-C or test harness)
    admin.join().await?;

    // 6) Shutdown overlay
    overlay.shutdown().await?;

    Ok(())
}

```

### crates/svc-overlay/src/observe.rs
<a id="crates-svc-overlay-src-observe-rs"></a>

```rust
//! Observability bootstrap + metric helpers.
//! Contract: Prometheus exposition via /metrics with stable names/buckets.
//! See docs/OBSERVABILITY.md and API.MD for the golden set.
//
// NOTE: We intentionally avoid calling `metrics::*` macros here because the
// workspace currently pulls in two different `metrics` versions via
// `metrics-exporter-prometheus`, which causes type/trait conflicts.
// The `emit` helpers are kept as no-ops so call sites compile. Once we unify
// on a single `metrics` version across the workspace, we can flip these back
// on without changing call sites.

use metrics_exporter_prometheus::{Matcher, PrometheusBuilder, PrometheusHandle};
use once_cell::sync::OnceCell;
use std::net::SocketAddr;
use tracing::info;

// Global handle used by /metrics handler to render a scrape.
static PROM_HANDLE: OnceCell<PrometheusHandle> = OnceCell::new();

/// Install a Prometheus recorder and store a handle for /metrics scraping.
/// Returns the configured bind address (HTTP listener is owned by the exporter).
pub fn init_metrics(addr: SocketAddr) -> anyhow::Result<SocketAddr> {
    // Buckets aligned with docs: latency 5ms..5s, frame sizes up to 1MiB.
    let builder = PrometheusBuilder::new()
        .with_http_listener(addr)
        // metrics-exporter-prometheus 0.15 uses (Matcher, &[f64]) — set each metric separately.
        .set_buckets_for_metric(
            Matcher::Full("request_latency_seconds".into()),
            &[0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0],
        )?
        .set_buckets_for_metric(
            Matcher::Full("overlay_frame_size_bytes".into()),
            &[
                512.0,
                1024.0,
                4096.0,
                16384.0,
                65536.0,
                262_144.0,
                524_288.0,
                1_048_576.0,
            ],
        )?;

    // Start exporter + install recorder.
    let handle = builder.install_recorder()?;

    // Touch to ensure recorder is live (silence unused warnings).
    let _ = handle.render().len();

    // Store global handle for /metrics endpoint.
    let _ = PROM_HANDLE.set(handle);

    info!("metrics recorder installed on {}", addr);
    Ok(addr)
}

/// Render Prometheus metrics as text/plain; used by the HTTP handler.
pub fn render_prometheus() -> String {
    PROM_HANDLE
        .get()
        .map(|h| h.render())
        .unwrap_or_else(|| "# no recorder".to_string())
}

/// Canonical metric helpers (names stabilized here).
/// Currently NO-OPs to avoid `metrics` crate version conflicts.
/// Re-enable by replacing bodies with `metrics::*` macros once the workspace
/// is on a single `metrics` version.
pub mod emit {
    #[inline]
    pub fn http_req_total(_route: &'static str, _method: &'static str, _status: u16) {
        // NO-OP (see module docs)
    }

    #[inline]
    pub fn http_latency(_route: &'static str, _method: &'static str, _secs: f64) {
        // NO-OP (see module docs)
    }

    #[inline]
    pub fn ready_state(_val: i64) {
        // NO-OP (see module docs)
    }
}

```

### crates/svc-overlay/src/pq/mod.rs
<a id="crates-svc-overlay-src-pq-mod-rs"></a>

```rust
//! RO:WHAT — Post-quantum negotiation
pub mod negotiate;

```

### crates/svc-overlay/src/pq/negotiate.rs
<a id="crates-svc-overlay-src-pq-negotiate-rs"></a>

```rust
//! RO:WHAT — PQ negotiation stub
#![allow(dead_code)]
pub async fn negotiate() -> bool {
    true
}

```

### crates/svc-overlay/src/protocol/cbor.rs
<a id="crates-svc-overlay-src-protocol-cbor-rs"></a>

```rust
//! RO:WHAT — CBOR helpers for OAP (placeholder)
#![allow(dead_code)]

```

### crates/svc-overlay/src/protocol/error.rs
<a id="crates-svc-overlay-src-protocol-error-rs"></a>

```rust
//! RO:WHAT — Protocol-level errors (OAP/1 framing & handshake).
//! RO:INVARIANTS — No allocation bombs; errors are structured and non-panicking.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum ProtoError {
    #[error("frame too large: {got} > {max} bytes")]
    FrameTooLarge { got: usize, max: usize },

    #[error("incomplete frame")]
    Incomplete,

    #[error("bad magic/version: got {got:?}")]
    BadPreamble { got: [u8; 5] },

    #[error("io: {0}")]
    Io(#[from] std::io::Error),

    #[error("handshake timeout")]
    HandshakeTimeout,

    #[error("capability mismatch")]
    CapabilityMismatch,
}

pub type ProtoResult<T> = Result<T, ProtoError>;

```

### crates/svc-overlay/src/protocol/flags.rs
<a id="crates-svc-overlay-src-protocol-flags-rs"></a>

```rust
//! RO:WHAT — OAP/1 capability flags used during handshake.
//! RO:WHY  — Keep overlay features discoverable and future-proof.

bitflags::bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct Caps: u32 {
        const NONE        = 0;
        const GOSSIP_V1   = 1 << 0;
        const RESERVED_1  = 1 << 1;
        // Future: const PQ_HYBRID = 1 << 8;  // negotiated at overlay level; transport does TLS/PQ.
    }
}

impl Default for Caps {
    fn default() -> Self {
        Caps::GOSSIP_V1
    }
}

```

### crates/svc-overlay/src/protocol/handshake.rs
<a id="crates-svc-overlay-src-protocol-handshake-rs"></a>

```rust
//! RO:WHAT — Minimal OAP/1 handshake over any AsyncRead/Write stream.
//! RO:WHY  — Establish version & capability agreement before frames.
//! RO:INVARIANTS — Fixed-size preamble; bounded IO; timeout guarded.

use crate::protocol::error::{ProtoError, ProtoResult};
use crate::protocol::flags::Caps;
use tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};
use tokio::time::{timeout, Duration};

const MAGIC: &[u8; 4] = b"OAP1";
const WIRE_HELLO_LEN: usize = 4 /*MAGIC*/ + 1 /*ver*/ + 4 /*caps*/;
pub const VERSION: u8 = 1;

#[derive(Debug, Clone, Copy)]
pub struct Negotiated {
    pub version: u8,
    pub caps: Caps,
}

fn encode_hello(buf: &mut [u8; WIRE_HELLO_LEN], ver: u8, caps: Caps) {
    buf[0..4].copy_from_slice(MAGIC);
    buf[4] = ver;
    buf[5..9].copy_from_slice(&(caps.bits()).to_be_bytes());
}

fn decode_hello(buf: &[u8; WIRE_HELLO_LEN]) -> ProtoResult<(u8, Caps)> {
    if &buf[0..4] != MAGIC {
        return Err(ProtoError::BadPreamble {
            got: [buf[0], buf[1], buf[2], buf[3], buf[4]],
        });
    }
    let ver = buf[4];
    let mut caps_b = [0u8; 4];
    caps_b.copy_from_slice(&buf[5..9]);
    let caps = u32::from_be_bytes(caps_b);
    Ok((ver, Caps::from_bits_truncate(caps)))
}

/// Perform a 1-RTT symmetric hello exchange with a timeout.
pub async fn handshake<IO>(io: &mut IO, ours: Caps, dur: Duration) -> ProtoResult<Negotiated>
where
    IO: AsyncRead + AsyncWrite + Unpin,
{
    let mut buf_out = [0u8; WIRE_HELLO_LEN];
    let mut buf_in = [0u8; WIRE_HELLO_LEN];

    encode_hello(&mut buf_out, VERSION, ours);

    let fut = async {
        // Write our hello, then flush
        io.write_all(&buf_out).await?;
        io.flush().await?;

        // Read peer hello (exact len)
        io.read_exact(&mut buf_in).await?;
        ProtoResult::Ok(())
    };

    timeout(dur, fut)
        .await
        .map_err(|_| ProtoError::HandshakeTimeout)??;

    let (peer_ver, peer_caps) = decode_hello(&buf_in)?;
    if peer_ver != VERSION {
        return Err(ProtoError::BadPreamble {
            got: [buf_in[0], buf_in[1], buf_in[2], buf_in[3], buf_in[4]],
        });
    }

    // Minimal check: both must support GOSSIP_V1 for now.
    let needed = Caps::GOSSIP_V1;
    if !peer_caps.contains(needed) || !ours.contains(needed) {
        return Err(ProtoError::CapabilityMismatch);
    }

    Ok(Negotiated {
        version: peer_ver,
        caps: peer_caps & ours,
    })
}

```

### crates/svc-overlay/src/protocol/mod.rs
<a id="crates-svc-overlay-src-protocol-mod-rs"></a>

```rust
//! RO:WHAT — Protocol (OAP-1) framing/handshake surface
pub mod cbor;
pub mod error;
pub mod flags;
pub mod handshake;
pub mod oap;

```

### crates/svc-overlay/src/protocol/oap.rs
<a id="crates-svc-overlay-src-protocol-oap-rs"></a>

```rust
//! RO:WHAT — OAP/1 framing: length-prefixed frames with a kind byte.
//! RO:WHY  — Provide message boundaries over byte-stream transports.
//! RO:INVARIANTS — Max frame size is sourced from ron-proto; parsing is incremental & non-panicking.

use crate::protocol::error::{ProtoError, ProtoResult};
use bytes::{Buf, BufMut, Bytes, BytesMut};

/// Canonical limit from `ron-proto`.
const MAX_FRAME_BYTES: usize = ron_proto::oap::MAX_FRAME_BYTES;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum FrameKind {
    /// Application/gossip data frame (payload = opaque).
    Data = 0x01,
    /// Control/handshake or control acks (payload = small).
    Ctrl = 0x02,
}

impl FrameKind {
    fn from_byte(b: u8) -> Option<Self> {
        match b {
            0x01 => Some(FrameKind::Data),
            0x02 => Some(FrameKind::Ctrl),
            _ => None,
        }
    }
}

#[derive(Debug, Clone)]
pub struct Frame {
    pub kind: FrameKind,
    pub payload: Bytes,
}

impl Frame {
    /// Encode: 4-byte BE length (kind + payload), then 1-byte kind, then payload.
    pub fn encode_to(&self, out: &mut BytesMut) -> ProtoResult<()> {
        let len = 1usize + self.payload.len();
        if len > MAX_FRAME_BYTES {
            return Err(ProtoError::FrameTooLarge {
                got: len,
                max: MAX_FRAME_BYTES,
            });
        }
        out.reserve(4 + len);
        out.put_u32(len as u32);
        out.put_u8(self.kind as u8);
        out.extend_from_slice(&self.payload);
        Ok(())
    }
}

/// Try to parse a single frame from the buffer; leaves remaining bytes in `buf`.
pub fn try_parse_frame(buf: &mut BytesMut) -> ProtoResult<Option<Frame>> {
    const HDR: usize = 4; // BE length
    if buf.len() < HDR {
        return Ok(None);
    }
    let mut len_bytes = &buf[..HDR];
    let len = len_bytes.get_u32() as usize;

    if len > MAX_FRAME_BYTES {
        return Err(ProtoError::FrameTooLarge {
            got: len,
            max: MAX_FRAME_BYTES,
        });
    }

    if buf.len() < HDR + len {
        // Not enough yet
        return Ok(None);
    }

    buf.advance(HDR);
    let kind_b = buf.get_u8();
    let Some(kind) = FrameKind::from_byte(kind_b) else {
        // Treat as control error; drop this frame safely by consuming payload.
        buf.advance(len - 1);
        return Err(ProtoError::BadPreamble {
            got: [b'F', b'K', kind_b, 0, 0],
        });
    };

    let payload_len = len - 1;
    let payload = buf.split_to(payload_len).freeze();

    Ok(Some(Frame { kind, payload }))
}

```

### crates/svc-overlay/src/readiness/mod.rs
<a id="crates-svc-overlay-src-readiness-mod-rs"></a>

```rust
//! RO:WHAT — Readiness/health gate
use parking_lot::RwLock;
use std::sync::Arc;

#[derive(Clone)]
pub struct HealthGate(Arc<RwLock<State>>);

#[derive(Default)]
struct State {
    pub listeners_bound: bool,
    pub metrics_bound: bool,
    pub cfg_loaded: bool,
    pub queues_ok: bool,
    pub shed_rate_ok: bool,
    pub fd_headroom: bool,
}

impl HealthGate {
    #[must_use]
    pub fn new() -> Self {
        Self(Arc::new(RwLock::new(State::default())))
    }

    pub fn set_listeners_bound(&self, v: bool) {
        self.0.write().listeners_bound = v;
    }
    pub fn set_metrics_bound(&self, v: bool) {
        self.0.write().metrics_bound = v;
    }
    pub fn set_cfg_loaded(&self, v: bool) {
        self.0.write().cfg_loaded = v;
    }
    pub fn set_queues_ok(&self, v: bool) {
        self.0.write().queues_ok = v;
    }
    pub fn set_shed_rate_ok(&self, v: bool) {
        self.0.write().shed_rate_ok = v;
    }
    pub fn set_fd_headroom(&self, v: bool) {
        self.0.write().fd_headroom = v;
    }

    pub fn readyz_state(&self) -> (u16, serde_json::Value) {
        let s = self.0.read();
        let ok = s.listeners_bound
            && s.metrics_bound
            && s.cfg_loaded
            && s.queues_ok
            && s.shed_rate_ok
            && s.fd_headroom;

        if ok {
            (200, serde_json::json!({"ready": true}))
        } else {
            let mut missing = vec![];
            if !s.listeners_bound {
                missing.push("listeners_bound");
            }
            if !s.metrics_bound {
                missing.push("metrics_bound");
            }
            if !s.cfg_loaded {
                missing.push("cfg_loaded");
            }
            if !s.queues_ok {
                missing.push("queues_ok");
            }
            if !s.shed_rate_ok {
                missing.push("shed_rate_ok");
            }
            if !s.fd_headroom {
                missing.push("fd_headroom");
            }

            (
                503,
                serde_json::json!({
                    "ready": false,
                    "degraded": true,
                    "missing": missing,
                    "retry_after": 5
                }),
            )
        }
    }

    pub fn healthz(&self) -> (u16, serde_json::Value) {
        (200, serde_json::json!({"ok": true}))
    }
}

// ✅ Satisfy clippy: `new_without_default`
impl Default for HealthGate {
    fn default() -> Self {
        Self::new()
    }
}

```

### crates/svc-overlay/src/readiness/sampler.rs
<a id="crates-svc-overlay-src-readiness-sampler-rs"></a>

```rust
//! RO:WHAT — Readiness sampler (periodic checks). Placeholder.
#![allow(dead_code)]

```

### crates/svc-overlay/src/shutdown.rs
<a id="crates-svc-overlay-src-shutdown-rs"></a>

```rust
//! RO:WHAT — Shutdown coordination
pub async fn wait_for_shutdown() {
    let _ = tokio::signal::ctrl_c().await;
}

```

### crates/svc-overlay/src/supervisor.rs
<a id="crates-svc-overlay-src-supervisor-rs"></a>

```rust
//! RO:WHAT — Runtime supervisor for overlay loops
use crate::{admin::ReadyProbe, config::Config, listener};
use anyhow::Result;
use tokio::task::JoinHandle;
use tracing::{info, warn};

pub struct OverlayRuntime {
    join: JoinHandle<()>,
    stop: tokio::sync::oneshot::Sender<()>,
    listener: Option<listener::ListenerHandle>,
}

impl OverlayRuntime {
    pub async fn start(cfg: Config, probe: ReadyProbe) -> Result<Self> {
        // Bind listener first; flips /readyz to green when successful.
        let lh = listener::spawn_listener(&cfg, &probe).await?;

        let (stop_tx, mut stop_rx) = tokio::sync::oneshot::channel::<()>();
        let join = tokio::spawn(async move {
            info!("overlay supervisor running");
            loop {
                tokio::select! {
                    _ = &mut stop_rx => {
                        info!("overlay supervisor stopping");
                        break;
                    }
                    _ = tokio::time::sleep(std::time::Duration::from_millis(250)) => {
                        // place periodic tasks here (samplers, house-keeping)
                    }
                }
            }
        });

        Ok(Self {
            join,
            stop: stop_tx,
            listener: Some(lh),
        })
    }

    pub async fn shutdown(mut self) -> Result<()> {
        if let Some(lh) = self.listener.take() {
            lh.shutdown().await?;
        }
        let _ = self.stop.send(());
        if let Err(e) = self.join.await {
            warn!(error=?e, "overlay supervisor join error");
        }
        Ok(())
    }
}

```

### crates/svc-overlay/src/transport/mod.rs
<a id="crates-svc-overlay-src-transport-mod-rs"></a>

```rust
//! RO:WHAT — Transport facade for svc-overlay.
//! RO:WHY  — Allow swapping plain TCP for `ron-transport` without touching call-sites.
//! RO:NOTE — For now, BOTH feature paths use Tokio TCP. When we align with the real
//!           `ron-transport` API, only this file needs changes.

use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};

pub struct Listener {
    inner: TcpListener,
}

pub struct TransportStream {
    pub inner: TcpStream,
}

impl TransportStream {
    pub fn into_split(
        self,
    ) -> (
        tokio::net::tcp::OwnedReadHalf,
        tokio::net::tcp::OwnedWriteHalf,
    ) {
        self.inner.into_split()
    }
}

pub async fn bind_listener(addr: SocketAddr) -> std::io::Result<(Listener, SocketAddr)> {
    let inner = TcpListener::bind(addr).await?;
    let local = inner.local_addr()?;
    Ok((Listener { inner }, local))
}

impl Listener {
    pub async fn accept(&self) -> std::io::Result<(TransportStream, SocketAddr)> {
        let (sock, peer) = self.inner.accept().await?;
        Ok((TransportStream { inner: sock }, peer))
    }
}

```

### crates/svc-overlay/src/transport/quic.rs
<a id="crates-svc-overlay-src-transport-quic-rs"></a>

```rust
//! RO:WHAT — QUIC transport (stub)
#![allow(dead_code)]

```

### crates/svc-overlay/src/transport/tls.rs
<a id="crates-svc-overlay-src-transport-tls-rs"></a>

```rust
//! RO:WHAT — TLS transport (stub)
#![allow(dead_code)]

```

### crates/svc-overlay/src/transport/tor.rs
<a id="crates-svc-overlay-src-transport-tor-rs"></a>

```rust
//! RO:WHAT — Tor transport (stub)
#![allow(dead_code)]

```

### crates/svc-overlay/src/tuning.rs
<a id="crates-svc-overlay-src-tuning-rs"></a>

```rust
//! RO:WHAT — Small runtime “tuning knobs” for svc-overlay.
//! RO:WHY  — Allow ops/tests to tune without rebuilds until full Config plumbing lands.
//!
//! Env vars (optional):
//! - RON_OVERLAY_TX_WATERMARK : i64   — default 96 (of 128-slot TX queue)
//! - RON_OVERLAY_HANDSHAKE_MS : u64   — default 2000 (ms)
//!
//! Invariants:
//! - Clamped to safe ranges; parsing failures fall back to defaults.
//! - Values are read on each call; cheap enough for infrequent reads in our usage.

use std::time::Duration;

const DEF_WATERMARK: i64 = 96;
const DEF_HSHAKE_MS: u64 = 2_000;

pub fn tx_queue_watermark() -> i64 {
    match std::env::var("RON_OVERLAY_TX_WATERMARK") {
        Ok(v) => v
            .parse::<i64>()
            .ok()
            .map(|n| n.clamp(1, 127))
            .unwrap_or(DEF_WATERMARK),
        Err(_) => DEF_WATERMARK,
    }
}

pub fn handshake_timeout() -> Duration {
    let ms = match std::env::var("RON_OVERLAY_HANDSHAKE_MS") {
        Ok(v) => v
            .parse::<u64>()
            .ok()
            .map(|ms| ms.clamp(100, 30_000))
            .unwrap_or(DEF_HSHAKE_MS),
        Err(_) => DEF_HSHAKE_MS,
    };
    Duration::from_millis(ms)
}

```

### crates/svc-overlay/src/types.rs
<a id="crates-svc-overlay-src-types-rs"></a>

```rust
//! RO:WHAT — Common types
#![allow(dead_code)]
use std::net::SocketAddr;
pub type PeerAddr = SocketAddr;

```

### crates/svc-overlay/tests/http_contract.rs
<a id="crates-svc-overlay-tests-httpcontract-rs"></a>

```rust
// http_contract.rs — placeholder
// Validates /healthz, /readyz semantics and /metrics scrape shape.

```

### crates/svc-overlay/tests/integration/oap_session_handshake.rs
<a id="crates-svc-overlay-tests-integration-oapsessionhandshake-rs"></a>

```rust
// oap_session_handshake.rs — placeholder
// Drives session establishment over the real stack (hello/ack paths).

```

### crates/svc-overlay/tests/integration/overlay_admin_roundtrip.rs
<a id="crates-svc-overlay-tests-integration-overlayadminroundtrip-rs"></a>

```rust
// overlay_admin_roundtrip.rs — placeholder
// Spins admin plane (healthz/readyz/metrics) and asserts end-to-end contracts.

```

### crates/svc-overlay/tests/integration/overlay_oap_streaming.rs
<a id="crates-svc-overlay-tests-integration-overlayoapstreaming-rs"></a>

```rust
// overlay_oap_streaming.rs — placeholder
// Streaming happy-path with bounded backpressure and latency assertions.

```

### crates/svc-overlay/tests/interop_vectors.rs
<a id="crates-svc-overlay-tests-interopvectors-rs"></a>

```rust
// interop_vectors.rs — placeholder
// Golden vectors for hello/ack, oversize/ratio rejects (OAP invariants).

```

### crates/svc-overlay/tests/loom/loom_overlay.rs
<a id="crates-svc-overlay-tests-loom-loomoverlay-rs"></a>

```rust
// loom_overlay.rs — placeholder
// Interleavings for one-writer invariant, bounded queues, orderly shutdown.

```

### crates/svc-overlay/tests/metrics_schema.rs
<a id="crates-svc-overlay-tests-metricsschema-rs"></a>

```rust
// metrics_schema.rs — placeholder
// Emits sample metrics and asserts names/labels match docs/api-history.

```

### crates/svc-overlay/tests/pq_negotiation.rs
<a id="crates-svc-overlay-tests-pqnegotiation-rs"></a>

```rust
// pq_negotiation.rs — placeholder
// Matrix tests: off<->off, hybrid<->hybrid, hybrid<->off refusal cases.

```

### crates/svc-overlay/tests/readiness_under_pressure.rs
<a id="crates-svc-overlay-tests-readinessunderpressure-rs"></a>

```rust
// readiness_under_pressure.rs — placeholder
// Induces saturation; expects early degrade and recovery.

```

