<!-- Generated by scripts/make_crate_codex.sh on 2025-11-06T20:58:03Z -->
# Code Bundle — `ron-kms`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-kms/.cargo/config.toml](#crates-ron-kms--cargo-config-toml)
- [crates/ron-kms/Cargo.toml](#crates-ron-kms-Cargo-toml)
- [crates/ron-kms/benches/batch_verify.rs](#crates-ron-kms-benches-batchverify-rs)
- [crates/ron-kms/benches/decap_bench.rs](#crates-ron-kms-benches-decapbench-rs)
- [crates/ron-kms/benches/encap_bench.rs](#crates-ron-kms-benches-encapbench-rs)
- [crates/ron-kms/benches/parallel_throughput.rs](#crates-ron-kms-benches-parallelthroughput-rs)
- [crates/ron-kms/benches/sign_bench.rs](#crates-ron-kms-benches-signbench-rs)
- [crates/ron-kms/benches/sign_fast.rs](#crates-ron-kms-benches-signfast-rs)
- [crates/ron-kms/benches/verify_bench.rs](#crates-ron-kms-benches-verifybench-rs)
- [crates/ron-kms/benches/verify_fast.rs](#crates-ron-kms-benches-verifyfast-rs)
- [crates/ron-kms/deny.toml](#crates-ron-kms-deny-toml)
- [crates/ron-kms/examples/metrics.rs](#crates-ron-kms-examples-metrics-rs)
- [crates/ron-kms/examples/rotate.rs](#crates-ron-kms-examples-rotate-rs)
- [crates/ron-kms/examples/smoke.rs](#crates-ron-kms-examples-smoke-rs)
- [crates/ron-kms/fuzz/Cargo.toml](#crates-ron-kms-fuzz-Cargo-toml)
- [crates/ron-kms/fuzz/fuzz_targets/dto_sign.rs](#crates-ron-kms-fuzz-fuzztargets-dtosign-rs)
- [crates/ron-kms/fuzz/fuzz_targets/sealed_header.rs](#crates-ron-kms-fuzz-fuzztargets-sealedheader-rs)
- [crates/ron-kms/rust-toolchain.toml](#crates-ron-kms-rust-toolchain-toml)
- [crates/ron-kms/scripts/bench.sh](#crates-ron-kms-scripts-bench-sh)
- [crates/ron-kms/src/backends/dalek.rs](#crates-ron-kms-src-backends-dalek-rs)
- [crates/ron-kms/src/backends/fast.rs](#crates-ron-kms-src-backends-fast-rs)
- [crates/ron-kms/src/backends/fast_ring.rs](#crates-ron-kms-src-backends-fastring-rs)
- [crates/ron-kms/src/backends/file.rs](#crates-ron-kms-src-backends-file-rs)
- [crates/ron-kms/src/backends/memory.rs](#crates-ron-kms-src-backends-memory-rs)
- [crates/ron-kms/src/backends/mod.rs](#crates-ron-kms-src-backends-mod-rs)
- [crates/ron-kms/src/backends/pkcs11.rs](#crates-ron-kms-src-backends-pkcs11-rs)
- [crates/ron-kms/src/config.rs](#crates-ron-kms-src-config-rs)
- [crates/ron-kms/src/error.rs](#crates-ron-kms-src-error-rs)
- [crates/ron-kms/src/lib.rs](#crates-ron-kms-src-lib-rs)
- [crates/ron-kms/src/metrics.rs](#crates-ron-kms-src-metrics-rs)
- [crates/ron-kms/src/ops/attest.rs](#crates-ron-kms-src-ops-attest-rs)
- [crates/ron-kms/src/ops/create.rs](#crates-ron-kms-src-ops-create-rs)
- [crates/ron-kms/src/ops/mod.rs](#crates-ron-kms-src-ops-mod-rs)
- [crates/ron-kms/src/ops/rotate.rs](#crates-ron-kms-src-ops-rotate-rs)
- [crates/ron-kms/src/ops/sign.rs](#crates-ron-kms-src-ops-sign-rs)
- [crates/ron-kms/src/ops/unwrap.rs](#crates-ron-kms-src-ops-unwrap-rs)
- [crates/ron-kms/src/ops/verify.rs](#crates-ron-kms-src-ops-verify-rs)
- [crates/ron-kms/src/ops/verify_batch.rs](#crates-ron-kms-src-ops-verifybatch-rs)
- [crates/ron-kms/src/ops/wrap.rs](#crates-ron-kms-src-ops-wrap-rs)
- [crates/ron-kms/src/pq/mldsa.rs](#crates-ron-kms-src-pq-mldsa-rs)
- [crates/ron-kms/src/pq/mlkem.rs](#crates-ron-kms-src-pq-mlkem-rs)
- [crates/ron-kms/src/pq/mod.rs](#crates-ron-kms-src-pq-mod-rs)
- [crates/ron-kms/src/pq/slhdsa.rs](#crates-ron-kms-src-pq-slhdsa-rs)
- [crates/ron-kms/src/prelude.rs](#crates-ron-kms-src-prelude-rs)
- [crates/ron-kms/src/sealed/aead.rs](#crates-ron-kms-src-sealed-aead-rs)
- [crates/ron-kms/src/sealed/anti_rollback.rs](#crates-ron-kms-src-sealed-antirollback-rs)
- [crates/ron-kms/src/sealed/header.rs](#crates-ron-kms-src-sealed-header-rs)
- [crates/ron-kms/src/sealed/mod.rs](#crates-ron-kms-src-sealed-mod-rs)
- [crates/ron-kms/src/sealed/store.rs](#crates-ron-kms-src-sealed-store-rs)
- [crates/ron-kms/src/telemetry.rs](#crates-ron-kms-src-telemetry-rs)
- [crates/ron-kms/src/traits/hybrid.rs](#crates-ron-kms-src-traits-hybrid-rs)
- [crates/ron-kms/src/traits/kem.rs](#crates-ron-kms-src-traits-kem-rs)
- [crates/ron-kms/src/traits/keystore.rs](#crates-ron-kms-src-traits-keystore-rs)
- [crates/ron-kms/src/traits/mod.rs](#crates-ron-kms-src-traits-mod-rs)
- [crates/ron-kms/src/traits/pubkey.rs](#crates-ron-kms-src-traits-pubkey-rs)
- [crates/ron-kms/src/traits/signer.rs](#crates-ron-kms-src-traits-signer-rs)
- [crates/ron-kms/src/traits/verifier.rs](#crates-ron-kms-src-traits-verifier-rs)
- [crates/ron-kms/src/types.rs](#crates-ron-kms-src-types-rs)
- [crates/ron-kms/src/util/ct.rs](#crates-ron-kms-src-util-ct-rs)
- [crates/ron-kms/src/util/mod.rs](#crates-ron-kms-src-util-mod-rs)
- [crates/ron-kms/src/util/time.rs](#crates-ron-kms-src-util-time-rs)
- [crates/ron-kms/src/util/zeroize.rs](#crates-ron-kms-src-util-zeroize-rs)
- [crates/ron-kms/telemetry.rs](#crates-ron-kms-telemetry-rs)
- [crates/ron-kms/testing/kms-dev-server/Cargo.toml](#crates-ron-kms-testing-kms-dev-server-Cargo-toml)
- [crates/ron-kms/testing/kms-dev-server/src/main.rs](#crates-ron-kms-testing-kms-dev-server-src-main-rs)
- [crates/ron-kms/tests/attest.rs](#crates-ron-kms-tests-attest-rs)
- [crates/ron-kms/tests/interop_kats.rs](#crates-ron-kms-tests-interopkats-rs)
- [crates/ron-kms/tests/keyid_and_roundtrip.rs](#crates-ron-kms-tests-keyidandroundtrip-rs)
- [crates/ron-kms/tests/unit/attest_test.rs](#crates-ron-kms-tests-unit-attesttest-rs)
- [crates/ron-kms/tests/unit/rotate_test.rs](#crates-ron-kms-tests-unit-rotatetest-rs)
- [crates/ron-kms/tests/unit/sealed_header_test.rs](#crates-ron-kms-tests-unit-sealedheadertest-rs)
- [crates/ron-kms/tests/unit/zeroize_test.rs](#crates-ron-kms-tests-unit-zeroizetest-rs)
- [crates/ron-kms/tests/versioned_verify.rs](#crates-ron-kms-tests-versionedverify-rs)
- [crates/ron-kms/xtask/src/main.rs](#crates-ron-kms-xtask-src-main-rs)

### crates/ron-kms/.cargo/config.toml
<a id="crates-ron-kms--cargo-config-toml"></a>

```toml
[build]
rustflags = []

[term]
verbose = false

```

### crates/ron-kms/Cargo.toml
<a id="crates-ron-kms-Cargo-toml"></a>

```toml
[package]
name = "ron-kms"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[lib]
path = "src/lib.rs"

[features]
default = []
with-metrics = ["dep:prometheus", "dep:once_cell"]
# Optional backends / algorithms
fast      = ["dep:ring"]     # enables ASM-accelerated Ed25519 via ring for sign/verify
mlkem     = []
mldsa     = []
slhdsa    = []
soft-seal = []
pkcs11    = []
dalek-batch = []

[dependencies]
# Default crypto backend (audit-friendly, pure Rust)
ed25519-dalek = { version = "2", default-features = false, features = ["fast", "rand_core", "batch"] }

# Optional fast backend (feature-gated)
ring = { version = "0.17", optional = true }

rand        = "0.8"
rand_core   = "0.6"
zeroize     = { version = "1.7", features = ["alloc"] }
thiserror   = "1"
serde       = { version = "1", features = ["derive"] }
serde_json  = "1"
blake3      = "1"
parking_lot = "0.12"
ahash       = "0.8"
prometheus  = { version = "0.14", optional = true }
once_cell   = { version = "1", optional = true }
time        = { version = "0.3", features = ["macros"] }
uuid        = { version = "1", features = ["v4", "serde"] }
anyhow      = "1"

[dev-dependencies]
hex = "0.4"
criterion = { version = "0.5", default-features = false, features = ["cargo_bench_support","html_reports"] }

# Criterion benches need harness=false
[[bench]]
name = "sign_bench"
harness = false

[[bench]]
name = "verify_bench"
harness = false

[[bench]]
name = "batch_verify"
harness = false

[[bench]]
name = "parallel_throughput"
harness = false

# Stubs for later:
# [[bench]]
# name = "encap_bench"
# harness = false
#
# [[bench]]
# name = "decap_bench"
# harness = false

```

### crates/ron-kms/benches/batch_verify.rs
<a id="crates-ron-kms-benches-batchverify-rs"></a>

```rust
use criterion::{criterion_group, criterion_main, BatchSize, BenchmarkId, Criterion};
use rand::{rngs::StdRng, RngCore, SeedableRng};
use ron_kms::backends::ed25519;

fn rand_bytes(len: usize, rng: &mut StdRng) -> Vec<u8> {
    let mut buf = vec![0u8; len];
    rng.fill_bytes(&mut buf);
    buf
}

pub fn bench_batch_verify(c: &mut Criterion) {
    let mut g = c.benchmark_group("verify_batch");

    for &n in &[8usize, 32, 64] {
        g.bench_function(BenchmarkId::from_parameter(n), |b| {
            // Setup: N keypairs, messages, sigs
            let mut rng = StdRng::seed_from_u64(99 + n as u64);

            let mut pks = Vec::with_capacity(n);
            let mut msgs = Vec::with_capacity(n);
            let mut sigs = Vec::with_capacity(n);
            for _ in 0..n {
                let (pk, sk) = ed25519::generate();
                let m = rand_bytes(128, &mut rng);
                let s = ed25519::sign(&sk, &m);
                pks.push(pk);
                msgs.push(m);
                sigs.push(s);
            }
            let msg_refs: Vec<&[u8]> = msgs.iter().map(|m| m.as_slice()).collect();

            // Measure: single call into backend batch
            b.iter_batched(
                || (),
                |_| {
                    let _ = ed25519::verify_batch(&pks, &msg_refs, &sigs);
                },
                BatchSize::LargeInput,
            );
        });
    }

    g.finish();
}

criterion_group! {
    name = benches;
    config = Criterion::default()
        .sample_size(90)
        .measurement_time(std::time::Duration::from_secs(12))
        .warm_up_time(std::time::Duration::from_secs(3));
    targets = bench_batch_verify
}
criterion_main!(benches);

```

### crates/ron-kms/benches/decap_bench.rs
<a id="crates-ron-kms-benches-decapbench-rs"></a>

```rust
// bench scaffold
fn main() {}

```

### crates/ron-kms/benches/encap_bench.rs
<a id="crates-ron-kms-benches-encapbench-rs"></a>

```rust
// bench scaffold
fn main() {}

```

### crates/ron-kms/benches/parallel_throughput.rs
<a id="crates-ron-kms-benches-parallelthroughput-rs"></a>

```rust
use criterion::{criterion_group, criterion_main, Criterion};
use rand::{rngs::StdRng, RngCore, SeedableRng};
use std::sync::Arc;
use std::thread;

use ron_kms::backends::ed25519;

fn rand_bytes(len: usize, rng: &mut StdRng) -> Vec<u8> {
    let mut buf = vec![0u8; len];
    rng.fill_bytes(&mut buf);
    buf
}

const OPS: usize = 4_000; // per run
const THREADS: usize = 4;

pub fn bench_parallel(c: &mut Criterion) {
    let mut g = c.benchmark_group("parallel");

    // --- Sign 4× ---
    g.bench_function("parallel_sign_4x", |b| {
        let mut rng = StdRng::seed_from_u64(777);
        let (_pk, sk) = ed25519::generate();
        let msg = Arc::new(rand_bytes(128, &mut rng));

        b.iter(|| {
            let mut handles = Vec::with_capacity(THREADS);
            for _ in 0..THREADS {
                let sk = sk; // copy seed
                let msg = Arc::clone(&msg);
                handles.push(thread::spawn(move || {
                    for _ in 0..(OPS / THREADS) {
                        let _ = ed25519::sign(&sk, &msg);
                    }
                }));
            }
            for h in handles {
                let _ = h.join();
            }
        });
    });

    // --- Verify 4× ---
    g.bench_function("parallel_verify_4x", |b| {
        let mut rng = StdRng::seed_from_u64(778);
        let (pk, sk) = ed25519::generate();
        let msg = Arc::new(rand_bytes(128, &mut rng));
        let sig = ed25519::sign(&sk, &msg);

        b.iter(|| {
            let mut handles = Vec::with_capacity(THREADS);
            for _ in 0..THREADS {
                let pk = pk;
                let msg = Arc::clone(&msg);
                let sig = sig;
                handles.push(thread::spawn(move || {
                    for _ in 0..(OPS / THREADS) {
                        let _ = ed25519::verify(&pk, &msg, &sig);
                    }
                }));
            }
            for h in handles {
                let _ = h.join();
            }
        });
    });

    g.finish();
}

criterion_group! {
    name = benches;
    config = Criterion::default()
        .sample_size(60)
        .measurement_time(std::time::Duration::from_secs(8))
        .warm_up_time(std::time::Duration::from_secs(2));
    targets = bench_parallel
}
criterion_main!(benches);

```

### crates/ron-kms/benches/sign_bench.rs
<a id="crates-ron-kms-benches-signbench-rs"></a>

```rust
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};
use rand::{rngs::StdRng, RngCore, SeedableRng};

use ron_kms::backends::ed25519;

#[cfg(not(feature = "fast"))]
mod native {
    pub use ed25519_dalek::{Signer as _, SigningKey};
}
#[cfg(feature = "fast")]
mod native {
    pub use ring::signature::Ed25519KeyPair;
}

fn rand_bytes(len: usize, rng: &mut StdRng) -> Vec<u8> {
    let mut buf = vec![0u8; len];
    rng.fill_bytes(&mut buf);
    buf
}

pub fn bench_sign(c: &mut Criterion) {
    let mut g = c.benchmark_group("ed25519_sign_128B");
    let mut rng = StdRng::seed_from_u64(42);

    // Adapter path (seed -> sign) to reflect API
    {
        let (_pk, sk_seed) = ed25519::generate();
        let msg = rand_bytes(128, &mut rng);
        g.bench_function(BenchmarkId::new("adapter", "seed_→_sign"), |b| {
            b.iter(|| {
                let _sig = ed25519::sign(&sk_seed, &msg);
            });
        });
    }

    // Steady-state: prebuilt key, measure only .sign()
    #[cfg(not(feature = "fast"))]
    {
        use native::*;
        let sk_seed = {
            let (_, s) = ed25519::generate();
            s
        };
        let sk = SigningKey::from_bytes(&sk_seed);
        let msg = rand_bytes(128, &mut rng);

        g.bench_function(BenchmarkId::new("steady", "dalek_signingkey.sign"), |b| {
            b.iter(|| {
                let _ = sk.sign(&msg);
            })
        });
    }

    #[cfg(feature = "fast")]
    {
        use native::*;
        let sk_seed = {
            let (_, s) = ed25519::generate();
            s
        };
        let kp = Ed25519KeyPair::from_seed_unchecked(&sk_seed).expect("ring seed");
        let msg = rand_bytes(128, &mut rng);

        g.bench_function(BenchmarkId::new("steady", "ring_keypair.sign"), |b| {
            b.iter(|| {
                let _ = kp.sign(&msg);
            })
        });
    }

    g.finish();
}

criterion_group! {
    name = benches;
    config = Criterion::default()
        .sample_size(120)
        .measurement_time(std::time::Duration::from_secs(10))
        .warm_up_time(std::time::Duration::from_secs(3));
    targets = bench_sign
}
criterion_main!(benches);

```

### crates/ron-kms/benches/sign_fast.rs
<a id="crates-ron-kms-benches-signfast-rs"></a>

```rust
#![cfg(feature = "fast")]
//! RO:WHAT  A/B bench for fast (ring) sign on 128B message.
//! RO:WHY   Quantify single-op latency vs default dalek path.

use criterion::{criterion_group, criterion_main, Criterion};
use ron_kms::backends::ed25519;

fn bench_sign_fast(c: &mut Criterion) {
    let (sk_blob, _pk) = ed25519::ed25519_generate();
    let msg = vec![0u8; 128];

    c.bench_function("ed25519_sign_fast_128B", |b| {
        b.iter(|| {
            let _sig = ed25519::ed25519_sign(&sk_blob, &msg);
        })
    });
}

criterion_group!(benches, bench_sign_fast);
criterion_main!(benches);

```

### crates/ron-kms/benches/verify_bench.rs
<a id="crates-ron-kms-benches-verifybench-rs"></a>

```rust
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};
use rand::{rngs::StdRng, RngCore, SeedableRng};

use ron_kms::backends::ed25519;

#[cfg(not(feature = "fast"))]
mod native {
    pub use ed25519_dalek::{Signature, Verifier as _, VerifyingKey};
}
#[cfg(feature = "fast")]
mod native {
    pub use ring::signature::{UnparsedPublicKey, ED25519};
}

fn rand_bytes(len: usize, rng: &mut StdRng) -> Vec<u8> {
    let mut buf = vec![0u8; len];
    rng.fill_bytes(&mut buf);
    buf
}

pub fn bench_verify(c: &mut Criterion) {
    let mut g = c.benchmark_group("ed25519_verify_128B");
    let mut rng = StdRng::seed_from_u64(43);

    let (pk, sk_seed) = ed25519::generate();
    let msg = rand_bytes(128, &mut rng);
    let sig = ed25519::sign(&sk_seed, &msg);

    // Adapter path (bytes -> verify)
    g.bench_function(BenchmarkId::new("adapter", "bytes_verify"), |b| {
        b.iter(|| {
            let _ok = ed25519::verify(&pk, &msg, &sig);
        })
    });

    // Steady-state: preparse verifying key + signature; verify only
    #[cfg(not(feature = "fast"))]
    {
        use native::*;
        let vk = VerifyingKey::from_bytes(&pk).expect("vk");
        let sig = Signature::from_slice(&sig).expect("sig");

        g.bench_function(BenchmarkId::new("steady", "dalek_vk.verify"), |b| {
            b.iter(|| {
                let _ = vk.verify_strict(&msg, &sig);
            })
        });
    }

    #[cfg(feature = "fast")]
    {
        use native::*;
        let verifier = UnparsedPublicKey::new(&ED25519, &pk);

        g.bench_function(BenchmarkId::new("steady", "ring_unparsed.verify"), |b| {
            b.iter(|| {
                let _ = verifier.verify(&msg, &sig);
            })
        });
    }

    g.finish();
}

criterion_group! {
    name = benches;
    config = Criterion::default()
        .sample_size(120)
        .measurement_time(std::time::Duration::from_secs(10))
        .warm_up_time(std::time::Duration::from_secs(3));
    targets = bench_verify
}
criterion_main!(benches);

```

### crates/ron-kms/benches/verify_fast.rs
<a id="crates-ron-kms-benches-verifyfast-rs"></a>

```rust
#![cfg(feature = "fast")]
//! RO:WHAT  A/B bench for fast (ring) verify on 128B message.
//! RO:WHY   Quantify single-op latency vs default dalek path.

use criterion::{criterion_group, criterion_main, Criterion};
use ron_kms::backends::ed25519;

fn bench_verify_fast(c: &mut Criterion) {
    let (sk_blob, pk) = ed25519::ed25519_generate();
    let msg = vec![0u8; 128];
    let sig = ed25519::ed25519_sign(&sk_blob, &msg);

    c.bench_function("ed25519_verify_fast_128B", |b| {
        b.iter(|| {
            let _ok = ed25519::ed25519_verify(&pk, &msg, &sig);
        })
    });
}

criterion_group!(benches, bench_verify_fast);
criterion_main!(benches);

```

### crates/ron-kms/deny.toml
<a id="crates-ron-kms-deny-toml"></a>

```toml
# cargo-deny scaffold (fill with project rules later)
[advisories]
yanked = "warn"

[bans]
multiple-versions = "warn"

[sources]
unknown-registry = "deny"
unknown-git = "deny"

```

### crates/ron-kms/examples/metrics.rs
<a id="crates-ron-kms-examples-metrics-rs"></a>

```rust
// Minimal metrics demo: perform a few ops, then print Prometheus text.
use ron_kms::memory_keystore;
use ron_kms::ops::{attest::attest, create, rotate, sign, verify};

fn main() -> anyhow::Result<()> {
    // Do a few ops so counters/histogram tick.
    let kms = memory_keystore();
    let kid = create::ed25519(&kms, "auth", "signing")?;
    let msg = b"hello-metrics";
    let sig = sign::sign(&kms, &kid, msg)?;
    assert!(verify::verify(&kms, &kid, msg, &sig)?);
    let kid2 = rotate::rotate(&kms, &kid)?;
    let _ = attest(&kms, &kid2)?;

    // Print Prometheus exposition to stdout (feature `with-metrics` must be enabled).
    #[cfg(feature = "with-metrics")]
    {
        use prometheus::{gather, Encoder, TextEncoder};
        let encoder = TextEncoder::new();
        let mf = gather();
        let mut buf = Vec::new();
        encoder.encode(&mf, &mut buf).expect("encode");
        println!("{}", String::from_utf8_lossy(&buf));
    }

    Ok(())
}

```

### crates/ron-kms/examples/rotate.rs
<a id="crates-ron-kms-examples-rotate-rs"></a>

```rust
// crates/ron-kms/examples/rotate.rs
use ron_kms::{memory_keystore, Keystore, Signer, Verifier};

fn main() -> anyhow::Result<()> {
    let kms = memory_keystore();

    // v1
    let kid_v1 = kms.create_ed25519("auth", "signing")?;
    let msg_v1 = b"first signature before rotation";
    let sig_v1 = kms.sign(&kid_v1, msg_v1)?;
    assert!(kms.verify(&kid_v1, msg_v1, &sig_v1)?);

    // rotate → v2
    let kid_v2 = kms.rotate(&kid_v1)?;
    assert_eq!(kid_v2.version, kid_v1.version + 1);

    // v2 signs and verifies
    let msg_v2 = b"second signature after rotation";
    let sig_v2 = kms.sign(&kid_v2, msg_v2)?;
    assert!(kms.verify(&kid_v2, msg_v2, &sig_v2)?);

    // NOTE: In this dev backend, the latest public key replaces the old one.
    // Old signatures are not guaranteed to verify after rotation (by design here).

    Ok(())
}

```

### crates/ron-kms/examples/smoke.rs
<a id="crates-ron-kms-examples-smoke-rs"></a>

```rust
use ron_kms::{memory_keystore, Keystore, Signer, Verifier};

fn main() -> anyhow::Result<()> {
    let kms = memory_keystore();
    let kid = kms.create_ed25519("auth", "signing")?;
    let msg = b"rustyonions";
    let sig = kms.sign(&kid, msg)?;
    assert!(kms.verify(&kid, msg, &sig)?);
    Ok(())
}

```

### crates/ron-kms/fuzz/Cargo.toml
<a id="crates-ron-kms-fuzz-Cargo-toml"></a>

```toml
[package]
name = "ron-kms2-fuzz"
version = "0.0.0"
publish = false
edition = "2021"

[dependencies]
libfuzzer-sys = { version = "0.4", features = ["arbitrary-derive"] }

[package.metadata]
cargo-fuzz = true

[[bin]]
name = "sealed_header"
path = "fuzz_targets/sealed_header.rs"
test = false
doc = false

[[bin]]
name = "dto_sign"
path = "fuzz_targets/dto_sign.rs"
test = false
doc = false

```

### crates/ron-kms/fuzz/fuzz_targets/dto_sign.rs
<a id="crates-ron-kms-fuzz-fuzztargets-dtosign-rs"></a>

```rust
// fuzz target scaffold
#![no_main]
use libfuzzer_sys::fuzz_target;
fuzz_target!(|data: &[u8]| {
    let _ = data.iter().fold(0u8, |acc, b| acc ^ b);
});

```

### crates/ron-kms/fuzz/fuzz_targets/sealed_header.rs
<a id="crates-ron-kms-fuzz-fuzztargets-sealedheader-rs"></a>

```rust
// fuzz target scaffold
#![no_main]
use libfuzzer_sys::fuzz_target;
fuzz_target!(|data: &[u8]| {
    let _ = data.len();
});

```

### crates/ron-kms/rust-toolchain.toml
<a id="crates-ron-kms-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["clippy", "rustfmt"]

```

### crates/ron-kms/scripts/bench.sh
<a id="crates-ron-kms-scripts-bench-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Usage:
#   crates/ron-kms/scripts/bench.sh        # dalek lane
#   FAST=1 crates/ron-kms/scripts/bench.sh # ring lane

export RUSTFLAGS="-C target-cpu=native"

# robust under set -u: use string not array
FEATURES_ARGS=""
if [[ "${FAST:-0}" == "1" ]]; then
  FEATURES_ARGS="--features fast"
fi

cargo bench -p ron-kms $FEATURES_ARGS \
  --bench sign_bench \
  --bench verify_bench \
  --bench batch_verify \
  --bench parallel_throughput \
  -- --sample-size 120 --measurement-time 10 --warm-up-time 3

```

### crates/ron-kms/src/backends/dalek.rs
<a id="crates-ron-kms-src-backends-dalek-rs"></a>

```rust
//! Dalek (pure Rust) Ed25519 helpers.
//! Uses `ed25519-dalek` v2 types explicitly to avoid collisions with the `ed25519` trait crate.

#![allow(clippy::module_name_repetitions)]

use ed25519_dalek::{Signature, SigningKey, VerifyingKey};
use ed25519_dalek::{Signer, Verifier}; // bring trait methods into scope
use rand::rngs::OsRng;

/// Generate a new Ed25519 keypair, returning (`public_key_bytes`, `secret_key_bytes`).
/// - `public_key_bytes`: 32 bytes
/// - `secret_key_bytes`: 32 bytes (seed)
#[must_use]
pub fn ed25519_generate() -> ([u8; 32], [u8; 32]) {
    let mut csprng = OsRng;
    let sk: SigningKey = SigningKey::generate(&mut csprng);
    let vk: VerifyingKey = VerifyingKey::from(&sk);

    let sk_bytes: [u8; 32] = sk.to_bytes(); // seed bytes (32)
    let pk_bytes: [u8; 32] = vk.to_bytes(); // verifying key bytes (32)
    (pk_bytes, sk_bytes)
}

/// Sign `msg` using a 32-byte Ed25519 secret key (seed).
/// Returns the 64-byte signature.
#[must_use]
pub fn ed25519_sign(secret_seed: &[u8; 32], msg: &[u8]) -> [u8; 64] {
    // dalek v2: construct SigningKey directly from seed bytes.
    let sk: SigningKey = SigningKey::from_bytes(secret_seed);
    let sig: Signature = sk.sign(msg);
    sig.to_bytes()
}

/// Verify a 64-byte signature against a 32-byte public key.
/// Returns true if valid.
#[must_use]
pub fn ed25519_verify(pk_bytes: &[u8; 32], msg: &[u8], sig_bytes: &[u8; 64]) -> bool {
    let Ok(sig) = Signature::from_slice(sig_bytes) else { return false; };
    let Ok(vk)  = VerifyingKey::from_bytes(pk_bytes) else { return false; };
    vk.verify(msg, &sig).is_ok()
}

/// Batch verify N signatures. Expects `pks.len() == msgs.len() == sigs.len()`.
/// Returns `true` iff all verifies succeed.
///
/// Fast path (when enabled): use dalek's true multiscalar batch verifier.
/// Fallback: pre-parse once, then tight loop of `verify_strict` (zero per-op parsing).
#[must_use]
pub fn ed25519_verify_batch(pks: &[[u8; 32]], msgs: &[&[u8]], sigs: &[[u8; 64]]) -> bool {
    if !(pks.len() == msgs.len() && msgs.len() == sigs.len()) {
        return false;
    }

    // --- Optional true batch (feature "dalek-batch") ---
    #[cfg(feature = "dalek-batch")]
    {
        // Build the vectors that dalek's batch API expects.
        let mut vks = Vec::with_capacity(pks.len());
        for pk in pks {
            let Ok(vk) = VerifyingKey::from_bytes(pk) else { return false; };
            vks.push(vk);
        }
        let mut sig_parsed = Vec::with_capacity(sigs.len());
        for s in sigs {
            let Ok(sig) = Signature::from_slice(s) else { return false; };
            sig_parsed.push(sig);
        }

        // ed25519-dalek v2 provides a batch API accepting slices of (&[u8], Signature, VerifyingKey).
        // Safety/constant-time handled by dalek; returns Ok if all entries verify.
        // If your dalek version lacks this API, disable the "dalek-batch" feature to compile the fallback.
        if ed25519_dalek::verify_batch(&msgs, &sig_parsed, &vks).is_ok() {
            return true;
        } else {
            return false;
        }
    }

    // --- Fallback: tight loop, no per-op parsing (works without the feature) ---
    #[cfg(not(feature = "dalek-batch"))]
    {
        let mut vks = Vec::with_capacity(pks.len());
        for pk in pks {
            let Ok(vk) = VerifyingKey::from_bytes(pk) else { return false; };
            vks.push(vk);
        }
        let mut sig_parsed = Vec::with_capacity(sigs.len());
        for s in sigs {
            let Ok(sig) = Signature::from_slice(s) else { return false; };
            sig_parsed.push(sig);
        }
        for i in 0..pks.len() {
            if vks[i].verify_strict(msgs[i], &sig_parsed[i]).is_err() {
                return false;
            }
        }
        true
    }
}

```

### crates/ron-kms/src/backends/fast.rs
<a id="crates-ron-kms-src-backends-fast-rs"></a>

```rust
//! Fast Ed25519 path using `ring`.
//!
//! Exposes the same free functions as the dalek backend so callers can feature-switch:
//! - `ed25519_generate()` -> (`public_key_bytes`, `secret_key_bytes`)
//! - `ed25519_sign(seed, msg)` -> signature bytes
//! - `ed25519_verify(pk, msg, sig)` -> bool

#![allow(clippy::module_name_repetitions)]

use ring::rand::{SecureRandom, SystemRandom};
use ring::signature::{Ed25519KeyPair, Signature, UnparsedPublicKey, ED25519};

/// Generate a new Ed25519 keypair, returning (`public_key_bytes`, `secret_key_bytes`).
/// - public key: 32 bytes
/// - secret key (seed): 32 bytes
#[must_use]
pub fn ed25519_generate() -> ([u8; 32], [u8; 32]) {
    let rng = SystemRandom::new();

    // ring's Ed25519KeyPair can be constructed from a 32-byte seed.
    let mut seed = [0u8; 32];
    rng.fill(&mut seed).expect("ring: RNG failed");

    let kp = Ed25519KeyPair::from_seed_unchecked(&seed).expect("ring: from_seed_unchecked failed");
    let pk_bytes: [u8; 32] = kp.public_key().as_ref().try_into().expect("pk size");

    (pk_bytes, seed)
}

/// Sign `msg` using a 32-byte Ed25519 secret key (seed).
/// Returns the 64-byte signature.
#[must_use]
pub fn ed25519_sign(secret_seed: &[u8; 32], msg: &[u8]) -> [u8; 64] {
    let kp = Ed25519KeyPair::from_seed_unchecked(secret_seed).expect("ring: from_seed_unchecked");
    let sig: Signature = kp.sign(msg);
    sig.as_ref().try_into().expect("sig size")
}

/// Verify a 64-byte signature against a 32-byte public key.
/// Returns true if valid.
#[must_use]
pub fn ed25519_verify(pk_bytes: &[u8; 32], msg: &[u8], sig_bytes: &[u8; 64]) -> bool {
    let verifier = UnparsedPublicKey::new(&ED25519, pk_bytes);
    verifier.verify(msg, sig_bytes).is_ok()
}

```

### crates/ron-kms/src/backends/fast_ring.rs
<a id="crates-ron-kms-src-backends-fastring-rs"></a>

```rust
//! Fast Ed25519 path using `ring`.
//!
//! Exposes the same free functions as the dalek backend so callers can feature-switch:
//! - `ed25519_generate()` -> (`public_key_bytes`, `secret_key_bytes`)
//! - `ed25519_sign(seed, msg)` -> signature bytes
//! - `ed25519_verify(pk, msg, sig)` -> bool
//! - `ed25519_verify_batch(pks, msgs, sigs)` -> bool
//!
//! Invariants:
//! - Always return fixed-size arrays ([u8; 32] pubkey/seed, [u8; 64] signature)
//! - No allocations on hot sign/verify paths.
//! - Pure `ring` API; no unsafe.

#![allow(clippy::module_name_repetitions)]

use ring::rand::{SecureRandom, SystemRandom};
use ring::signature::{Ed25519KeyPair, KeyPair, Signature, UnparsedPublicKey, ED25519};

/// Generate a new Ed25519 keypair, returning (`public_key_bytes`, `secret_key_bytes`).
/// - public key: 32 bytes
/// - secret key (seed): 32 bytes
#[must_use]
pub fn ed25519_generate() -> ([u8; 32], [u8; 32]) {
    let rng = SystemRandom::new();

    // ring’s Ed25519KeyPair can be constructed from a 32-byte seed.
    let mut seed = [0u8; 32];
    rng.fill(&mut seed).expect("ring RNG failed");

    let kp = Ed25519KeyPair::from_seed_unchecked(&seed).expect("ring from_seed_unchecked");
    let mut pk = [0u8; 32];
    pk.copy_from_slice(kp.public_key().as_ref()); // KeyPair::public_key() -> &[u8] (32)

    (pk, seed)
}

/// Sign `msg` using a 32-byte Ed25519 secret key (seed).
/// Returns the 64-byte signature.
#[must_use]
pub fn ed25519_sign(secret_seed: &[u8; 32], msg: &[u8]) -> [u8; 64] {
    let kp = Ed25519KeyPair::from_seed_unchecked(secret_seed).expect("ring from_seed_unchecked");
    let sig: Signature = kp.sign(msg);
    let mut out = [0u8; 64];
    out.copy_from_slice(sig.as_ref()); // 64 bytes
    out
}

/// Verify a 64-byte signature against a 32-byte public key.
/// Returns true if valid.
#[must_use]
pub fn ed25519_verify(pk_bytes: &[u8; 32], msg: &[u8], sig_bytes: &[u8; 64]) -> bool {
    let verifier = UnparsedPublicKey::new(&ED25519, pk_bytes);
    verifier.verify(msg, sig_bytes).is_ok()
}

/// Batch verify N signatures. Expects `pks.len() == msgs.len() == sigs.len()`.
#[must_use]
pub fn ed25519_verify_batch(pks: &[[u8; 32]], msgs: &[&[u8]], sigs: &[[u8; 64]]) -> bool {
    if !(pks.len() == msgs.len() && msgs.len() == sigs.len()) {
        return false;
    }
    // Build once; ring's UnparsedPublicKey holds a reference, so no copies.
    let verifiers: Vec<UnparsedPublicKey<&[u8; 32]>> =
        pks.iter().map(|pk| UnparsedPublicKey::new(&ED25519, pk)).collect();
    for i in 0..pks.len() {
        if verifiers[i].verify(msgs[i], &sigs[i]).is_err() {
            return false;
        }
    }
    true
}

```

### crates/ron-kms/src/backends/file.rs
<a id="crates-ron-kms-src-backends-file-rs"></a>

```rust
// File backend scaffold

```

### crates/ron-kms/src/backends/memory.rs
<a id="crates-ron-kms-src-backends-memory-rs"></a>

```rust
// RO:WHAT  Dev in-memory KMS with version-retaining verification (contiguous VKs).
// RO:INV   Non-exportability; only the latest version can sign; any version can verify.

use crate::{
    error::KmsError,
    traits::pubkey::PubkeyProvider,
    traits::{Keystore, Signer, Verifier},
    types::{Alg, KeyId, KeyMeta},
    util::time::now_utc_ms,
};
use ahash::AHashMap as HashMap;
use ed25519_dalek::Signer as _; // bring .sign() into scope
use ed25519_dalek::{Signature, SigningKey, VerifyingKey};
use parking_lot::RwLock;
use rand::rngs::OsRng;
use std::sync::Arc;

#[derive(Clone)]
pub struct MemoryKeystore(Arc<RwLock<State>>);

#[derive(Default)]
struct State {
    // Map by "stable root" (tenant/purpose/alg/uuid → per-root record)
    roots: HashMap<String, Root>,
}

struct Root {
    alg: Alg,
    current_version: u32,
    created_ms: i128,
    // Only the latest private key is retained.
    sk: SigningKey,
    // Convenience copy of the current verifying key.
    vk: VerifyingKey,
    // Verification keys for all versions we've ever issued (including current).
    // Index = version - 1.
    vks: Vec<VerifyingKey>,
}

impl Default for MemoryKeystore {
    fn default() -> Self {
        Self(Arc::new(RwLock::new(State {
            roots: HashMap::new(),
        })))
    }
}

impl MemoryKeystore {
    fn root_id(tenant: &str, purpose: &str, alg: Alg, uuid: uuid::Uuid) -> String {
        format!("{tenant}/{purpose}/{alg}/{uuid}")
    }

    fn gen_signing_key() -> SigningKey {
        // Requires ed25519-dalek feature "rand_core".
        SigningKey::generate(&mut OsRng)
    }
}

impl Keystore for MemoryKeystore {
    fn create_ed25519(&self, tenant: &str, purpose: &str) -> Result<KeyId, KmsError> {
        let alg = Alg::Ed25519;
        let kid = KeyId::new(tenant, purpose, alg);
        let root_id = Self::root_id(&kid.tenant, &kid.purpose, kid.alg, kid.uuid);

        let sk = Self::gen_signing_key();
        let vk = VerifyingKey::from(&sk);

        let mut vks = Vec::with_capacity(4);
        vks.push(vk);

        let root = Root {
            alg,
            current_version: kid.version,
            created_ms: now_utc_ms(),
            sk,
            vk,
            vks,
        };

        let mut st = self.0.write();
        st.roots.insert(root_id, root);
        Ok(kid)
    }

    fn rotate(&self, kid: &KeyId) -> Result<KeyId, KmsError> {
        let root_id = Self::root_id(&kid.tenant, &kid.purpose, kid.alg, kid.uuid);
        let mut st = self.0.write();
        let root = st.roots.get_mut(&root_id).ok_or(KmsError::NoSuchKey)?;
        if root.alg != Alg::Ed25519 {
            return Err(KmsError::AlgUnavailable);
        }
        // New keypair → bump version → retain vk for verify
        let sk = Self::gen_signing_key();
        let vk = VerifyingKey::from(&sk);

        root.current_version = root.current_version.saturating_add(1);
        // Compare without truncation: convert len → u32 (Option) and compare to checked_sub(1).
        debug_assert_eq!(
            u32::try_from(root.vks.len()).ok(),
            root.current_version.checked_sub(1)
        );
        root.vks.push(vk);
        root.sk = sk;
        root.vk = vk;

        let mut new = kid.clone();
        new.version = root.current_version;
        Ok(new)
    }

    fn alg(&self, kid: &KeyId) -> Result<Alg, KmsError> {
        let root_id = Self::root_id(&kid.tenant, &kid.purpose, kid.alg, kid.uuid);
        let st = self.0.read();
        let root = st.roots.get(&root_id).ok_or(KmsError::NoSuchKey)?;
        Ok(root.alg)
    }

    fn meta(&self, kid: &KeyId) -> Result<KeyMeta, KmsError> {
        let root_id = Self::root_id(&kid.tenant, &kid.purpose, kid.alg, kid.uuid);
        let st = self.0.read();
        let root = st.roots.get(&root_id).ok_or(KmsError::NoSuchKey)?;
        // Versions are 1..=current_version by invariant.
        let versions: Vec<u32> = (1..=root.current_version).collect();
        Ok(KeyMeta {
            alg: root.alg,
            current_version: root.current_version,
            versions,
            created_ms: root.created_ms,
        })
    }
}

impl Signer for MemoryKeystore {
    fn sign(&self, kid: &KeyId, msg: &[u8]) -> Result<Vec<u8>, KmsError> {
        if kid.alg != Alg::Ed25519 {
            return Err(KmsError::AlgUnavailable);
        }
        let root_id = Self::root_id(&kid.tenant, &kid.purpose, kid.alg, kid.uuid);
        let st = self.0.read();
        let root = st.roots.get(&root_id).ok_or(KmsError::NoSuchKey)?;

        // Only the latest version is allowed to sign.
        if kid.version != root.current_version {
            return Err(KmsError::Busy);
        }

        let sig: Signature = root.sk.sign(msg);
        Ok(sig.to_bytes().to_vec())
    }
}

impl Verifier for MemoryKeystore {
    fn verify(&self, kid: &KeyId, msg: &[u8], sig: &[u8]) -> Result<bool, KmsError> {
        if kid.alg != Alg::Ed25519 {
            return Err(KmsError::AlgUnavailable);
        }
        let root_id = Self::root_id(&kid.tenant, &kid.purpose, kid.alg, kid.uuid);
        let st = self.0.read();
        let root = st.roots.get(&root_id).ok_or(KmsError::NoSuchKey)?;

        let idx = kid.version.checked_sub(1).ok_or(KmsError::NoSuchKey)? as usize;
        let vk = root.vks.get(idx).ok_or(KmsError::NoSuchKey)?;
        let sig = ed25519_dalek::Signature::from_slice(sig).map_err(|_| KmsError::VerifyFailed)?;
        Ok(vk.verify_strict(msg, &sig).is_ok())
    }
}

impl PubkeyProvider for MemoryKeystore {
    fn verifying_key_bytes(&self, kid: &KeyId) -> Result<[u8; 32], KmsError> {
        if kid.alg != Alg::Ed25519 {
            return Err(KmsError::AlgUnavailable);
        }
        let root_id = Self::root_id(&kid.tenant, &kid.purpose, kid.alg, kid.uuid);
        let st = self.0.read();
        let root = st.roots.get(&root_id).ok_or(KmsError::NoSuchKey)?;
        let idx = kid.version.checked_sub(1).ok_or(KmsError::NoSuchKey)? as usize;
        let vk = root.vks.get(idx).ok_or(KmsError::NoSuchKey)?;
        Ok(vk.to_bytes())
    }
}

```

### crates/ron-kms/src/backends/mod.rs
<a id="crates-ron-kms-src-backends-mod-rs"></a>

```rust
//! Backend selection and re-exports.
//! Default: dalek (pure Rust). Optional: ring via `fast` feature.

#![allow(clippy::module_name_repetitions)]

#[cfg(not(feature = "fast"))]
pub mod dalek;
#[cfg(not(feature = "fast"))]
pub use crate::backends::dalek::{
    ed25519_generate, ed25519_sign, ed25519_verify, ed25519_verify_batch,
};

#[cfg(feature = "fast")]
pub mod fast_ring;
#[cfg(feature = "fast")]
pub use crate::backends::fast_ring::{
    ed25519_generate, ed25519_sign, ed25519_verify, ed25519_verify_batch,
};

pub mod memory;
pub use memory::MemoryKeystore;

/// Stable adapter so benches/tests can `use ron_kms::backends::ed25519`.
/// It forwards to the currently selected backend (dalek or ring).
pub mod ed25519 {
    /// Generate a new Ed25519 keypair, returning (`public_key_bytes`, `secret_key_bytes`).
    #[must_use]
    pub fn generate() -> ([u8; 32], [u8; 32]) {
        super::ed25519_generate()
    }
    /// Sign `msg` using a 32-byte Ed25519 secret key (seed). Returns a 64-byte signature.
    #[must_use]
    pub fn sign(secret_seed: &[u8; 32], msg: &[u8]) -> [u8; 64] {
        super::ed25519_sign(secret_seed, msg)
    }
    /// Verify a 64-byte signature against a 32-byte public key.
    #[must_use]
    pub fn verify(pk_bytes: &[u8; 32], msg: &[u8], sig_bytes: &[u8; 64]) -> bool {
        super::ed25519_verify(pk_bytes, msg, sig_bytes)
    }
    /// Batch verify N signatures. `pks.len() == msgs.len() == sigs.len()`.
    #[must_use]
    pub fn verify_batch(pks: &[[u8; 32]], msgs: &[&[u8]], sigs: &[[u8; 64]]) -> bool {
        super::ed25519_verify_batch(pks, msgs, sigs)
    }
}

```

### crates/ron-kms/src/backends/pkcs11.rs
<a id="crates-ron-kms-src-backends-pkcs11-rs"></a>

```rust
// PKCS#11 backend scaffold (feature-gated in real impl)

```

### crates/ron-kms/src/config.rs
<a id="crates-ron-kms-src-config-rs"></a>

```rust
// Config scaffold (no IO yet)
pub struct KmsConfig;
impl KmsConfig {
    pub fn load() -> Self { Self }
}

```

### crates/ron-kms/src/error.rs
<a id="crates-ron-kms-src-error-rs"></a>

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum KmsError {
    #[error("no such key")]
    NoSuchKey,
    #[error("algorithm unavailable in this build")]
    AlgUnavailable,
    #[error("key expired or not valid for use")]
    Expired,
    #[error("entropy/rng error")]
    Entropy,
    #[error("verification failed")]
    VerifyFailed,
    #[error("capability required")]
    CapabilityMissing,
    #[error("rotation in progress; try again")]
    Busy,
    #[error("internal error: {0}")]
    Internal(&'static str),
}

impl KmsError {
    #[must_use]
    pub fn kind(&self) -> &'static str {
        match self {
            KmsError::NoSuchKey => "NoSuchKey",
            KmsError::AlgUnavailable => "AlgUnavailable",
            KmsError::Expired => "Expired",
            KmsError::Entropy => "Entropy",
            KmsError::VerifyFailed => "VerifyFailed",
            KmsError::CapabilityMissing => "CapabilityMissing",
            KmsError::Busy => "Busy",
            KmsError::Internal(_) => "Internal",
        }
    }
}

```

### crates/ron-kms/src/lib.rs
<a id="crates-ron-kms-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]
#![deny(rust_2018_idioms, clippy::all, clippy::pedantic)]
#![allow(clippy::missing_errors_doc, clippy::module_name_repetitions)]

pub mod backends;
pub mod error;
pub mod ops;
pub mod traits;
pub mod types;
pub mod util;

#[cfg(feature = "with-metrics")]
pub mod metrics;
#[cfg(feature = "with-metrics")]
mod telemetry;

pub mod prelude;

pub use crate::error::KmsError;
pub use crate::traits::{Keystore, Signer, Verifier};
pub use crate::types::{Alg, KeyId};

#[must_use]
pub fn memory_keystore() -> backends::memory::MemoryKeystore {
    backends::memory::MemoryKeystore::default()
}

```

### crates/ron-kms/src/metrics.rs
<a id="crates-ron-kms-src-metrics-rs"></a>

```rust
//! RO:WHAT  Prometheus metrics for ron-kms.
//! RO:INV   Small, stable label sets to avoid cardinality explosions.

#![cfg(feature = "with-metrics")]

use prometheus::{opts, register_histogram, register_int_counter_vec, Histogram, IntCounterVec};

pub struct KmsMetrics {
    /// Operation counts, labeled by operation and algorithm.
    /// op ∈ {create,rotate,sign,verify,attest}
    /// alg ∈ {"ed25519", ...}
    pub ops_total: IntCounterVec,

    /// Failure counts, labeled by operation and error kind.
    /// op ∈ {create,rotate,sign,verify,attest}
    /// kind ∈ {"NoSuchKey","AlgUnavailable","Expired","Entropy","VerifyFailed","CapabilityMissing","Busy","Internal"}
    pub failures_total: IntCounterVec,

    /// Latency histogram (seconds) across ops.
    pub op_latency_seconds: Histogram,
}

impl KmsMetrics {
    /// Registers all metrics in the default Prometheus registry.
    #[must_use]
    pub fn register() -> Self {
        let ops_total = register_int_counter_vec!(
            opts!(
                "kms_ops_total",
                "Total successful KMS operations by type and algorithm"
            ),
            &["op", "alg"]
        )
        .expect("register kms_ops_total");

        let failures_total = register_int_counter_vec!(
            opts!(
                "kms_failures_total",
                "Total failed KMS operations by type and error kind"
            ),
            &["op", "kind"]
        )
        .expect("register kms_failures_total");

        // Buckets: generic powers-of-two-ish, adequate for dev; refine later if needed.
        let op_latency_seconds = register_histogram!(
            "kms_op_latency_seconds",
            "Latency of KMS operations in seconds"
        )
        .expect("register kms_op_latency_seconds");

        Self {
            ops_total,
            failures_total,
            op_latency_seconds,
        }
    }
}

```

### crates/ron-kms/src/ops/attest.rs
<a id="crates-ron-kms-src-ops-attest-rs"></a>

```rust
use crate::{
    error::KmsError,
    traits::Keystore,
    types::{KeyId, KeyMeta},
};
#[cfg(feature = "with-metrics")]
use {crate::telemetry, std::time::Instant};

pub fn attest<K: Keystore>(ks: &K, kid: &KeyId) -> Result<KeyMeta, KmsError> {
    #[cfg(feature = "with-metrics")]
    let start = Instant::now();

    let res = ks.meta(kid);

    #[cfg(feature = "with-metrics")]
    {
        let m = telemetry::metrics();
        match &res {
            Ok(meta) => {
                m.ops_total
                    .with_label_values(&["attest", meta.alg.as_str()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
            Err(e) => {
                m.failures_total
                    .with_label_values(&["attest", e.kind()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
        }
    }
    res
}

```

### crates/ron-kms/src/ops/create.rs
<a id="crates-ron-kms-src-ops-create-rs"></a>

```rust
use crate::{error::KmsError, traits::Keystore, types::KeyId};
#[cfg(feature = "with-metrics")]
use {crate::telemetry, std::time::Instant};

pub fn ed25519<K: Keystore>(ks: &K, tenant: &str, purpose: &str) -> Result<KeyId, KmsError> {
    #[cfg(feature = "with-metrics")]
    let start = Instant::now();

    let res = ks.create_ed25519(tenant, purpose);

    #[cfg(feature = "with-metrics")]
    {
        let m = telemetry::metrics();
        match &res {
            Ok(kid) => {
                m.ops_total
                    .with_label_values(&["create", kid.alg.as_str()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
            Err(e) => {
                m.failures_total
                    .with_label_values(&["create", e.kind()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
        }
    }
    res
}

```

### crates/ron-kms/src/ops/mod.rs
<a id="crates-ron-kms-src-ops-mod-rs"></a>

```rust
pub mod attest;
pub mod create;
pub mod rotate;
pub mod sign;
pub mod verify;
pub mod verify_batch;

```

### crates/ron-kms/src/ops/rotate.rs
<a id="crates-ron-kms-src-ops-rotate-rs"></a>

```rust
use crate::{error::KmsError, traits::Keystore, types::KeyId};
#[cfg(feature = "with-metrics")]
use {crate::telemetry, std::time::Instant};

pub fn rotate<K: Keystore>(ks: &K, kid: &KeyId) -> Result<KeyId, KmsError> {
    #[cfg(feature = "with-metrics")]
    let start = Instant::now();

    let res = ks.rotate(kid);

    #[cfg(feature = "with-metrics")]
    {
        let m = telemetry::metrics();
        match &res {
            Ok(new_kid) => {
                m.ops_total
                    .with_label_values(&["rotate", new_kid.alg.as_str()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
            Err(e) => {
                m.failures_total
                    .with_label_values(&["rotate", e.kind()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
        }
    }
    res
}

```

### crates/ron-kms/src/ops/sign.rs
<a id="crates-ron-kms-src-ops-sign-rs"></a>

```rust
use crate::{error::KmsError, traits::Signer, types::KeyId};
#[cfg(feature = "with-metrics")]
use {crate::telemetry, std::time::Instant};

pub fn sign<K: Signer>(ks: &K, kid: &KeyId, msg: &[u8]) -> Result<Vec<u8>, KmsError> {
    #[cfg(feature = "with-metrics")]
    let start = Instant::now();

    let res = ks.sign(kid, msg);

    #[cfg(feature = "with-metrics")]
    {
        let m = telemetry::metrics();
        match &res {
            Ok(_) => {
                m.ops_total
                    .with_label_values(&["sign", kid.alg.as_str()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
            Err(e) => {
                m.failures_total
                    .with_label_values(&["sign", e.kind()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
        }
    }
    res
}

```

### crates/ron-kms/src/ops/unwrap.rs
<a id="crates-ron-kms-src-ops-unwrap-rs"></a>

```rust
// unwrap op scaffold

```

### crates/ron-kms/src/ops/verify.rs
<a id="crates-ron-kms-src-ops-verify-rs"></a>

```rust
use crate::{error::KmsError, traits::Verifier, types::KeyId};
#[cfg(feature = "with-metrics")]
use {crate::telemetry, std::time::Instant};

pub fn verify<K: Verifier>(ks: &K, kid: &KeyId, msg: &[u8], sig: &[u8]) -> Result<bool, KmsError> {
    #[cfg(feature = "with-metrics")]
    let start = Instant::now();

    let res = ks.verify(kid, msg, sig);

    #[cfg(feature = "with-metrics")]
    {
        let m = telemetry::metrics();
        match &res {
            Ok(_) => {
                m.ops_total
                    .with_label_values(&["verify", kid.alg.as_str()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
            Err(e) => {
                m.failures_total
                    .with_label_values(&["verify", e.kind()])
                    .inc();
                m.op_latency_seconds.observe(start.elapsed().as_secs_f64());
            }
        }
    }
    res
}

```

### crates/ron-kms/src/ops/verify_batch.rs
<a id="crates-ron-kms-src-ops-verifybatch-rs"></a>

```rust
//! RO:WHAT  Batch verification with a fast all-or-nothing path using dalek's batch API,
//!          and a per-item fallback to produce precise booleans when a batch contains failures.
//! RO:WHY   Batch verify amortizes expensive scalar multiplications; this is our “God tier” lever.
//! RO:INV   - All items must share `Alg::Ed25519` for fast path.
//!          - If the batch fails as a whole, we fall back to per-item verify to return Vec<bool>.

use crate::{
    error::KmsError,
    traits::pubkey::PubkeyProvider,
    traits::Verifier,
    types::{Alg, KeyId},
};

/// One item to verify in a batch.
pub struct VerifyItem<'m, 's> {
    pub kid: &'m KeyId,
    pub msg: &'m [u8],
    pub sig: &'s [u8],
}

/// Verify a batch of (kid, msg, sig). Returns per-item booleans.
///
/// Fast path (all Ed25519, all pass): single dalek batch verify → Vec<true>.
/// If the batch fails, we fall back to per-item verify for correctness.
/// For mixed algorithms, we chunk by alg (currently only Ed25519 supported).
pub fn verify_batch<K>(kms: &K, items: &[VerifyItem<'_, '_>]) -> Result<Vec<bool>, KmsError>
where
    K: Verifier + PubkeyProvider,
{
    if items.is_empty() {
        return Ok(Vec::new());
    }

    // Verify all items are Ed25519 (current supported fast path).
    let all_ed25519 = items.iter().all(|it| it.kid.alg == Alg::Ed25519);
    if !all_ed25519 {
        // Fallback: per-item verify for any non-Ed25519.
        return items
            .iter()
            .map(|it| kms.verify(it.kid, it.msg, it.sig))
            .collect();
    }

    // Collect publics, messages, signatures for dalek batch.
    let mut msgs: Vec<&[u8]> = Vec::with_capacity(items.len());
    let mut sigs: Vec<ed25519_dalek::Signature> = Vec::with_capacity(items.len());
    let mut pubs: Vec<ed25519_dalek::VerifyingKey> = Vec::with_capacity(items.len());

    for it in items {
        let pk_bytes: [u8; 32] = kms.verifying_key_bytes(it.kid)?;
        let vk = ed25519_dalek::VerifyingKey::from_bytes(&pk_bytes)
            .map_err(|_| KmsError::VerifyFailed)?;
        let sig =
            ed25519_dalek::Signature::from_slice(it.sig).map_err(|_| KmsError::VerifyFailed)?;

        pubs.push(vk);
        sigs.push(sig);
        msgs.push(it.msg);
    }

    // Fast all-or-nothing batch verify (requires ed25519-dalek "batch" feature).
    let batch_ok = ed25519_dalek::verify_batch(&msgs, &sigs, &pubs).is_ok();
    if batch_ok {
        return Ok(vec![true; items.len()]);
    }

    // Fallback: precise booleans per item.
    items
        .iter()
        .map(|it| kms.verify(it.kid, it.msg, it.sig))
        .collect()
}

```

### crates/ron-kms/src/ops/wrap.rs
<a id="crates-ron-kms-src-ops-wrap-rs"></a>

```rust
// wrap op scaffold

```

### crates/ron-kms/src/pq/mldsa.rs
<a id="crates-ron-kms-src-pq-mldsa-rs"></a>

```rust
// ML-DSA scaffold (feature: mldsa)

```

### crates/ron-kms/src/pq/mlkem.rs
<a id="crates-ron-kms-src-pq-mlkem-rs"></a>

```rust
// ML-KEM scaffold (feature: mlkem)

```

### crates/ron-kms/src/pq/mod.rs
<a id="crates-ron-kms-src-pq-mod-rs"></a>

```rust
// PQ adapters scaffold
pub mod mlkem;
pub mod mldsa;
pub mod slhdsa;

```

### crates/ron-kms/src/pq/slhdsa.rs
<a id="crates-ron-kms-src-pq-slhdsa-rs"></a>

```rust
// SLH-DSA scaffold (feature: slhdsa)

```

### crates/ron-kms/src/prelude.rs
<a id="crates-ron-kms-src-prelude-rs"></a>

```rust
// Tiny prelude for callers.
pub use crate::{
    error::KmsError,
    traits::{Keystore, Signer, Verifier},
    types::{Alg, KeyId},
};

```

### crates/ron-kms/src/sealed/aead.rs
<a id="crates-ron-kms-src-sealed-aead-rs"></a>

```rust
// AEAD scaffold (no crypto)

```

### crates/ron-kms/src/sealed/anti_rollback.rs
<a id="crates-ron-kms-src-sealed-antirollback-rs"></a>

```rust
// Anti-rollback scaffold

```

### crates/ron-kms/src/sealed/header.rs
<a id="crates-ron-kms-src-sealed-header-rs"></a>

```rust
// Sealed header scaffold
#[allow(dead_code)]
pub struct SealedHeader {
    pub version: u8,
}

```

### crates/ron-kms/src/sealed/mod.rs
<a id="crates-ron-kms-src-sealed-mod-rs"></a>

```rust
// Sealed primitives scaffold
pub mod header;
pub mod aead;
pub mod anti_rollback;
pub mod store;

```

### crates/ron-kms/src/sealed/store.rs
<a id="crates-ron-kms-src-sealed-store-rs"></a>

```rust
// Sealed store trait scaffold
use crate::error::KmResult;

pub trait SealedStore {
    fn put(&self, _blob: &[u8]) -> KmResult<()>;
}

```

### crates/ron-kms/src/telemetry.rs
<a id="crates-ron-kms-src-telemetry-rs"></a>

```rust
//! RO:WHAT  Lazy, single global access to KMS Prometheus metrics.
//! RO:WHY   Avoid passing metrics handles everywhere; keep it opt-in via the `with-metrics` feature.

#![cfg(feature = "with-metrics")]

use crate::metrics::KmsMetrics;
use once_cell::sync::OnceCell;

static METRICS: OnceCell<KmsMetrics> = OnceCell::new();

/// Get the process-global metrics set (registers on first use).
#[must_use]
pub fn metrics() -> &'static KmsMetrics {
    METRICS.get_or_init(KmsMetrics::register)
}

```

### crates/ron-kms/src/traits/hybrid.rs
<a id="crates-ron-kms-src-traits-hybrid-rs"></a>

```rust
// Hybrid trait scaffold
use crate::error::KmResult;

pub trait Hybrid {
    fn wrap(&self, _pt: &[u8]) -> KmResult<Vec<u8>>;
    fn unwrap_(&self, _ct: &[u8]) -> KmResult<Vec<u8>>;
}

```

### crates/ron-kms/src/traits/kem.rs
<a id="crates-ron-kms-src-traits-kem-rs"></a>

```rust
// KEM trait scaffold
use crate::error::KmResult;

pub trait Kem {
    fn encap(&self, _peer_pub: &[u8]) -> KmResult<(Vec<u8>, Vec<u8>)>;
    fn decap(&self, _ct: &[u8]) -> KmResult<Vec<u8>>;
}

```

### crates/ron-kms/src/traits/keystore.rs
<a id="crates-ron-kms-src-traits-keystore-rs"></a>

```rust
use crate::{
    error::KmsError,
    types::{Alg, KeyId, KeyMeta},
};

/// Custody lifecycle — create/rotate/get metadata/attest (subset for core boot).
pub trait Keystore: Send + Sync {
    fn create_ed25519(&self, tenant: &str, purpose: &str) -> Result<KeyId, KmsError>;
    fn rotate(&self, kid: &KeyId) -> Result<KeyId, KmsError>;
    fn alg(&self, kid: &KeyId) -> Result<Alg, KmsError>;
    /// Public metadata about a key root.
    fn meta(&self, kid: &KeyId) -> Result<KeyMeta, KmsError>;
}

```

### crates/ron-kms/src/traits/mod.rs
<a id="crates-ron-kms-src-traits-mod-rs"></a>

```rust
//! KMS trait surfaces

pub mod keystore;
pub mod signer;
pub mod verifier;

// Internal-only helper for batch verify fast path.
pub(crate) mod pubkey;

pub use keystore::Keystore;
pub use signer::Signer;
pub use verifier::Verifier;

```

### crates/ron-kms/src/traits/pubkey.rs
<a id="crates-ron-kms-src-traits-pubkey-rs"></a>

```rust
//! RO:WHAT  Internal trait to expose verifying keys for batch verify fast paths.
//! RO:WHY   Our public Verifier trait only exposes boolean checks; batch verify
//!          needs access to the raw verifying keys to use dalek's batch API.

use crate::{error::KmsError, types::KeyId};

/// Internal-only surface to fetch verifying key bytes for a given `KeyId` version.
/// Implemented by in-crate backends (memory, file, pkcs11) as needed.
pub trait PubkeyProvider {
    /// Returns the raw verifying key bytes (Ed25519, 32 bytes) for this `KeyId`/version.
    fn verifying_key_bytes(&self, kid: &KeyId) -> Result<[u8; 32], KmsError>;
}

```

### crates/ron-kms/src/traits/signer.rs
<a id="crates-ron-kms-src-traits-signer-rs"></a>

```rust
use crate::{error::KmsError, types::KeyId};

pub trait Signer: Send + Sync {
    /// Sign message bytes with the private key designated by `kid`.
    fn sign(&self, kid: &KeyId, msg: &[u8]) -> Result<Vec<u8>, KmsError>;
}

```

### crates/ron-kms/src/traits/verifier.rs
<a id="crates-ron-kms-src-traits-verifier-rs"></a>

```rust
use crate::{error::KmsError, types::KeyId};

pub trait Verifier: Send + Sync {
    /// Verify the signature for `msg` under `kid`'s public key.
    fn verify(&self, kid: &KeyId, msg: &[u8], sig: &[u8]) -> Result<bool, KmsError>;
}

```

### crates/ron-kms/src/types.rs
<a id="crates-ron-kms-src-types-rs"></a>

```rust
use serde::{Deserialize, Serialize};
use std::{fmt, str::FromStr};
use time::OffsetDateTime;
use uuid::Uuid;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Alg {
    Ed25519,
    // Future: MlDsa, SlhDsa, X25519, MlKem...
}

impl Alg {
    #[must_use]
    pub const fn as_str(self) -> &'static str {
        match self {
            Alg::Ed25519 => "ed25519",
        }
    }
}

impl fmt::Display for Alg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Alg::Ed25519 => write!(f, "Ed25519"),
        }
    }
}

impl FromStr for Alg {
    type Err = &'static str;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Ed25519" | "ed25519" => Ok(Self::Ed25519),
            _ => Err("unknown alg"),
        }
    }
}

/// Versioned key identifier: `<tenant>/<purpose>/<alg>/<uuid>#vN`
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct KeyId {
    pub tenant: String,
    pub purpose: String,
    pub alg: Alg,
    pub uuid: Uuid,
    pub version: u32,
}

impl KeyId {
    #[must_use]
    pub fn new(tenant: impl Into<String>, purpose: impl Into<String>, alg: Alg) -> Self {
        Self {
            tenant: tenant.into(),
            purpose: purpose.into(),
            alg,
            uuid: Uuid::new_v4(),
            version: 1,
        }
    }

    #[must_use]
    pub fn bump(&self) -> Self {
        let mut k = self.clone();
        k.version += 1;
        k
    }

    #[must_use]
    pub fn now_utc_ms() -> i128 {
        OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000
    }
}

impl fmt::Display for KeyId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}/{}/{}/{}#v{}",
            self.tenant, self.purpose, self.alg, self.uuid, self.version
        )
    }
}

impl FromStr for KeyId {
    type Err = &'static str;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (left, vpart) = s.rsplit_once("#v").ok_or("missing version")?;
        let version: u32 = vpart.parse().map_err(|_| "bad version")?;
        let mut it = left.split('/');
        let tenant = it.next().ok_or("missing tenant")?;
        let purpose = it.next().ok_or("missing purpose")?;
        let alg = it.next().ok_or("missing alg")?.parse().map_err(|_| "alg")?;
        let uuid_s = it.next().ok_or("missing uuid")?;
        if it.next().is_some() {
            return Err("too many parts");
        }
        let uuid = uuid::Uuid::parse_str(uuid_s).map_err(|_| "uuid")?;
        Ok(Self {
            tenant: tenant.to_string(),
            purpose: purpose.to_string(),
            alg,
            uuid,
            version,
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct KeyMeta {
    pub alg: Alg,
    pub current_version: u32,
    pub versions: Vec<u32>,
    pub created_ms: i128,
}

```

### crates/ron-kms/src/util/ct.rs
<a id="crates-ron-kms-src-util-ct-rs"></a>

```rust
// RO:WHAT Constant-time helpers (tiny, just equality for now).
#[must_use]
pub fn ct_eq(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }
    let mut acc = 0u8;
    for (&x, &y) in a.iter().zip(b.iter()) {
        acc |= x ^ y;
    }
    acc == 0
}

```

### crates/ron-kms/src/util/mod.rs
<a id="crates-ron-kms-src-util-mod-rs"></a>

```rust
// Module glue for util/ submodules.
pub mod ct;
pub mod time;
pub mod zeroize;

pub use ct::*;
pub use time::*;
pub use zeroize::*;

```

### crates/ron-kms/src/util/time.rs
<a id="crates-ron-kms-src-util-time-rs"></a>

```rust
use time::OffsetDateTime;

#[must_use]
pub fn now_utc_ms() -> i128 {
    OffsetDateTime::now_utc().unix_timestamp_nanos() / 1_000_000
}

```

### crates/ron-kms/src/util/zeroize.rs
<a id="crates-ron-kms-src-util-zeroize-rs"></a>

```rust
// RO:WHAT Helpers to wipe secrets explicitly when using Vec/Box.
use zeroize::Zeroize;

pub fn wipe_vec(v: &mut Vec<u8>) {
    v.zeroize();
}

```

### crates/ron-kms/telemetry.rs
<a id="crates-ron-kms-telemetry-rs"></a>

```rust
#![cfg(feature = "with-metrics")]

use once_cell::sync::OnceCell;
use crate::metrics::KmsMetrics;

static METRICS: OnceCell<KmsMetrics> = OnceCell::new();

#[must_use]
pub fn metrics() -> &'static KmsMetrics {
    METRICS.get_or_init(KmsMetrics::register)
}

```

### crates/ron-kms/testing/kms-dev-server/Cargo.toml
<a id="crates-ron-kms-testing-kms-dev-server-Cargo-toml"></a>

```toml
[package]
name = "kms-dev-server"
version = "0.0.0"
edition = "2021"
publish = false

[dependencies]
# Intentionally empty; fill when building the dev server harness.

```

### crates/ron-kms/testing/kms-dev-server/src/main.rs
<a id="crates-ron-kms-testing-kms-dev-server-src-main-rs"></a>

```rust
// Dev server harness scaffold (keep separate from library)
fn main() {
    println!("kms-dev-server scaffold (no HTTP yet)");
}

```

### crates/ron-kms/tests/attest.rs
<a id="crates-ron-kms-tests-attest-rs"></a>

```rust
use ron_kms::ops::attest::attest;
use ron_kms::{memory_keystore, Keystore}; // <-- import the function, not the module

#[test]
fn attest_reports_versions_and_current() {
    let kms = memory_keystore();
    let kid_v1 = kms.create_ed25519("auth", "signing").expect("create");

    let meta1 = attest(&kms, &kid_v1).expect("attest v1");
    assert_eq!(meta1.current_version, 1);
    assert_eq!(meta1.versions, vec![1]);
    assert!(meta1.created_ms > 0);

    let kid_v2 = kms.rotate(&kid_v1).expect("rotate");
    let meta2 = attest(&kms, &kid_v2).expect("attest v2");
    assert_eq!(meta2.current_version, 2);
    assert_eq!(meta2.versions, vec![1, 2]);
    assert_eq!(meta2.created_ms, meta1.created_ms);
}

```

### crates/ron-kms/tests/interop_kats.rs
<a id="crates-ron-kms-tests-interopkats-rs"></a>

```rust
// interop KATs scaffold

```

### crates/ron-kms/tests/keyid_and_roundtrip.rs
<a id="crates-ron-kms-tests-keyidandroundtrip-rs"></a>

```rust
use ron_kms::{memory_keystore, Alg, KeyId, Keystore, Signer, Verifier};
use std::str::FromStr;

#[test]
fn keyid_format_parse_roundtrip() {
    let kid = KeyId::new("tenantA", "purposeX", Alg::Ed25519);
    let s = kid.to_string();
    let parsed = KeyId::from_str(&s).expect("parse");
    assert_eq!(kid.tenant, parsed.tenant);
    assert_eq!(kid.purpose, parsed.purpose);
    assert_eq!(kid.alg, parsed.alg);
    assert_eq!(kid.uuid, parsed.uuid);
    assert_eq!(kid.version, parsed.version);
}

#[test]
fn sign_verify_roundtrip() {
    let kms = memory_keystore();
    let kid = kms.create_ed25519("auth", "signing").expect("create");
    let msg = b"roundtrip";
    let sig = kms.sign(&kid, msg).expect("sign");
    let ok = kms.verify(&kid, msg, &sig).expect("verify");
    assert!(ok);
}

#[test]
fn rotate_bumps_version_and_still_works() {
    let kms = memory_keystore();
    let kid_v1 = kms.create_ed25519("auth", "signing").expect("create");

    // v1 sign/verify
    let msg1 = b"before rotate";
    let sig1 = kms.sign(&kid_v1, msg1).expect("sign v1");
    assert!(kms.verify(&kid_v1, msg1, &sig1).expect("verify v1"));

    // rotate → v2
    let kid_v2 = kms.rotate(&kid_v1).expect("rotate");
    assert_eq!(kid_v2.version, kid_v1.version + 1);

    // v2 sign/verify
    let msg2 = b"after rotate";
    let sig2 = kms.sign(&kid_v2, msg2).expect("sign v2");
    assert!(kms.verify(&kid_v2, msg2, &sig2).expect("verify v2"));

    // NOTE: In the current dev backend, rotating replaces the stored public key.
    // Old signatures are not guaranteed to verify after rotation (by design here).
}

```

### crates/ron-kms/tests/unit/attest_test.rs
<a id="crates-ron-kms-tests-unit-attesttest-rs"></a>

```rust
// scaffold test placeholder

```

### crates/ron-kms/tests/unit/rotate_test.rs
<a id="crates-ron-kms-tests-unit-rotatetest-rs"></a>

```rust
// scaffold test placeholder

```

### crates/ron-kms/tests/unit/sealed_header_test.rs
<a id="crates-ron-kms-tests-unit-sealedheadertest-rs"></a>

```rust
// scaffold test placeholder

```

### crates/ron-kms/tests/unit/zeroize_test.rs
<a id="crates-ron-kms-tests-unit-zeroizetest-rs"></a>

```rust
// scaffold test placeholder

```

### crates/ron-kms/tests/versioned_verify.rs
<a id="crates-ron-kms-tests-versionedverify-rs"></a>

```rust
use ron_kms::{memory_keystore, Keystore, Signer, Verifier};

#[test]
fn old_signatures_verify_after_rotate() {
    let kms = memory_keystore();

    // Create v1 and sign a message.
    let kid_v1 = kms.create_ed25519("auth", "signing").expect("create");
    let msg_v1 = b"old message";
    let sig_v1 = kms.sign(&kid_v1, msg_v1).expect("sign v1");
    assert!(kms.verify(&kid_v1, msg_v1, &sig_v1).expect("verify v1"));

    // Rotate to v2.
    let kid_v2 = kms.rotate(&kid_v1).expect("rotate");
    assert_eq!(kid_v2.version, kid_v1.version + 1);

    // Old v1 signature should still verify using the v1 KeyId.
    assert!(kms
        .verify(&kid_v1, msg_v1, &sig_v1)
        .expect("verify v1 after rotate"));

    // New v2 signing works; verifying with v2 KeyId works.
    let msg_v2 = b"new message";
    let sig_v2 = kms.sign(&kid_v2, msg_v2).expect("sign v2");
    assert!(kms.verify(&kid_v2, msg_v2, &sig_v2).expect("verify v2"));

    // Attempting to sign with stale v1 should fail (only latest may sign).
    let stale_sign = kms.sign(&kid_v1, b"should fail");
    assert!(stale_sign.is_err(), "stale KeyId should not sign");
}

```

### crates/ron-kms/xtask/src/main.rs
<a id="crates-ron-kms-xtask-src-main-rs"></a>

```rust
// xtask scaffold (placeholder CLI)
fn main() {
    println!("xtask: ron-kms2 scaffold");
}

```

