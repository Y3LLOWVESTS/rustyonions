<!-- Generated by scripts/make_crate_codex.sh on 2025-11-23T00:01:56Z -->
# Code Bundle — `omnigate`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/omnigate/.cargo/config.toml](#crates-omnigate--cargo-config-toml)
- [crates/omnigate/.github/workflows/chaos.yml](#crates-omnigate--github-workflows-chaos-yml)
- [crates/omnigate/.github/workflows/ci.yml](#crates-omnigate--github-workflows-ci-yml)
- [crates/omnigate/.github/workflows/perf-regression.yml](#crates-omnigate--github-workflows-perf-regression-yml)
- [crates/omnigate/.github/workflows/public-api.yml](#crates-omnigate--github-workflows-public-api-yml)
- [crates/omnigate/.github/workflows/render-mermaid.yml](#crates-omnigate--github-workflows-render-mermaid-yml)
- [crates/omnigate/Cargo.toml](#crates-omnigate-Cargo-toml)
- [crates/omnigate/benches/hydration.rs](#crates-omnigate-benches-hydration-rs)
- [crates/omnigate/benches/media_range.rs](#crates-omnigate-benches-mediarange-rs)
- [crates/omnigate/benches/middleware_ping.rs](#crates-omnigate-benches-middlewareping-rs)
- [crates/omnigate/build.rs](#crates-omnigate-build-rs)
- [crates/omnigate/configs/omnigate.toml](#crates-omnigate-configs-omnigate-toml)
- [crates/omnigate/configs/policy.bundle.json](#crates-omnigate-configs-policy-bundle-json)
- [crates/omnigate/configs/staging.toml](#crates-omnigate-configs-staging-toml)
- [crates/omnigate/deny.toml](#crates-omnigate-deny-toml)
- [crates/omnigate/fuzz/Cargo.toml](#crates-omnigate-fuzz-Cargo-toml)
- [crates/omnigate/fuzz/fuzz_targets/capability.rs](#crates-omnigate-fuzz-fuzztargets-capability-rs)
- [crates/omnigate/fuzz/fuzz_targets/decompress_guard.rs](#crates-omnigate-fuzz-fuzztargets-decompressguard-rs)
- [crates/omnigate/fuzz/fuzz_targets/headers.rs](#crates-omnigate-fuzz-fuzztargets-headers-rs)
- [crates/omnigate/rust-toolchain.toml](#crates-omnigate-rust-toolchain-toml)
- [crates/omnigate/scripts/check_boundary.sh](#crates-omnigate-scripts-checkboundary-sh)
- [crates/omnigate/scripts/ci_metrics_guard.sh](#crates-omnigate-scripts-cimetricsguard-sh)
- [crates/omnigate/scripts/hnDL_sim.sh](#crates-omnigate-scripts-hnDLsim-sh)
- [crates/omnigate/scripts/inject_faults.sh](#crates-omnigate-scripts-injectfaults-sh)
- [crates/omnigate/scripts/render_mermaid.sh](#crates-omnigate-scripts-rendermermaid-sh)
- [crates/omnigate/scripts/sanity_omnigate.sh](#crates-omnigate-scripts-sanityomnigate-sh)
- [crates/omnigate/scripts/smoke_omnigate.sh](#crates-omnigate-scripts-smokeomnigate-sh)
- [crates/omnigate/scripts/smoke_policy.sh](#crates-omnigate-scripts-smokepolicy-sh)
- [crates/omnigate/scripts/smoke_readiness.sh](#crates-omnigate-scripts-smokereadiness-sh)
- [crates/omnigate/scripts/soak.sh](#crates-omnigate-scripts-soak-sh)
- [crates/omnigate/src/admission/fair_queue.rs](#crates-omnigate-src-admission-fairqueue-rs)
- [crates/omnigate/src/admission/mod.rs](#crates-omnigate-src-admission-mod-rs)
- [crates/omnigate/src/admission/quotas.rs](#crates-omnigate-src-admission-quotas-rs)
- [crates/omnigate/src/auth/capability.rs](#crates-omnigate-src-auth-capability-rs)
- [crates/omnigate/src/auth/mod.rs](#crates-omnigate-src-auth-mod-rs)
- [crates/omnigate/src/auth/passport_client.rs](#crates-omnigate-src-auth-passportclient-rs)
- [crates/omnigate/src/auth/revocation.rs](#crates-omnigate-src-auth-revocation-rs)
- [crates/omnigate/src/bootstrap/health_probe.rs](#crates-omnigate-src-bootstrap-healthprobe-rs)
- [crates/omnigate/src/bootstrap/metrics_server.rs](#crates-omnigate-src-bootstrap-metricsserver-rs)
- [crates/omnigate/src/bootstrap/mod.rs](#crates-omnigate-src-bootstrap-mod-rs)
- [crates/omnigate/src/bootstrap/server.rs](#crates-omnigate-src-bootstrap-server-rs)
- [crates/omnigate/src/config/env.rs](#crates-omnigate-src-config-env-rs)
- [crates/omnigate/src/config/file.rs](#crates-omnigate-src-config-file-rs)
- [crates/omnigate/src/config/mod.rs](#crates-omnigate-src-config-mod-rs)
- [crates/omnigate/src/config/reload.rs](#crates-omnigate-src-config-reload-rs)
- [crates/omnigate/src/config/validate.rs](#crates-omnigate-src-config-validate-rs)
- [crates/omnigate/src/downstream/dht_client.rs](#crates-omnigate-src-downstream-dhtclient-rs)
- [crates/omnigate/src/downstream/error.rs](#crates-omnigate-src-downstream-error-rs)
- [crates/omnigate/src/downstream/hedge.rs](#crates-omnigate-src-downstream-hedge-rs)
- [crates/omnigate/src/downstream/index_client.rs](#crates-omnigate-src-downstream-indexclient-rs)
- [crates/omnigate/src/downstream/latency.rs](#crates-omnigate-src-downstream-latency-rs)
- [crates/omnigate/src/downstream/mailbox_client.rs](#crates-omnigate-src-downstream-mailboxclient-rs)
- [crates/omnigate/src/downstream/mod.rs](#crates-omnigate-src-downstream-mod-rs)
- [crates/omnigate/src/downstream/registry.rs](#crates-omnigate-src-downstream-registry-rs)
- [crates/omnigate/src/downstream/retry.rs](#crates-omnigate-src-downstream-retry-rs)
- [crates/omnigate/src/downstream/storage_client.rs](#crates-omnigate-src-downstream-storageclient-rs)
- [crates/omnigate/src/downstream/types.rs](#crates-omnigate-src-downstream-types-rs)
- [crates/omnigate/src/errors/http_map.rs](#crates-omnigate-src-errors-httpmap-rs)
- [crates/omnigate/src/errors/mod.rs](#crates-omnigate-src-errors-mod-rs)
- [crates/omnigate/src/errors/reasons.rs](#crates-omnigate-src-errors-reasons-rs)
- [crates/omnigate/src/hydration/compose.rs](#crates-omnigate-src-hydration-compose-rs)
- [crates/omnigate/src/hydration/mod.rs](#crates-omnigate-src-hydration-mod-rs)
- [crates/omnigate/src/hydration/planner.rs](#crates-omnigate-src-hydration-planner-rs)
- [crates/omnigate/src/lib.rs](#crates-omnigate-src-lib-rs)
- [crates/omnigate/src/main.rs](#crates-omnigate-src-main-rs)
- [crates/omnigate/src/metrics/gates.rs](#crates-omnigate-src-metrics-gates-rs)
- [crates/omnigate/src/metrics/mod.rs](#crates-omnigate-src-metrics-mod-rs)
- [crates/omnigate/src/metrics/registry.rs](#crates-omnigate-src-metrics-registry-rs)
- [crates/omnigate/src/middleware/body_caps.rs](#crates-omnigate-src-middleware-bodycaps-rs)
- [crates/omnigate/src/middleware/classify.rs](#crates-omnigate-src-middleware-classify-rs)
- [crates/omnigate/src/middleware/corr_id.rs](#crates-omnigate-src-middleware-corrid-rs)
- [crates/omnigate/src/middleware/decompress_guard.rs](#crates-omnigate-src-middleware-decompressguard-rs)
- [crates/omnigate/src/middleware/inflight.rs](#crates-omnigate-src-middleware-inflight-rs)
- [crates/omnigate/src/middleware/mod.rs](#crates-omnigate-src-middleware-mod-rs)
- [crates/omnigate/src/middleware/policy.rs](#crates-omnigate-src-middleware-policy-rs)
- [crates/omnigate/src/middleware/slow_loris.rs](#crates-omnigate-src-middleware-slowloris-rs)
- [crates/omnigate/src/observability/logging.rs](#crates-omnigate-src-observability-logging-rs)
- [crates/omnigate/src/observability/mod.rs](#crates-omnigate-src-observability-mod-rs)
- [crates/omnigate/src/observability/tracing_spans.rs](#crates-omnigate-src-observability-tracingspans-rs)
- [crates/omnigate/src/pq/mod.rs](#crates-omnigate-src-pq-mod-rs)
- [crates/omnigate/src/pq/negotiate.rs](#crates-omnigate-src-pq-negotiate-rs)
- [crates/omnigate/src/readiness/keys.rs](#crates-omnigate-src-readiness-keys-rs)
- [crates/omnigate/src/readiness/mod.rs](#crates-omnigate-src-readiness-mod-rs)
- [crates/omnigate/src/readiness/policy.rs](#crates-omnigate-src-readiness-policy-rs)
- [crates/omnigate/src/readiness/sampler.rs](#crates-omnigate-src-readiness-sampler-rs)
- [crates/omnigate/src/readiness/state.rs](#crates-omnigate-src-readiness-state-rs)
- [crates/omnigate/src/routes/mod.rs](#crates-omnigate-src-routes-mod-rs)
- [crates/omnigate/src/routes/ops.rs](#crates-omnigate-src-routes-ops-rs)
- [crates/omnigate/src/routes/v1/app.rs](#crates-omnigate-src-routes-v1-app-rs)
- [crates/omnigate/src/routes/v1/dht.rs](#crates-omnigate-src-routes-v1-dht-rs)
- [crates/omnigate/src/routes/v1/facet/feed.rs](#crates-omnigate-src-routes-v1-facet-feed-rs)
- [crates/omnigate/src/routes/v1/facet/graph.rs](#crates-omnigate-src-routes-v1-facet-graph-rs)
- [crates/omnigate/src/routes/v1/facet/media.rs](#crates-omnigate-src-routes-v1-facet-media-rs)
- [crates/omnigate/src/routes/v1/facet/mod.rs](#crates-omnigate-src-routes-v1-facet-mod-rs)
- [crates/omnigate/src/routes/v1/index.rs](#crates-omnigate-src-routes-v1-index-rs)
- [crates/omnigate/src/routes/v1/mailbox.rs](#crates-omnigate-src-routes-v1-mailbox-rs)
- [crates/omnigate/src/routes/v1/mod.rs](#crates-omnigate-src-routes-v1-mod-rs)
- [crates/omnigate/src/routes/v1/objects.rs](#crates-omnigate-src-routes-v1-objects-rs)
- [crates/omnigate/src/routes/v1/ping.rs](#crates-omnigate-src-routes-v1-ping-rs)
- [crates/omnigate/src/runtime/channels.rs](#crates-omnigate-src-runtime-channels-rs)
- [crates/omnigate/src/runtime/mod.rs](#crates-omnigate-src-runtime-mod-rs)
- [crates/omnigate/src/runtime/sample.rs](#crates-omnigate-src-runtime-sample-rs)
- [crates/omnigate/src/runtime/shutdown.rs](#crates-omnigate-src-runtime-shutdown-rs)
- [crates/omnigate/src/runtime/supervisor.rs](#crates-omnigate-src-runtime-supervisor-rs)
- [crates/omnigate/src/runtime/worker.rs](#crates-omnigate-src-runtime-worker-rs)
- [crates/omnigate/src/state.rs](#crates-omnigate-src-state-rs)
- [crates/omnigate/src/types/dto.rs](#crates-omnigate-src-types-dto-rs)
- [crates/omnigate/src/types/mod.rs](#crates-omnigate-src-types-mod-rs)
- [crates/omnigate/src/zk/mod.rs](#crates-omnigate-src-zk-mod-rs)
- [crates/omnigate/src/zk/no_mutate.rs](#crates-omnigate-src-zk-nomutate-rs)
- [crates/omnigate/src/zk/receipts.rs](#crates-omnigate-src-zk-receipts-rs)
- [crates/omnigate/testing/chaos/scenario.yml](#crates-omnigate-testing-chaos-scenario-yml)
- [crates/omnigate/testing/performance/baselines/p95_hydration.json](#crates-omnigate-testing-performance-baselines-p95hydration-json)
- [crates/omnigate/testing/performance/baselines/p95_range.json](#crates-omnigate-testing-performance-baselines-p95range-json)
- [crates/omnigate/testing/performance/hydrate_mix.sh](#crates-omnigate-testing-performance-hydratemix-sh)
- [crates/omnigate/testing/vectors/omnigate/error_413.json](#crates-omnigate-testing-vectors-omnigate-error413-json)
- [crates/omnigate/testing/vectors/omnigate/range_read.json](#crates-omnigate-testing-vectors-omnigate-rangeread-json)
- [crates/omnigate/testing/vectors/omnigate/unauth_401.json](#crates-omnigate-testing-vectors-omnigate-unauth401-json)
- [crates/omnigate/tests/admission_contract.rs](#crates-omnigate-tests-admissioncontract-rs)
- [crates/omnigate/tests/dto_serialization.rs](#crates-omnigate-tests-dtoserialization-rs)
- [crates/omnigate/tests/hardening.rs](#crates-omnigate-tests-hardening-rs)
- [crates/omnigate/tests/interop_vectors.rs](#crates-omnigate-tests-interopvectors-rs)
- [crates/omnigate/tests/loom_fanout.rs](#crates-omnigate-tests-loomfanout-rs)
- [crates/omnigate/tests/metrics_contract.rs](#crates-omnigate-tests-metricscontract-rs)
- [crates/omnigate/tests/middleware_contract.rs](#crates-omnigate-tests-middlewarecontract-rs)
- [crates/omnigate/tests/oap_limits.rs](#crates-omnigate-tests-oaplimits-rs)
- [crates/omnigate/tests/policy_gate.rs](#crates-omnigate-tests-policygate-rs)
- [crates/omnigate/tests/policy_metrics.rs](#crates-omnigate-tests-policymetrics-rs)
- [crates/omnigate/tests/readiness_error_rate.rs](#crates-omnigate-tests-readinesserrorrate-rs)
- [crates/omnigate/tests/readiness_inflight.rs](#crates-omnigate-tests-readinessinflight-rs)
- [crates/omnigate/tests/ready_truth.rs](#crates-omnigate-tests-readytruth-rs)
- [crates/omnigate/tests/readyz_overload.rs](#crates-omnigate-tests-readyzoverload-rs)
- [crates/omnigate/tests/zk_read_only.rs](#crates-omnigate-tests-zkreadonly-rs)
- [crates/omnigate/tests/zk_receipts.rs](#crates-omnigate-tests-zkreceipts-rs)

### crates/omnigate/.cargo/config.toml
<a id="crates-omnigate--cargo-config-toml"></a>

```toml
[build]
rustflags = []

[term]
verbose = false

```

### crates/omnigate/.github/workflows/chaos.yml
<a id="crates-omnigate--github-workflows-chaos-yml"></a>

```yaml
name: chaos
on:
  schedule:
    - cron: "0 3 * * 0"
jobs:
  soak:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Chaos/soak scaffold."

```

### crates/omnigate/.github/workflows/ci.yml
<a id="crates-omnigate--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [x86_64, aarch64]
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: echo "Scaffold CI placeholder."

```

### crates/omnigate/.github/workflows/perf-regression.yml
<a id="crates-omnigate--github-workflows-perf-regression-yml"></a>

```yaml
name: perf-regression
on:
  workflow_dispatch:
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Perf regression scaffold."

```

### crates/omnigate/.github/workflows/public-api.yml
<a id="crates-omnigate--github-workflows-public-api-yml"></a>

```yaml
name: public-api
on: [pull_request]
jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Public API guard scaffold."

```

### crates/omnigate/.github/workflows/render-mermaid.yml
<a id="crates-omnigate--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Render mermaid placeholder."

```

### crates/omnigate/Cargo.toml
<a id="crates-omnigate-Cargo-toml"></a>

```toml
[package]
name = "omnigate"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false
build = "build.rs"

[lib]
name = "omnigate"
path = "src/lib.rs"

[[bin]]
name = "omnigate"
path = "src/main.rs"

# Criterion uses its own harness
[[bench]]
name = "middleware_ping"
harness = false

[features]
default = []
arti = []

[dependencies]
# RON workspace crates
ron-kernel = { path = "../ron-kernel" }
ron-proto  = { path = "../ron-proto" }
oap        = { path = "../oap" }
ron-policy = { path = "../ron-policy" }     # used by PolicyLayer integration
ron-app-sdk = { path = "../ron-app-sdk" }

# Async/HTTP stack
tokio       = { version = "1", features = ["macros", "rt-multi-thread", "signal", "time", "io-util", "sync", "net", "fs"] }
axum        = { version = "0.7", default-features = false, features = ["tokio", "http1", "http2", "json", "query"] }
tower       = "0.5"
tower-http  = { version = "0.6.6", features = ["trace"] }
http        = "1"
tokio-util  = "0.7"

# Outbound HTTP (downstream clients)
reqwest = { version = "0.12", features = ["rustls-tls-native-roots", "json"] }

# Observability
tracing            = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus         = "0.14"

# Config & serde
serde           = { version = "1.0", features = ["derive"] }
serde_json      = "1"
toml            = "0.8"
humantime-serde = "1"

# Misc
thiserror    = "1"
anyhow       = "1"
bytes        = "1"
once_cell    = "1.19"
parking_lot  = "0.12"
futures      = "0.3"
futures-util = "0.3"          # used in middleware policy layer
rand         = "0.9"          # downstream retry/jitter (matches workspace pin)
tokio-rustls = "0.26.2"       # TLS (tokio_rustls::rustls types)
fastrand     = { workspace = true }  # corr_id request IDs

[dev-dependencies]
# Criterion bench harness
criterion = { version = "0.5.1", features = ["async_tokio"] }

# Tests: in-process server + clients
# We include the same tokio with multi-thread runtime + time so readiness tests work.
tokio     = { version = "1", features = ["macros", "rt-multi-thread", "time"] }

# `reqwest` is already a normal dependency, so tests can use it.
# If you ever drop it from [dependencies], uncomment this line:
# reqwest   = { version = "0.12", features = ["rustls-tls-native-roots", "json"] }

regex     = "1"

```

### crates/omnigate/benches/hydration.rs
<a id="crates-omnigate-benches-hydration-rs"></a>

```rust


```

### crates/omnigate/benches/media_range.rs
<a id="crates-omnigate-benches-mediarange-rs"></a>

```rust


```

### crates/omnigate/benches/middleware_ping.rs
<a id="crates-omnigate-benches-middlewareping-rs"></a>

```rust
//! Bench the omnigate middleware stack end-to-end (in-process, no sockets).
//! Build an axum Router, apply `omnigate::middleware::apply`, then
//! issue GET /ping requests and measure total round-trip time.
//!
//! Run: `cargo bench -p omnigate --bench middleware_ping`

use std::time::Duration;

use axum::{
    body::{self, Body},
    http::{Request, StatusCode},
    routing::get,
    Router,
};
use criterion::{black_box, criterion_group, criterion_main, BatchSize, Criterion, Throughput};
use tower::ServiceExt; // for .oneshot()

fn build_router() -> Router {
    let api = Router::new().route("/ping", get(|| async { "pong" }));
    omnigate::middleware::apply(api)
}

/// Issue a single in-process GET /ping and return (status, body_len).
async fn hit_ping(router: &Router) -> (StatusCode, usize) {
    let req = Request::builder()
        .method("GET")
        .uri("/ping")
        .body(Body::empty())
        .expect("request");

    let resp = router.clone().oneshot(req).await.expect("response");
    let status = resp.status();

    // axum 0.7: to_bytes requires an explicit limit
    let bytes = body::to_bytes(resp.into_body(), usize::MAX)
        .await
        .expect("to_bytes");

    (status, bytes.len())
}

fn bench_middleware_ping(c: &mut Criterion) {
    // Build router once; cloned per-req by ServiceExt::oneshot
    let router = build_router();

    // Current-thread Tokio runtime (cheap to drive short async ops)
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .expect("tokio rt");

    let mut group = c.benchmark_group("omnigate/middleware_ping");
    group.warm_up_time(Duration::from_millis(500));
    group.measurement_time(Duration::from_secs(8));
    group.sample_size(40);
    group.throughput(Throughput::Elements(1));

    group.bench_function("GET /ping (in-process)", |b| {
        b.iter_batched(
            || router.clone(),
            |svc| {
                rt.block_on(async move {
                    let (status, len) = hit_ping(&svc).await;
                    assert_eq!(status, StatusCode::OK);
                    black_box(len);
                });
            },
            BatchSize::SmallInput,
        );
    });

    group.finish();
}

criterion_group!(benches, bench_middleware_ping);
criterion_main!(benches);

```

### crates/omnigate/build.rs
<a id="crates-omnigate-build-rs"></a>

```rust
// Build script to embed a short Git commit into the binary as GIT_COMMIT_SHORT.
// Falls back cleanly if `git` is unavailable (e.g., shallow CI clones).

use std::process::Command;

fn main() {
    // Re-run if HEAD moves.
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs/");

    let short = Command::new("git")
        .args(["rev-parse", "--short=9", "HEAD"])
        .output()
        .ok()
        .and_then(|o| o.status.success().then_some(o))
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .map(|s| s.trim().to_string());

    if let Some(s) = short {
        println!("cargo:rustc-env=GIT_COMMIT_SHORT={}", s);
    }
}

```

### crates/omnigate/configs/omnigate.toml
<a id="crates-omnigate-configs-omnigate-toml"></a>

```toml
# omnigate — default config (Beta)

[server]
bind         = "127.0.0.1:5305"
metrics_addr = "127.0.0.1:9605"
amnesia      = true

[oap]
# Keep <= 1 MiB as enforced by config validation & invariants.
max_frame_bytes    = 1048576
stream_chunk_bytes = 65536

[admission.global_quota]
# Default (sane) production-ish limits. For forcing 429s in smoke, see the
# commented dev overrides further below.
qps   = 20000
burst = 40000

[admission.ip_quota]
enabled = true
qps     = 2000
burst   = 4000
# buckets = [ { cidr="10.0.0.0/8", qps=5000, burst=10000 } ]

[admission.fair_queue]
# Hard cap. Leave roomy for prod; readiness trips use a lower threshold below.
max_inflight = 2048
# Optional interactive headroom; if omitted, computed as max_inflight/8 by code.
headroom = 256
weights = { anon = 1, auth = 5, admin = 10 }

[admission.body]
# IMPORTANT: Align with middleware guard (1 MiB) to avoid 413s before decompression budget.
# (The decompression guard also uses this as its max expanded size.)
max_content_length       = 1048576
reject_on_missing_length = true

[admission.decompression]
allow        = ["identity", "gzip"]
deny_stacked = true

[policy]
enabled     = true
bundle_path = "crates/omnigate/configs/policy.bundle.json"
fail_mode   = "deny"  # "deny" | "allow"

[readiness]
# Tune low enough for laptop smoke to trip:
# - The inflight gauge crosses this threshold under /v1/sleep load
# - Error-rate path trips if 429/503 share exceeds this %
max_inflight_threshold = 64
error_rate_429_503_pct = 1.0
window_secs            = 10
hold_for_secs          = 20

# --- Optional dev overrides for smoke tests (uncomment as needed) ---
# [admission.global_quota]
# qps   = 50
# burst = 50
#
# [admission.ip_quota]
# enabled = true
# qps     = 50
# burst   = 50
#
# [readiness]
# max_inflight_threshold = 64
# error_rate_429_503_pct = 1.0
# window_secs            = 10
# hold_for_secs          = 20

```

### crates/omnigate/configs/policy.bundle.json
<a id="crates-omnigate-configs-policy-bundle-json"></a>

```json
{
  "version": 1,
  "meta": {
    "name": "omnigate-default",
    "description": "Default Omnigate policy: allow safe reads, deny writes by default."
  },
  "defaults": {
    "default_action": "deny",
    "max_body_bytes": 262144
  },
  "rules": [
    {
      "id": "allow-gets",
      "when": { "method": "GET" },
      "action": "allow",
      "reason": "read ok"
    },
    {
      "id": "allow-heads",
      "when": { "method": "HEAD" },
      "action": "allow",
      "reason": "head ok"
    },
    {
      "id": "deny-puts",
      "when": { "method": "PUT" },
      "action": "deny",
      "reason": "put blocked"
    },
    {
      "id": "deny-deletes",
      "when": { "method": "DELETE" },
      "action": "deny",
      "reason": "delete blocked"
    }
  ]
}

```

### crates/omnigate/configs/staging.toml
<a id="crates-omnigate-configs-staging-toml"></a>

```toml

```

### crates/omnigate/deny.toml
<a id="crates-omnigate-deny-toml"></a>

```toml
[advisories]
yanked = "deny"
unmaintained = "deny"
vulnerability = "deny"

[licenses]
allow = ["MIT", "Apache-2.0"]

```

### crates/omnigate/fuzz/Cargo.toml
<a id="crates-omnigate-fuzz-Cargo-toml"></a>

```toml
[package]
name = "omnigate2-fuzz"
version = "0.0.0"
edition = "2021"
publish = false

[package.metadata]
cargo-fuzz = true

```

### crates/omnigate/fuzz/fuzz_targets/capability.rs
<a id="crates-omnigate-fuzz-fuzztargets-capability-rs"></a>

```rust

```

### crates/omnigate/fuzz/fuzz_targets/decompress_guard.rs
<a id="crates-omnigate-fuzz-fuzztargets-decompressguard-rs"></a>

```rust

```

### crates/omnigate/fuzz/fuzz_targets/headers.rs
<a id="crates-omnigate-fuzz-fuzztargets-headers-rs"></a>

```rust

```

### crates/omnigate/rust-toolchain.toml
<a id="crates-omnigate-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt","clippy"]

```

### crates/omnigate/scripts/check_boundary.sh
<a id="crates-omnigate-scripts-checkboundary-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: add grep/lints for forbidden deps and patterns.

```

### crates/omnigate/scripts/ci_metrics_guard.sh
<a id="crates-omnigate-scripts-cimetricsguard-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: scrape /metrics and assert label/name contracts.

```

### crates/omnigate/scripts/hnDL_sim.sh
<a id="crates-omnigate-scripts-hnDLsim-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: Harvest-now-decrypt-later drill placeholder.

```

### crates/omnigate/scripts/inject_faults.sh
<a id="crates-omnigate-scripts-injectfaults-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: locally simulate latency/errors.

```

### crates/omnigate/scripts/render_mermaid.sh
<a id="crates-omnigate-scripts-rendermermaid-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: render docs/mermaid/*.mmd to SVGs.

```

### crates/omnigate/scripts/sanity_omnigate.sh
<a id="crates-omnigate-scripts-sanityomnigate-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

API_ADDR="${API_ADDR:-127.0.0.1:5305}"
METRICS_ADDR="${METRICS_ADDR:-127.0.0.1:9605}"
BIN_PKG="omnigate"
RUST_LOG_LEVEL="${RUST_LOG_LEVEL:-info}"
TRACE_LOG_COMPONENT="${TRACE_LOG_COMPONENT:-omnigate=trace}"
CARGO="${CARGO:-cargo}"
CONFIG_PATH="${CONFIG_PATH:-crates/omnigate/configs/omnigate.toml}"   # default to repo config
SKIP_NET_BURST="${SKIP_NET_BURST:-0}"                                 # set to 1 to skip the 429 burst check

req()  { printf "[sanity] %s\n" "$*"; }
fail() { printf "[sanity][FAIL] %s\n" "$*" >&2; exit 1; }

need() { command -v "$1" >/dev/null 2>&1 || fail "missing required tool: $1"; }

# --- prerequisites ---
need curl; need awk; need jq; need dd

# --- helpers ---
CHILD_PID=""
stop_child() {
  if [[ -n "${CHILD_PID:-}" ]] && kill -0 "$CHILD_PID" 2>/dev/null; then
    # Try graceful first, then a hard kill if needed
    kill "$CHILD_PID" 2>/dev/null || true
    sleep 0.2
    kill -0 "$CHILD_PID" 2>/dev/null && kill -9 "$CHILD_PID" 2>/dev/null || true
    wait "$CHILD_PID" 2>/dev/null || true
    CHILD_PID=""
  fi
}
trap stop_child EXIT

http_code() {
  local url="$1"
  curl -s -o /dev/null -w "%{http_code}" "$url"
}

wait_200() {
  local url="$1" tries="${2:-80}" delay="${3:-0.125}"
  for ((i=1;i<=tries;i++)); do
    local code; code="$(http_code "$url" || true)"
    [[ "$code" == "200" ]] && return 0
    sleep "$delay"
  done
  return 1
}

assert_http_200() {
  local url="$1"
  local code; code="$(http_code "$url" || true)"
  [[ "$code" == "200" ]] || fail "expected 200: $url (got $code)"
}

assert_json_true() {
  local url="$1" key="$2"
  local val; val="$(curl -s "$url" | jq -r ".${key}")"
  [[ "$val" == "true" ]] || fail "expected ${key}=true at $url (got $val)"
}

metric_value() {
  local metric="$1"
  # Grab the first *unlabeled* sample line:  "<name> <value>"
  curl -s "http://${METRICS_ADDR}/metrics" \
    | awk -v m="$metric" '$1==m{print $2; exit}'
}

assert_metric_eq() {
  local metric="$1" expect="$2"
  local val; val="$(metric_value "$metric")"
  [[ "${val:-}" == "$expect" ]] || fail "metric $metric expected $expect got ${val:-<missing>}"
}

print_metric() {
  local metric="$1"
  curl -s "http://${METRICS_ADDR}/metrics" | awk -v m="$metric" '$1==m{print}'
}

# --- build & tests ---
req "fmt + clippy + build"
$CARGO fmt -p "$BIN_PKG"
$CARGO clippy -p "$BIN_PKG" --no-deps -- -D warnings
$CARGO build -p "$BIN_PKG"

req "unit/integration tests"
$CARGO test -p "$BIN_PKG" --test dto_serialization --test ready_truth --test zk_receipts

# --- run helper ---
run_omnigate() {
  local dev_ready="$1" # 0 or 1
  stop_child
  req "starting omnigate (OMNIGATE_DEV_READY=${dev_ready})"
  req "using --config $CONFIG_PATH"

  OMNIGATE_DEV_READY="$dev_ready" \
  OMNIGATE_AMNESIA=on \
  RUST_LOG="${RUST_LOG_LEVEL},${TRACE_LOG_COMPONENT}" \
  $CARGO run -p "$BIN_PKG" --quiet -- --config "$CONFIG_PATH" &

  CHILD_PID=$!

  req "waiting for /healthz 200"
  wait_200 "http://${API_ADDR}/healthz" || fail "healthz did not become 200"

  req "waiting for /readyz 200"
  wait_200 "http://${API_ADDR}/readyz" || fail "readyz did not become 200"

  req "waiting for /metrics 200"
  wait_200 "http://${METRICS_ADDR}/metrics" || req "WARN: metrics endpoint not yet 200 (continuing best-effort)"

  # small settle to avoid initial scrape races
  sleep 0.15
}

# --- Phase A: DEV override ON ---
run_omnigate 1

req "check admin plane & v1 routes"
assert_http_200 "http://${API_ADDR}/healthz"
assert_http_200 "http://${API_ADDR}/readyz"
assert_json_true "http://${API_ADDR}/v1/ping" "ok"

req "versionz contains version (git may be null)"
curl -s "http://${API_ADDR}/versionz" | jq -e '.version | length > 0' >/dev/null \
  || fail "/versionz missing 'version'"

req "assert amnesia_mode == 1"
assert_metric_eq amnesia_mode 1

stop_child

# --- Phase B: DEV override OFF (real gates) ---
run_omnigate 0

req "assert readyz payload is true"
assert_json_true "http://${API_ADDR}/readyz" "ready"

req "gate gauges (best-effort if present)"
for m in listeners_bound metrics_bound cfg_loaded ready_state; do
  val="$(metric_value "$m" || true)"
  if [[ -n "$val" && "$val" != "1" ]]; then
    req "WARN: $m present but not 1 (got $val)"
  fi
done

# --- Fair queue cap header check ---
req "fair queue cap header exposes different caps for priorities"
curl -s -i -H 'x-omnigate-priority: interactive' "http://${API_ADDR}/v1/ping" \
  | awk 'BEGIN{IGNORECASE=1}/^x-omnigate-cap:/{print}'
curl -s -i -H 'x-omnigate-priority: bulk'        "http://${API_ADDR}/v1/ping" \
  | awk 'BEGIN{IGNORECASE=1}/^x-omnigate-cap:/{print}'

# --- Global quota burst to try for 429s ---
if [[ "$SKIP_NET_BURST" != "1" ]]; then
  req "burst load to trigger some 429 (best-effort)"
  if command -v xargs >/dev/null 2>&1; then
    seq 1 1200 | xargs -n1 -P64 -I{} curl -s -o /dev/null -w "%{http_code}\n" \
      "http://${API_ADDR}/v1/ping" | sort | uniq -c || true
  else
    req "WARN: xargs not available; skipping burst"
  fi
else
  req "SKIP_NET_BURST=1 — skipping the 429 burst check"
fi

req "check quota exhaust counter (if burst produced 429s)"
print_metric admission_quota_exhausted_total || req "NOTE: admission_quota_exhausted_total not present yet"

# --- Body caps: oversize -> 413 + counter ---
req "body caps oversize 413 + metric"
TMP_BIG="/tmp/omnigate_big.bin"
dd if=/dev/urandom of="$TMP_BIG" bs=1k count=1100 status=none
code="$(curl -s -o /dev/null -w "%{http_code}" -X POST --data-binary @"$TMP_BIG" "http://${API_ADDR}/v1/ping")"
if [[ "$code" != "413" ]]; then
  req "WARN: oversize POST did not return 413 (got $code) — verify route setup for POST on /v1/ping or test an endpoint that accepts body"
fi
print_metric body_reject_total || req "NOTE: body_reject_total not present yet"

# --- Decompression guard: unknown + stacked encodings ---
req "decompress guard rejects: unknown encoding"
code="$(curl -s -o /dev/null -w "%{http_code}" -H 'Content-Encoding: compress' -X POST --data 'abc' "http://${API_ADDR}/v1/ping")" || true
if [[ "$code" != "415" ]]; then
  req "WARN: unknown encoding did not return 415 (got $code) — ensure POST route is guarded by decompress layer"
fi

req "decompress guard rejects: stacked encodings"
code="$(curl -s -o /dev/null -w "%{http_code}" -H 'Content-Encoding: gzip, deflate' -X POST --data 'abc' "http://${API_ADDR}/v1/ping")" || true
if [[ "$code" != "415" ]]; then
  req "WARN: stacked encodings did not return 415 (got $code) — ensure POST route is guarded by decompress layer"
fi
print_metric decompress_reject_total || req "NOTE: decompress_reject_total not present yet"

# --- Ready trip/recover (best-effort) ---
req "ready trip metrics snapshot"
curl -s "http://${METRICS_ADDR}/metrics" | egrep 'ready_trips_total|ready_state_changes_total|ready_error_rate_pct|ready_inflight_current' || true

# Done
stop_child
req "OK — all sanity checks finished"

```

### crates/omnigate/scripts/smoke_omnigate.sh
<a id="crates-omnigate-scripts-smokeomnigate-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Colors
G="\033[0;32m"; Y="\033[1;33m"; R="\033[0;31m"; Z="\033[0m"

echo -e "${Y}fmt + clippy + build…${Z}"
cargo fmt -p omnigate
cargo clippy -p omnigate --no-deps -- -D warnings
cargo build -p omnigate

# Defaults (API=5305, ADMIN=9605)
API_ADDR="${API_ADDR:-127.0.0.1:5305}"
ADMIN_ADDR="${ADMIN_ADDR:-127.0.0.1:9605}"
LOG="/tmp/omnigate.log"

# REQUIRED: config path (can be overridden)
CONFIG_PATH="${OMNIGATE_CONFIG:-crates/omnigate/configs/omnigate.toml}"
if [ ! -f "${CONFIG_PATH}" ]; then
  echo -e "${R}❌ Config file not found at: ${CONFIG_PATH}${Z}"
  exit 1
fi
echo -e "${Y}using config: ${CONFIG_PATH}${Z}"

# Optional dev-readiness override
export OMNIGATE_DEV_READY="${OMNIGATE_DEV_READY:-}"

echo -e "${Y}starting omnigate at ${API_ADDR} (logs: ${LOG})…${Z}"
BIN="target/debug/omnigate"
# Pass --config so the readiness 'config' gate can flip
"${BIN}" --config "${CONFIG_PATH}" > "${LOG}" 2>&1 &
PID=$!

cleanup() {
  echo -e "${Y}stopping omnigate (pid=${PID})…${Z}"
  kill "${PID}" >/dev/null 2>&1 || true
  wait "${PID}" >/dev/null 2>&1 || true
}
trap cleanup EXIT

# Wait for /healthz on the API port
echo "waiting for /healthz…"
set +e
for i in {1..100}; do
  curl -sf "http://${API_ADDR}/healthz" >/dev/null && break
  sleep 0.1
done
set -e

echo "-- /healthz (API)"
curl -sf "http://${API_ADDR}/healthz"
echo

# Metrics are on the ADMIN plane
echo "-- /metrics (ADMIN)"
if ! curl -sf "http://${ADMIN_ADDR}/metrics" | head -n 20; then
  echo -e "${R}❌ /metrics not available on ${ADMIN_ADDR}. Check ${LOG}.${Z}"
  exit 1
fi

# Root / should 404
echo "-- / (API, expect 404)"
CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://${API_ADDR}/")
if [ "${CODE}" = "404" ]; then
  echo -e "✅ 404 ok"
else
  echo -e "${R}❌ expected 404, got ${CODE}${Z}"
  exit 1
fi

check_ready() {
  local path="$1"
  local status body
  status=$(curl -s -o /dev/null -w "%{http_code}" "http://${API_ADDR}${path}")
  body=$(curl -s "http://${API_ADDR}${path}" || true)
  echo "readyz status (${path} on API): ${status}"
  if [ "${status}" = "200" ]; then
    echo -e "${G}✅ ready (body: ${body})${Z}"
    return 0
  else
    echo -e "${Y}ℹ️ not ready (status ${status}, body: ${body})${Z}"
    # Show last 20 log lines to explain the gate
    echo -e "${Y}--- tail ${LOG} ---${Z}"
    tail -n 20 "${LOG}" || true
    echo -e "${Y}-------------------${Z}"
    return 1
  fi
}

echo "-- /readyz (API; truthful readiness)"
check_ready "/readyz" || true

echo "-- /ops/readyz (API alias)"
check_ready "/ops/readyz" || true

echo -e "${G}✅ smoke ok${Z}"

```

### crates/omnigate/scripts/smoke_policy.sh
<a id="crates-omnigate-scripts-smokepolicy-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

API_ADDR="${API_ADDR:-127.0.0.1:5305}"
ADMIN_ADDR="${ADMIN_ADDR:-127.0.0.1:9605}"
MAX_BODY="${OMNIGATE_MAX_BODY:-10485760}"

# We scrape the default Prom registry exposed by the API on /ops/metrics
METRICS_URL="${METRICS_URL:-http://${API_ADDR}/ops/metrics}"

say() { printf "\n\033[1m▶ %s\033[0m\n" "$*"; }
status() { curl -s -o /dev/null -w "%{http_code}" "$@"; }

metric_sum() {
  local metric="$1"
  curl -s "$METRICS_URL" \
  | awk -v re="^"$(printf "%s" "$metric" | sed 's/[].[^$*+?{}()|/\\]/\\&/g') \
      '$0 ~ re { v=$NF; if (v ~ /^[0-9]+([.][0-9]+)?$/) s+=v+0 } END { printf("%.0f\n", (s==""?0:s)) }'
}

metric_show() {
  local metric="$1"
  echo "---- ${metric} lines ----"
  curl -s "$METRICS_URL" \
  | awk -v re="^"$(printf "%s" "$metric" | sed 's/[].[^$*+?{}()|/\\]/\\&/g') '$0 ~ re { print }'
  echo "-------------------------"
}

say "Check /readyz"
[ "$(status "http://${ADMIN_ADDR}/readyz")" = "200" ] && echo "✅ /readyz: 200" || { echo "❌ /readyz not 200"; exit 1; }

say "GET /v1/ping (expect 200)"
[ "$(status -X GET "http://${API_ADDR}/v1/ping")" = "200" ] && echo "✅ GET /v1/ping: 200" || { echo "❌ ping"; exit 1; }

POLICY_METRIC="policy_middleware_shortcircuits_total"
BODY_METRIC="body_reject_total"
DECOMP_METRIC="decompress_reject_total"

P_BEFORE="$(metric_sum "$POLICY_METRIC")"
B_BEFORE="$(metric_sum "$BODY_METRIC")"
D_BEFORE="$(metric_sum "$DECOMP_METRIC")"

say "PUT /v1/ping with Content-Length: 0 (expect policy 403)"
[ "$(status -X PUT -H "Content-Length: 0" "http://${API_ADDR}/v1/ping")" = "403" ] && echo "✅ PUT /v1/ping (CL:0): 403" || { echo "❌ policy 403"; exit 1; }

say "PUT /v1/ping with stacked encodings (expect 415)"
[ "$(status -X PUT -H "Content-Encoding: gzip, br" -H "Content-Length: 0" "http://${API_ADDR}/v1/ping")" = "415" ] && echo "✅ PUT /v1/ping (stacked encodings): 415" || { echo "❌ 415"; exit 1; }

say "PUT /v1/ping oversize body (expect 413)"
TMP_BIG="$(mktemp -t omnigate-big.XXXXXX)"
if head -c "$((MAX_BODY + 1))" /dev/zero > "$TMP_BIG" 2>/dev/null; then :; else
  dd if=/dev/zero bs=1 count=$((MAX_BODY + 1)) of="$TMP_BIG" status=none
fi
[ "$(status -X PUT --data-binary @"$TMP_BIG" "http://${API_ADDR}/v1/ping")" = "413" ] && echo "✅ PUT /v1/ping (oversize): 413" || { echo "❌ 413"; rm -f "$TMP_BIG"; exit 1; }
rm -f "$TMP_BIG"

P_AFTER="$(metric_sum "$POLICY_METRIC")"
B_AFTER="$(metric_sum "$BODY_METRIC")"
D_AFTER="$(metric_sum "$DECOMP_METRIC")"

say "Metrics deltas"
printf "  %s: %s -> %s  (Δ=%s)\n" "$POLICY_METRIC" "$P_BEFORE" "$P_AFTER" "$((P_AFTER - P_BEFORE))"
printf "  %s: %s -> %s  (Δ=%s)\n" "$BODY_METRIC"    "$B_BEFORE" "$B_AFTER" "$((B_AFTER - B_BEFORE))"
printf "  %s: %s -> %s  (Δ=%s)\n" "$DECOMP_METRIC"  "$D_BEFORE" "$D_AFTER" "$((D_AFTER - D_BEFORE))"

metric_show "$POLICY_METRIC"
metric_show "$BODY_METRIC"
metric_show "$DECOMP_METRIC"

say "All checks passed."

```

### crates/omnigate/scripts/smoke_readiness.sh
<a id="crates-omnigate-scripts-smokereadiness-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# RO:WHAT   Drive inflight & error proxies, then verify /readyz degrades (503) and recovers.
# RO:USE    OMNIGATE_DEV_READY=0 cargo run -p omnigate --bin omnigate
#           chmod +x crates/omnigate/scripts/smoke_readiness.sh
#           crates/omnigate/scripts/smoke_readiness.sh
# RO:ENV    BASE=http://127.0.0.1:5305  CONCURRENCY=600  DURATION=12  MS=800  POLL_TIMEOUT=25

BASE="${BASE:-http://127.0.0.1:5305}"
CONCURRENCY="${CONCURRENCY:-600}"   # macOS-safe; bump if your box can take it
DURATION="${DURATION:-12}"          # seconds to sustain load
MS="${MS:-800}"                     # /v1/sleep duration per request
POLL_TIMEOUT="${POLL_TIMEOUT:-25}"  # seconds to wait for a 503

get() { curl -sS -o /dev/null -w "%{http_code}" "$1"; }
say() { printf "%s\n" "$*"; }
ok() { printf "✅ %s\n" "$*"; }
bad() { printf "❌ %s\n" "$*" ; }

say ""
say "▶ Check /readyz before load"
code="$(get "$BASE/readyz")"
if [[ "$code" == "200" ]]; then ok "/readyz: 200"; else bad "/readyz: $code"; exit 1; fi

say ""
say "▶ Create inflight pressure via /v1/sleep?ms=$MS (CONCURRENCY=$CONCURRENCY for ${DURATION}s)"

# Background load generator (bounded duration)
(
  end=$((SECONDS + DURATION))
  while (( SECONDS < end )); do
    # Fire CONCURRENCY requests, then wait for them to complete
    for _ in $(seq 1 "$CONCURRENCY"); do
      curl -sS -o /dev/null "$BASE/v1/sleep?ms=$MS" &
    done
    wait
  done
) & LOAD_PID=$!

say ""
say "▶ Poll /readyz for degrade (expect 503 within a few seconds)"
deadline=$((SECONDS + POLL_TIMEOUT))
tripped=0
while (( SECONDS < deadline )); do
  code="$(get "$BASE/readyz")"
  if [[ "$code" == "503" ]]; then
    ok "Observed degrade: /readyz -> 503"
    tripped=1
    break
  fi
  sleep 0.25
done

# Stop background load if it’s still running
if ps -p "$LOAD_PID" >/dev/null 2>&1; then kill "$LOAD_PID" 2>/dev/null || true; wait "$LOAD_PID" 2>/dev/null || true; fi

if [[ "$tripped" == "0" ]]; then
  bad "Did not observe degrade (still 200)"
  # Show quick gauges to help debug thresholds
  say ""
  say "---- readiness gauges ----"
  curl -sS "$BASE/ops/metrics" | grep -E 'ready_(inflight_current|error_rate_pct|queue_saturated)' || true
  exit 1
fi

say ""
say "▶ Hold window check: /readyz should remain 503 briefly, then recover"
sleep 1
code="$(get "$BASE/readyz")"
say "   now: $code (will go back to 200 after hold_for_secs)"

say ""
say "---- readiness gauges ----"
curl -sS "$BASE/ops/metrics" | grep -E 'ready_(inflight_current|error_rate_pct|queue_saturated)'

ok "All checks executed."

```

### crates/omnigate/scripts/soak.sh
<a id="crates-omnigate-scripts-soak-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: 24h soak runner placeholder.

```

### crates/omnigate/src/admission/fair_queue.rs
<a id="crates-omnigate-src-admission-fairqueue-rs"></a>

```rust
//! RO:WHAT  Inflight cap with interactive headroom (priority via x-omnigate-priority).
//! RO:WHY   Shed overload early with stable semantics and visibility into capacity.
//! RO:INVARS Single-writer discipline for counters; label bounds on metrics.

use std::sync::{
    atomic::{AtomicUsize, Ordering},
    Arc,
};

use axum::{
    body::Body,
    extract::State,
    http::{HeaderMap, HeaderName, HeaderValue, Request, StatusCode},
    middleware::{from_fn_with_state, Next},
    response::{IntoResponse, Response},
    Router,
};
use serde::Serialize;

const HEADER_PRIORITY: &str = "x-omnigate-priority";

#[derive(Clone)]
struct Gate {
    hard: usize,
    headroom: usize,
    in_flight: Arc<AtomicUsize>,
}

impl Gate {
    fn new(hard: usize, headroom: usize) -> Self {
        Self {
            hard,
            headroom,
            in_flight: Arc::new(AtomicUsize::new(0)),
        }
    }

    fn limit_for(&self, headers: &HeaderMap) -> usize {
        match headers
            .get(HEADER_PRIORITY)
            .and_then(|v| v.to_str().ok())
            .unwrap_or("bulk")
        {
            "interactive" => self.hard + self.headroom,
            _ => self.hard,
        }
    }

    fn try_enter(&self, headers: &HeaderMap) -> bool {
        let cap = self.limit_for(headers);
        loop {
            let cur = self.in_flight.load(Ordering::Relaxed);
            if cur >= cap {
                return false;
            }
            if self
                .in_flight
                .compare_exchange(cur, cur + 1, Ordering::AcqRel, Ordering::Relaxed)
                .is_ok()
            {
                // reflect the new inflight count to readiness gauges
                crate::metrics::gates::READY_INFLIGHT_CURRENT.set((cur + 1) as i64);
                return true;
            }
        }
    }

    fn leave(&self) {
        let prev = self.in_flight.fetch_sub(1, Ordering::AcqRel);
        // saturating floor at 0 for safety
        let now = prev.saturating_sub(1);
        crate::metrics::gates::READY_INFLIGHT_CURRENT.set(now as i64);
    }
}

#[derive(Serialize)]
struct ErrorBody<'a> {
    reason: &'a str,
    message: &'a str,
}

async fn fairness_guard(State(gate): State<Arc<Gate>>, req: Request<Body>, next: Next) -> Response {
    if gate.try_enter(req.headers()) {
        // admitted: queue not saturated
        crate::metrics::gates::READY_QUEUE_SATURATED.set(0);

        struct Guard(Arc<Gate>);
        impl Drop for Guard {
            fn drop(&mut self) {
                self.0.leave();
            }
        }
        let cap = gate.limit_for(req.headers());
        let _guard = Guard(gate.clone());

        let mut resp = next.run(req).await;
        let _ = resp.headers_mut().insert(
            HeaderName::from_static("x-omnigate-cap"),
            HeaderValue::from_str(&cap.to_string()).unwrap_or(HeaderValue::from_static("0")),
        );
        resp
    } else {
        // Shed: mark queue saturation and count a drop event.
        crate::metrics::gates::READY_QUEUE_SATURATED.set(1);
        crate::metrics::FAIR_Q_EVENTS_TOTAL
            .with_label_values(&["dropped"])
            .inc();

        (
            StatusCode::SERVICE_UNAVAILABLE,
            axum::Json(ErrorBody {
                reason: "overloaded",
                message: "server is shedding load; please retry",
            }),
        )
            .into_response()
    }
}

/// Attach the fair-queue guard with the current (default) capacity.
/// NOTE: retained for tests/back-compat; prefer `attach_with_cfg`.
pub fn attach<S>(router: Router<S>) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    router.layer(from_fn_with_state(
        Arc::new(Gate::new(256, 32)),
        fairness_guard,
    ))
}

/// Attach the fair-queue guard using FairQueue from Config.
pub fn attach_with_cfg<S>(router: Router<S>, fq: &crate::config::FairQueue) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    let (hard, headroom) = fq.hard_and_headroom();
    let gate = Arc::new(Gate::new(hard, headroom));
    router.layer(from_fn_with_state(gate, fairness_guard))
}

```

### crates/omnigate/src/admission/mod.rs
<a id="crates-omnigate-src-admission-mod-rs"></a>

```rust
// crates/omnigate/src/admission/mod.rs
//! RO:WHAT   Admission composite attach point.
//! RO:WHY    Single place to enable quotas + fair-queue before handlers.
//! RO:INVARS Layers are low-cardinality; return 429/503 only.

mod fair_queue;
mod quotas;

use axum::Router;

/// Attach admission layers (quotas first, then fairness shed) using defaults.
/// Kept for tests/back-compat. Prefer `attach_with_cfg`.
pub fn attach<S>(router: Router<S>) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    // Quotas first (fast reject), then fairness gate.
    fair_queue::attach(quotas::attach(router))
}

/// Attach admission layers using values from Config.
/// Order matters: quotas first, then fair-queue.
/// NOTE: Decompression guard is layered in `middleware::apply_with_cfg`.
pub fn attach_with_cfg<S>(router: Router<S>, cfg: &crate::config::Admission) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    // Pass the whole Admission to quotas (it needs both global & ip slices)
    let r = quotas::attach_with_cfg(router, cfg);
    // Then pass just the FairQueue part to the fairness gate
    fair_queue::attach_with_cfg(r, &cfg.fair_queue)
}

```

### crates/omnigate/src/admission/quotas.rs
<a id="crates-omnigate-src-admission-quotas-rs"></a>

```rust
// crates/omnigate/src/admission/quotas.rs
//! RO:WHAT  Global + per-IP token-bucket admission guards that return 429 when over limit.
//! RO:WHY   Prevent abuse/overload by bounding request rate upfront, before heavy work.
//! RO:INVARS Constant-time hot path; no label explosion; pure edge guards; no drift in deps.

use std::{
    collections::HashMap,
    sync::{Arc, Mutex},
    time::Instant,
};

use axum::{
    body::Body,
    extract::State,
    http::{HeaderMap, Request},
    middleware::{from_fn_with_state, Next},
    response::{IntoResponse, Response},
    Router,
};

use crate::errors::GateError;

// -----------------------------
// Bucket + limiter primitives
// -----------------------------

#[derive(Debug)]
struct Bucket {
    tokens: f64,
    last: Instant,
    rate_per_sec: f64,
    burst: f64,
}

impl Bucket {
    fn new(qps: u64, burst: u64) -> Self {
        let now = Instant::now();
        Self {
            tokens: burst as f64,
            last: now,
            rate_per_sec: qps as f64,
            burst: burst as f64,
        }
    }

    #[inline]
    fn allow(&mut self) -> bool {
        let now = Instant::now();
        let dt = (now - self.last).as_secs_f64();
        self.last = now;

        // refill
        self.tokens = (self.tokens + dt * self.rate_per_sec).min(self.burst);

        if self.tokens >= 1.0 {
            self.tokens -= 1.0;
            true
        } else {
            false
        }
    }
}

// -----------------------------
// Global limiter
// -----------------------------

#[derive(Clone)]
struct GlobalLimiter {
    inner: Arc<Mutex<Bucket>>,
}

impl GlobalLimiter {
    fn new(qps: u64, burst: u64) -> Self {
        Self {
            inner: Arc::new(Mutex::new(Bucket::new(qps, burst))),
        }
    }

    #[inline]
    fn allow(&self) -> bool {
        let mut b = self.inner.lock().expect("global limiter poisoned");
        b.allow()
    }
}

async fn global_quota_guard(
    State(glob): State<GlobalLimiter>,
    req: Request<Body>,
    next: Next,
) -> Response {
    if glob.allow() {
        next.run(req).await
    } else {
        // Heuristic small backoff; refine later if needed.
        let retry_ms = 50u64;

        // Metrics bump (scope=global, reason=qps).
        crate::metrics::gates::QUOTA_REJECT_TOTAL
            .with_label_values(&["global", "qps"])
            .inc();

        GateError::RateLimitedGlobal {
            retry_after_ms: retry_ms,
        }
        .into_response()
    }
}

// -----------------------------
// Per-IP limiter (optional)
// -----------------------------

#[derive(Clone)]
struct IpLimiter {
    rate: u64,
    burst: u64,
    enabled: bool,
    by_ip: Arc<Mutex<HashMap<String, Bucket>>>,
}

impl IpLimiter {
    fn new(enabled: bool, qps: u64, burst: u64) -> Self {
        Self {
            rate: qps,
            burst,
            enabled,
            by_ip: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    #[inline]
    fn allow(&self, ip: &str) -> bool {
        if !self.enabled {
            return true;
        }
        let mut map = self.by_ip.lock().expect("ip limiter poisoned");
        let b = map
            .entry(ip.to_string())
            .or_insert_with(|| Bucket::new(self.rate, self.burst));
        b.allow()
    }
}

fn ip_from_headers(headers: &HeaderMap) -> String {
    if let Some(v) = headers.get("x-forwarded-for") {
        if let Ok(s) = v.to_str() {
            if let Some(first) = s.split(',').next() {
                return first.trim().to_string();
            }
        }
    }
    if let Some(v) = headers.get("x-real-ip") {
        if let Ok(s) = v.to_str() {
            return s.trim().to_string();
        }
    }
    "local".to_string()
}

async fn ip_quota_guard(State(ipq): State<IpLimiter>, req: Request<Body>, next: Next) -> Response {
    let ip = ip_from_headers(req.headers());
    if ipq.allow(&ip) {
        next.run(req).await
    } else {
        let retry_ms = 50u64;

        // Metrics bump (scope=ip, reason=qps).
        crate::metrics::gates::QUOTA_REJECT_TOTAL
            .with_label_values(&["ip", "qps"])
            .inc();

        GateError::RateLimitedIp {
            retry_after_ms: retry_ms,
        }
        .into_response()
    }
}

// -----------------------------
// Attach points
// -----------------------------

/// Attach the quota limiter layer with **default constants** (test/back-compat).
/// Prefer `attach_with_cfg` in production paths.
pub fn attach<S>(router: Router<S>) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    router
        .layer(from_fn_with_state(
            GlobalLimiter::new(500, 1000),
            global_quota_guard,
        ))
        .layer(from_fn_with_state(
            IpLimiter::new(false, 200, 400),
            ip_quota_guard,
        ))
}

/// Attach quota limiters using values from **Admission** config.
/// Order: global first (cheap, broad), then per-IP (optional).
pub fn attach_with_cfg<S>(router: Router<S>, adm: &crate::config::Admission) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    let ip = &adm.ip_quota;

    router
        .layer(from_fn_with_state(
            GlobalLimiter::new(adm.global_quota.qps, adm.global_quota.burst),
            global_quota_guard,
        ))
        .layer(from_fn_with_state(
            IpLimiter::new(ip.enabled, ip.qps, ip.burst),
            ip_quota_guard,
        ))
}

```

### crates/omnigate/src/auth/capability.rs
<a id="crates-omnigate-src-auth-capability-rs"></a>

```rust
/// STUBBED - FINISH SVC-PASSPORT THEN COME BACK
```

### crates/omnigate/src/auth/mod.rs
<a id="crates-omnigate-src-auth-mod-rs"></a>

```rust
/// STUBBED - FINISH SVC-PASSPORT THEN COME BACK
```

### crates/omnigate/src/auth/passport_client.rs
<a id="crates-omnigate-src-auth-passportclient-rs"></a>

```rust
/// STUBBED - FINISH SVC-PASSPORT THEN COME BACK
```

### crates/omnigate/src/auth/revocation.rs
<a id="crates-omnigate-src-auth-revocation-rs"></a>

```rust
/// STUBBED - FINISH SVC-PASSPORT THEN COME BACK
```

### crates/omnigate/src/bootstrap/health_probe.rs
<a id="crates-omnigate-src-bootstrap-healthprobe-rs"></a>

```rust
//! RO:WHAT — Helpers for health/readiness wiring (stubs for future use).
//! RO:WHY  — Keep separation of concerns; Concerns: RES/GOV.
//! RO:INTERACTS — ron_kernel::metrics::{health, readiness}.

pub struct HealthProbe; // future: gates for downstream client binding, queues_ok, etc.

```

### crates/omnigate/src/bootstrap/metrics_server.rs
<a id="crates-omnigate-src-bootstrap-metricsserver-rs"></a>

```rust
//! RO:WHAT — Placeholder to document metrics server behavior (served by ron-kernel Metrics).
//! RO:WHY  — Keep parity with TODO structure; Concerns: GOV/OBS.
//! RO:INTERACTS — ron_kernel::Metrics::serve() started in App::build().
//! RO:INVARIANTS — none here; admin plane lives in kernel exporter.

/// Metrics server is started in `App::build()` via `ron_kernel::Metrics::serve`.
pub struct MetricsServer;

```

### crates/omnigate/src/bootstrap/mod.rs
<a id="crates-omnigate-src-bootstrap-mod-rs"></a>

```rust
//! RO:WHAT — Bootstrap modules: API server, metrics server (via kernel), health probe helpers.
//! RO:WHY  — Keep main.rs tiny; Concerns: RES/PERF (clean layering, quick start/stop).
//! RO:INTERACTS — server.rs (axum serve), metrics_server.rs (delegates to ron-kernel), health_probe.rs.
//! RO:INVARIANTS — single writer per listener; truthful readiness; no blocking in async.

pub mod health_probe;
pub mod metrics_server;
pub mod server;

```

### crates/omnigate/src/bootstrap/server.rs
<a id="crates-omnigate-src-bootstrap-server-rs"></a>

```rust
//! RO:WHAT — Axum HTTP server bootstrap for the API plane.
//! RO:WHY  — Separate from main; Concerns: RES/PERF; handles bind + graceful-ish shutdown.
//! RO:INTERACTS — axum::Router, crate::config::Server, ron-kernel readiness (future toggle).
//! RO:INVARIANTS — bind before marking ready; one server task, one listener; stop cleanly on Ctrl-C.

use axum::Router;
use std::net::SocketAddr;
use tokio::task::JoinHandle;
use tracing::{error, info};

pub async fn serve(
    cfg: crate::config::Server,
    router: Router,
) -> anyhow::Result<(JoinHandle<()>, SocketAddr)> {
    // Bind first to satisfy "bind before ready".
    let listener = tokio::net::TcpListener::bind(cfg.bind).await?;
    let local: SocketAddr = listener.local_addr()?;
    info!(%local, "api listener bound");

    // Axum/Hyper server with graceful shutdown on Ctrl-C.
    // (Main still holds the JoinHandle and can abort on top; this just ensures
    //  a clean drain when Ctrl-C is delivered to the process.)
    let http = axum::serve(listener, router).with_graceful_shutdown(async {
        // Best-effort: if ctrl_c fails, just keep serving.
        if let Err(e) = tokio::signal::ctrl_c().await {
            // Log once; we don't bubble this up because we want the server to continue.
            error!(error=?e, "ctrl-c listener failed in server task");
        }
    });

    let task = tokio::spawn(async move {
        if let Err(e) = http.await {
            // This fires on listener errors or if the accept loop ends unexpectedly.
            tracing::error!(error=?e, "http server stopped with error");
        } else {
            tracing::info!("http server exited");
        }
    });

    Ok((task, local))
}

```

### crates/omnigate/src/config/env.rs
<a id="crates-omnigate-src-config-env-rs"></a>

```rust
//! RO:WHAT — Apply env var overrides to Config.
//! RO:WHY  — 12 Pillars hardening: explicit/typed config; Concerns: GOV.
//! RO:INVARIANTS — Only documented keys; parse-safe; no panics.

use super::Config;
use std::env;

pub fn apply_env_overrides(cfg: &mut Config) -> anyhow::Result<()> {
    if let Ok(v) = env::var("OMNIGATE_BIND") {
        cfg.server.bind = v.parse()?;
    }
    if let Ok(v) = env::var("OMNIGATE_METRICS_ADDR") {
        cfg.server.metrics_addr = v.parse()?;
    }
    if let Ok(v) = env::var("OMNIGATE_AMNESIA") {
        cfg.server.amnesia = matches!(v.as_str(), "1" | "true" | "on" | "yes" | "TRUE");
    }
    Ok(())
}

```

### crates/omnigate/src/config/file.rs
<a id="crates-omnigate-src-config-file-rs"></a>

```rust
//! RO:WHAT — Load Config from TOML file if present (simple search).

use super::Config;
use std::{fs, path::PathBuf};

const DEFAULT_PATHS: &[&str] = &[
    "crates/omnigate/configs/omnigate.toml", // repo-relative (dev)
    "configs/omnigate.toml",                 // crate-relative (installed)
    "/etc/ron/omnigate.toml",                // system
];

pub fn load_from_default_path() -> anyhow::Result<Option<Config>> {
    for p in DEFAULT_PATHS {
        if let Some(cfg) = try_load(PathBuf::from(p))? {
            return Ok(Some(cfg));
        }
    }
    Ok(None)
}

fn try_load(path: PathBuf) -> anyhow::Result<Option<Config>> {
    if !path.exists() {
        return Ok(None);
    }
    let s = fs::read_to_string(&path)?;
    let cfg: Config = toml::from_str::<Config>(&s)?;
    Ok(Some(cfg))
}

```

### crates/omnigate/src/config/mod.rs
<a id="crates-omnigate-src-config-mod-rs"></a>

```rust
// crates/omnigate/src/config/mod.rs
//! RO:WHAT   Omnigate configuration model + loaders (env/file) + defaults.
//! RO:INVARS  oap.max_frame_bytes ≤ 1MiB; body caps aligned with middleware guards.

use serde::Deserialize;
use std::{fs, net::SocketAddr, path::Path};

mod env;
mod file;
mod validate;

#[derive(Debug, Clone, Deserialize)]
pub struct Config {
    pub server: Server,
    pub oap: Oap,
    #[serde(default)]
    pub admission: Admission,
    pub policy: Policy,
    pub readiness: Readiness,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Server {
    /// API listener bind, e.g. "127.0.0.1:5305"
    pub bind: SocketAddr,
    /// Admin/metrics bind, e.g. "127.0.0.1:9605"
    pub metrics_addr: SocketAddr,
    pub amnesia: bool,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Oap {
    pub max_frame_bytes: u64,
    pub stream_chunk_bytes: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Admission {
    #[serde(default)]
    pub global_quota: GlobalQuota,
    #[serde(default)]
    pub ip_quota: IpQuota,
    #[serde(default)]
    pub fair_queue: FairQueue,
    #[serde(default)]
    pub body: BodyCaps,
    #[serde(default)]
    pub decompression: Decompress,
}

impl Default for Admission {
    fn default() -> Self {
        Self {
            global_quota: GlobalQuota {
                qps: 20_000,
                burst: 40_000,
            },
            ip_quota: IpQuota {
                enabled: true,
                qps: 2_000,
                burst: 4_000,
            },
            fair_queue: FairQueue {
                max_inflight: 2_048,
                headroom: None, // computed as 1/8th of hard cap if absent
                weights: Weights {
                    anon: 1,
                    auth: 5,
                    admin: 10,
                },
            },
            body: BodyCaps {
                max_content_length: 1_048_576 * 10,
                reject_on_missing_length: true,
            },
            decompression: Decompress {
                allow: vec!["identity".into(), "gzip".into()],
                deny_stacked: true,
            },
        }
    }
}

#[derive(Default, Debug, Clone, Deserialize)]
pub struct GlobalQuota {
    pub qps: u64,
    pub burst: u64,
}

impl GlobalQuota {
    /// Downcast to the types our limiter expects.
    #[inline]
    pub fn params_u32(&self) -> (u32, u32) {
        (self.qps as u32, self.burst as u32)
    }
}

#[derive(Default, Debug, Clone, Deserialize)]
pub struct IpQuota {
    #[serde(default)]
    pub enabled: bool,
    pub qps: u64,
    pub burst: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct FairQueue {
    /// Maximum in-flight (the hard cap).
    pub max_inflight: u64,
    /// Optional extra headroom for interactive traffic.
    /// If None, computed as `max_inflight / 8`.
    #[serde(default)]
    pub headroom: Option<u64>,
    #[serde(default)]
    pub weights: Weights,
}

impl Default for FairQueue {
    fn default() -> Self {
        Self {
            max_inflight: 2_048,
            headroom: None,
            // Mirror the Admission::default() weights so serde(default) yields identical behavior.
            weights: Weights {
                anon: 1,
                auth: 5,
                admin: 10,
            },
        }
    }
}

impl FairQueue {
    /// Returns (hard, headroom) as `usize` for guards.
    #[inline]
    pub fn hard_and_headroom(&self) -> (usize, usize) {
        let hard = self.max_inflight as usize;
        // clippy(unnecessary_min_or_max): value is non-negative already (u64)
        let head = self.headroom.unwrap_or(self.max_inflight / 8) as usize;
        (hard, head)
    }
}

#[derive(Debug, Clone, Deserialize, Default)]
pub struct Weights {
    #[serde(default)]
    pub anon: u32,
    #[serde(default)]
    pub auth: u32,
    #[serde(default)]
    pub admin: u32,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BodyCaps {
    pub max_content_length: u64,
    pub reject_on_missing_length: bool,
}

impl Default for BodyCaps {
    fn default() -> Self {
        Self {
            max_content_length: 1_048_576 * 10,
            reject_on_missing_length: true,
        }
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct Decompress {
    #[serde(default)]
    pub allow: Vec<String>,
    #[serde(default)]
    pub deny_stacked: bool,
}

impl Default for Decompress {
    fn default() -> Self {
        Self {
            allow: vec!["identity".into(), "gzip".into()],
            deny_stacked: true,
        }
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct Policy {
    pub enabled: bool,
    pub bundle_path: String,
    /// "deny" or "allow" on evaluator failure (kept for future use).
    #[serde(default = "Policy::default_fail_mode")]
    pub fail_mode: String,
}

impl Policy {
    fn default_fail_mode() -> String {
        "deny".into()
    }
    pub fn fail_deny(&self) -> bool {
        self.fail_mode.eq_ignore_ascii_case("deny")
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct Readiness {
    pub max_inflight_threshold: u64,
    pub error_rate_429_503_pct: f64,
    pub window_secs: u64,
    pub hold_for_secs: u64,
}

impl Config {
    /// Load config with precedence: CLI `--config <path>` (handled in main) → env overrides → defaults/file.
    pub fn load() -> anyhow::Result<Self> {
        // Try file from default search paths.
        if let Some(cfg) = file::load_from_default_path()? {
            let mut cfg = cfg;
            env::apply_env_overrides(&mut cfg)?;
            validate::validate(&cfg)?;
            anyhow::ensure!(
                cfg.oap.max_frame_bytes <= 1_048_576,
                "oap.max_frame_bytes > 1MiB not allowed"
            );
            return Ok(cfg);
        }

        // Fallback minimal defaults (safe localhost).
        let mut cfg = Self {
            server: Server {
                bind: "127.0.0.1:5305".parse()?,
                metrics_addr: "127.0.0.1:9605".parse()?,
                amnesia: true,
            },
            oap: Oap {
                max_frame_bytes: 1_048_576,
                stream_chunk_bytes: 65_536,
            },
            admission: Admission::default(),
            policy: Policy {
                enabled: false,
                bundle_path: "policy.bundle.json".into(),
                fail_mode: "deny".into(),
            },
            readiness: Readiness {
                max_inflight_threshold: 1_800,
                error_rate_429_503_pct: 2.0,
                window_secs: 10,
                hold_for_secs: 30,
            },
        };
        env::apply_env_overrides(&mut cfg)?;
        validate::validate(&cfg)?;
        Ok(cfg)
    }

    /// Explicit file load (used by main when `--config` is provided).
    pub fn from_toml_file<P: AsRef<Path>>(p: P) -> anyhow::Result<Self> {
        let s = fs::read_to_string(p)?;
        let mut cfg: Self = toml::from_str(&s)?;
        env::apply_env_overrides(&mut cfg)?;
        validate::validate(&cfg)?;
        anyhow::ensure!(
            cfg.oap.max_frame_bytes <= 1_048_576,
            "oap.max_frame_bytes > 1MiB not allowed"
        );
        Ok(cfg)
    }
}

```

### crates/omnigate/src/config/reload.rs
<a id="crates-omnigate-src-config-reload-rs"></a>

```rust
//! RO:WHAT — Hot-reload scaffold (listen for kernel ConfigUpdated, apply).
//! RO:WHY  — RON pattern: runtime config changes without restart; Concerns: GOV/RES.
//! RO:INTERACTS — ron-kernel bus events; to be wired in Phase 2.

pub struct Reload; // placeholder for future reload worker

```

### crates/omnigate/src/config/validate.rs
<a id="crates-omnigate-src-config-validate-rs"></a>

```rust
//! RO:WHAT — Validate Config invariants (caps, limits).
//! RO:WHY  — Prevent misconfig from violating protocol/HTTP limits; Concerns: GOV/SEC.
//! RO:INVARIANTS — OAP max_frame=1MiB; body cap ≤1MiB; decompression ≤10x (to be added when body handling lands).

use super::Config;

pub fn validate(_cfg: &Config) -> anyhow::Result<()> {
    // Add concrete checks as data-plane routes land (body caps, timeouts, inflight).
    Ok(())
}

```

### crates/omnigate/src/downstream/dht_client.rs
<a id="crates-omnigate-src-downstream-dhtclient-rs"></a>

```rust
//! RO:WHAT   DHT service client (thin).
//! RO:WHY    Encapsulate K/V provider lookups etc.

use super::{build_client, DsError};
use std::time::Duration;

#[derive(Clone)]
pub struct DhtClient {
    base_url: String,
    client: reqwest::Client,
    connect_timeout: Duration,
    req_timeout: Duration,
}

impl Default for DhtClient {
    fn default() -> Self { Self::new("http://127.0.0.1:5301") }
}

impl DhtClient {
    pub fn new(base_url: &str) -> Self {
        Self {
            base_url: base_url.to_owned(),
            client: build_client(),
            connect_timeout: Duration::from_millis(200),
            req_timeout: Duration::from_secs(2),
        }
    }

    pub async fn healthz(&self) -> Result<String, DsError> {
        let url = format!("{}/healthz", self.base_url.trim_end_matches('/'));
        let res = self.client
            .get(url)
            .connect_timeout(self.connect_timeout)
            .timeout(self.req_timeout)
            .send().await?;
        if res.status().is_success() {
            Ok(res.text().await.unwrap_or_default())
        } else {
            Ok(format!("status={}", res.status().as_u16()))
        }
    }
}

```

### crates/omnigate/src/downstream/error.rs
<a id="crates-omnigate-src-downstream-error-rs"></a>

```rust
//! RO:WHAT   Egress error taxonomy.
//! RO:WHY    Normalize reqwest errors + HTTP status into a small set.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum DsError {
    #[error("http {status}: {body}")]
    Http { status: u16, body: String },
    #[error("network: {0}")]
    Net(#[from] reqwest::Error),
    #[error("serde: {0}")]
    Serde(#[from] serde_json::Error),
}

impl DsError {
    pub fn is_retryable(&self) -> bool {
        match self {
            DsError::Http { status, .. } => (500..600).contains(status),
            DsError::Net(e) => e.is_connect() || e.is_timeout() || e.is_request(),
            DsError::Serde(_) => false,
        }
    }
}

```

### crates/omnigate/src/downstream/hedge.rs
<a id="crates-omnigate-src-downstream-hedge-rs"></a>

```rust
//! RO:WHAT   Hedged requests helper: launch a second attempt after a delay, take first success.
//! RO:WHY    Reduce tail latency for p95+ under occasional stragglers.
//! RO:INVARS  Max two in-flight per call; second attempt only if first hasn't finished.

use super::{DsError, RetryPolicy};
use rand::rngs::StdRng;
use tokio::task::JoinSet;
use std::future::Future;

pub async fn hedge2<F, T>(
    make_call: impl Fn() -> F + Send + Sync + 'static + Clone,
    hedged_after_ms: u64,
) -> Result<T, DsError>
where
    F: Future<Output = Result<T, DsError>> + Send + 'static,
    T: Send + 'static,
{
    let mut js = JoinSet::new();
    js.spawn(make_call.clone()());
    tokio::time::sleep(std::time::Duration::from_millis(hedged_after_ms)).await;
    js.spawn(make_call());

    while let Some(res) = js.join_next().await {
        match res {
            Ok(Ok(v)) => return Ok(v),
            Ok(Err(_)) => continue,
            Err(_) => continue,
        }
    }
    Err(DsError::Net(reqwest::Error::new(
        reqwest::ErrorKind::Request,
        "both hedged attempts failed",
    )))
}

```

### crates/omnigate/src/downstream/index_client.rs
<a id="crates-omnigate-src-downstream-indexclient-rs"></a>

```rust
//! RO:WHAT   Index service client (thin wrapper over reqwest).
//! RO:WHY    Keep service-specific paths/types out of generic code.
//! RO:INTERACTS  GET /healthz, generic JSON GET/POST for later expansion.

use super::{build_client, DsError, RetryPolicy, full_jitter_backoff};
use rand::rngs::StdRng;
use rand::SeedableRng;
use std::time::Duration;

#[derive(Clone)]
pub struct IndexClient {
    base_url: String,
    client: reqwest::Client,
    retry: RetryPolicy,
    connect_timeout: Duration,
    req_timeout: Duration,
}

impl Default for IndexClient {
    fn default() -> Self {
        Self::new("http://127.0.0.1:5304")
    }
}

impl IndexClient {
    pub fn new(base_url: &str) -> Self {
        Self {
            base_url: base_url.to_owned(),
            client: build_client(),
            retry: RetryPolicy::default(),
            connect_timeout: Duration::from_millis(200),
            req_timeout: Duration::from_secs(2),
        }
    }

    pub fn with_retry(mut self, retry: RetryPolicy) -> Self { self.retry = retry; self }

    pub async fn healthz(&self) -> Result<String, DsError> {
        self.get_text("/healthz", None).await
    }

    pub async fn get_json<T: serde::de::DeserializeOwned>(&self, path: &str) -> Result<T, DsError> {
        self.exec::<(), T>("GET", path, None, None).await
    }

    pub async fn post_json<B: serde::Serialize, T: serde::de::DeserializeOwned>(&self, path: &str, body: &B) -> Result<T, DsError> {
        self.exec("POST", path, Some(body), None).await
    }

    pub async fn get_text(&self, path: &str, corr_id: Option<&str>) -> Result<String, DsError> {
        self.exec::<(), String>("GET", path, None, corr_id).await
    }

    async fn exec<B: serde::Serialize, T: serde::de::DeserializeOwned>(
        &self,
        method: &str,
        path: &str,
        body: Option<&B>,
        corr_id: Option<&str>,
    ) -> Result<T, DsError> {
        let url = format!("{}/{}", self.base_url.trim_end_matches('/'), path.trim_start_matches('/'));
        let mut attempt = 1u32;
        let mut rng = StdRng::from_entropy();

        loop {
            let res = {
                let mut req = self.client
                    .request(reqwest::Method::from_bytes(method.as_bytes()).unwrap(), &url)
                    .connect_timeout(self.connect_timeout)
                    .timeout(self.req_timeout);

                if let Some(id) = corr_id {
                    if let Ok(v) = reqwest::header::HeaderValue::from_str(id) {
                        let mut h = req.headers_mut();
                        h.insert("x-correlation-id", v);
                    }
                }
                if let Some(b) = body {
                    req = req.json(b);
                }
                req.send().await
            };

            match res {
                Ok(r) if r.status().is_success() => {
                    if std::any::TypeId::of::<T>() == std::any::TypeId::of::<String>() {
                        // Fast path: text
                        let txt = r.text().await.map_err(DsError::Net)?;
                        // SAFETY: we know T=String at this call site
                        let any = unsafe { std::mem::transmute::<String, T>(txt) };
                        return Ok(any);
                    } else {
                        let txt = r.text().await.map_err(DsError::Net)?;
                        let out = serde_json::from_str::<T>(&txt)?;
                        return Ok(out);
                    }
                }
                Ok(r) => {
                    let status = r.status().as_u16();
                    let body = r.text().await.unwrap_or_default();
                    let err = DsError::Http { status, body };
                    if attempt >= self.retry.max_attempts || !err.is_retryable() {
                        return Err(err);
                    }
                    let sleep = full_jitter_backoff(attempt, self.retry.base_delay, self.retry.max_delay, &mut rng);
                    tokio::time::sleep(sleep).await;
                }
                Err(e) => {
                    let err = DsError::from(e);
                    if attempt >= self.retry.max_attempts || !err.is_retryable() {
                        return Err(err);
                    }
                    let sleep = full_jitter_backoff(attempt, self.retry.base_delay, self.retry.max_delay, &mut rng);
                    tokio::time::sleep(sleep).await;
                }
            }

            attempt += 1;
        }
    }
}

```

### crates/omnigate/src/downstream/latency.rs
<a id="crates-omnigate-src-downstream-latency-rs"></a>

```rust
//! RO:WHAT   Small latency helpers for downstream timing (standalone).
//! RO:WHY    Keep measurement logic trivial to test/mock.

use std::time::{Duration, Instant};

pub struct Timer(Instant);

impl Timer {
    pub fn start() -> Self { Self(Instant::now()) }
    pub fn stop(self) -> Duration { self.0.elapsed() }
}

```

### crates/omnigate/src/downstream/mailbox_client.rs
<a id="crates-omnigate-src-downstream-mailboxclient-rs"></a>

```rust
//! RO:WHAT   Mailbox/notification client (thin).
//! RO:WHY    Keeps notify calls decoupled from core.

use super::{build_client, DsError};
use std::time::Duration;

#[derive(Clone)]
pub struct MailboxClient {
    base_url: String,
    client: reqwest::Client,
    connect_timeout: Duration,
    req_timeout: Duration,
}

impl Default for MailboxClient {
    fn default() -> Self { Self::new("http://127.0.0.1:5310") }
}

impl MailboxClient {
    pub fn new(base_url: &str) -> Self {
        Self {
            base_url: base_url.to_owned(),
            client: build_client(),
            connect_timeout: Duration::from_millis(200),
            req_timeout: Duration::from_secs(2),
        }
    }

    pub async fn healthz(&self) -> Result<String, DsError> {
        let url = format!("{}/healthz", self.base_url.trim_end_matches('/'));
        let res = self.client
            .get(url)
            .connect_timeout(self.connect_timeout)
            .timeout(self.req_timeout)
            .send().await?;
        if res.status().is_success() {
            Ok(res.text().await.unwrap_or_default())
        } else {
            Ok(format!("status={}", res.status().as_u16()))
        }
    }
}

```

### crates/omnigate/src/downstream/mod.rs
<a id="crates-omnigate-src-downstream-mod-rs"></a>

```rust
//! RO:WHAT   Downstream (egress) HTTP client stack for calling RON services.
//! RO:WHY    Centralize retries, timeouts, and error taxonomy; keep wrappers thin.
//! RO:INTERACTS reqwest (rustls), tokio, crate::observability (corr-id later).
//! RO:INVARS  Finite timeouts; 4xx never retried; retries use jitter; no panics.

mod retry;
mod error;

pub mod latency;
pub mod hedge;

pub mod index_client;
pub mod storage_client;
pub mod mailbox_client;
pub mod dht_client;

pub use error::DsError;
pub use retry::{RetryPolicy, full_jitter_backoff};

use std::time::Duration;

/// RO:WHAT Build a default reqwest client suitable for internal calls.
/// RO:WHY  Ensure consistent TLS & connection settings.
pub fn build_client() -> reqwest::Client {
    reqwest::Client::builder()
        .pool_idle_timeout(Duration::from_secs(30))
        .tcp_keepalive(Duration::from_secs(30))
        .use_rustls_tls()
        .build()
        .expect("reqwest client")
}

```

### crates/omnigate/src/downstream/registry.rs
<a id="crates-omnigate-src-downstream-registry-rs"></a>

```rust
//! RO:WHAT   In-memory registry mapping ServiceKind -> Endpoint config.
//! RO:WHY    Late-binding of base URLs and timeouts; simple and explicit.
//! RO:INVARS  Base URLs are absolute; timeouts finite; defaults are localhost dev-safe.

use crate::downstream::types::ServiceKind;
use std::collections::HashMap;
use std::time::Duration;

#[derive(Debug, Clone)]
pub struct EndpointCfg {
    pub base_url: String,          // e.g., "http://127.0.0.1:5304"
    pub connect_timeout: Duration, // TCP connect
    pub timeout: Duration,         // whole request
}

#[derive(Debug, Clone)]
pub struct DownstreamRegistry {
    map: HashMap<ServiceKind, EndpointCfg>,
}

impl DownstreamRegistry {
    pub fn get(&self, k: ServiceKind) -> Option<&EndpointCfg> {
        self.map.get(&k)
    }

    pub fn insert(&mut self, k: ServiceKind, e: EndpointCfg) {
        self.map.insert(k, e);
    }
}

impl Default for DownstreamRegistry {
    fn default() -> Self {
        use ServiceKind::*;
        let mut map = HashMap::new();
        let fast = EndpointCfg {
            base_url: "http://127.0.0.1:5300".into(),
            connect_timeout: Duration::from_millis(200),
            timeout: Duration::from_secs(2),
        };
        // Dev-safe placeholders; change per crate ports as needed.
        map.insert(Index,   EndpointCfg { base_url: "http://127.0.0.1:5304".into(), ..fast.clone() });
        map.insert(Storage, EndpointCfg { base_url: "http://127.0.0.1:5303".into(), ..fast.clone() });
        map.insert(Dht,     EndpointCfg { base_url: "http://127.0.0.1:5301".into(), ..fast.clone() });
        map.insert(Naming,  EndpointCfg { base_url: "http://127.0.0.1:5302".into(), ..fast.clone() });
        map.insert(Overlay, EndpointCfg { base_url: "http://127.0.0.1:5306".into(), ..fast.clone() });
        map.insert(Policy,  EndpointCfg { base_url: "http://127.0.0.1:9609".into(), ..fast.clone() });
        Self { map }
    }
}

```

### crates/omnigate/src/downstream/retry.rs
<a id="crates-omnigate-src-downstream-retry-rs"></a>

```rust
//! RO:WHAT   Retry policy & jittered backoff helpers for outbound HTTP.
//! RO:WHY    Make transient failures tolerable without thundering herd.
//! RO:INVARS  Budgeted attempts; exponential w/ full jitter; never retry 4xx.

use rand::{rngs::StdRng, Rng, SeedableRng};
use std::time::Duration;

#[derive(Debug, Clone)]
pub struct RetryPolicy {
    pub max_attempts: u32,   // total, including first try
    pub base_delay: Duration,
    pub max_delay: Duration,
}

impl Default for RetryPolicy {
    fn default() -> Self {
        Self {
            max_attempts: 3,
            base_delay: Duration::from_millis(50),
            max_delay: Duration::from_millis(600),
        }
    }
}

pub fn full_jitter_backoff(attempt: u32, base: Duration, max: Duration, rng: &mut StdRng) -> Duration {
    let exp = base.saturating_mul(1u32.saturating_shl(attempt.saturating_sub(1).min(10)));
    let cap = std::cmp::min(exp, max);
    let nanos = rng.gen_range(0..=cap.as_nanos() as u128);
    Duration::from_nanos(nanos as u64)
}

pub fn new_rng() -> StdRng { StdRng::from_entropy() }

```

### crates/omnigate/src/downstream/storage_client.rs
<a id="crates-omnigate-src-downstream-storageclient-rs"></a>

```rust
//! RO:WHAT   Storage service client (thin).
//! RO:WHY    Keep storage-specific calls contained here.

use super::{build_client, DsError, RetryPolicy, full_jitter_backoff};
use rand::rngs::StdRng;
use rand::SeedableRng;
use std::time::Duration;

#[derive(Clone)]
pub struct StorageClient {
    base_url: String,
    client: reqwest::Client,
    retry: RetryPolicy,
    connect_timeout: Duration,
    req_timeout: Duration,
}

impl Default for StorageClient {
    fn default() -> Self { Self::new("http://127.0.0.1:5303") }
}

impl StorageClient {
    pub fn new(base_url: &str) -> Self {
        Self {
            base_url: base_url.to_owned(),
            client: build_client(),
            retry: RetryPolicy::default(),
            connect_timeout: Duration::from_millis(200),
            req_timeout: Duration::from_secs(3),
        }
    }

    pub async fn healthz(&self) -> Result<String, DsError> {
        self.get_text("/healthz").await
    }

    pub async fn get_text(&self, path: &str) -> Result<String, DsError> {
        self.exec::<(), String>("GET", path, None).await
    }

    pub async fn post_json<B: serde::Serialize, T: serde::de::DeserializeOwned>(&self, path: &str, body: &B) -> Result<T, DsError> {
        self.exec("POST", path, Some(body)).await
    }

    async fn exec<B: serde::Serialize, T: serde::de::DeserializeOwned>(
        &self,
        method: &str,
        path: &str,
        body: Option<&B>,
    ) -> Result<T, DsError> {
        let url = format!("{}/{}", self.base_url.trim_end_matches('/'), path.trim_start_matches('/'));
        let mut attempt = 1u32;
        let mut rng = StdRng::from_entropy();

        loop {
            let res = {
                let mut req = self.client
                    .request(reqwest::Method::from_bytes(method.as_bytes()).unwrap(), &url)
                    .connect_timeout(self.connect_timeout)
                    .timeout(self.req_timeout);

                if let Some(b) = body { req = req.json(b); }
                req.send().await
            };

            match res {
                Ok(r) if r.status().is_success() => {
                    if std::any::TypeId::of::<T>() == std::any::TypeId::of::<String>() {
                        let txt = r.text().await.map_err(DsError::Net)?;
                        let any = unsafe { std::mem::transmute::<String, T>(txt) };
                        return Ok(any);
                    } else {
                        let txt = r.text().await.map_err(DsError::Net)?;
                        let out = serde_json::from_str::<T>(&txt)?;
                        return Ok(out);
                    }
                }
                Ok(r) => {
                    let status = r.status().as_u16();
                    let body = r.text().await.unwrap_or_default();
                    let err = DsError::Http { status, body };
                    if attempt >= self.retry.max_attempts || !err.is_retryable() {
                        return Err(err);
                    }
                    let sleep = full_jitter_backoff(attempt, self.retry.base_delay, self.retry.max_delay, &mut rng);
                    tokio::time::sleep(sleep).await;
                }
                Err(e) => {
                    let err = DsError::from(e);
                    if attempt >= self.retry.max_attempts || !err.is_retryable() {
                        return Err(err);
                    }
                    let sleep = full_jitter_backoff(attempt, self.retry.base_delay, self.retry.max_delay, &mut rng);
                    tokio::time::sleep(sleep).await;
                }
            }
            attempt += 1;
        }
    }
}

```

### crates/omnigate/src/downstream/types.rs
<a id="crates-omnigate-src-downstream-types-rs"></a>

```rust
//! RO:WHAT   Core enums/types for downstream services.
//! RO:WHY    Keep labels low-cardinality and stable across releases.

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ServiceKind {
    Index,
    Storage,
    Dht,
    Naming,
    Overlay,
    Policy, // if ever queried (bundle host, etc.)
}

impl ServiceKind {
    pub fn as_str(&self) -> &'static str {
        match self {
            ServiceKind::Index => "index",
            ServiceKind::Storage => "storage",
            ServiceKind::Dht => "dht",
            ServiceKind::Naming => "naming",
            ServiceKind::Overlay => "overlay",
            ServiceKind::Policy => "policy",
        }
    }
}

```

### crates/omnigate/src/errors/http_map.rs
<a id="crates-omnigate-src-errors-httpmap-rs"></a>

```rust
// crates/omnigate/src/errors/http_map.rs
//! RO:WHAT   Map admission/policy errors to stable JSON problem docs + helpers.
//! RO:WHY    Clients/SREs need consistent, parseable error envelopes.
//! RO:INTERACTS middleware::{quotas,fair_queue,body_caps,decompress_guard,policy}, admin plane.
//! RO:INVARS  Always include x-request-id upstream; no secret leakage; status matches code.

use axum::{
    http::{header::RETRY_AFTER, HeaderMap, HeaderValue, StatusCode},
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;

use super::reasons::Reason;

/// Stable problem envelope for client-visible errors.
#[derive(Serialize)]
pub struct Problem<'a> {
    pub code: &'a str,
    pub message: &'a str,
    pub retryable: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retry_after_ms: Option<u64>,
    /// Optional free-form reason (e.g., policy reason like "put blocked").
    /// For guard helpers (body_caps, decompress_guard, etc.) this is a
    /// lowercase/snake-case code derived from `Reason`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<&'a str>,
}

/// Convert a millisecond budget into a Retry-After header value in SECONDS (ceil).
#[inline]
fn retry_after_header_secs(ms: u64) -> String {
    ms.div_ceil(1000).to_string()
}

/// Tiny helper used by tests and preflight guards: returns a canonical Problem JSON with the
/// HTTP status derived from `Reason`.
pub fn to_response(reason: Reason, message: &str) -> Response {
    let body = Problem {
        code: reason.code_str(),
        message,
        retryable: reason.retryable(),
        retry_after_ms: None,
        // IMPORTANT: tests like middleware_contract assert on this field
        // being a non-null snake_case string (e.g. "payload_too_large").
        reason: Some(reason.reason_str()),
    };
    (reason.status(), Json(body)).into_response()
}

/// Admission / policy / overload error space rendered as Problem JSON.
pub enum GateError<'a> {
    // Admission
    RateLimitedGlobal {
        retry_after_ms: u64,
    },
    RateLimitedIp {
        retry_after_ms: u64,
    },
    PayloadTooLarge {
        limit: u64,
    },
    UnsupportedEncoding {
        encoding: &'a str,
    },
    StackedEncodings,

    // Policy
    /// 403 default, 451 for legal blocks (status provided by caller)
    PolicyDeny {
        reason: &'a str,
        status: StatusCode,
    },
    /// 503 when evaluator fails/errors
    PolicyError,

    // Overload
    /// 503 when readiness gate is down
    Degraded,
}

impl<'a> IntoResponse for GateError<'a> {
    fn into_response(self) -> Response {
        match self {
            GateError::RateLimitedGlobal { retry_after_ms } => {
                let mut headers = HeaderMap::new();
                let hv = HeaderValue::from_str(&retry_after_header_secs(retry_after_ms))
                    .unwrap_or_else(|_| HeaderValue::from_static("1"));
                headers.insert(RETRY_AFTER, hv);
                let body = Problem {
                    code: Reason::TooManyRequests.code_str(),
                    message: "Global rate limit",
                    retryable: true,
                    retry_after_ms: Some(retry_after_ms),
                    reason: None,
                };
                (StatusCode::TOO_MANY_REQUESTS, headers, Json(body)).into_response()
            }
            GateError::RateLimitedIp { retry_after_ms } => {
                let mut headers = HeaderMap::new();
                let hv = HeaderValue::from_str(&retry_after_header_secs(retry_after_ms))
                    .unwrap_or_else(|_| HeaderValue::from_static("1"));
                headers.insert(RETRY_AFTER, hv);
                let body = Problem {
                    code: Reason::TooManyRequests.code_str(),
                    message: "IP quota exceeded",
                    retryable: true,
                    retry_after_ms: Some(retry_after_ms),
                    reason: None,
                };
                (StatusCode::TOO_MANY_REQUESTS, headers, Json(body)).into_response()
            }
            GateError::PayloadTooLarge { .. } => {
                let body = Problem {
                    code: Reason::PayloadTooLarge.code_str(),
                    message: "Body exceeds limit",
                    retryable: false,
                    retry_after_ms: None,
                    reason: None,
                };
                (StatusCode::PAYLOAD_TOO_LARGE, Json(body)).into_response()
            }
            GateError::UnsupportedEncoding { .. } | GateError::StackedEncodings => {
                let body = Problem {
                    code: Reason::UnsupportedMediaType.code_str(),
                    message: "Encoding not allowed",
                    retryable: false,
                    retry_after_ms: None,
                    reason: None,
                };
                (StatusCode::UNSUPPORTED_MEDIA_TYPE, Json(body)).into_response()
            }
            GateError::PolicyDeny { reason, status } => {
                let code = if status == StatusCode::UNAVAILABLE_FOR_LEGAL_REASONS {
                    "LEGAL_RESTRICTION"
                } else {
                    "POLICY_DENY"
                };
                let body = Problem {
                    code,
                    message: "Access denied",
                    retryable: false,
                    retry_after_ms: None,
                    // For policy we preserve the free-form reason provided by caller.
                    reason: Some(reason),
                };
                (status, Json(body)).into_response()
            }
            GateError::PolicyError => {
                // Small backoff hint (250ms) + header
                let retry_after_ms = 250u64;
                let mut headers = HeaderMap::new();
                let hv = HeaderValue::from_str(&retry_after_header_secs(retry_after_ms))
                    .unwrap_or_else(|_| HeaderValue::from_static("1"));
                headers.insert(RETRY_AFTER, hv);
                let body = Problem {
                    code: "POLICY_ERROR",
                    message: "Policy evaluation failed",
                    retryable: true,
                    retry_after_ms: Some(retry_after_ms),
                    reason: None,
                };
                (StatusCode::SERVICE_UNAVAILABLE, headers, Json(body)).into_response()
            }
            GateError::Degraded => {
                // Backoff hint (250ms) + header
                let retry_after_ms = 250u64;
                let mut headers = HeaderMap::new();
                let hv = HeaderValue::from_str(&retry_after_header_secs(retry_after_ms))
                    .unwrap_or_else(|_| HeaderValue::from_static("1"));
                headers.insert(RETRY_AFTER, hv);
                let body = Problem {
                    code: "SERVICE_DEGRADED",
                    message: "Overload protection",
                    retryable: true,
                    retry_after_ms: Some(retry_after_ms),
                    reason: None,
                };
                (StatusCode::SERVICE_UNAVAILABLE, headers, Json(body)).into_response()
            }
        }
    }
}

/// Generic downstream error mapper used by v1 passthrough routes (no crate::downstream dependency).
pub fn map_ds_error<E: std::fmt::Display>(e: E) -> (StatusCode, String) {
    (StatusCode::BAD_GATEWAY, e.to_string())
}

```

### crates/omnigate/src/errors/mod.rs
<a id="crates-omnigate-src-errors-mod-rs"></a>

```rust
//! RO:WHAT — Error taxonomy + HTTP mapping.
//! RO:WHY  — Deterministic errors (RON invariant); Concerns: DX/GOV.
//! RO:INTERACTS — http_map.rs, reasons.rs.

pub mod http_map;
pub mod reasons;

pub use http_map::{GateError, Problem};
pub use reasons::Reason;

```

### crates/omnigate/src/errors/reasons.rs
<a id="crates-omnigate-src-errors-reasons-rs"></a>

```rust
// RO:WHAT  Canonical reason codes used by http_map to produce JSON envelopes.
// RO:INVARS Codes are stable ASCII-UPPER_SNAKE where applicable.

use axum::http::StatusCode;

#[derive(Debug, Copy, Clone)]
pub enum Reason {
    // Common
    BadRequest,
    Unauthorized,
    Forbidden,
    NotFound,
    MethodNotAllowed,
    PayloadTooLarge,
    UnsupportedMediaType,
    TooManyRequests,
    Internal,

    // Policy
    PolicyDeny,
    PolicyError,

    // New: for 411 responses when payload methods omit Content-Length
    LengthRequired,
}

impl Reason {
    pub fn status(self) -> StatusCode {
        match self {
            Reason::BadRequest => StatusCode::BAD_REQUEST,
            Reason::Unauthorized => StatusCode::UNAUTHORIZED,
            Reason::Forbidden => StatusCode::FORBIDDEN,
            Reason::NotFound => StatusCode::NOT_FOUND,
            Reason::MethodNotAllowed => StatusCode::METHOD_NOT_ALLOWED,
            Reason::PayloadTooLarge => StatusCode::PAYLOAD_TOO_LARGE,
            Reason::UnsupportedMediaType => StatusCode::UNSUPPORTED_MEDIA_TYPE,
            Reason::TooManyRequests => StatusCode::TOO_MANY_REQUESTS,
            Reason::Internal => StatusCode::INTERNAL_SERVER_ERROR,

            Reason::PolicyDeny => StatusCode::FORBIDDEN,
            Reason::PolicyError => StatusCode::SERVICE_UNAVAILABLE,

            Reason::LengthRequired => StatusCode::LENGTH_REQUIRED, // 411
        }
    }

    pub fn code_str(self) -> &'static str {
        match self {
            Reason::BadRequest => "BAD_REQUEST",
            Reason::Unauthorized => "UNAUTHORIZED",
            Reason::Forbidden => "FORBIDDEN",
            Reason::NotFound => "NOT_FOUND",
            Reason::MethodNotAllowed => "METHOD_NOT_ALLOWED",
            Reason::PayloadTooLarge => "PAYLOAD_TOO_LARGE",
            Reason::UnsupportedMediaType => "UNSUPPORTED_MEDIA_TYPE",
            Reason::TooManyRequests => "TOO_MANY_REQUESTS",
            Reason::Internal => "INTERNAL",

            Reason::PolicyDeny => "POLICY_DENY",
            Reason::PolicyError => "POLICY_ERROR",

            Reason::LengthRequired => "LENGTH_REQUIRED",
        }
    }

    /// Lowercase/snake-case reason code used in Problem JSON.
    ///
    /// This is what middleware_contract tests assert on, e.g.:
    ///   * 413 → "payload_too_large"
    ///   * 415 → "unsupported_media_type"
    ///   * 411 → "length_required"
    pub fn reason_str(self) -> &'static str {
        match self {
            Reason::BadRequest => "bad_request",
            Reason::Unauthorized => "unauthorized",
            Reason::Forbidden => "forbidden",
            Reason::NotFound => "not_found",
            Reason::MethodNotAllowed => "method_not_allowed",
            Reason::PayloadTooLarge => "payload_too_large",
            Reason::UnsupportedMediaType => "unsupported_media_type",
            Reason::TooManyRequests => "too_many_requests",
            Reason::Internal => "internal",

            Reason::PolicyDeny => "policy_deny",
            Reason::PolicyError => "policy_error",

            Reason::LengthRequired => "length_required",
        }
    }

    pub fn retryable(self) -> bool {
        matches!(
            self,
            Reason::TooManyRequests | Reason::PolicyError | Reason::Internal
        )
    }
}

```

### crates/omnigate/src/hydration/compose.rs
<a id="crates-omnigate-src-hydration-compose-rs"></a>

```rust

```

### crates/omnigate/src/hydration/mod.rs
<a id="crates-omnigate-src-hydration-mod-rs"></a>

```rust

```

### crates/omnigate/src/hydration/planner.rs
<a id="crates-omnigate-src-hydration-planner-rs"></a>

```rust

```

### crates/omnigate/src/lib.rs
<a id="crates-omnigate-src-lib-rs"></a>

```rust
// crates/omnigate/src/lib.rs
#![allow(clippy::needless_return)]

pub mod admission;
pub mod bootstrap;
pub mod config;
pub mod errors;
pub mod metrics;
pub mod middleware;
pub mod observability;
pub mod readiness;
pub mod routes;
pub mod runtime;
pub mod types;
pub mod zk;

use axum::{extract::State, response::IntoResponse, routing::get, Extension, Router};
use ron_kernel::metrics::{health::HealthState, readiness::Readiness as KernelReadiness};
use ron_kernel::Metrics;
use std::net::SocketAddr;
use std::sync::Arc;
use tracing::{info, warn};

use ron_policy::PolicyBundle;
use serde_json::Map;

#[derive(Clone)]
pub struct App {
    pub router: Router,
    pub admin_addr: SocketAddr,
}

impl App {
    pub async fn build(cfg: config::Config) -> anyhow::Result<Self> {
        let amnesia_from_cfg = cfg.server.amnesia;
        let amnesia_from_env = matches!(
            std::env::var("OMNIGATE_AMNESIA").as_deref(),
            Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
        );
        let amnesia_on = amnesia_from_cfg || amnesia_from_env;
        info!(
            amnesia_from_cfg,
            amnesia_from_env, amnesia_on, "amnesia mode resolved"
        );

        let metrics = Metrics::new(false);
        metrics.set_amnesia(amnesia_on);

        crate::metrics::gates::init_gate_metrics();

        let health = HealthState::new();
        let kernel_ready = KernelReadiness::new(health.clone());

        let (_admin_task, admin_addr) = metrics
            .clone()
            .serve(
                cfg.server.metrics_addr,
                health.clone(),
                kernel_ready.clone(),
            )
            .await
            .map_err(|e| anyhow::anyhow!("{}", e))?;

        health.set("omnigate", true);
        health.set("config", true);
        kernel_ready.set_config_loaded(true);

        let dev_ready = matches!(
            std::env::var("OMNIGATE_DEV_READY").as_deref(),
            Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
        );
        if dev_ready {
            info!("OMNIGATE_DEV_READY=on — /readyz will report 200 (dev override)");
        }

        // Local readiness policy + admin state
        let rp = Arc::new(readiness::policy::ReadyPolicy::new());
        let admin_state = readiness::state::AdminState::new(
            health.clone(),
            kernel_ready.clone(),
            dev_ready,
            &cfg.readiness,
            rp.clone(),
        );

        // -------------------- ROUTES --------------------
        let api_v1 = crate::routes::v1::index::router();

        async fn healthz(State(st): State<readiness::state::AdminState>) -> impl IntoResponse {
            ron_kernel::metrics::health::healthz_handler(st.health.clone()).await
        }

        let ops = Router::new()
            .route("/ops/version", get(crate::routes::ops::version))
            .route("/ops/readyz", get(readiness::readyz))
            .route("/ops/healthz", get(healthz))
            .route(
                "/ops/metrics",
                get(|| async {
                    use prometheus::TextEncoder;
                    let encoder = TextEncoder::new();
                    let mfs = prometheus::gather();
                    encoder.encode_to_string(&mfs).unwrap_or_default()
                }),
            )
            .with_state(admin_state.clone());

        let roots = Router::new()
            .route("/versionz", get(crate::routes::ops::versionz))
            .route("/readyz", get(readiness::readyz))
            .route("/healthz", get(healthz))
            .with_state(admin_state);

        // Base router (no layers yet)
        let mut app_router = Router::new().merge(roots).merge(ops).nest("/v1", api_v1);

        // -------------------- HTTP MIDDLEWARE + ADMISSION (INNER) --------------------
        // Apply the HTTP middleware stack first (includes PolicyLayer),
        // then admission (quotas/fair-queue) — these are INNER layers.
        app_router = middleware::apply_with_cfg(app_router, &cfg.admission)
            .layer(observability::http_trace_layer());
        app_router = crate::admission::attach_with_cfg(app_router, &cfg.admission);

        // -------------------- POLICY BUNDLE (OUTERMOST so inner policy layer can see it) --------------------
        // In Axum, the last .layer(...) is the outermost and runs first. We want the Extension
        // to run BEFORE the PolicyLayer (which we already added inside apply_with_cfg), so it must
        // be layered AFTER apply_with_cfg/admission.
        let mut have_bundle = false;
        if cfg.policy.enabled {
            match std::fs::read_to_string(&cfg.policy.bundle_path) {
                Ok(json) => match serde_json::from_str::<PolicyBundle>(&json) {
                    Ok(bundle) => {
                        crate::metrics::registry::POLICY_BUNDLE_LOADED_TOTAL.inc();
                        info!(path=%cfg.policy.bundle_path, "policy bundle loaded and inserted");
                        app_router = app_router.layer(Extension(Arc::new(bundle)));
                        have_bundle = true;
                    }
                    Err(e1) => {
                        let top_keys = serde_json::from_str::<serde_json::Value>(&json)
                            .ok()
                            .and_then(|v| {
                                v.as_object().map(|o| o.keys().cloned().collect::<Vec<_>>())
                            });
                        warn!(error=?e1, ?top_keys, path=%cfg.policy.bundle_path, "failed to parse policy bundle (strict)");
                        match serde_json::from_str::<serde_json::Value>(&json)
                            .ok()
                            .and_then(|mut v| {
                                normalize_policy_value(&mut v);
                                serde_json::from_value::<PolicyBundle>(v).ok()
                            }) {
                            Some(bundle) => {
                                crate::metrics::registry::POLICY_BUNDLE_LOADED_TOTAL.inc();
                                info!(path=%cfg.policy.bundle_path, "policy bundle loaded via normalized schema");
                                app_router = app_router.layer(Extension(Arc::new(bundle)));
                                have_bundle = true;
                            }
                            None => {
                                warn!(path=%cfg.policy.bundle_path, "policy bundle still failed after normalization; PolicyLayer will pass-through");
                            }
                        }
                    }
                },
                Err(e) => {
                    warn!(error=?e, path=%cfg.policy.bundle_path, "failed to read policy bundle; PolicyLayer will pass-through");
                }
            }
        } else {
            info!("policy disabled in config; PolicyLayer will no-op");
        }

        if have_bundle {
            info!("policy Extension layered outermost (visible to PolicyLayer)");
        }

        // ---- GLOBAL INFLIGHT BRIDGE (ABSOLUTE OUTERMOST) ----
        // We want this to run before everything to count every request.
        app_router = middleware::inflight::attach(app_router, rp.clone());

        // -------------------- READINESS SAMPLER --------------------
        readiness::sampler::spawn_err_rate_sampler(rp.clone(), cfg.readiness.window_secs);

        Ok(Self {
            router: app_router,
            admin_addr,
        })
    }
}

fn normalize_policy_value(root: &mut serde_json::Value) {
    let obj = match root.as_object_mut() {
        Some(m) => m,
        None => return,
    };
    if let Some(v) = obj.get_mut("version") {
        if v.is_string() {
            if let Ok(n) = v.as_str().unwrap_or_default().parse::<u32>() {
                *v = serde_json::Value::Number(serde_json::Number::from(n));
            }
        }
    } else {
        obj.insert(
            "version".to_string(),
            serde_json::Value::Number(1u32.into()),
        );
    }
    if let Some(desc) = obj.remove("description") {
        let meta = obj
            .entry("meta")
            .or_insert_with(|| serde_json::Value::Object(Map::new()));
        if let Some(mo) = meta.as_object_mut() {
            mo.entry("name".to_string()).or_insert(desc);
        }
    } else {
        obj.entry("meta")
            .or_insert_with(|| serde_json::Value::Object(Map::new()));
    }
    let mut defaults_obj = obj
        .remove("defaults")
        .and_then(|v| v.as_object().cloned())
        .unwrap_or_default();
    if let Some(def) = obj.remove("default") {
        defaults_obj
            .entry("default_action".to_string())
            .or_insert(def);
    }
    if let Some(v) = defaults_obj.remove("effect") {
        defaults_obj
            .entry("default_action".to_string())
            .or_insert(v);
    }
    defaults_obj
        .entry("default_action".to_string())
        .or_insert(serde_json::Value::String("deny".to_string()));
    obj.insert(
        "defaults".to_string(),
        serde_json::Value::Object(defaults_obj),
    );

    let mut rules = obj
        .remove("rules")
        .and_then(|v| v.as_array().cloned())
        .unwrap_or_else(Vec::new);
    for r in &mut rules {
        if let Some(ro) = r.as_object_mut() {
            if let Some(eff) = ro.remove("effect") {
                ro.entry("action".to_string()).or_insert(eff);
            }
        }
    }
    obj.insert("rules".to_string(), serde_json::Value::Array(rules));
}

```

### crates/omnigate/src/main.rs
<a id="crates-omnigate-src-main-rs"></a>

```rust
//! RO:WHAT — Omnigate binary entrypoint: loads config, boots admin plane, serves HTTP.
//! RO:WHY  — Small main to keep logic in lib; Concerns: GOV/RES (truthful health/ready, graceful shutdown).
//! RO:INTERACTS — omnigate::config, omnigate::bootstrap::server; ron-kernel surfaces.
//! RO:INVARIANTS — no locks across .await; graceful shutdown.

use omnigate::{bootstrap, config::Config};
use ron_kernel::wait_for_ctrl_c;
use tracing::{error, info};

#[tokio::main(flavor = "multi_thread")]
async fn main() -> anyhow::Result<()> {
    omnigate::observability::init_tracing();

    // Minimal arg scan so `--config path` works (used by smoke script).
    let mut args = std::env::args().skip(1);
    let mut cfg_path: Option<String> = None;
    while let Some(arg) = args.next() {
        if arg == "--config" {
            if let Some(p) = args.next() {
                cfg_path = Some(p);
            }
            break;
        }
    }

    let cfg = match cfg_path {
        Some(p) => Config::from_toml_file(p),
        None => Config::load(),
    }
    .map_err(|e| {
        error!(error=?e, "failed to load config");
        e
    })?;

    info!(amnesia = %cfg.server.amnesia, cfg=?cfg, "omnigate config");

    // Build app (starts admin plane) and serve the API listener.
    let app = omnigate::App::build(cfg.clone()).await?;

    let server_cfg = cfg.server;
    let admin_addr = server_cfg.metrics_addr;

    let (server_task, bind) = bootstrap::server::serve(server_cfg, app.router).await?;
    info!(%bind, %admin_addr, "omnigate up");

    let workers: Vec<omnigate::runtime::DynWorker> =
        vec![omnigate::runtime::sample::TickWorker::new() as _];
    let supervisor = omnigate::runtime::spawn_supervisor(workers, 128);

    wait_for_ctrl_c().await;

    let _ = supervisor
        .tx_cmd
        .send(omnigate::runtime::SupervisorMsg::Stop);
    supervisor.shutdown.cancel();
    let _ = supervisor.join.await;

    server_task.abort();
    Ok(())
}

```

### crates/omnigate/src/metrics/gates.rs
<a id="crates-omnigate-src-metrics-gates-rs"></a>

```rust
// crates/omnigate/src/metrics/gates.rs
//! RED/Readiness gate metrics (gauges + counters)
//!
//! Also hosts gate-level guard counters used by policy/body/decompress/quotas middleware
//! so everything exports from the *default* Prometheus registry. The API exposes
//! this registry via /ops/metrics.

use once_cell::sync::Lazy;
use prometheus::{
    register_gauge, register_int_counter_vec, register_int_gauge, Gauge, IntCounterVec, IntGauge,
};

// ==============================
// Readiness
// ==============================

pub static READY_INFLIGHT_CURRENT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "ready_inflight_current",
        "Current in-flight requests as tracked by readiness policy"
    )
    .expect("register ready_inflight_current")
});

pub static READY_ERROR_RATE_PCT: Lazy<Gauge> = Lazy::new(|| {
    register_gauge!(
        "ready_error_rate_pct",
        "Rolling 429/503 error rate percentage over the readiness window"
    )
    .expect("register ready_error_rate_pct")
});

pub static READY_QUEUE_SATURATED: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!("ready_queue_saturated", "Queue saturation flag (0/1)")
        .expect("register ready_queue_saturated")
});

pub static READY_TRIPS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "ready_trips_total",
        "Count of readiness trips to degraded by reason",
        &["reason"] // inflight | err_rate | queue
    )
    .expect("register ready_trips_total")
});

pub static READY_STATE_CHANGES_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "ready_state_changes_total",
        "Readiness state changes",
        &["to"] // ready | degraded
    )
    .expect("register ready_state_changes_total")
});

// ==============================
// Gate guards (counters)
// ==============================

/// Policy middleware short-circuits (deny/legal/error).
/// Label `code`: "403" | "451" | "503".
pub static POLICY_MIDDLEWARE_SHORTCIRCUITS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "policy_middleware_shortcircuits_total",
        "Policy middleware short-circuited the request",
        &["code"]
    )
    .expect("register policy_middleware_shortcircuits_total")
});

/// Body admission rejections. reason: "oversize" | "missing_length".
pub static BODY_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "body_reject_total",
        "Body preflight or body-limit rejected the request",
        &["reason"]
    )
    .expect("register body_reject_total")
});

/// Decompression guard rejections. reason: "stacked" | "unknown" | "over_budget".
pub static DECOMPRESS_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "decompress_reject_total",
        "Decompression guard rejected the request",
        &["reason"]
    )
    .expect("register decompress_reject_total")
});

/// Quota rejections (global or per-IP).
/// Labels:
///   - scope: "global" | "ip"
///   - reason: "qps" (MVP; future may distinguish "burst" etc.)
pub static QUOTA_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "quota_reject_total",
        "Quota guard rejected the request",
        &["scope", "reason"]
    )
    .expect("register quota_reject_total")
});

/// Force-initialize so the series exist before the first scrape.
pub fn init_gate_metrics() {
    let _ = &*POLICY_MIDDLEWARE_SHORTCIRCUITS_TOTAL;
    let _ = &*BODY_REJECT_TOTAL;
    let _ = &*DECOMPRESS_REJECT_TOTAL;
    let _ = &*QUOTA_REJECT_TOTAL;

    let _ = &*READY_INFLIGHT_CURRENT;
    let _ = &*READY_ERROR_RATE_PCT;
    let _ = &*READY_QUEUE_SATURATED;
    let _ = &*READY_TRIPS_TOTAL;
    let _ = &*READY_STATE_CHANGES_TOTAL;
}

```

### crates/omnigate/src/metrics/mod.rs
<a id="crates-omnigate-src-metrics-mod-rs"></a>

```rust
//! RO:WHAT   Prometheus registry & handles for Omnigate.
//! RO:WHY    Stable counters/histograms backing the metrics contract test.
//! RO:INTERACTS middleware::{quotas,fair_queue,body_caps,decompress_guard,policy}, admin/handlers.
pub mod gates;
pub mod registry;

use once_cell::sync::Lazy;
use prometheus::{register_histogram_vec, register_int_counter_vec, HistogramVec, IntCounterVec};

pub static HTTP_REQS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "http_requests_total",
        "Requests by route/method/status",
        &["route", "method", "status"]
    )
    .expect("register http_requests_total")
});

pub static REQUEST_LATENCY_SECONDS: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "request_latency_seconds",
        "Request latency by route/method",
        &["route", "method"]
    )
    .expect("register request_latency_seconds")
});

pub static ADMISSION_QUOTA_EXHAUSTED_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "admission_quota_exhausted_total",
        "Quota rejections by scope",
        &["scope"] // global|ip|token
    )
    .expect("register admission_quota_exhausted_total")
});

pub static FAIR_Q_EVENTS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "admission_fair_queue_events_total",
        "Fair queue events by type",
        &["event"] // enqueued|dropped
    )
    .expect("register admission_fair_queue_events_total")
});

pub static BODY_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "body_reject_total",
        "Body rejections by reason",
        &["reason"] // oversize|missing_len
    )
    .expect("register body_reject_total")
});

pub static DECOMPRESS_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "decompress_reject_total",
        "Decompression guard rejections",
        &["reason"] // unknown|stacked
    )
    .expect("register decompress_reject_total")
});

pub static POLICY_SHORTCIRCUITS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "policy_middleware_shortcircuits_total",
        "Requests denied by policy middleware",
        &["status"] // 403|451|503
    )
    .expect("register policy_middleware_shortcircuits_total")
});

```

### crates/omnigate/src/metrics/registry.rs
<a id="crates-omnigate-src-metrics-registry-rs"></a>

```rust
//! RO:WHAT   Prometheus registry & handles for Omnigate.
//! RO:WHY    Stable counters/histograms backing the metrics contract test.
//! RO:INTERACTS middleware::{quotas,fair_queue,body_caps,decompress_guard,policy}, http routes, admin plane.
//! RO:INVARS  Base labels elsewhere should include {service,instance,build_version,amnesia}.

use once_cell::sync::Lazy;
use prometheus::{
    register_histogram_vec, register_int_counter, register_int_counter_vec, register_int_gauge,
    HistogramVec, IntCounter, IntCounterVec, IntGauge,
};

/// Gauge reflecting whether we’re running in “amnesia mode” (Micronode/dev style).
/// Convention: 1 = amnesia ON, 0 = OFF. Wire this in App::build from cfg.server.amnesia.
pub static AMNESIA_MODE: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "amnesia_mode",
        "Amnesia (stateless) mode flag: 1 when enabled, else 0"
    )
    .expect("register amnesia_mode")
});

/// Count of times a policy bundle has been successfully loaded (startup/reload).
/// Increment once after policy init so sanity scripts can assert it happened.
pub static POLICY_BUNDLE_LOADED_TOTAL: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "policy_bundle_loaded_total",
        "Policy bundles successfully loaded (startup/reload)"
    )
    .expect("register policy_bundle_loaded_total")
});

pub static HTTP_REQS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "http_requests_total",
        "Requests by route/method/status",
        &["route", "method", "status"]
    )
    .expect("register http_requests_total")
});

pub static REQUEST_LATENCY_SECONDS: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "request_latency_seconds",
        "Request latency by route/method",
        &["route", "method"]
    )
    .expect("register request_latency_seconds")
});

pub static ADMISSION_QUOTA_EXHAUSTED_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "admission_quota_exhausted_total",
        "Quota rejections by scope",
        &["scope"] // global|ip|token
    )
    .expect("register admission_quota_exhausted_total")
});

pub static FAIR_Q_EVENTS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "admission_fair_queue_events_total",
        "Fair queue events by type",
        &["event"] // enqueued|dropped
    )
    .expect("register admission_fair_queue_events_total")
});

pub static BODY_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "body_reject_total",
        "Body rejections by reason",
        &["reason"] // oversize|missing_len
    )
    .expect("register body_reject_total")
});

pub static DECOMPRESS_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "decompress_reject_total",
        "Decompression guard rejections",
        &["reason"] // unknown|stacked
    )
    .expect("register decompress_reject_total")
});

pub static POLICY_SHORTCIRCUITS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "policy_middleware_shortcircuits_total",
        "Requests denied by policy middleware",
        &["status"] // 403|451|503
    )
    .expect("register policy_middleware_shortcircuits_total")
});

```

### crates/omnigate/src/middleware/body_caps.rs
<a id="crates-omnigate-src-middleware-bodycaps-rs"></a>

```rust
//! RO:WHAT — Request body size caps.
//! RO:WHY  — Prevent DoS and enforce hard limits early.
//! RO:BEHAVIOR —
//!   * If `Content-Length` is present and > MAX, short-circuit with 413 JSON using our error map.
//!   * Otherwise, forward and rely on Axum's body limiter (`DefaultBodyLimit::max`) for streaming
//!     and methods without Content-Length.
//!
//! RO:INVARIANTS — Keep MAX aligned with OAP/HTTP caps (default: 1 MiB). Emit metrics for oversize rejects.
//!                 Do not emit 411 here; policy_gate tests rely on 405/403 from routing/policy layers.

use std::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};

use axum::{
    extract::DefaultBodyLimit,
    http::{self, Request},
    response::{IntoResponse, Response},
};
use tower::{Layer, Service};

use crate::errors::{http_map, Reason};
// IMPORTANT: use metrics from gates module so we hit the default-registry counters.
use crate::metrics::gates::BODY_REJECT_TOTAL;

/// Size constants (avoid clippy identity-op).
const KIB: usize = 1024;
const MIB: usize = KIB * KIB;
/// Default max body bytes (1 MiB). Keep in sync with service config later.
const MAX_BYTES: usize = MIB;

/// Public factory returning the composed guard as a tuple of layers,
/// which implements `Layer<Route>` (compatible with `Router::layer`).
pub fn layer() -> (PreflightContentLengthGuardLayer, DefaultBodyLimit) {
    (
        PreflightContentLengthGuardLayer { max: MAX_BYTES },
        // NOTE: DefaultBodyLimit::max takes a usize, and MAX_BYTES is already usize.
        DefaultBodyLimit::max(MAX_BYTES),
    )
}

/// Fast-path guard that inspects `Content-Length` and short-circuits with a 413 JSON
/// when the declared size is clearly over budget.
#[derive(Clone, Copy)]
pub struct PreflightContentLengthGuardLayer {
    pub(crate) max: usize,
}

impl<S> Layer<S> for PreflightContentLengthGuardLayer {
    type Service = PreflightContentLengthGuard<S>;
    fn layer(&self, inner: S) -> Self::Service {
        PreflightContentLengthGuard {
            inner,
            max: self.max,
        }
    }
}

#[derive(Clone)]
pub struct PreflightContentLengthGuard<S> {
    inner: S,
    max: usize,
}

impl<S, B> Service<Request<B>> for PreflightContentLengthGuard<S>
where
    S: Service<Request<B>>,
    S::Future: Send + 'static,
    S::Response: IntoResponse,
{
    type Response = Response;
    type Error = S::Error;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        // If Content-Length is present and too big, reject immediately with our envelope.
        if let Some(len) = req
            .headers()
            .get(http::header::CONTENT_LENGTH)
            .and_then(|v| v.to_str().ok())
            .and_then(|s| s.parse::<u64>().ok())
        {
            if len as usize > self.max {
                // Metrics: body oversize reject
                BODY_REJECT_TOTAL.with_label_values(&["oversize"]).inc();

                let resp = http_map::to_response(
                    Reason::PayloadTooLarge,
                    "request body exceeds configured limit",
                );
                return Box::pin(async move { Ok(resp) });
            }
        }

        // NOTE:
        // We *do not* emit 411 LengthRequired here anymore.
        //
        // For payload-carrying methods without a Content-Length header, and for
        // streaming/unknown sizes, we allow the request to proceed. Axum's
        // DefaultBodyLimit (wired via `layer()`) still enforces a hard cap on
        // the actual body size, while leaving routing/policy behavior (405/403)
        // intact for the policy_gate tests.
        let fut = self.inner.call(req);
        Box::pin(async move {
            let res = fut.await?.into_response();
            Ok(res)
        })
    }
}

```

### crates/omnigate/src/middleware/classify.rs
<a id="crates-omnigate-src-middleware-classify-rs"></a>

```rust
//! RO:WHAT — Response classifier (stub).
//! RO:WHY  — Future: classify errors for metrics; integrate with tower_http::classify.
//! RO:INVARIANTS — Bounded label cardinality; now identity.

use tower::layer::Layer;

/// Identity layer placeholder (no-op).
#[derive(Clone, Copy, Default)]
pub struct NopLayer;

impl<S> Layer<S> for NopLayer {
    type Service = S;
    fn layer(&self, inner: S) -> Self::Service {
        inner
    }
}

pub fn layer() -> NopLayer {
    NopLayer
}

```

### crates/omnigate/src/middleware/corr_id.rs
<a id="crates-omnigate-src-middleware-corrid-rs"></a>

```rust
//! RO:WHAT   Correlation/request IDs middleware.
//! RO:WHY    Stable per-request IDs for logs/metrics/traces.
//! RO:INVARS Low cardinality; always attach request_id; optional correlation chain.

use axum::{
    extract::Request,
    http::header::{HeaderName, HeaderValue},
    response::{IntoResponse, Response},
};
use futures_util::future::BoxFuture;
use tower::{Layer, Service};

static HDR_REQ_ID: HeaderName = HeaderName::from_static("x-request-id");
static HDR_CORR_ID: HeaderName = HeaderName::from_static("x-correlation-id");

#[allow(dead_code)] // will be consumed by logging/observe once wired
#[derive(Debug, Clone)]
pub struct CorrelationIds {
    pub request_id: String,
    pub correlation_id: String,
}

#[derive(Clone)]
pub struct CorrIdLayer;

pub fn layer() -> CorrIdLayer {
    CorrIdLayer
}

impl<S> Layer<S> for CorrIdLayer {
    type Service = CorrIdService<S>;
    fn layer(&self, inner: S) -> Self::Service {
        CorrIdService { inner }
    }
}

#[derive(Clone)]
pub struct CorrIdService<S> {
    inner: S,
}

// 128-bit random hex via fastrand 2.x (requires an explicit range).
#[inline]
fn gen_request_id() -> String {
    // full 64-bit range on each half
    let hi = fastrand::u64(0..=u64::MAX);
    let lo = fastrand::u64(0..=u64::MAX);
    format!("{:016x}{:016x}", hi, lo)
}

impl<S> Service<Request> for CorrIdService<S>
where
    S: Service<Request> + Clone + Send + 'static,
    S::Response: IntoResponse + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<Box<dyn std::error::Error + Send + Sync>> + Send + 'static,
{
    type Response = Response;
    type Error = S::Error;
    type Future = BoxFuture<'static, Result<Self::Response, Self::Error>>;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, mut req: Request) -> Self::Future {
        let mut inner = self.inner.clone();

        // Request ID (always)
        let req_id = gen_request_id();

        // Correlation ID (propagate if present, else req_id). Keep ASCII-only to ensure header validity.
        let corr_id = req
            .headers()
            .get(&HDR_CORR_ID)
            .and_then(|v| v.to_str().ok())
            .map(str::to_owned)
            .filter(|s| s.is_ascii())
            .unwrap_or_else(|| req_id.clone());

        // Stash into request headers for downstream visibility (insert only if HeaderValue parses).
        if let Ok(v) = HeaderValue::from_str(&req_id) {
            req.headers_mut().insert(HDR_REQ_ID.clone(), v);
        }
        if let Ok(v) = HeaderValue::from_str(&corr_id) {
            req.headers_mut().insert(HDR_CORR_ID.clone(), v);
        }

        Box::pin(async move {
            let mut res = inner.call(req).await?.into_response();

            // Reflect IDs back to the client (again, only if HeaderValue parses).
            if let Ok(v) = HeaderValue::from_str(&req_id) {
                res.headers_mut().insert(HDR_REQ_ID.clone(), v);
            }
            if let Ok(v) = HeaderValue::from_str(&corr_id) {
                res.headers_mut().insert(HDR_CORR_ID.clone(), v);
            }

            Ok(res)
        })
    }
}

```

### crates/omnigate/src/middleware/decompress_guard.rs
<a id="crates-omnigate-src-middleware-decompressguard-rs"></a>

```rust
//! RO:WHAT — Decompression guard for request bodies.
//! RO:WHY  — Stop risky encodings and cap potential decompression-bomb expansion at the edge.
//!
//! RO:BEHAVIOR —
//!   • Reject unsupported or (optionally) stacked encodings with 415 using our JSON envelope.
//!   • Allowed encodings come from config: `admission.decompression.allow` (e.g., ["identity","gzip"]).
//!   • If compressed (encoding != identity) and Content-Length is present, require:
//!         compressed_length * EXPANSION_CAP <= MAX_EXPANDED
//!     where MAX_EXPANDED = `admission.body.max_content_length` and EXPANSION_CAP = 10.
//!   • Streaming/unknown sizes are still protected by `DefaultBodyLimit` in `body_caps`.
//!
//! RO:INVARIANTS — Pure guard (no decompression). Budgets track body caps precisely.

use std::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};

use axum::{
    http::{HeaderValue, Request},
    response::{IntoResponse, Response},
    Router,
};
use tower::{Layer, Service};

use crate::errors::{http_map, Reason};
// IMPORTANT: use counters from metrics/gates so we're on the default registry.
use crate::metrics::gates::DECOMPRESS_REJECT_TOTAL;

/// Worst-case expansion factor budgeted for compressed bodies.
const EXPANSION_CAP: usize = 10;

/// Default absolute expansion budget used by the factory `layer()`.
/// This is intentionally conservative (1 MiB), and the cfg-driven
/// `attach_with_cfg` path uses `Admission.body.max_content_length` instead.
const KIB: usize = 1024;
const MIB: usize = KIB * KIB;
const DEFAULT_MAX_EXPANDED: usize = MIB;

/// Config-aware attach: add the guard with values pulled from Admission.
pub fn attach_with_cfg<S>(router: Router<S>, adm: &crate::config::Admission) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    let allow = adm
        .decompression
        .allow
        .iter()
        .map(|s| s.to_ascii_lowercase())
        .collect::<Vec<_>>();
    let deny_stacked = adm.decompression.deny_stacked;
    let max_expanded = adm.body.max_content_length as usize;

    router.layer(DecompressGuardLayer {
        allow,
        deny_stacked,
        max_expanded,
    })
}

/// Public factory used by tests and simple stacks.
///
/// Defaults:
///   • Allowed encodings: identity, gzip, deflate, br.
///   • deny_stacked = true.
///   • max_expanded = 1 MiB (see DEFAULT_MAX_EXPANDED).
pub fn layer() -> DecompressGuardLayer {
    let allow = ["identity", "gzip", "deflate", "br"]
        .iter()
        .map(|s| s.to_string())
        .collect::<Vec<_>>();

    DecompressGuardLayer {
        allow,
        deny_stacked: true,
        max_expanded: DEFAULT_MAX_EXPANDED,
    }
}

/// Layer carrying admission parameters.
#[derive(Clone)]
pub struct DecompressGuardLayer {
    allow: Vec<String>,
    deny_stacked: bool,
    max_expanded: usize,
}

impl<S> Layer<S> for DecompressGuardLayer {
    type Service = DecompressGuard<S>;
    fn layer(&self, inner: S) -> Self::Service {
        DecompressGuard {
            inner,
            allow: self.allow.clone(),
            deny_stacked: self.deny_stacked,
            max_expanded: self.max_expanded,
        }
    }
}

#[derive(Clone)]
pub struct DecompressGuard<S> {
    inner: S,
    allow: Vec<String>,
    deny_stacked: bool,
    max_expanded: usize,
}

impl<S, B> Service<Request<B>> for DecompressGuard<S>
where
    S: Service<Request<B>>,
    S::Future: Send + 'static,
    S::Response: IntoResponse,
{
    type Response = Response;
    type Error = S::Error;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        // Parse and normalize Content-Encoding(s)
        let enc_header = req.headers().get(axum::http::header::CONTENT_ENCODING);

        let encodings = enc_header
            .and_then(|hv: &HeaderValue| hv.to_str().ok())
            .unwrap_or("")
            .split(',')
            .map(|s| s.trim())
            .filter(|s| !s.is_empty())
            .map(|s| s.to_ascii_lowercase())
            .collect::<Vec<_>>();

        // Stacked encodings?
        if self.deny_stacked && encodings.len() > 1 {
            DECOMPRESS_REJECT_TOTAL
                .with_label_values(&["stacked"])
                .inc();

            let resp = http_map::to_response(
                Reason::UnsupportedMediaType,
                "stacked Content-Encoding not allowed",
            );
            return Box::pin(async move { Ok(resp) });
        }

        // Validate the (single) encoding or absence thereof.
        let encoding_opt = encodings.first().map(|s| s.as_str());
        let is_identity_or_none = match encoding_opt {
            None => true, // no header = identity
            Some(enc) => enc == "identity",
        };

        if let Some(enc) = encoding_opt {
            if !self.allow.iter().any(|a| a == enc) {
                // Disallowed/unknown encoding.
                DECOMPRESS_REJECT_TOTAL
                    .with_label_values(&["unknown"])
                    .inc();

                let resp = http_map::to_response(
                    Reason::UnsupportedMediaType,
                    "Content-Encoding not allowed by policy",
                );
                return Box::pin(async move { Ok(resp) });
            }
        }

        // If compressed and length is known, enforce expansion budget.
        if !is_identity_or_none {
            if let Some(cl) = req
                .headers()
                .get(axum::http::header::CONTENT_LENGTH)
                .and_then(|v| v.to_str().ok())
                .and_then(|s| s.parse::<u64>().ok())
            {
                let compressed = cl as usize;
                if compressed.saturating_mul(EXPANSION_CAP) > self.max_expanded {
                    DECOMPRESS_REJECT_TOTAL
                        .with_label_values(&["over_budget"])
                        .inc();

                    let resp = http_map::to_response(
                        Reason::PayloadTooLarge,
                        "compressed body exceeds allowed expansion budget",
                    );
                    return Box::pin(async move { Ok(resp) });
                }
            }
            // No Content-Length → streaming is still guarded by DefaultBodyLimit downstream.
        }

        let fut = self.inner.call(req);
        Box::pin(async move {
            let res = fut.await?.into_response();
            Ok(res)
        })
    }
}

```

### crates/omnigate/src/middleware/inflight.rs
<a id="crates-omnigate-src-middleware-inflight-rs"></a>

```rust
//! RO:WHAT  Global inflight bridge: measure actual concurrent requests across the whole stack.
//! RO:WHY   Guarantees that /readyz sees truthful concurrency no matter which path a request takes.

use crate::readiness::policy::ReadyPolicy;
use axum::{extract::State, middleware::from_fn_with_state, Router};
use std::sync::Arc;

pub async fn inflight_bridge(
    State(rp): State<Arc<ReadyPolicy>>,
    req: axum::http::Request<axum::body::Body>,
    next: axum::middleware::Next,
) -> axum::response::Response {
    rp.inc();
    struct Guard(Arc<ReadyPolicy>);
    impl Drop for Guard {
        fn drop(&mut self) {
            self.0.dec();
        }
    }
    let _g = Guard(rp);
    next.run(req).await
}

/// Attach the inflight bridge as the outermost layer.
pub fn attach<S>(router: Router<S>, rp: Arc<ReadyPolicy>) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    router.layer(from_fn_with_state(rp, inflight_bridge))
}

```

### crates/omnigate/src/middleware/mod.rs
<a id="crates-omnigate-src-middleware-mod-rs"></a>

```rust
// crates/omnigate/src/middleware/mod.rs
//! RO:WHAT  Shared middleware stack for the app.
//! RO:WHY   Keep router layering in one place (except admission which is cfg-driven).
//! RO:INVARS Low overhead; stable label cardinality; no blocking across .await.

pub mod body_caps;
mod classify;
mod corr_id;
pub mod decompress_guard;
pub mod inflight;
mod policy;
mod slow_loris;

use crate::config::Admission;
use axum::Router;

/// Canonical middleware stack **with config** (recommended).
/// Order: classify -> corr_id -> policy -> body caps -> default body limit -> decompress guard -> slow-loris
pub fn apply_with_cfg<S>(router: Router<S>, adm: &Admission) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    // Cheap gates first (no body access)
    let router = router
        .layer(classify::layer())
        .layer(corr_id::layer())
        .layer(policy::layer());

    // Preflight length + Axum's DefaultBodyLimit pair
    let (preflight_len_guard, default_body_limit) = body_caps::layer();

    // Attach caps/limit, then cfg-driven decompression guard, then slow-loris
    let router = router.layer(preflight_len_guard).layer(default_body_limit);

    // Config-driven decompression guard; this call ensures the symbol is referenced in this module.
    let router = decompress_guard::attach_with_cfg(router, adm);

    router.layer(slow_loris::layer())
}

/// Legacy shim kept for tests/back-compat (no config at callsite).
/// Internally calls `apply_with_cfg` using `Admission::default()`.
pub fn apply<S>(router: Router<S>) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    let defaults = crate::config::Admission::default();
    apply_with_cfg(router, &defaults)
}

```

### crates/omnigate/src/middleware/policy.rs
<a id="crates-omnigate-src-middleware-policy-rs"></a>

```rust
//! RO:WHAT   Thin policy middleware that consults a ron-policy Evaluator (if provided).
//! RO:WHY    Centralize allow/deny; keep business handlers policy-agnostic.
//! RO:INVARS If no evaluator is present, act as a no-op (safe pass-through).
//!           When denying, emit stable JSON envelopes and bounded-label metrics.

use std::{
    collections::BTreeSet,
    sync::Arc,
    time::{SystemTime, UNIX_EPOCH},
};

use axum::{
    extract::Request,
    http::StatusCode,
    response::{IntoResponse, Response},
};
use futures_util::future::BoxFuture;
use tower::{Layer, Service};

use crate::errors::GateError;
// IMPORTANT: pull counters from the gates module to match registration on the default registry.
use crate::metrics::gates::POLICY_MIDDLEWARE_SHORTCIRCUITS_TOTAL;

#[derive(Clone)]
pub struct PolicyLayer;

/// Public constructor used by the top-level middleware::apply.
pub fn layer() -> PolicyLayer {
    PolicyLayer
}

impl<S> Layer<S> for PolicyLayer {
    type Service = PolicyService<S>;
    fn layer(&self, inner: S) -> Self::Service {
        PolicyService { inner }
    }
}

#[derive(Clone)]
pub struct PolicyService<S> {
    inner: S,
}

impl<S> Service<Request> for PolicyService<S>
where
    S: Service<Request> + Clone + Send + 'static,
    S::Response: IntoResponse + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<Box<dyn std::error::Error + Send + Sync>> + Send + 'static,
{
    type Response = Response;
    type Error = S::Error;
    type Future = BoxFuture<'static, Result<Self::Response, Self::Error>>;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request) -> Self::Future {
        let mut inner = self.inner.clone();

        // Pull an optional policy bundle from request extensions; build an Evaluator per request.
        let maybe_bundle = req
            .extensions()
            .get::<Arc<ron_policy::PolicyBundle>>()
            .cloned();

        Box::pin(async move {
            if let Some(bundle) = maybe_bundle {
                // Build Evaluator borrowing the bundle (lives for the request via Arc).
                match ron_policy::Evaluator::new(&bundle) {
                    Ok(eval) => {
                        // ron-policy Context (current API): populate minimally & safely.
                        let now_ms = SystemTime::now()
                            .duration_since(UNIX_EPOCH)
                            .unwrap_or_default()
                            .as_millis() as u64;

                        // Tags: keep cardinality low and deterministic.
                        let mut tags: BTreeSet<String> = BTreeSet::new();
                        tags.insert("omnigate".to_string());

                        let method = req.method().as_str().to_owned();
                        // Region/tenant may be wired later via AppState; keep safe defaults.
                        let region = String::new();
                        let tenant = "default".to_string();

                        let ctx = ron_policy::Context {
                            now_ms,
                            body_bytes: 0, // unknown at admission time
                            method,
                            region,
                            tags,
                            tenant,
                        };

                        match eval.evaluate(&ctx) {
                            Ok(dec) => {
                                // DecisionEffect doesn’t expose is_allow(); match the variant.
                                match dec.effect {
                                    ron_policy::DecisionEffect::Allow => {
                                        let res = inner.call(req).await?;
                                        return Ok(res.into_response());
                                    }
                                    _ => {
                                        let status = if dec.reason.as_deref() == Some("LEGAL") {
                                            StatusCode::UNAVAILABLE_FOR_LEGAL_REASONS
                                        } else {
                                            StatusCode::FORBIDDEN
                                        };

                                        // Metrics increment for deny/short-circuit.
                                        POLICY_MIDDLEWARE_SHORTCIRCUITS_TOTAL
                                            .with_label_values(&[status.as_str()])
                                            .inc();

                                        let resp = GateError::PolicyDeny {
                                            reason: dec.reason.as_deref().unwrap_or("DENY"),
                                            status,
                                        }
                                        .into_response();
                                        return Ok(resp);
                                    }
                                }
                            }
                            Err(_e) => {
                                // Evaluator error → 503
                                POLICY_MIDDLEWARE_SHORTCIRCUITS_TOTAL
                                    .with_label_values(&["503"])
                                    .inc();
                                let resp = GateError::PolicyError.into_response();
                                return Ok(resp);
                            }
                        }
                    }
                    Err(_e) => {
                        // If Evaluator construction fails, treat as transient policy error.
                        POLICY_MIDDLEWARE_SHORTCIRCUITS_TOTAL
                            .with_label_values(&["503"])
                            .inc();
                        let resp = GateError::PolicyError.into_response();
                        return Ok(resp);
                    }
                }
            }

            // No bundle present → no-op pass-through.
            let res = inner.call(req).await?;
            Ok(res.into_response())
        })
    }
}

```

### crates/omnigate/src/middleware/slow_loris.rs
<a id="crates-omnigate-src-middleware-slowloris-rs"></a>

```rust
//! RO:WHAT — Slow-loris protection (stub).
//! RO:WHY  — Future: per-read header/body timeouts, idle caps; now identity.
//! RO:INVARIANTS — Avoid false positives under load when enabled.

use tower::layer::Layer;

/// Identity layer placeholder (no-op).
#[derive(Clone, Copy, Default)]
pub struct NopLayer;

impl<S> Layer<S> for NopLayer {
    type Service = S;
    fn layer(&self, inner: S) -> Self::Service {
        inner
    }
}

pub fn layer() -> NopLayer {
    NopLayer
}

```

### crates/omnigate/src/observability/logging.rs
<a id="crates-omnigate-src-observability-logging-rs"></a>

```rust

```

### crates/omnigate/src/observability/mod.rs
<a id="crates-omnigate-src-observability-mod-rs"></a>

```rust
//! RO:WHAT — Tracing init + HTTP trace layer.
//! RO:WHY  — Uniform logs + RED metrics; Concerns: OBS/PERF.
//! RO:INVARIANTS — Bounded labels; no PII in logs.

use tower_http::trace::TraceLayer;
use tracing_subscriber::{fmt, EnvFilter};

pub fn init_tracing() {
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).compact().init();
}

pub fn http_trace_layer(
) -> TraceLayer<tower_http::classify::SharedClassifier<tower_http::classify::ServerErrorsAsFailures>>
{
    TraceLayer::new_for_http()
}

```

### crates/omnigate/src/observability/tracing_spans.rs
<a id="crates-omnigate-src-observability-tracingspans-rs"></a>

```rust

```

### crates/omnigate/src/pq/mod.rs
<a id="crates-omnigate-src-pq-mod-rs"></a>

```rust

```

### crates/omnigate/src/pq/negotiate.rs
<a id="crates-omnigate-src-pq-negotiate-rs"></a>

```rust

```

### crates/omnigate/src/readiness/keys.rs
<a id="crates-omnigate-src-readiness-keys-rs"></a>

```rust

```

### crates/omnigate/src/readiness/mod.rs
<a id="crates-omnigate-src-readiness-mod-rs"></a>

```rust
//! RO:WHAT  Readiness module: policy (truth), admin state, /readyz, and samplers.
//! RO:WHY   Keep lib.rs slim; keep readiness logic cohesive and testable.

pub mod policy;
pub mod sampler;
pub mod state;

use axum::{extract::State, response::IntoResponse};
use std::time::{Duration, Instant};

use crate::errors::http_map::GateError;
use crate::metrics::gates::{READY_STATE_CHANGES_TOTAL, READY_TRIPS_TOTAL};
use state::AdminState;

/// /readyz handler: consults local ReadyPolicy + sticky hold, else delegates to kernel.
pub async fn readyz(State(st): State<AdminState>) -> impl IntoResponse {
    if st.dev_ready {
        return (axum::http::StatusCode::OK, "ready (dev override)").into_response();
    }

    // Honor the hold window if previously tripped.
    let now = Instant::now();
    {
        // Take a copy of the Option<Instant>, since Instant is Copy.
        let mut guard = st.hold_until_lock();
        if let Some(until) = *guard {
            if now < until {
                return GateError::Degraded.into_response();
            } else {
                // Hold expired — clear and mark recovery.
                *guard = None;
                READY_STATE_CHANGES_TOTAL
                    .with_label_values(&["ready"])
                    .inc();
            }
        }
    }

    // Sample current policy state.
    let inflight = st.rp.inflight();
    let err_pct_like = st.rp.err_rate_pct();

    // Trip if either threshold is exceeded.
    let trip_inflight = inflight > st.max_inflight_threshold;
    let trip_err = err_pct_like >= st.error_rate_429_503_pct;

    if trip_inflight || trip_err {
        // Start/extend hold window.
        st.set_hold_until(now + Duration::from_secs(st.hold_for_secs.max(1)));

        // Mark trip metadata.
        let reason = if trip_inflight {
            "inflight"
        } else {
            "err_rate"
        };
        READY_TRIPS_TOTAL.with_label_values(&[reason]).inc();
        READY_STATE_CHANGES_TOTAL
            .with_label_values(&["degraded"])
            .inc();

        return GateError::Degraded.into_response();
    }

    // Otherwise delegate to kernel readiness handler (200 path).
    ron_kernel::metrics::readiness::readyz_handler(st.ready.clone()).await
}

```

### crates/omnigate/src/readiness/policy.rs
<a id="crates-omnigate-src-readiness-policy-rs"></a>

```rust
//! RO:WHAT  Local readiness policy bridge with atomics (truth source for /readyz).
//! RO:WHY   /readyz must reflect *actual* concurrency/error pressure.

use std::sync::atomic::{AtomicBool, AtomicI64, AtomicU64, Ordering};

pub struct ReadyPolicy {
    inflight: AtomicI64,
    err_rate_bits: AtomicU64, // f64 stored as bits for atomicity
    queue_saturated: AtomicBool,
}

impl ReadyPolicy {
    #[inline]
    pub fn new() -> Self {
        Self {
            inflight: AtomicI64::new(0),
            err_rate_bits: AtomicU64::new(0f64.to_bits()),
            queue_saturated: AtomicBool::new(false),
        }
    }

    #[inline]
    pub fn update_inflight(&self, v: i64) {
        let val = v.max(0);
        self.inflight.store(val, Ordering::Release);
        // mirror to gauge for observability
        crate::metrics::gates::READY_INFLIGHT_CURRENT.set(val);
    }

    #[inline]
    pub fn inc(&self) {
        let v = self.inflight.fetch_add(1, Ordering::AcqRel) + 1;
        crate::metrics::gates::READY_INFLIGHT_CURRENT.set(v.max(0));
    }

    #[inline]
    pub fn dec(&self) {
        let v = self.inflight.fetch_sub(1, Ordering::AcqRel) - 1;
        crate::metrics::gates::READY_INFLIGHT_CURRENT.set(v.max(0));
    }

    #[inline]
    pub fn update_err_rate(&self, pct: f64) {
        let c = pct.clamp(0.0, 100.0);
        self.err_rate_bits.store(c.to_bits(), Ordering::Release);
        crate::metrics::gates::READY_ERROR_RATE_PCT.set(c);
    }

    #[inline]
    pub fn set_queue_saturated(&self, on: bool) {
        self.queue_saturated.store(on, Ordering::Release);
        crate::metrics::gates::READY_QUEUE_SATURATED.set(if on { 1 } else { 0 });
    }

    #[inline]
    pub fn inflight(&self) -> i64 {
        self.inflight.load(Ordering::Acquire)
    }

    #[inline]
    pub fn err_rate_pct(&self) -> f64 {
        f64::from_bits(self.err_rate_bits.load(Ordering::Acquire))
    }

    #[allow(dead_code)]
    #[inline]
    pub fn queue_saturated(&self) -> bool {
        self.queue_saturated.load(Ordering::Acquire)
    }
}

// Silence clippy::new_without_default by providing Default in terms of new()
impl Default for ReadyPolicy {
    fn default() -> Self {
        Self::new()
    }
}

```

### crates/omnigate/src/readiness/sampler.rs
<a id="crates-omnigate-src-readiness-sampler-rs"></a>

```rust
//! RO:WHAT  Rolling error-rate sampler: turns 429/503/drops into a pct-like signal.
//! RO:WHY   /readyz should trip on sustained errors even if inflight is modest.

use super::policy::ReadyPolicy;
use crate::metrics::gates::POLICY_MIDDLEWARE_SHORTCIRCUITS_TOTAL;
use crate::metrics::{ADMISSION_QUOTA_EXHAUSTED_TOTAL, FAIR_Q_EVENTS_TOTAL};
use std::sync::Arc;
use std::time::Duration;

/// Spawns a background task; safe to call once at app boot.
pub fn spawn_err_rate_sampler(rp: Arc<ReadyPolicy>, window_secs: u64) {
    let window = window_secs.max(1);
    tokio::spawn(async move {
        let mut last_quota = {
            let g = ADMISSION_QUOTA_EXHAUSTED_TOTAL
                .with_label_values(&["global"])
                .get();
            let i = ADMISSION_QUOTA_EXHAUSTED_TOTAL
                .with_label_values(&["ip"])
                .get();
            g + i
        } as f64;
        let mut last_policy_503 = POLICY_MIDDLEWARE_SHORTCIRCUITS_TOTAL
            .with_label_values(&["503"])
            .get() as f64;
        let mut last_fair_drops = FAIR_Q_EVENTS_TOTAL.with_label_values(&["dropped"]).get() as f64;

        loop {
            tokio::time::sleep(Duration::from_secs(window)).await;

            let quota_now = {
                let g = ADMISSION_QUOTA_EXHAUSTED_TOTAL
                    .with_label_values(&["global"])
                    .get();
                let i = ADMISSION_QUOTA_EXHAUSTED_TOTAL
                    .with_label_values(&["ip"])
                    .get();
                g + i
            } as f64;
            let policy_503_now = POLICY_MIDDLEWARE_SHORTCIRCUITS_TOTAL
                .with_label_values(&["503"])
                .get() as f64;
            let fair_drops_now = FAIR_Q_EVENTS_TOTAL.with_label_values(&["dropped"]).get() as f64;

            let d_quota = (quota_now - last_quota).max(0.0);
            let d_p503 = (policy_503_now - last_policy_503).max(0.0);
            let d_drops = (fair_drops_now - last_fair_drops).max(0.0);

            let err_events = d_quota + d_p503 + d_drops;
            let per_sec = err_events / (window as f64);
            let pct_like = (per_sec * 100.0).min(100.0);

            // Update the policy (truth) — it mirrors to the gauge internally.
            rp.update_err_rate(pct_like);

            last_quota = quota_now;
            last_policy_503 = policy_503_now;
            last_fair_drops = fair_drops_now;
        }
    });
}

```

### crates/omnigate/src/readiness/state.rs
<a id="crates-omnigate-src-readiness-state-rs"></a>

```rust
//! RO:WHAT  AdminState: thresholds, kernel handles, sticky hold, and ReadyPolicy handle.

use super::policy::ReadyPolicy;
use ron_kernel::metrics::{health::HealthState, readiness::Readiness as KernelReadiness};
use std::{
    sync::{Arc, Mutex},
    time::Instant,
};

#[derive(Clone)]
pub struct AdminState {
    pub health: HealthState,
    pub ready: KernelReadiness,
    pub dev_ready: bool,
    pub max_inflight_threshold: i64,
    pub error_rate_429_503_pct: f64,
    pub hold_for_secs: u64,
    pub rp: Arc<ReadyPolicy>,
    hold_until: Arc<Mutex<Option<Instant>>>,
}

impl AdminState {
    pub fn new(
        health: HealthState,
        ready: KernelReadiness,
        dev_ready: bool,
        cfg: &crate::config::Readiness,
        rp: Arc<ReadyPolicy>,
    ) -> Self {
        Self {
            health,
            ready,
            dev_ready,
            max_inflight_threshold: cfg.max_inflight_threshold as i64,
            error_rate_429_503_pct: cfg.error_rate_429_503_pct,
            hold_for_secs: cfg.hold_for_secs,
            rp,
            hold_until: Arc::new(Mutex::new(None)),
        }
    }

    #[inline]
    pub fn hold_until_lock(&self) -> std::sync::MutexGuard<'_, Option<Instant>> {
        self.hold_until.lock().expect("hold_until mutex poisoned")
    }

    #[inline]
    pub fn set_hold_until(&self, when: Instant) {
        *self.hold_until.lock().unwrap() = Some(when);
    }

    #[inline]
    pub fn clear_hold_until(&self) {
        *self.hold_until.lock().unwrap() = None;
    }
}

```

### crates/omnigate/src/routes/mod.rs
<a id="crates-omnigate-src-routes-mod-rs"></a>

```rust
//! RO:WHAT — Route modules aggregation.
//! RO:WHY  — Keep the tree organized exactly like TODO.
//! RO:INTERACTS — ops.rs, v1::*, future middleware/auth/admission.

pub mod ops;
pub mod v1;

```

### crates/omnigate/src/routes/ops.rs
<a id="crates-omnigate-src-routes-ops-rs"></a>

```rust
//! RO:WHAT — Ops/administration endpoints (version, health, ready).
//! RO:WHY  — Keep admin plane consistent and DTO-stable.
//! RO:INVARIANTS — Shapes match types::dto; no secret/PII in responses.

use crate::types::VersionResponse;
use axum::{response::IntoResponse, Json};

/// GET /versionz (or /ops/version if routed) — returns service version and optional git short hash.
/// Wire shape: VersionResponse { version: String, git: Option<String> }.
pub async fn versionz() -> impl IntoResponse {
    // Prefer compile-time embed from build.rs; fall back to runtime env (CI can export it).
    let git = option_env!("GIT_COMMIT_SHORT")
        .map(|s| s.to_string())
        .or_else(|| std::env::var("GIT_COMMIT_SHORT").ok());

    Json(VersionResponse {
        version: env!("CARGO_PKG_VERSION").to_string(),
        git,
    })
}

/// Back-compat shim so existing router entries calling `routes::ops::version` still work.
pub async fn version() -> impl IntoResponse {
    versionz().await
}

```

### crates/omnigate/src/routes/v1/app.rs
<a id="crates-omnigate-src-routes-v1-app-rs"></a>

```rust
//! RO:WHAT  — v1 App plane stub router.
//! RO:WHY   — Reserve `/v1/app/*` and provide a simple health endpoint so we
//!            can start hanging real app-plane routes under this prefix.
//!
//! RO:INVARS
//!   - No business logic here: this module only defines HTTP shape.
//!   - It is safe to replace this stub with a `RonApp`-backed router later
//!     without breaking the `/v1/app/*` URL contract.
//!
//! In a later slice, this module will:
//!   - Host one or more `RonApp` implementations from `ron-app-sdk`.
//!   - Use `mount_app()` to bridge AppContract routes onto axum.
//!   - Enforce capability / auth extraction before invoking app handlers.

use axum::{routing::get, Json, Router};
use serde::Serialize;

/// Simple health payload for the app plane stub.
#[derive(Debug, Serialize)]
struct AppPlaneHealth {
    /// Always `true` for now; later we can surface per-app readiness.
    ok: bool,
    /// Human-readable note for debugging / integration tests.
    note: &'static str,
}

/// Build the `/v1/app/*` routing tree.
///
/// For now this only exposes:
///   - `GET /v1/app/healthz`
///
/// Later, this router will be replaced (or extended) to mount real RON apps
/// defined via the `ron-app-sdk` App Contract.
pub fn router<S>() -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    Router::new().route("/healthz", get(get_health))
}

/// `GET /v1/app/healthz`
///
/// Minimal "is the app plane wired?" probe. This is mostly for integration
/// tests and manual curl checks while we bootstrap the App Plane.
async fn get_health() -> Json<AppPlaneHealth> {
    Json(AppPlaneHealth {
        ok: true,
        note: "app plane stub mounted",
    })
}

```

### crates/omnigate/src/routes/v1/dht.rs
<a id="crates-omnigate-src-routes-v1-dht-rs"></a>

```rust
//! RO:WHAT   v1: /dht health stub (client passthrough soon).
//! RO:INVARS 200/JSON only.

use axum::{routing::get, Json, Router};
use serde::Serialize;

#[derive(Serialize)]
pub struct HealthReply {
    pub ok: bool,
}

pub fn router<S>() -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    Router::new().route("/healthz", get(healthz))
}

pub async fn healthz() -> Json<HealthReply> {
    Json(HealthReply { ok: true })
}

```

### crates/omnigate/src/routes/v1/facet/feed.rs
<a id="crates-omnigate-src-routes-v1-facet-feed-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/facet/graph.rs
<a id="crates-omnigate-src-routes-v1-facet-graph-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/facet/media.rs
<a id="crates-omnigate-src-routes-v1-facet-media-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/facet/mod.rs
<a id="crates-omnigate-src-routes-v1-facet-mod-rs"></a>

```rust
//! RO:WHAT   v1: /facet/{feed,media,graph} read-only stubs.
//! RO:WHY    Policy/capability probing + skeleton for hydration later.
//! RO:INVARS 200/JSON `{ ok: true }`, no leakage.

use axum::{routing::get, Json, Router};
use serde::Serialize;

#[derive(Serialize)]
pub struct FacetOk {
    pub ok: bool,
}

pub fn router<S>() -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    Router::new()
        .route("/feed", get(feed))
        .route("/media", get(media))
        .route("/graph", get(graph))
}

pub async fn feed() -> Json<FacetOk> {
    Json(FacetOk { ok: true })
}

pub async fn media() -> Json<FacetOk> {
    Json(FacetOk { ok: true })
}

pub async fn graph() -> Json<FacetOk> {
    Json(FacetOk { ok: true })
}

```

### crates/omnigate/src/routes/v1/index.rs
<a id="crates-omnigate-src-routes-v1-index-rs"></a>

```rust
//! RO:WHAT   v1: /ping + /index/healthz + /index/search + /sleep (bounded).
//! RO:WHY    Fast client confidence checks and a simple load helper for readiness smoke.
//! RO:INVARS JSON DTOs are stable and tiny; 200 on success. /sleep clamps ms ≤ 1000.

use axum::{
    extract::Query,
    routing::{get, post},
    Json, Router,
};
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Serialize)]
pub struct PingResponse {
    pub ok: bool,
}

#[derive(Serialize)]
pub struct HealthReply {
    pub ok: bool,
}

#[derive(Deserialize, Serialize)]
pub struct SearchRequest {
    pub q: String,
}

#[derive(Serialize)]
pub struct SearchReply {
    pub ok: bool,
    pub echoed: String,
}

#[derive(Deserialize)]
pub struct SleepQ {
    /// Milliseconds to sleep; clamped to ≤ 1000. Default: 500.
    pub ms: Option<u64>,
}

#[derive(Serialize)]
pub struct SleepReply {
    pub ok: bool,
    pub slept_ms: u64,
}

pub fn router<S>() -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    Router::new()
        .route("/ping", get(ping))
        .route("/index/healthz", get(healthz))
        .route("/index/search", post(search_echo))
        .route("/sleep", get(sleep_ms))
}

pub async fn ping() -> Json<PingResponse> {
    Json(PingResponse { ok: true })
}

pub async fn healthz() -> Json<HealthReply> {
    Json(HealthReply { ok: true })
}

pub async fn search_echo(Json(body): Json<SearchRequest>) -> Json<SearchReply> {
    Json(SearchReply {
        ok: true,
        echoed: body.q,
    })
}

/// Bounded sleep helper for readiness/inflight smoke tests.
pub async fn sleep_ms(Query(q): Query<SleepQ>) -> Json<SleepReply> {
    let ms = q.ms.unwrap_or(500).min(1_000);
    tokio::time::sleep(Duration::from_millis(ms)).await;
    Json(SleepReply {
        ok: true,
        slept_ms: ms,
    })
}

```

### crates/omnigate/src/routes/v1/mailbox.rs
<a id="crates-omnigate-src-routes-v1-mailbox-rs"></a>

```rust
//! RO:WHAT   v1/mailbox surface (health stub now; real ops later).
//! RO:INVARS Stable JSON shapes for health; S must be Send+Sync for layering.

use axum::{routing::get, Json, Router};
use serde::Serialize;

#[derive(Serialize)]
pub struct HealthReply {
    pub ok: bool,
}

pub async fn healthz() -> Json<HealthReply> {
    Json(HealthReply { ok: true })
}

/// Minimal router for /v1/mailbox/*
pub fn router<S>() -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    Router::new().route("/healthz", get(healthz))
}

```

### crates/omnigate/src/routes/v1/mod.rs
<a id="crates-omnigate-src-routes-v1-mod-rs"></a>

```rust
//! RO:WHAT   v1 API surface aggregator (health/ping + facet stubs).
//! RO:WHY    Keep top-level router slim; v1 evolves independently.
//! RO:INVARS Only DTO-stable shapes; never leak internals.

pub mod app;
pub mod dht;
pub mod facet;
pub mod index;
pub mod mailbox;
pub mod objects;

use axum::Router;

/// Compose the whole v1 subtree.
///
/// Mount with:
/// ```ignore
/// .nest("/v1", routes::v1::router())
/// ```
pub fn router<S>() -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    Router::new()
        .merge(index::router()) // includes /ping and /index/healthz
        .nest("/objects", objects::router())
        .nest("/mailbox", mailbox::router())
        .nest("/dht", dht::router())
        .nest("/facet", facet::router())
        .nest("/app", app::router())
}

```

### crates/omnigate/src/routes/v1/objects.rs
<a id="crates-omnigate-src-routes-v1-objects-rs"></a>

```rust
//! RO:WHAT   v1: /objects health stub (ready to swap to StorageClient).
//! RO:INVARS 200/JSON only; no internal details.

use axum::{routing::get, Json, Router};
use serde::Serialize;

#[derive(Serialize)]
pub struct HealthReply {
    pub ok: bool,
}

pub fn router<S>() -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    Router::new().route("/healthz", get(healthz))
}

pub async fn healthz() -> Json<HealthReply> {
    Json(HealthReply { ok: true })
}

```

### crates/omnigate/src/routes/v1/ping.rs
<a id="crates-omnigate-src-routes-v1-ping-rs"></a>

```rust
//! RO:WHAT   GET /v1/ping handler
//! RO:WHY    Minimal health style endpoint used by benches and smoke tests.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
pub struct PingResponse {
    pub ok: bool,
}

pub async fn handler() -> impl IntoResponse {
    Json(PingResponse { ok: true })
}

```

### crates/omnigate/src/runtime/channels.rs
<a id="crates-omnigate-src-runtime-channels-rs"></a>

```rust
//! RO:WHAT — Message channels between supervisor and workers.
//! RO:WHY  — Broadcast down (supervisor→workers), MPSC up (workers→supervisor).

use tokio::sync::{broadcast, mpsc};

#[derive(Debug, Clone)]
pub enum SupervisorMsg {
    /// Ask all workers to stop gracefully.
    Stop,
    /// Future: reload config, etc.
    Nop,
}

#[derive(Debug)]
pub enum WorkerMsg {
    Started(&'static str),
    Stopped(&'static str),
}

pub use broadcast::{Receiver as BcastRx, Sender as BcastTx};
pub use mpsc::{Receiver as MpscRx, Sender as MpscTx};

/// Build the control plane channels.
/// - `worker_backlog`: size of the per-worker upstream MPSC buffer.
pub fn mk_supervisor_bus(
    worker_backlog: usize,
) -> (
    BcastTx<SupervisorMsg>,
    BcastRx<SupervisorMsg>,
    MpscTx<WorkerMsg>,
    MpscRx<WorkerMsg>,
) {
    let (tx_cmd, rx_cmd) = broadcast::channel(16);
    let (up_tx, up_rx) = mpsc::channel(worker_backlog);
    (tx_cmd, rx_cmd, up_tx, up_rx)
}

```

### crates/omnigate/src/runtime/mod.rs
<a id="crates-omnigate-src-runtime-mod-rs"></a>

```rust
//! RO:WHAT — Lightweight runtime layer: supervised background workers + cooperative shutdown.
//! RO:WHY  — Keep App/router lean; side-loops (samplers, refreshers, warmers) live here.
//! RO:INTERACTS — ron-kernel (Bus/Events), Metrics (recorders), admission, policy.
//! RO:INVARIANTS — Single owner per worker task; graceful stop within timeout; no locks across .await.

mod channels;
mod shutdown;
mod supervisor;
mod worker;

pub mod sample;

pub use channels::{mk_supervisor_bus, SupervisorMsg, WorkerMsg};
pub use shutdown::{pair as shutdown_pair, Shutdown, ShutdownTrigger};
pub use supervisor::{spawn_supervisor, SupervisorHandle};
pub use worker::{spawn_worker, DynWorker, Worker};

```

### crates/omnigate/src/runtime/sample.rs
<a id="crates-omnigate-src-runtime-sample-rs"></a>

```rust
//! RO:WHAT — Example worker used by tests and as a template.
//! RO:WHY  — Minimal worker that exits on shutdown or Stop.

use std::{future::Future, pin::Pin, sync::Arc};
use tokio::sync::{broadcast, mpsc};
use tracing::info;

use super::channels::{SupervisorMsg, WorkerMsg};
use super::shutdown::Shutdown;
use super::worker::Worker;

#[derive(Default)]
pub struct TickWorker;

impl TickWorker {
    pub fn new() -> Arc<Self> {
        Arc::new(Self)
    }
}

impl Worker for TickWorker {
    fn name(&self) -> &'static str {
        "tick"
    }

    fn run(
        &self,
        shutdown: Shutdown,
        mut commands: broadcast::Receiver<SupervisorMsg>,
        up_tx: mpsc::Sender<WorkerMsg>,
    ) -> Pin<Box<dyn Future<Output = ()> + Send>> {
        Box::pin(async move {
            loop {
                tokio::select! {
                    _ = shutdown.cancelled() => {
                        break;
                    }
                    Ok(msg) = commands.recv() => {
                        if let SupervisorMsg::Stop = msg {
                            break;
                        }
                    }
                }
            }
            let _ = up_tx.send(WorkerMsg::Stopped("tick")).await;
            info!("tick worker exiting");
        })
    }
}

```

### crates/omnigate/src/runtime/shutdown.rs
<a id="crates-omnigate-src-runtime-shutdown-rs"></a>

```rust
//! RO:WHAT — Cooperative shutdown primitives.
//! RO:WHY  — A tiny CancellationToken wrapper so workers/supervisor can agree on quit.
//! RO:INVARIANTS — Non-blocking; clone is cheap; `cancelled()` is awaitable.

use tokio_util::sync::CancellationToken;

/// Handle that tasks can hold/clone to observe shutdown.
#[derive(Clone)]
pub struct Shutdown {
    token: CancellationToken,
}

/// Trigger used by the supervisor to request shutdown.
#[derive(Clone)]
pub struct ShutdownTrigger {
    token: CancellationToken,
}

/// Construct a (Shutdown, ShutdownTrigger) pair.
pub fn pair() -> (Shutdown, ShutdownTrigger) {
    let token = CancellationToken::new();
    (
        Shutdown {
            token: token.clone(),
        },
        ShutdownTrigger { token },
    )
}

impl Shutdown {
    /// Wait until shutdown is requested.
    pub async fn cancelled(&self) {
        self.token.cancelled().await;
    }
}

impl ShutdownTrigger {
    /// Request shutdown for all holders of the paired `Shutdown`.
    pub fn cancel(&self) {
        self.token.cancel();
    }
}

```

### crates/omnigate/src/runtime/supervisor.rs
<a id="crates-omnigate-src-runtime-supervisor-rs"></a>

```rust
//! RO:WHAT — Spawns and coordinates all workers.
//! RO:WHY  — Single place that can trigger graceful shutdown and fan-out commands.

use tokio::{sync::broadcast, task::JoinHandle};
use tracing::info;

use super::channels::{mk_supervisor_bus, MpscRx, SupervisorMsg};
use super::shutdown::{pair as shutdown_pair, ShutdownTrigger};
use super::worker::{spawn_worker, DynWorker};

pub struct SupervisorHandle {
    pub join: JoinHandle<()>,
    pub tx_cmd: broadcast::Sender<SupervisorMsg>,
    pub shutdown: ShutdownTrigger,
    pub up_rx: MpscRx<super::channels::WorkerMsg>,
}

pub fn spawn_supervisor(workers: Vec<DynWorker>, worker_backlog: usize) -> SupervisorHandle {
    let (tx_cmd, _rx_cmd, up_tx, up_rx) = mk_supervisor_bus(worker_backlog);
    let tx_cmd_for_task = tx_cmd.clone();

    let (shutdown, trigger) = shutdown_pair();

    let join = tokio::spawn(async move {
        // spawn all workers
        let mut joins: Vec<JoinHandle<()>> = Vec::with_capacity(workers.len());
        for w in workers {
            let rx = tx_cmd_for_task.subscribe();
            let j = spawn_worker(w, shutdown.clone(), rx, up_tx.clone());
            joins.push(j);
        }

        // Wait for shutdown, then ask everyone to stop.
        shutdown.cancelled().await;
        let _ = tx_cmd_for_task.send(SupervisorMsg::Stop);

        // Drain joins.
        for j in joins {
            let _ = j.await;
        }
        info!("supervisor exited");
    });

    SupervisorHandle {
        join,
        tx_cmd,
        shutdown: trigger,
        up_rx,
    }
}

```

### crates/omnigate/src/runtime/worker.rs
<a id="crates-omnigate-src-runtime-worker-rs"></a>

```rust
//! RO:WHAT — Worker trait + spawner glue.
//! RO:WHY  — Lets us run heterogeneous background tasks under a supervisor.

use std::{future::Future, pin::Pin, sync::Arc};
use tokio::{
    sync::{broadcast, mpsc},
    task::JoinHandle,
};
use tracing::info;

use super::channels::{SupervisorMsg, WorkerMsg};
use super::shutdown::Shutdown;

/// Vtable for a managed worker.
pub trait Worker: Send + Sync + 'static {
    fn name(&self) -> &'static str;

    fn run(
        &self,
        shutdown: Shutdown,
        commands: broadcast::Receiver<SupervisorMsg>,
        up_tx: mpsc::Sender<WorkerMsg>,
    ) -> Pin<Box<dyn Future<Output = ()> + Send>>;
}

pub type DynWorker = Arc<dyn Worker>;

pub fn spawn_worker(
    w: DynWorker,
    shutdown: Shutdown,
    commands: broadcast::Receiver<SupervisorMsg>,
    up_tx: mpsc::Sender<WorkerMsg>,
) -> JoinHandle<()> {
    let name = w.name();
    tokio::spawn(async move {
        // Let the supervisor know we’re starting.
        let _ = up_tx.send(WorkerMsg::Started(name)).await;

        // Run the worker future to completion.
        let fut = (*w).run(shutdown, commands, up_tx.clone());
        fut.await;

        info!(worker = name, "worker exited");
        // Best-effort notify stop.
        let _ = up_tx.send(WorkerMsg::Stopped(name)).await;
    })
}

```

### crates/omnigate/src/state.rs
<a id="crates-omnigate-src-state-rs"></a>

```rust
//! RO:WHAT   Shared application state container.
//! RO:WHY    Centralize config, policy evaluator, readiness policy, and helpers.

use std::sync::Arc;
use crate::readiness::policy::ReadyPolicy;

#[derive(Clone)]
pub struct AppState {
    pub config: Arc<crate::config::Config>,
    pub ready: ReadyPolicy,
    pub policy: Option<ron_policy::Evaluator>,
    pub tenant: Option<String>,
    pub region: Option<String>,
}

impl AppState {
    pub fn new(config: Arc<crate::config::Config>, ready: ReadyPolicy, policy: Option<ron_policy::Evaluator>) -> Arc<Self> {
        Arc::new(Self { config, ready, policy, tenant: None, region: None })
    }

    pub fn tags_for<B>(&self, _req: &axum::http::Request<B>) -> Vec<String> {
        // Future: pull auth claims or route-classifier tags.
        Vec::new()
    }
}

```

### crates/omnigate/src/types/dto.rs
<a id="crates-omnigate-src-types-dto-rs"></a>

```rust
//! RO:WHAT — Public response DTOs the API returns.
//! RO:WHY  — Tests serialize/deserialize these; keep stable wire shape.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct VersionResponse {
    pub version: String,
    /// Optional short git hash if available.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub git: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct PingResponse {
    pub ok: bool,
}

```

### crates/omnigate/src/types/mod.rs
<a id="crates-omnigate-src-types-mod-rs"></a>

```rust
pub mod dto;

pub use dto::{PingResponse, VersionResponse};

```

### crates/omnigate/src/zk/mod.rs
<a id="crates-omnigate-src-zk-mod-rs"></a>

```rust
//! RO:WHAT — Zero-knowledge–ready envelope surface.
//! RO:WHY  — Carve clean seams (read-only vs mutate) + receipts without committing to a prover.
//! RO:INVARIANTS — No proof code here; only types and gating logic surfaces.

pub mod no_mutate;
pub mod receipts;

pub use no_mutate::{OpClass, OpGuard};
pub use receipts::{Receipt, ReceiptId, ReceiptStatus};

```

### crates/omnigate/src/zk/no_mutate.rs
<a id="crates-omnigate-src-zk-nomutate-rs"></a>

```rust
//! RO:WHAT — Read-only vs Mutate operation gating.
//! RO:WHY  — Allow policy/rate-limit paths to key off operation class.
//! RO:INVARIANTS — Pure classification; no IO; easy to unit test.

/// Operation class used by admissions/policy.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OpClass {
    ReadOnly,
    Mutate,
}

/// Guard object carried in request extensions to mark op class.
#[derive(Debug, Clone, Copy)]
pub struct OpGuard {
    class: OpClass,
}

impl OpGuard {
    pub fn new(class: OpClass) -> Self {
        Self { class }
    }
    pub fn class(&self) -> OpClass {
        self.class
    }
}

```

### crates/omnigate/src/zk/receipts.rs
<a id="crates-omnigate-src-zk-receipts-rs"></a>

```rust
//! RO:WHAT — Generic receipt type for mutating operations.
//! RO:WHY  — Provide durable handle for async/queued mutations without picking a backend yet.
//! RO:INVARIANTS — Opaque ids; monotonic timestamps; status is conservative.

use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

pub type ReceiptId = String;

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ReceiptStatus {
    Accepted,
    Processing,
    Completed,
    Failed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Receipt {
    pub id: ReceiptId,
    pub status: ReceiptStatus,
    pub created_ms: u128,
    pub last_update_ms: u128,
}

impl Receipt {
    pub fn new(id: ReceiptId) -> Self {
        let now = now_ms();
        Self {
            id,
            status: ReceiptStatus::Accepted,
            created_ms: now,
            last_update_ms: now,
        }
    }
    pub fn set_status(&mut self, s: ReceiptStatus) {
        self.status = s;
        self.last_update_ms = now_ms();
    }
}

fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

```

### crates/omnigate/testing/chaos/scenario.yml
<a id="crates-omnigate-testing-chaos-scenario-yml"></a>

```yaml
# Scaffold example for chaos; fill with providers and injections.
injections: []

```

### crates/omnigate/testing/performance/baselines/p95_hydration.json
<a id="crates-omnigate-testing-performance-baselines-p95hydration-json"></a>

```json
{"p95_ms":150}

```

### crates/omnigate/testing/performance/baselines/p95_range.json
<a id="crates-omnigate-testing-performance-baselines-p95range-json"></a>

```json
{"p95_ms":100}

```

### crates/omnigate/testing/performance/hydrate_mix.sh
<a id="crates-omnigate-testing-performance-hydratemix-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: put your loadgen here and assert p95 targets.

```

### crates/omnigate/testing/vectors/omnigate/error_413.json
<a id="crates-omnigate-testing-vectors-omnigate-error413-json"></a>

```json

```

### crates/omnigate/testing/vectors/omnigate/range_read.json
<a id="crates-omnigate-testing-vectors-omnigate-rangeread-json"></a>

```json

```

### crates/omnigate/testing/vectors/omnigate/unauth_401.json
<a id="crates-omnigate-testing-vectors-omnigate-unauth401-json"></a>

```json

```

### crates/omnigate/tests/admission_contract.rs
<a id="crates-omnigate-tests-admissioncontract-rs"></a>

```rust
// RO:WHAT
// Contract checks for simple "admission-style" guards wired via `from_fn_with_state`.
// These are *test-only* helpers to make sure our layering semantics and extractor
// signatures are correct under Axum 0.7.

use axum::{
    body::Body,
    extract::State,
    http::{Request, StatusCode},
    middleware::{from_fn_with_state, Next},
    response::{IntoResponse, Response},
    routing::get,
    Router,
};
use std::sync::{
    atomic::{AtomicUsize, Ordering},
    Arc,
};
use tower::ServiceExt;

// ----- Tiny quota guard -------------------------------------------------------

#[derive(Debug, Default)]
struct Tiny {
    // "hard" is a max-requests-left style counter.
    hard: AtomicUsize,
    // "soft" unused in these tiny tests but parked here for parity with previous shape.
    #[allow(dead_code)]
    soft: AtomicUsize,
}

async fn tiny_guard(State(state): State<Arc<Tiny>>, req: Request<Body>, next: Next) -> Response {
    // If no budget left, 429 immediately (cheap shed).
    if state.hard.load(Ordering::Relaxed) == 0 {
        return StatusCode::TOO_MANY_REQUESTS.into_response();
    }
    // Decrement and pass through.
    state.hard.fetch_sub(1, Ordering::Relaxed);
    next.run(req).await
}

// ----- "Once" guard (allow exactly one) --------------------------------------

#[derive(Debug)]
struct Once(AtomicUsize);

async fn once_guard(State(state): State<Arc<Once>>, req: Request<Body>, next: Next) -> Response {
    // First request allowed (counter set to 1), subsequent ones 429.
    if state.0.fetch_sub(1, Ordering::Relaxed) == 0 {
        return StatusCode::TOO_MANY_REQUESTS.into_response();
    }
    next.run(req).await
}

// ----- Tests -----------------------------------------------------------------

#[tokio::test]
async fn tiny_quota_allows_then_429s() {
    // Start with budget=2.
    let tiny = Arc::new(Tiny {
        hard: AtomicUsize::new(2),
        soft: AtomicUsize::new(0),
    });

    let app = Router::new()
        .route("/", get(|| async { "ok" }))
        .layer(from_fn_with_state(tiny.clone(), tiny_guard));

    // First two requests ok…
    let res = app
        .clone()
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::OK);

    let res = app
        .clone()
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::OK);

    // …third should be shed.
    let res = app
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::TOO_MANY_REQUESTS);
}

#[tokio::test]
async fn quota_when_exhausted_429() {
    // Allow exactly one request.
    let once = Arc::new(Once(AtomicUsize::new(1)));

    let app = Router::new()
        .route("/", get(|| async { "ok" }))
        .layer(from_fn_with_state(once.clone(), once_guard));

    // First request OK…
    let res = app
        .clone()
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::OK);

    // …second is 429.
    let res = app
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::TOO_MANY_REQUESTS);
}

```

### crates/omnigate/tests/dto_serialization.rs
<a id="crates-omnigate-tests-dtoserialization-rs"></a>

```rust
use omnigate::types::dto::{PingResponse, VersionResponse};

#[test]
fn dto_roundtrips() {
    // VersionResponse now: { version, git }
    let v = VersionResponse {
        version: "0.0.0".to_string(),
        git: Some("deadbeef".to_string()),
    };
    let s = serde_json::to_string(&v).unwrap();
    let _: VersionResponse = serde_json::from_str(&s).unwrap();

    // PingResponse now: { ok }
    let p = PingResponse { ok: true };
    let s = serde_json::to_string(&p).unwrap();
    let _: PingResponse = serde_json::from_str(&s).unwrap();
}

```

### crates/omnigate/tests/hardening.rs
<a id="crates-omnigate-tests-hardening-rs"></a>

```rust


```

### crates/omnigate/tests/interop_vectors.rs
<a id="crates-omnigate-tests-interopvectors-rs"></a>

```rust


```

### crates/omnigate/tests/loom_fanout.rs
<a id="crates-omnigate-tests-loomfanout-rs"></a>

```rust


```

### crates/omnigate/tests/metrics_contract.rs
<a id="crates-omnigate-tests-metricscontract-rs"></a>

```rust
//! Ensures /metrics exports required series & labels.
//! Run: cargo test -p omnigate --test metrics_contract

use regex::Regex;

#[test]
fn metrics_shape_is_present() {
    // For CI stability you can replace this with a boot-and-fetch helper.
    let metrics = include_str!("../testing/fixtures/metrics.sample.txt");

    for name in &[
        "http_requests_total",
        "request_latency_seconds",
        "admission_quota_exhausted_total",
        "admission_fair_queue_events_total",
        "body_reject_total",
        "decompress_reject_total",
        "policy_middleware_shortcircuits_total",
    ] {
        assert!(metrics.contains(name), "missing series: {name}");
    }

    let re = Regex::new(
        r#"http_requests_total\{route="[^"]+",method="(GET|POST|PUT|DELETE)",status="\d{3}"\}"#,
    )
    .unwrap();
    assert!(
        re.is_match(metrics),
        "labels missing on http_requests_total"
    );
}

```

### crates/omnigate/tests/middleware_contract.rs
<a id="crates-omnigate-tests-middlewarecontract-rs"></a>

```rust
// RO:WHAT — Contract tests for edge guards (decompress + body caps).
// RO:WHY  — Prevent regressions: unknown/stacked encodings => 415; over-budget compressed => 413;
//           oversized bodies => 413; small ones pass.

use axum::{
    body::{self, Body},
    http::{Request, StatusCode},
    response::IntoResponse,
    Json,
};
use serde_json::json;
use tower::{service_fn, ServiceBuilder, ServiceExt}; // ServiceExt gives us `.oneshot`

// Keep this comfortably above any tiny JSON error envelopes these tests read.
const READ_LIMIT: usize = 256 * 1024;

#[tokio::test]
async fn decompress_guard_unknown_encoding_415() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::decompress_guard::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(axum::http::header::CONTENT_ENCODING, "compress") // not allowed
        .body(Body::from("tiny"))
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::UNSUPPORTED_MEDIA_TYPE);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["reason"], "unsupported_media_type");
}

#[tokio::test]
async fn decompress_guard_stacked_encodings_415() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::decompress_guard::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(axum::http::header::CONTENT_ENCODING, "gzip, br")
        .body(Body::from("tiny"))
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::UNSUPPORTED_MEDIA_TYPE);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["reason"], "unsupported_media_type");
}

#[tokio::test]
async fn decompress_guard_over_budget_413() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::decompress_guard::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    // With EXPANSION_CAP=10 and MAX_EXPANDED=1 MiB, any compressed length > ~104_857 bytes triggers 413.
    let declared_len = 200_000u64;

    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(axum::http::header::CONTENT_ENCODING, "gzip")
        .header(axum::http::header::CONTENT_LENGTH, declared_len.to_string())
        .body(Body::empty())
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::PAYLOAD_TOO_LARGE);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["reason"], "payload_too_large");
}

#[tokio::test]
async fn body_caps_oversized_by_header_413() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::body_caps::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    // 2 MiB > 1 MiB limit -> reject immediately via preflight guard.
    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(
            axum::http::header::CONTENT_LENGTH,
            (2 * 1024 * 1024).to_string(),
        )
        .body(Body::empty())
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::PAYLOAD_TOO_LARGE);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["reason"], "payload_too_large");
}

#[tokio::test]
async fn body_caps_small_ok_200() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::body_caps::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    let body_txt = "hello world";
    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(
            axum::http::header::CONTENT_LENGTH,
            body_txt.len().to_string(),
        )
        .body(Body::from(body_txt.to_string()))
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::OK);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["ok"], true);
}

```

### crates/omnigate/tests/oap_limits.rs
<a id="crates-omnigate-tests-oaplimits-rs"></a>

```rust


```

### crates/omnigate/tests/policy_gate.rs
<a id="crates-omnigate-tests-policygate-rs"></a>

```rust
//! Verifies PolicyLayer wiring and shows the failure/success cases.
//!
//! Case A (broken): Extension<PolicyBundle> layered *before* `middleware::apply` →
//!                  PolicyLayer can’t see the bundle → PUT returns 405 (router method guard).
//! Case B (fixed):  Extension<PolicyBundle> layered *after*  `middleware::apply` →
//!                  PolicyLayer sees the bundle → PUT returns 403 (policy deny).

use std::sync::Arc;

use axum::{
    body::Body, extract::Request, http::StatusCode, response::IntoResponse, routing::get, Json,
    Router,
};
use ron_policy::PolicyBundle;
use serde_json::json;
use tower::ServiceExt;

async fn ping() -> impl IntoResponse {
    Json(json!({ "ok": true }))
}

// Minimal strict-policy bundle:
// - default deny
// - allow only GET
fn test_bundle() -> PolicyBundle {
    let json = r#"
    {
      "version": 1,
      "defaults": { "default_action": "deny" },
      "rules": [
        { "id": "allow-gets", "when": { "method": "GET" }, "action": "allow" }
      ]
    }"#;

    serde_json::from_str::<PolicyBundle>(json).expect("strict bundle should parse")
}

#[tokio::test]
async fn policy_broken_layering_yields_405_put() {
    // Router with only GET /v1/ping
    let router = Router::new().route("/v1/ping", get(ping));

    // ❌ BROKEN ORDER: layer Extension first, then apply middleware stack.
    // In this order, the PolicyLayer (added by middleware::apply) sits OUTSIDE
    // the Extension layer and thus does NOT see the bundled policy.
    let router = router.layer(axum::Extension(Arc::new(test_bundle())));
    let router = omnigate::middleware::apply(router);

    // PUT should not be allowed by the route; without policy, this becomes 405.
    let req = Request::builder()
        .method("PUT")
        .uri("/v1/ping")
        .body(Body::empty())
        .unwrap();

    let resp = router.oneshot(req).await.unwrap();
    assert_eq!(
        resp.status(),
        StatusCode::METHOD_NOT_ALLOWED,
        "broken layering should yield 405 (policy unseen)"
    );
}

#[tokio::test]
async fn policy_correct_layering_yields_403_put() {
    // Router with only GET /v1/ping
    let base = Router::new().route("/v1/ping", get(ping));

    // ✅ CORRECT ORDER: build the middleware stack first (includes PolicyLayer),
    // then layer the Extension so it runs OUTSIDE and is visible to PolicyLayer.
    let router = omnigate::middleware::apply(base).layer(axum::Extension(Arc::new(test_bundle())));

    // PUT should be denied by policy (default deny; only GET is allowed).
    let req = Request::builder()
        .method("PUT")
        .uri("/v1/ping")
        .body(Body::empty())
        .unwrap();

    let resp = router.clone().oneshot(req).await.unwrap();
    assert_eq!(
        resp.status(),
        StatusCode::FORBIDDEN,
        "correct layering should yield 403 (policy deny)"
    );

    // GET should still pass (rule allows GET)
    let req_ok = Request::builder()
        .method("GET")
        .uri("/v1/ping")
        .body(Body::empty())
        .unwrap();

    let resp_ok = router.oneshot(req_ok).await.unwrap();
    assert_eq!(
        resp_ok.status(),
        StatusCode::OK,
        "GET should be allowed by policy"
    );
}

```

### crates/omnigate/tests/policy_metrics.rs
<a id="crates-omnigate-tests-policymetrics-rs"></a>

```rust
// crates/omnigate/tests/policy_metrics.rs
// Proves policy_middleware_shortcircuits_total increments when policy denies a request.
// We scrape the text exposition to avoid private proto APIs.

use std::sync::Arc;

use axum::{body::Body, extract::Request, routing::get, Json, Router};
use prometheus::{gather, Encoder, TextEncoder};
use regex::Regex;
use ron_policy::PolicyBundle;
use serde_json::json;
use tower::ServiceExt;

async fn ping() -> Json<serde_json::Value> {
    Json(json!({ "ok": true }))
}

// Strict bundle: default deny; allow only GET.
fn strict_bundle() -> PolicyBundle {
    let json = r#"
    {
      "version": 1,
      "defaults": { "default_action": "deny" },
      "rules": [
        { "id": "allow-gets", "when": { "method": "GET" }, "action": "allow" }
      ]
    }"#;
    serde_json::from_str::<PolicyBundle>(json).unwrap()
}

// Scrape the text exposition and sum all samples for a counter (any labels).
fn scrape_counter_sum(name: &str) -> f64 {
    let mut buf = Vec::new();
    TextEncoder::new().encode(&gather(), &mut buf).ok();
    let text = String::from_utf8_lossy(&buf);

    // Matches lines like:
    // policy_middleware_shortcircuits_total 3
    // policy_middleware_shortcircuits_total{status="403"} 2
    let re = Regex::new(&format!(
        r#"(?m)^{}\s*(?:\{{[^}}]*\}})?\s+([0-9]+(?:\.[0-9]+)?)\s*$"#,
        regex::escape(name)
    ))
    .unwrap();

    let mut sum = 0.0;
    for cap in re.captures_iter(&text) {
        if let Some(m) = cap.get(1) {
            if let Ok(v) = m.as_str().parse::<f64>() {
                sum += v;
            }
        }
    }
    sum
}

#[tokio::test]
async fn policy_deny_bumps_counter() {
    // Router with GET /v1/ping
    let base = Router::new().route("/v1/ping", get(ping));

    // Correct layering: middleware first (adds PolicyLayer), then Extension(bundle)
    let router =
        omnigate::middleware::apply(base).layer(axum::Extension(Arc::new(strict_bundle())));

    // Read counter before
    let before = scrape_counter_sum("policy_middleware_shortcircuits_total");

    // Issue a denied PUT (default deny)
    let req = Request::builder()
        .method("PUT")
        .uri("/v1/ping")
        .body(Body::empty())
        .unwrap();
    let resp = router.clone().oneshot(req).await.unwrap();
    assert_eq!(resp.status().as_u16(), 403, "policy should deny PUT");

    // Counter should have increased
    let after = scrape_counter_sum("policy_middleware_shortcircuits_total");
    assert!(
        after > before,
        "expected policy_middleware_shortcircuits_total to increase; before={before}, after={after}"
    );
}

```

### crates/omnigate/tests/readiness_error_rate.rs
<a id="crates-omnigate-tests-readinesserrorrate-rs"></a>

```rust
//! Verifies that sustained 503 drop/error rate trips /readyz → 503 (error-rate branch).
//! Strategy: set *tiny* fair-queue capacity to force 503 drops, but set inflight-threshold huge
//! so we do not trip via inflight. The sampler counts fair_q drops toward error-rate.

use anyhow::Result;
use omnigate::{config, App};
use reqwest::Client;
use std::net::SocketAddr;
use tokio::{
    net::TcpListener,
    time::{sleep, Duration},
};

async fn spawn_app_with_cfg(mut cfg: config::Config) -> Result<(SocketAddr, SocketAddr)> {
    cfg.server.bind = "127.0.0.1:0".parse().unwrap();
    cfg.server.metrics_addr = "127.0.0.1:0".parse().unwrap();

    let app = App::build(cfg).await?;
    let listener = TcpListener::bind("127.0.0.1:0").await?;
    let api_addr = listener.local_addr()?;
    let admin_addr = app.admin_addr;

    let router = app.router;
    tokio::spawn(async move {
        axum::serve(listener, router).await.unwrap();
    });

    Ok((api_addr, admin_addr))
}

fn cfg_error_rate_via_fair_queue() -> config::Config {
    config::Config {
        server: config::Server {
            bind: "127.0.0.1:5305".parse().unwrap(),
            metrics_addr: "127.0.0.1:9605".parse().unwrap(),
            amnesia: true,
        },
        oap: config::Oap {
            max_frame_bytes: 1_048_576,
            stream_chunk_bytes: 65_536,
        },
        admission: config::Admission {
            // Quotas generous (we don't want 429s for this test)
            global_quota: config::GlobalQuota {
                qps: 1_000_000,
                burst: 1_000_000,
            },
            ip_quota: config::IpQuota {
                enabled: false,
                qps: 0,
                burst: 0,
            },
            // FAIR-QUEUE: extremely tiny hard limit to force 503 drops under concurrency
            fair_queue: config::FairQueue {
                max_inflight: 8,
                headroom: Some(0),
                weights: config::Weights {
                    anon: 1,
                    auth: 1,
                    admin: 1,
                },
            },
            body: config::BodyCaps {
                max_content_length: 1_048_576,
                reject_on_missing_length: true,
            },
            decompression: config::Decompress {
                allow: vec!["identity".into(), "gzip".into()],
                deny_stacked: true,
            },
        },
        policy: config::Policy {
            enabled: false, // keep policy out of the picture for this test
            bundle_path: "crates/omnigate/configs/policy.bundle.json".into(),
            fail_mode: "deny".into(),
        },
        readiness: config::Readiness {
            max_inflight_threshold: 1_000_000, // make inflight path irrelevant
            error_rate_429_503_pct: 0.1,       // very easy to trip
            window_secs: 2,                    // short window => quick sampler ticks
            hold_for_secs: 3,
        },
    }
}

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn readiness_trips_on_error_rate() -> Result<()> {
    let (api, _admin) = spawn_app_with_cfg(cfg_error_rate_via_fair_queue()).await?;
    let api_base = format!("http://{}", api);
    let client = Client::builder().build()?;

    // 1) Sanity: /readyz starts 200
    let code = client
        .get(format!("{}/readyz", api_base))
        .send()
        .await?
        .status();
    assert!(code.is_success(), "expected 200 from /readyz, got {}", code);

    // 2) Create a heavy burst against /v1/sleep that will exceed the tiny fair-queue capacity
    let concurrency = 200usize;
    let sleep_ms = 800u64;
    let mut joins = Vec::with_capacity(concurrency);
    for _ in 0..concurrency {
        let url = format!("{}/v1/sleep?ms={}", api_base, sleep_ms);
        let c = client.clone();
        joins.push(tokio::spawn(async move {
            let _ = c.get(url).send().await; // many of these will be 503 from shedding
        }));
    }

    // 3) Poll /readyz until it flips to 503 (expect via error-rate branch)
    // Give sampler windows a chance to observe drops: up to ~8s
    let deadline = tokio::time::Instant::now() + Duration::from_secs(8);
    let mut degraded = false;
    while tokio::time::Instant::now() < deadline {
        let code = client
            .get(format!("{}/readyz", api_base))
            .send()
            .await?
            .status();
        if code.as_u16() == 503 {
            degraded = true;
            break;
        }
        sleep(Duration::from_millis(150)).await;
    }

    for j in joins {
        let _ = j.await;
    }
    assert!(
        degraded,
        "expected /readyz to degrade to 503 by error-rate (fair-queue drops)"
    );
    Ok(())
}

```

### crates/omnigate/tests/readiness_inflight.rs
<a id="crates-omnigate-tests-readinessinflight-rs"></a>

```rust
//! Verifies that sustained in-flight pressure trips /readyz → 503,
//! holds for hold_for_secs, then recovers to 200.

use anyhow::Result;
use omnigate::{config, App};
use reqwest::Client;
use std::net::SocketAddr;
use tokio::{
    net::TcpListener,
    time::{sleep, Duration},
};

async fn spawn_app_with_cfg(mut cfg: config::Config) -> Result<(SocketAddr, SocketAddr)> {
    // Bind API to an ephemeral port; we’ll override at serve-time.
    cfg.server.bind = "127.0.0.1:0"
        .parse()
        .unwrap_or("127.0.0.1:0".parse().unwrap());
    // Bind metrics/admin plane to ephemeral as well; App::build will return the actual addr.
    cfg.server.metrics_addr = "127.0.0.1:0".parse().unwrap();

    let app = App::build(cfg).await?;
    // Bind listener for API
    let listener = TcpListener::bind("127.0.0.1:0").await?;
    let api_addr = listener.local_addr()?;
    let admin_addr = app.admin_addr;

    // Serve API in background
    let router = app.router;
    tokio::spawn(async move {
        axum::serve(listener, router).await.unwrap();
    });

    Ok((api_addr, admin_addr))
}

fn cfg_inflight_low_threshold() -> config::Config {
    config::Config {
        server: config::Server {
            bind: "127.0.0.1:5305".parse().unwrap(), // ignored (we bind 0)
            metrics_addr: "127.0.0.1:9605".parse().unwrap(), // ignored (we bind 0)
            amnesia: true,
        },
        oap: config::Oap {
            max_frame_bytes: 1_048_576,
            stream_chunk_bytes: 65_536,
        },
        admission: config::Admission {
            global_quota: config::GlobalQuota {
                qps: 20_000,
                burst: 40_000,
            },
            ip_quota: config::IpQuota {
                enabled: true,
                qps: 2_000,
                burst: 4_000,
            },
            fair_queue: config::FairQueue {
                max_inflight: 2048,
                headroom: Some(256),
                weights: config::Weights {
                    anon: 1,
                    auth: 5,
                    admin: 10,
                },
            },
            body: config::BodyCaps {
                max_content_length: 1_048_576,
                reject_on_missing_length: true,
            },
            decompression: config::Decompress {
                allow: vec!["identity".into(), "gzip".into()],
                deny_stacked: true,
            },
        },
        policy: config::Policy {
            enabled: true,
            bundle_path: "crates/omnigate/configs/policy.bundle.json".into(),
            fail_mode: "deny".into(),
        },
        // Low thresholds so laptops trip quickly
        readiness: config::Readiness {
            max_inflight_threshold: 64,
            error_rate_429_503_pct: 100.0, // make inflight the only trigger here
            window_secs: 5,
            hold_for_secs: 6,
        },
    }
}

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn readiness_trips_on_inflight_then_recovers() -> Result<()> {
    let (api, admin) = spawn_app_with_cfg(cfg_inflight_low_threshold()).await?;
    let api_base = format!("http://{}", api);
    let ops_base = format!("http://{}", admin);
    let client = Client::builder().build()?;

    // 1) Sanity: /readyz starts 200
    let code = client
        .get(format!("{}/readyz", api_base))
        .send()
        .await?
        .status();
    assert!(code.is_success(), "expected 200 from /readyz, got {}", code);

    // 2) Create sustained in-flight using /v1/sleep
    let concurrency = 200usize;
    let sleep_ms = 800u64;

    let mut joins = Vec::with_capacity(concurrency);
    for _ in 0..concurrency {
        let url = format!("{}/v1/sleep?ms={}", api_base, sleep_ms);
        let c = client.clone();
        joins.push(tokio::spawn(async move {
            let _ = c.get(url).send().await;
        }));
    }

    // 3) Poll /readyz until it flips to 503 or timeout
    let deadline = tokio::time::Instant::now() + Duration::from_secs(10);
    let mut degraded = false;
    while tokio::time::Instant::now() < deadline {
        let code = client
            .get(format!("{}/readyz", api_base))
            .send()
            .await?
            .status();
        if code.as_u16() == 503 {
            degraded = true;
            break;
        }
        sleep(Duration::from_millis(200)).await;
    }
    assert!(degraded, "expected /readyz to degrade to 503 under load");

    // 4) During hold, /readyz should remain 503
    let code_hold = client
        .get(format!("{}/readyz", api_base))
        .send()
        .await?
        .status();
    assert_eq!(code_hold.as_u16(), 503, "expected hold window to stick");

    // 5) Wait hold_for_secs + cushion and expect recovery to 200
    sleep(Duration::from_secs(7)).await;
    let code_recover = client
        .get(format!("{}/readyz", api_base))
        .send()
        .await?
        .status();
    assert!(
        code_recover.is_success(),
        "expected /readyz to recover to 200"
    );

    // Optional: sample metrics once to ensure exporter is alive
    let _ = client.get(format!("{}/metrics", ops_base)).send().await?;

    // Ensure sleepers finish
    for j in joins {
        let _ = j.await;
    }

    Ok(())
}

```

### crates/omnigate/tests/ready_truth.rs
<a id="crates-omnigate-tests-readytruth-rs"></a>

```rust
use std::io::{Read, Write};
use std::net::TcpStream;
use std::path::PathBuf;
use std::time::Duration;

use omnigate::{bootstrap::server, config::Config};

fn http_get_status(addr: &str, path: &str) -> Option<u16> {
    let mut stream = TcpStream::connect(addr).ok()?;
    stream
        .set_read_timeout(Some(Duration::from_millis(800)))
        .ok()?;
    let req = format!(
        "GET {} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n",
        path, addr
    );
    stream.write_all(req.as_bytes()).ok()?;

    let mut buf = Vec::with_capacity(4096);
    stream.read_to_end(&mut buf).ok()?;
    let text = String::from_utf8_lossy(&buf);
    if let Some(status_line) = text.lines().next() {
        let parts: Vec<_> = status_line.split_whitespace().collect();
        if parts.len() >= 2 {
            return parts[1].parse::<u16>().ok();
        }
    }
    None
}

#[tokio::test(flavor = "multi_thread")]
async fn ready_flips_with_config() {
    // Build an absolute path to configs/omnigate.toml relative to THIS crate.
    let cfg_path: PathBuf = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("configs")
        .join("omnigate.toml");

    let cfg = Config::from_toml_file(cfg_path.to_string_lossy().as_ref()).expect("load config");

    // Build the app (admin plane + readiness config gate flip happens in lib.rs).
    let app = omnigate::App::build(cfg.clone()).await.expect("build app");

    // Start the API server; keep the JoinHandle alive for the test lifetime.
    let server_cfg = cfg.server; // move once
    let api_addr = server_cfg.bind;
    let (_task, _bound) = server::serve(server_cfg, app.router).await.expect("serve");

    // Probe /healthz until it is up.
    let api = api_addr.to_string();
    let mut ok = false;
    for _ in 0..100 {
        if let Some(code) = http_get_status(&api, "/healthz") {
            if code == 200 {
                ok = true;
                break;
            }
        }
        tokio::time::sleep(Duration::from_millis(50)).await;
    }
    assert!(ok, "healthz did not come up on {}", api);

    // Truthful readiness should be 200 after config gate flips.
    let mut ready_ok = false;
    for _ in 0..100 {
        if let Some(code) = http_get_status(&api, "/readyz") {
            if code == 200 {
                ready_ok = true;
                break;
            }
        }
        tokio::time::sleep(Duration::from_millis(50)).await;
    }
    assert!(ready_ok, "readyz did not return 200");
}

```

### crates/omnigate/tests/readyz_overload.rs
<a id="crates-omnigate-tests-readyzoverload-rs"></a>

```rust


```

### crates/omnigate/tests/zk_read_only.rs
<a id="crates-omnigate-tests-zkreadonly-rs"></a>

```rust


```

### crates/omnigate/tests/zk_receipts.rs
<a id="crates-omnigate-tests-zkreceipts-rs"></a>

```rust
use omnigate::zk::{OpClass, OpGuard, Receipt, ReceiptStatus};

#[test]
fn receipt_status_transitions_update_time() {
    let mut r = Receipt::new("r1".into());
    let t0 = r.last_update_ms;
    r.set_status(ReceiptStatus::Processing);
    assert!(r.last_update_ms >= t0);
    let t1 = r.last_update_ms;
    r.set_status(ReceiptStatus::Completed);
    assert!(r.last_update_ms >= t1);
}

#[test]
fn opguard_marks_class() {
    let g = OpGuard::new(OpClass::ReadOnly);
    assert_eq!(g.class(), OpClass::ReadOnly);
    let g2 = OpGuard::new(OpClass::Mutate);
    assert_eq!(g2.class(), OpClass::Mutate);
}

```

