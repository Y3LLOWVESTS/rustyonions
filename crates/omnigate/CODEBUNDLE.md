<!-- Generated by scripts/make_crate_codex.sh on 2025-11-01T01:51:40Z -->
# Code Bundle — `omnigate`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/omnigate/.cargo/config.toml](#crates-omnigate--cargo-config-toml)
- [crates/omnigate/.github/workflows/chaos.yml](#crates-omnigate--github-workflows-chaos-yml)
- [crates/omnigate/.github/workflows/ci.yml](#crates-omnigate--github-workflows-ci-yml)
- [crates/omnigate/.github/workflows/perf-regression.yml](#crates-omnigate--github-workflows-perf-regression-yml)
- [crates/omnigate/.github/workflows/public-api.yml](#crates-omnigate--github-workflows-public-api-yml)
- [crates/omnigate/.github/workflows/render-mermaid.yml](#crates-omnigate--github-workflows-render-mermaid-yml)
- [crates/omnigate/Cargo.toml](#crates-omnigate-Cargo-toml)
- [crates/omnigate/benches/hydration.rs](#crates-omnigate-benches-hydration-rs)
- [crates/omnigate/benches/media_range.rs](#crates-omnigate-benches-mediarange-rs)
- [crates/omnigate/benches/middleware_ping.rs](#crates-omnigate-benches-middlewareping-rs)
- [crates/omnigate/build.rs](#crates-omnigate-build-rs)
- [crates/omnigate/configs/omnigate.toml](#crates-omnigate-configs-omnigate-toml)
- [crates/omnigate/configs/policy.bundle.json](#crates-omnigate-configs-policy-bundle-json)
- [crates/omnigate/configs/staging.toml](#crates-omnigate-configs-staging-toml)
- [crates/omnigate/deny.toml](#crates-omnigate-deny-toml)
- [crates/omnigate/fuzz/Cargo.toml](#crates-omnigate-fuzz-Cargo-toml)
- [crates/omnigate/fuzz/fuzz_targets/capability.rs](#crates-omnigate-fuzz-fuzztargets-capability-rs)
- [crates/omnigate/fuzz/fuzz_targets/decompress_guard.rs](#crates-omnigate-fuzz-fuzztargets-decompressguard-rs)
- [crates/omnigate/fuzz/fuzz_targets/headers.rs](#crates-omnigate-fuzz-fuzztargets-headers-rs)
- [crates/omnigate/rust-toolchain.toml](#crates-omnigate-rust-toolchain-toml)
- [crates/omnigate/scripts/check_boundary.sh](#crates-omnigate-scripts-checkboundary-sh)
- [crates/omnigate/scripts/ci_metrics_guard.sh](#crates-omnigate-scripts-cimetricsguard-sh)
- [crates/omnigate/scripts/hnDL_sim.sh](#crates-omnigate-scripts-hnDLsim-sh)
- [crates/omnigate/scripts/inject_faults.sh](#crates-omnigate-scripts-injectfaults-sh)
- [crates/omnigate/scripts/render_mermaid.sh](#crates-omnigate-scripts-rendermermaid-sh)
- [crates/omnigate/scripts/sanity_omnigate.sh](#crates-omnigate-scripts-sanityomnigate-sh)
- [crates/omnigate/scripts/smoke_omnigate.sh](#crates-omnigate-scripts-smokeomnigate-sh)
- [crates/omnigate/scripts/soak.sh](#crates-omnigate-scripts-soak-sh)
- [crates/omnigate/src/admission/fair_queue.rs](#crates-omnigate-src-admission-fairqueue-rs)
- [crates/omnigate/src/admission/mod.rs](#crates-omnigate-src-admission-mod-rs)
- [crates/omnigate/src/admission/quotas.rs](#crates-omnigate-src-admission-quotas-rs)
- [crates/omnigate/src/auth/capability.rs](#crates-omnigate-src-auth-capability-rs)
- [crates/omnigate/src/auth/mod.rs](#crates-omnigate-src-auth-mod-rs)
- [crates/omnigate/src/auth/passport_client.rs](#crates-omnigate-src-auth-passportclient-rs)
- [crates/omnigate/src/auth/revocation.rs](#crates-omnigate-src-auth-revocation-rs)
- [crates/omnigate/src/bootstrap/health_probe.rs](#crates-omnigate-src-bootstrap-healthprobe-rs)
- [crates/omnigate/src/bootstrap/metrics_server.rs](#crates-omnigate-src-bootstrap-metricsserver-rs)
- [crates/omnigate/src/bootstrap/mod.rs](#crates-omnigate-src-bootstrap-mod-rs)
- [crates/omnigate/src/bootstrap/server.rs](#crates-omnigate-src-bootstrap-server-rs)
- [crates/omnigate/src/config/env.rs](#crates-omnigate-src-config-env-rs)
- [crates/omnigate/src/config/file.rs](#crates-omnigate-src-config-file-rs)
- [crates/omnigate/src/config/mod.rs](#crates-omnigate-src-config-mod-rs)
- [crates/omnigate/src/config/reload.rs](#crates-omnigate-src-config-reload-rs)
- [crates/omnigate/src/config/validate.rs](#crates-omnigate-src-config-validate-rs)
- [crates/omnigate/src/downstream/dht_client.rs](#crates-omnigate-src-downstream-dhtclient-rs)
- [crates/omnigate/src/downstream/error.rs](#crates-omnigate-src-downstream-error-rs)
- [crates/omnigate/src/downstream/hedge.rs](#crates-omnigate-src-downstream-hedge-rs)
- [crates/omnigate/src/downstream/index_client.rs](#crates-omnigate-src-downstream-indexclient-rs)
- [crates/omnigate/src/downstream/latency.rs](#crates-omnigate-src-downstream-latency-rs)
- [crates/omnigate/src/downstream/mailbox_client.rs](#crates-omnigate-src-downstream-mailboxclient-rs)
- [crates/omnigate/src/downstream/mod.rs](#crates-omnigate-src-downstream-mod-rs)
- [crates/omnigate/src/downstream/registry.rs](#crates-omnigate-src-downstream-registry-rs)
- [crates/omnigate/src/downstream/retry.rs](#crates-omnigate-src-downstream-retry-rs)
- [crates/omnigate/src/downstream/storage_client.rs](#crates-omnigate-src-downstream-storageclient-rs)
- [crates/omnigate/src/downstream/types.rs](#crates-omnigate-src-downstream-types-rs)
- [crates/omnigate/src/errors/http_map.rs](#crates-omnigate-src-errors-httpmap-rs)
- [crates/omnigate/src/errors/mod.rs](#crates-omnigate-src-errors-mod-rs)
- [crates/omnigate/src/errors/reasons.rs](#crates-omnigate-src-errors-reasons-rs)
- [crates/omnigate/src/hydration/compose.rs](#crates-omnigate-src-hydration-compose-rs)
- [crates/omnigate/src/hydration/mod.rs](#crates-omnigate-src-hydration-mod-rs)
- [crates/omnigate/src/hydration/planner.rs](#crates-omnigate-src-hydration-planner-rs)
- [crates/omnigate/src/lib.rs](#crates-omnigate-src-lib-rs)
- [crates/omnigate/src/main.rs](#crates-omnigate-src-main-rs)
- [crates/omnigate/src/metrics/gates.rs](#crates-omnigate-src-metrics-gates-rs)
- [crates/omnigate/src/metrics/mod.rs](#crates-omnigate-src-metrics-mod-rs)
- [crates/omnigate/src/metrics/registry.rs](#crates-omnigate-src-metrics-registry-rs)
- [crates/omnigate/src/middleware/body_caps.rs](#crates-omnigate-src-middleware-bodycaps-rs)
- [crates/omnigate/src/middleware/classify.rs](#crates-omnigate-src-middleware-classify-rs)
- [crates/omnigate/src/middleware/corr_id.rs](#crates-omnigate-src-middleware-corrid-rs)
- [crates/omnigate/src/middleware/decompress_guard.rs](#crates-omnigate-src-middleware-decompressguard-rs)
- [crates/omnigate/src/middleware/mod.rs](#crates-omnigate-src-middleware-mod-rs)
- [crates/omnigate/src/middleware/policy.rs](#crates-omnigate-src-middleware-policy-rs)
- [crates/omnigate/src/middleware/slow_loris.rs](#crates-omnigate-src-middleware-slowloris-rs)
- [crates/omnigate/src/observability/logging.rs](#crates-omnigate-src-observability-logging-rs)
- [crates/omnigate/src/observability/mod.rs](#crates-omnigate-src-observability-mod-rs)
- [crates/omnigate/src/observability/tracing_spans.rs](#crates-omnigate-src-observability-tracingspans-rs)
- [crates/omnigate/src/pq/mod.rs](#crates-omnigate-src-pq-mod-rs)
- [crates/omnigate/src/pq/negotiate.rs](#crates-omnigate-src-pq-negotiate-rs)
- [crates/omnigate/src/readiness/keys.rs](#crates-omnigate-src-readiness-keys-rs)
- [crates/omnigate/src/readiness/mod.rs](#crates-omnigate-src-readiness-mod-rs)
- [crates/omnigate/src/readiness/policy.rs](#crates-omnigate-src-readiness-policy-rs)
- [crates/omnigate/src/routes/mod.rs](#crates-omnigate-src-routes-mod-rs)
- [crates/omnigate/src/routes/ops.rs](#crates-omnigate-src-routes-ops-rs)
- [crates/omnigate/src/routes/v1/dht.rs](#crates-omnigate-src-routes-v1-dht-rs)
- [crates/omnigate/src/routes/v1/facet/feed.rs](#crates-omnigate-src-routes-v1-facet-feed-rs)
- [crates/omnigate/src/routes/v1/facet/graph.rs](#crates-omnigate-src-routes-v1-facet-graph-rs)
- [crates/omnigate/src/routes/v1/facet/media.rs](#crates-omnigate-src-routes-v1-facet-media-rs)
- [crates/omnigate/src/routes/v1/facet/mod.rs](#crates-omnigate-src-routes-v1-facet-mod-rs)
- [crates/omnigate/src/routes/v1/index.rs](#crates-omnigate-src-routes-v1-index-rs)
- [crates/omnigate/src/routes/v1/mailbox.rs](#crates-omnigate-src-routes-v1-mailbox-rs)
- [crates/omnigate/src/routes/v1/mod.rs](#crates-omnigate-src-routes-v1-mod-rs)
- [crates/omnigate/src/routes/v1/objects.rs](#crates-omnigate-src-routes-v1-objects-rs)
- [crates/omnigate/src/runtime/channels.rs](#crates-omnigate-src-runtime-channels-rs)
- [crates/omnigate/src/runtime/mod.rs](#crates-omnigate-src-runtime-mod-rs)
- [crates/omnigate/src/runtime/sample.rs](#crates-omnigate-src-runtime-sample-rs)
- [crates/omnigate/src/runtime/shutdown.rs](#crates-omnigate-src-runtime-shutdown-rs)
- [crates/omnigate/src/runtime/supervisor.rs](#crates-omnigate-src-runtime-supervisor-rs)
- [crates/omnigate/src/runtime/worker.rs](#crates-omnigate-src-runtime-worker-rs)
- [crates/omnigate/src/state.rs](#crates-omnigate-src-state-rs)
- [crates/omnigate/src/types/dto.rs](#crates-omnigate-src-types-dto-rs)
- [crates/omnigate/src/types/mod.rs](#crates-omnigate-src-types-mod-rs)
- [crates/omnigate/src/zk/mod.rs](#crates-omnigate-src-zk-mod-rs)
- [crates/omnigate/src/zk/no_mutate.rs](#crates-omnigate-src-zk-nomutate-rs)
- [crates/omnigate/src/zk/receipts.rs](#crates-omnigate-src-zk-receipts-rs)
- [crates/omnigate/testing/chaos/scenario.yml](#crates-omnigate-testing-chaos-scenario-yml)
- [crates/omnigate/testing/performance/baselines/p95_hydration.json](#crates-omnigate-testing-performance-baselines-p95hydration-json)
- [crates/omnigate/testing/performance/baselines/p95_range.json](#crates-omnigate-testing-performance-baselines-p95range-json)
- [crates/omnigate/testing/performance/hydrate_mix.sh](#crates-omnigate-testing-performance-hydratemix-sh)
- [crates/omnigate/testing/vectors/omnigate/error_413.json](#crates-omnigate-testing-vectors-omnigate-error413-json)
- [crates/omnigate/testing/vectors/omnigate/range_read.json](#crates-omnigate-testing-vectors-omnigate-rangeread-json)
- [crates/omnigate/testing/vectors/omnigate/unauth_401.json](#crates-omnigate-testing-vectors-omnigate-unauth401-json)
- [crates/omnigate/tests/admission_contract.rs](#crates-omnigate-tests-admissioncontract-rs)
- [crates/omnigate/tests/dto_serialization.rs](#crates-omnigate-tests-dtoserialization-rs)
- [crates/omnigate/tests/hardening.rs](#crates-omnigate-tests-hardening-rs)
- [crates/omnigate/tests/interop_vectors.rs](#crates-omnigate-tests-interopvectors-rs)
- [crates/omnigate/tests/loom_fanout.rs](#crates-omnigate-tests-loomfanout-rs)
- [crates/omnigate/tests/metrics_contract.rs](#crates-omnigate-tests-metricscontract-rs)
- [crates/omnigate/tests/middleware_contract.rs](#crates-omnigate-tests-middlewarecontract-rs)
- [crates/omnigate/tests/oap_limits.rs](#crates-omnigate-tests-oaplimits-rs)
- [crates/omnigate/tests/policy_gate.rs](#crates-omnigate-tests-policygate-rs)
- [crates/omnigate/tests/ready_truth.rs](#crates-omnigate-tests-readytruth-rs)
- [crates/omnigate/tests/readyz_overload.rs](#crates-omnigate-tests-readyzoverload-rs)
- [crates/omnigate/tests/zk_read_only.rs](#crates-omnigate-tests-zkreadonly-rs)
- [crates/omnigate/tests/zk_receipts.rs](#crates-omnigate-tests-zkreceipts-rs)

### crates/omnigate/.cargo/config.toml
<a id="crates-omnigate--cargo-config-toml"></a>

```toml
[build]
rustflags = []

[term]
verbose = false

```

### crates/omnigate/.github/workflows/chaos.yml
<a id="crates-omnigate--github-workflows-chaos-yml"></a>

```yaml
name: chaos
on:
  schedule:
    - cron: "0 3 * * 0"
jobs:
  soak:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Chaos/soak scaffold."

```

### crates/omnigate/.github/workflows/ci.yml
<a id="crates-omnigate--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [x86_64, aarch64]
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: echo "Scaffold CI placeholder."

```

### crates/omnigate/.github/workflows/perf-regression.yml
<a id="crates-omnigate--github-workflows-perf-regression-yml"></a>

```yaml
name: perf-regression
on:
  workflow_dispatch:
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Perf regression scaffold."

```

### crates/omnigate/.github/workflows/public-api.yml
<a id="crates-omnigate--github-workflows-public-api-yml"></a>

```yaml
name: public-api
on: [pull_request]
jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Public API guard scaffold."

```

### crates/omnigate/.github/workflows/render-mermaid.yml
<a id="crates-omnigate--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Render mermaid placeholder."

```

### crates/omnigate/Cargo.toml
<a id="crates-omnigate-Cargo-toml"></a>

```toml
[package]
name = "omnigate"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false
build = "build.rs"


[lib]
name = "omnigate"
path = "src/lib.rs"

[[bin]]
name = "omnigate"
path = "src/main.rs"

# Criterion uses its own harness
[[bench]]
name = "middleware_ping"
harness = false

[features]
default = []
arti = []

[dependencies]
# RON workspace crates
ron-kernel = { path = "../ron-kernel" }
ron-proto  = { path = "../ron-proto" }
oap        = { path = "../oap" }
ron-policy = { path = "../ron-policy" }     # used by PolicyLayer integration
tokio-util = "0.7"

# Async/HTTP stack (workspace pins implied)
tokio = { version = "1", features = ["macros", "rt-multi-thread", "signal", "time", "io-util", "sync", "net", "fs"] }
axum = { version = "0.7", default-features = false, features = ["tokio", "http1", "http2", "json"] }
tower = "0.5"
tower-http = { version = "0.6.6", features = ["trace"] }
http = "1"

# Outbound HTTP (downstream clients)
reqwest = { version = "0.12", features = ["rustls-tls-native-roots", "json"] }

# Observability
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus = "0.14"

# Config & serde
serde = { version = "1.0", features = ["derive"] }
serde_json = "1"
toml = "0.8"
humantime-serde = "1"

# Misc
thiserror = "1"
anyhow = "1"
bytes = "1"
once_cell = "1.19"
parking_lot = "0.12"
futures = "0.3"
futures-util = "0.3"          # needed for futures_util::... used in PolicyLayer
rand = "0.9"                  # downstream retry/jitter (matches workspace pin)
tokio-rustls = "0.26.2"       # TLS (keep using tokio_rustls::rustls types)

[dev-dependencies]
criterion = { version = "0.5.1", features = ["async_tokio"] }
tokio = { version = "1", features = ["rt", "macros"] }
regex = "1"


```

### crates/omnigate/benches/hydration.rs
<a id="crates-omnigate-benches-hydration-rs"></a>

```rust


```

### crates/omnigate/benches/media_range.rs
<a id="crates-omnigate-benches-mediarange-rs"></a>

```rust


```

### crates/omnigate/benches/middleware_ping.rs
<a id="crates-omnigate-benches-middlewareping-rs"></a>

```rust
//! Bench the omnigate middleware stack end-to-end (in-process, no sockets).
//! Build an axum Router, apply `omnigate::middleware::apply`, then
//! issue GET /ping requests and measure total round-trip time.
//!
//! Run: `cargo bench -p omnigate --bench middleware_ping`

use std::time::Duration;

use axum::{
    body::{self, Body},
    http::{Request, StatusCode},
    routing::get,
    Router,
};
use criterion::{black_box, criterion_group, criterion_main, BatchSize, Criterion, Throughput};
use tower::ServiceExt; // for .oneshot()

fn build_router() -> Router {
    let api = Router::new().route("/ping", get(|| async { "pong" }));
    omnigate::middleware::apply(api)
}

/// Issue a single in-process GET /ping and return (status, body_len).
async fn hit_ping(router: &Router) -> (StatusCode, usize) {
    let req = Request::builder()
        .method("GET")
        .uri("/ping")
        .body(Body::empty())
        .expect("request");

    let resp = router.clone().oneshot(req).await.expect("response");
    let status = resp.status();

    // axum 0.7: to_bytes requires an explicit limit
    let bytes = body::to_bytes(resp.into_body(), usize::MAX)
        .await
        .expect("to_bytes");

    (status, bytes.len())
}

fn bench_middleware_ping(c: &mut Criterion) {
    // Build router once; cloned per-req by ServiceExt::oneshot
    let router = build_router();

    // Current-thread Tokio runtime (cheap to drive short async ops)
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .expect("tokio rt");

    let mut group = c.benchmark_group("omnigate/middleware_ping");
    group.warm_up_time(Duration::from_millis(500));
    group.measurement_time(Duration::from_secs(8));
    group.sample_size(40);
    group.throughput(Throughput::Elements(1));

    group.bench_function("GET /ping (in-process)", |b| {
        b.iter_batched(
            || router.clone(),
            |svc| {
                rt.block_on(async move {
                    let (status, len) = hit_ping(&svc).await;
                    assert_eq!(status, StatusCode::OK);
                    black_box(len);
                });
            },
            BatchSize::SmallInput,
        );
    });

    group.finish();
}

criterion_group!(benches, bench_middleware_ping);
criterion_main!(benches);

```

### crates/omnigate/build.rs
<a id="crates-omnigate-build-rs"></a>

```rust
// Build script to embed a short Git commit into the binary as GIT_COMMIT_SHORT.
// Falls back cleanly if `git` is unavailable (e.g., shallow CI clones).

use std::process::Command;

fn main() {
    // Re-run if HEAD moves.
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs/");

    let short = Command::new("git")
        .args(["rev-parse", "--short=9", "HEAD"])
        .output()
        .ok()
        .and_then(|o| o.status.success().then_some(o))
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .map(|s| s.trim().to_string());

    if let Some(s) = short {
        println!("cargo:rustc-env=GIT_COMMIT_SHORT={}", s);
    }
}

```

### crates/omnigate/configs/omnigate.toml
<a id="crates-omnigate-configs-omnigate-toml"></a>

```toml
# omnigate — default config (Beta)

[server]
bind              = "127.0.0.1:5305"
metrics_addr      = "127.0.0.1:9605"
amnesia           = true

[oap]
max_frame_bytes    = 1048576
stream_chunk_bytes = 65536

[admission.global_quota]
qps    = 20000
burst  = 40000

[admission.ip_quota]
enabled = true
qps     = 2000
burst   = 4000
# buckets = [ { cidr="10.0.0.0/8", qps=5000, burst=10000 } ]

[admission.fair_queue]
max_inflight = 2048
weights = { anon = 1, auth = 5, admin = 10 }

[admission.body]
max_content_length       = 10485760
reject_on_missing_length = true

[admission.decompression]
allow        = ["identity", "gzip"]
deny_stacked = true

[policy]
enabled     = true
bundle_path = "crates/omnigate/configs/policy.bundle.json"
fail_mode   = "deny"  # "deny" | "allow"

[readiness]
max_inflight_threshold = 1800
error_rate_429_503_pct = 2.0
window_secs            = 10
hold_for_secs          = 30

```

### crates/omnigate/configs/policy.bundle.json
<a id="crates-omnigate-configs-policy-bundle-json"></a>

```json
{
  "meta": {
    "name": "allow-all (dev)",
    "version": 1
  },
  "rules": [
    { "when": { "any": true }, "allow": true }
  ]
}

```

### crates/omnigate/configs/staging.toml
<a id="crates-omnigate-configs-staging-toml"></a>

```toml

```

### crates/omnigate/deny.toml
<a id="crates-omnigate-deny-toml"></a>

```toml
[advisories]
yanked = "deny"
unmaintained = "deny"
vulnerability = "deny"

[licenses]
allow = ["MIT", "Apache-2.0"]

```

### crates/omnigate/fuzz/Cargo.toml
<a id="crates-omnigate-fuzz-Cargo-toml"></a>

```toml
[package]
name = "omnigate2-fuzz"
version = "0.0.0"
edition = "2021"
publish = false

[package.metadata]
cargo-fuzz = true

```

### crates/omnigate/fuzz/fuzz_targets/capability.rs
<a id="crates-omnigate-fuzz-fuzztargets-capability-rs"></a>

```rust

```

### crates/omnigate/fuzz/fuzz_targets/decompress_guard.rs
<a id="crates-omnigate-fuzz-fuzztargets-decompressguard-rs"></a>

```rust

```

### crates/omnigate/fuzz/fuzz_targets/headers.rs
<a id="crates-omnigate-fuzz-fuzztargets-headers-rs"></a>

```rust

```

### crates/omnigate/rust-toolchain.toml
<a id="crates-omnigate-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt","clippy"]

```

### crates/omnigate/scripts/check_boundary.sh
<a id="crates-omnigate-scripts-checkboundary-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: add grep/lints for forbidden deps and patterns.

```

### crates/omnigate/scripts/ci_metrics_guard.sh
<a id="crates-omnigate-scripts-cimetricsguard-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: scrape /metrics and assert label/name contracts.

```

### crates/omnigate/scripts/hnDL_sim.sh
<a id="crates-omnigate-scripts-hnDLsim-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: Harvest-now-decrypt-later drill placeholder.

```

### crates/omnigate/scripts/inject_faults.sh
<a id="crates-omnigate-scripts-injectfaults-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: locally simulate latency/errors.

```

### crates/omnigate/scripts/render_mermaid.sh
<a id="crates-omnigate-scripts-rendermermaid-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: render docs/mermaid/*.mmd to SVGs.

```

### crates/omnigate/scripts/sanity_omnigate.sh
<a id="crates-omnigate-scripts-sanityomnigate-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

API_ADDR="${API_ADDR:-127.0.0.1:5305}"
METRICS_ADDR="${METRICS_ADDR:-127.0.0.1:9605}"
BIN_PKG="omnigate"
RUST_LOG_LEVEL="${RUST_LOG_LEVEL:-info}"
TRACE_LOG_COMPONENT="${TRACE_LOG_COMPONENT:-omnigate=trace}"
CARGO="${CARGO:-cargo}"
CONFIG_PATH="${CONFIG_PATH:-}"              # optional: path to omnigate.toml
SKIP_NET_BURST="${SKIP_NET_BURST:-0}"       # set to 1 to skip the 429 burst check

req()  { printf "[sanity] %s\n" "$*"; }
fail() { printf "[sanity][FAIL] %s\n" "$*" >&2; exit 1; }

need() { command -v "$1" >/dev/null 2>&1 || fail "missing required tool: $1"; }

# --- prerequisites ---
need curl; need awk; need jq; need dd

# --- helpers ---
CHILD_PID=""
stop_child() {
  if [[ -n "${CHILD_PID:-}" ]] && kill -0 "$CHILD_PID" 2>/dev/null; then
    # Try graceful first, then a hard kill if needed
    kill "$CHILD_PID" 2>/dev/null || true
    sleep 0.2
    kill -0 "$CHILD_PID" 2>/dev/null && kill -9 "$CHILD_PID" 2>/dev/null || true
    wait "$CHILD_PID" 2>/dev/null || true
    CHILD_PID=""
  fi
}
trap stop_child EXIT

http_code() {
  local url="$1"
  curl -s -o /dev/null -w "%{http_code}" "$url"
}

wait_200() {
  local url="$1" tries="${2:-80}" delay="${3:-0.125}"
  for ((i=1;i<=tries;i++)); do
    local code; code="$(http_code "$url" || true)"
    [[ "$code" == "200" ]] && return 0
    sleep "$delay"
  done
  return 1
}

assert_http_200() {
  local url="$1"
  local code; code="$(http_code "$url" || true)"
  [[ "$code" == "200" ]] || fail "expected 200: $url (got $code)"
}

assert_json_true() {
  local url="$1" key="$2"
  local val; val="$(curl -s "$url" | jq -r ".${key}")"
  [[ "$val" == "true" ]] || fail "expected ${key}=true at $url (got $val)"
}

metric_value() {
  local metric="$1"
  # Grab the first *unlabeled* sample line:  "<name> <value>"
  curl -s "http://${METRICS_ADDR}/metrics" \
    | awk -v m="$metric" '$1==m{print $2; exit}'
}

assert_metric_eq() {
  local metric="$1" expect="$2"
  local val; val="$(metric_value "$metric")"
  [[ "${val:-}" == "$expect" ]] || fail "metric $metric expected $expect got ${val:-<missing>}"
}

print_metric() {
  local metric="$1"
  curl -s "http://${METRICS_ADDR}/metrics" | awk -v m="$metric" '$1==m{print}'
}

# --- build & tests ---
req "fmt + clippy + build"
$CARGO fmt -p "$BIN_PKG"
$CARGO clippy -p "$BIN_PKG" --no-deps -- -D warnings
$CARGO build -p "$BIN_PKG"

req "unit/integration tests"
$CARGO test -p "$BIN_PKG" --test dto_serialization --test ready_truth --test zk_receipts

# --- run helper ---
run_omnigate() {
  local dev_ready="$1" # 0 or 1
  stop_child
  req "starting omnigate (OMNIGATE_DEV_READY=${dev_ready})"
  if [[ -n "$CONFIG_PATH" ]]; then
    req "using --config $CONFIG_PATH"
  fi

  OMNIGATE_DEV_READY="$dev_ready" \
  RUST_LOG="${RUST_LOG_LEVEL},${TRACE_LOG_COMPONENT}" \
  $CARGO run -p "$BIN_PKG" --quiet -- ${CONFIG_PATH:+--config "$CONFIG_PATH"} &

  CHILD_PID=$!

  req "waiting for /healthz 200"
  wait_200 "http://${API_ADDR}/healthz" || fail "healthz did not become 200"

  req "waiting for /readyz 200"
  wait_200 "http://${API_ADDR}/readyz" || fail "readyz did not become 200"

  req "waiting for /metrics 200"
  wait_200 "http://${METRICS_ADDR}/metrics" || req "WARN: metrics endpoint not yet 200 (continuing best-effort)"
}

# --- Phase A: DEV override ON ---
run_omnigate 1

req "check admin plane & v1 routes"
assert_http_200 "http://${API_ADDR}/healthz"
assert_http_200 "http://${API_ADDR}/readyz"
assert_json_true "http://${API_ADDR}/v1/ping" "ok"

req "versionz contains version (git may be null)"
curl -s "http://${API_ADDR}/versionz" | jq -e '.version | length > 0' >/dev/null \
  || fail "/versionz missing 'version'"

req "metrics sanity (amnesia_mode should reflect cfg if wired)"
# If wired as in main.rs, this reflects cfg.server.amnesia (1 if true, else 0).
amnesia_val="$(metric_value amnesia_mode || true)"
if [[ -n "${amnesia_val:-}" ]]; then
  req "amnesia_mode=${amnesia_val}"
  # If your default config sets amnesia=true, expect 1:
  if [[ "${amnesia_val}" != "1" ]]; then
    req "WARN: amnesia_mode is ${amnesia_val} (expected 1 if cfg.server.amnesia=true)"
  fi
else
  req "NOTE: amnesia_mode not exported yet (gauge may be missing or metrics not up)"
fi

stop_child

# --- Phase B: DEV override OFF (real gates) ---
run_omnigate 0

req "assert readyz payload is true"
assert_json_true "http://${API_ADDR}/readyz" "ready"

req "gate gauges (best-effort if present)"
for m in listeners_bound metrics_bound cfg_loaded ready_state; do
  val="$(metric_value "$m" || true)"
  if [[ -n "$val" && "$val" != "1" ]]; then
    req "WARN: $m present but not 1 (got $val)"
  fi
done

# --- Fair queue cap header check ---
req "fair queue cap header exposes different caps for priorities"
curl -s -i -H 'x-omnigate-priority: interactive' "http://${API_ADDR}/v1/ping" \
  | awk 'BEGIN{IGNORECASE=1}/^x-omnigate-cap:/{print}'
curl -s -i -H 'x-omnigate-priority: bulk'        "http://${API_ADDR}/v1/ping" \
  | awk 'BEGIN{IGNORECASE=1}/^x-omnigate-cap:/{print}'

# --- Global quota burst to try for 429s ---
if [[ "$SKIP_NET_BURST" != "1" ]]; then
  req "burst load to trigger some 429 (best-effort)"
  if command -v xargs >/dev/null 2>&1; then
    seq 1 1200 | xargs -n1 -P64 -I{} curl -s -o /dev/null -w "%{http_code}\n" \
      "http://${API_ADDR}/v1/ping" | sort | uniq -c || true
  else
    req "WARN: xargs not available; skipping burst"
  fi
else
  req "SKIP_NET_BURST=1 — skipping the 429 burst check"
fi

req "check quota exhaust counter (if burst produced 429s)"
print_metric admission_quota_exhausted_total || req "NOTE: admission_quota_exhausted_total not present yet"

# --- Body caps: oversize -> 413 + counter ---
req "body caps oversize 413 + metric"
TMP_BIG="/tmp/omnigate_big.bin"
dd if=/dev/urandom of="$TMP_BIG" bs=1k count=1100 status=none
code="$(curl -s -o /dev/null -w "%{http_code}" -X POST --data-binary @"$TMP_BIG" "http://${API_ADDR}/v1/ping")"
if [[ "$code" != "413" ]]; then
  req "WARN: oversize POST did not return 413 (got $code) — verify route setup for POST on /v1/ping or test an endpoint that accepts body"
fi
print_metric body_reject_total || req "NOTE: body_reject_total not present yet"

# --- Decompression guard: unknown + stacked encodings ---
req "decompress guard rejects: unknown encoding"
code="$(curl -s -o /dev/null -w "%{http_code}" -H 'Content-Encoding: compress' -X POST --data 'abc' "http://${API_ADDR}/v1/ping")" || true
if [[ "$code" != "415" ]]; then
  req "WARN: unknown encoding did not return 415 (got $code) — ensure POST route is guarded by decompress layer"
fi

req "decompress guard rejects: stacked encodings"
code="$(curl -s -o /dev/null -w "%{http_code}" -H 'Content-Encoding: gzip, deflate' -X POST --data 'abc' "http://${API_ADDR}/v1/ping")" || true
if [[ "$code" != "415" ]]; then
  req "WARN: stacked encodings did not return 415 (got $code) — ensure POST route is guarded by decompress layer"
fi
print_metric decompress_reject_total || req "NOTE: decompress_reject_total not present yet"

# --- Ready trip/recover (best-effort) ---
req "ready trip metrics snapshot"
curl -s "http://${METRICS_ADDR}/metrics" | egrep 'ready_trips_total|ready_state_changes_total|ready_error_rate_pct|ready_inflight_current' || true

# Done
stop_child
req "OK — all sanity checks finished"

```

### crates/omnigate/scripts/smoke_omnigate.sh
<a id="crates-omnigate-scripts-smokeomnigate-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Colors
G="\033[0;32m"; Y="\033[1;33m"; R="\033[0;31m"; Z="\033[0m"

echo -e "${Y}fmt + clippy + build…${Z}"
cargo fmt -p omnigate
cargo clippy -p omnigate --no-deps -- -D warnings
cargo build -p omnigate

# Defaults (API=5305, ADMIN=9605)
API_ADDR="${API_ADDR:-127.0.0.1:5305}"
ADMIN_ADDR="${ADMIN_ADDR:-127.0.0.1:9605}"
LOG="/tmp/omnigate.log"

# REQUIRED: config path (can be overridden)
CONFIG_PATH="${OMNIGATE_CONFIG:-crates/omnigate/configs/omnigate.toml}"
if [ ! -f "${CONFIG_PATH}" ]; then
  echo -e "${R}❌ Config file not found at: ${CONFIG_PATH}${Z}"
  exit 1
fi
echo -e "${Y}using config: ${CONFIG_PATH}${Z}"

# Optional dev-readiness override
export OMNIGATE_DEV_READY="${OMNIGATE_DEV_READY:-}"

echo -e "${Y}starting omnigate at ${API_ADDR} (logs: ${LOG})…${Z}"
BIN="target/debug/omnigate"
# Pass --config so the readiness 'config' gate can flip
"${BIN}" --config "${CONFIG_PATH}" > "${LOG}" 2>&1 &
PID=$!

cleanup() {
  echo -e "${Y}stopping omnigate (pid=${PID})…${Z}"
  kill "${PID}" >/dev/null 2>&1 || true
  wait "${PID}" >/dev/null 2>&1 || true
}
trap cleanup EXIT

# Wait for /healthz on the API port
echo "waiting for /healthz…"
set +e
for i in {1..100}; do
  curl -sf "http://${API_ADDR}/healthz" >/dev/null && break
  sleep 0.1
done
set -e

echo "-- /healthz (API)"
curl -sf "http://${API_ADDR}/healthz"
echo

# Metrics are on the ADMIN plane
echo "-- /metrics (ADMIN)"
if ! curl -sf "http://${ADMIN_ADDR}/metrics" | head -n 20; then
  echo -e "${R}❌ /metrics not available on ${ADMIN_ADDR}. Check ${LOG}.${Z}"
  exit 1
fi

# Root / should 404
echo "-- / (API, expect 404)"
CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://${API_ADDR}/")
if [ "${CODE}" = "404" ]; then
  echo -e "✅ 404 ok"
else
  echo -e "${R}❌ expected 404, got ${CODE}${Z}"
  exit 1
fi

check_ready() {
  local path="$1"
  local status body
  status=$(curl -s -o /dev/null -w "%{http_code}" "http://${API_ADDR}${path}")
  body=$(curl -s "http://${API_ADDR}${path}" || true)
  echo "readyz status (${path} on API): ${status}"
  if [ "${status}" = "200" ]; then
    echo -e "${G}✅ ready (body: ${body})${Z}"
    return 0
  else
    echo -e "${Y}ℹ️ not ready (status ${status}, body: ${body})${Z}"
    # Show last 20 log lines to explain the gate
    echo -e "${Y}--- tail ${LOG} ---${Z}"
    tail -n 20 "${LOG}" || true
    echo -e "${Y}-------------------${Z}"
    return 1
  fi
}

echo "-- /readyz (API; truthful readiness)"
check_ready "/readyz" || true

echo "-- /ops/readyz (API alias)"
check_ready "/ops/readyz" || true

echo -e "${G}✅ smoke ok${Z}"

```

### crates/omnigate/scripts/soak.sh
<a id="crates-omnigate-scripts-soak-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: 24h soak runner placeholder.

```

### crates/omnigate/src/admission/fair_queue.rs
<a id="crates-omnigate-src-admission-fairqueue-rs"></a>

```rust
use std::sync::{
    atomic::{AtomicUsize, Ordering},
    Arc,
};

use axum::{
    body::Body,
    extract::State,
    http::{HeaderMap, HeaderName, HeaderValue, Request, StatusCode},
    middleware::{from_fn_with_state, Next},
    response::{IntoResponse, Response},
    Router,
};
use serde::Serialize;

const HEADER_PRIORITY: &str = "x-omnigate-priority";

#[derive(Clone)]
struct Gate {
    hard: usize,
    headroom: usize,
    in_flight: Arc<AtomicUsize>,
}

impl Gate {
    fn new(hard: usize, headroom: usize) -> Self {
        Self {
            hard,
            headroom,
            in_flight: Arc::new(AtomicUsize::new(0)),
        }
    }

    fn limit_for(&self, headers: &HeaderMap) -> usize {
        match headers
            .get(HEADER_PRIORITY)
            .and_then(|v| v.to_str().ok())
            .unwrap_or("bulk")
        {
            "interactive" => self.hard + self.headroom,
            _ => self.hard,
        }
    }

    fn try_enter(&self, headers: &HeaderMap) -> bool {
        let cap = self.limit_for(headers);
        loop {
            let cur = self.in_flight.load(Ordering::Relaxed);
            if cur >= cap {
                return false;
            }
            if self
                .in_flight
                .compare_exchange(cur, cur + 1, Ordering::AcqRel, Ordering::Relaxed)
                .is_ok()
            {
                return true;
            }
        }
    }

    fn leave(&self) {
        self.in_flight.fetch_sub(1, Ordering::AcqRel);
    }
}

#[derive(Serialize)]
struct ErrorBody<'a> {
    reason: &'a str,
    message: &'a str,
}

async fn fairness_guard(
    State(gate): State<Arc<Gate>>,
    req: Request<Body>,
    next: Next,
) -> Response {
    if gate.try_enter(req.headers()) {
        // We admitted this request; reflect "not saturated" best-effort.
        // (Authoritative gating still happens in ReadyPolicy; this keeps the gauge honest.)
        crate::metrics::gates::READY_QUEUE_SATURATED.set(0);

        // RAII guard to decrement in_flight when response completes.
        struct Guard(Arc<Gate>);
        impl Drop for Guard {
            fn drop(&mut self) {
                self.0.leave();
            }
        }
        let cap = gate.limit_for(req.headers());
        let _guard = Guard(gate.clone());

        let mut resp = next.run(req).await;
        let _ = resp.headers_mut().insert(
            HeaderName::from_static("x-omnigate-cap"),
            HeaderValue::from_str(&cap.to_string()).unwrap_or(HeaderValue::from_static("0")),
        );
        resp
    } else {
        // Shed: mark queue saturation and count a drop event.
        crate::metrics::gates::READY_QUEUE_SATURATED.set(1);
        crate::metrics::FAIR_Q_EVENTS_TOTAL
            .with_label_values(&["dropped"])
            .inc();

        (
            StatusCode::SERVICE_UNAVAILABLE,
            axum::Json(ErrorBody {
                reason: "overloaded",
                message: "server is shedding load; please retry",
            }),
        )
            .into_response()
    }
}

/// Attach the fair-queue guard as a middleware layer to the given Router.
/// Avoids generic `Layer` return types so Axum can infer everything cleanly.
pub fn attach<S>(router: Router<S>) -> Router<S>
where
    S: Clone + Send + 'static,
{
    let gate = Arc::new(Gate::new(256, 32));
    router.layer(from_fn_with_state(gate, fairness_guard))
}

```

### crates/omnigate/src/admission/mod.rs
<a id="crates-omnigate-src-admission-mod-rs"></a>

```rust
//! RO:WHAT
//! Admission (pre-routing) attach point.
//!
//! We’ll re-introduce fair-queue and quota layers here once they satisfy
//! Axum’s `Router::layer` bounds (Service<Request<Body>> + Clone + Send + 'static).
//!
//! For now this is a no-op shim to keep the crate compiling cleanly.

use axum::Router;

/// Attach admission layers to a router (currently no-op).
pub fn attach<S>(router: Router<S>) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    // TODO(admission): when `admission::fair_queue` and `admission::quotas`
    // are ready, do:
    //   router
    //     .layer(fair_queue::layer())
    //     .layer(quotas::layer())
    // For now, just return the router unchanged.
    router
}

```

### crates/omnigate/src/admission/quotas.rs
<a id="crates-omnigate-src-admission-quotas-rs"></a>

```rust
//! RO:WHAT  Global token-bucket admission guard that returns 429 when over limit.
//! RO:WHY   Prevents overload by bounding request rate upfront.
//! RO:INVARS Constant-time hot path; expose exhaust events via metrics.

use std::{
    sync::{Arc, Mutex},
    time::Instant,
};

use axum::{
    body::Body,
    extract::State,
    http::{Request, StatusCode},
    middleware::{from_fn_with_state, Next},
    response::{IntoResponse, Response},
    Router,
};
use serde::Serialize;

#[derive(Clone)]
struct GlobalLimiter {
    inner: Arc<Mutex<Bucket>>,
}

#[derive(Debug)]
struct Bucket {
    tokens: f64,
    last: Instant,
    rate_per_sec: f64,
    burst: f64,
}

impl GlobalLimiter {
    fn new(rate_per_sec: u32, burst: u32) -> Self {
        let now = Instant::now();
        Self {
            inner: Arc::new(Mutex::new(Bucket {
                tokens: burst as f64,
                last: now,
                rate_per_sec: rate_per_sec as f64,
                burst: burst as f64,
            })),
        }
    }

    #[inline]
    fn allow(&self) -> bool {
        let mut b = self.inner.lock().unwrap();
        let now = Instant::now();
        let elapsed = now.saturating_duration_since(b.last);
        b.last = now;

        let refill = elapsed.as_secs_f64() * b.rate_per_sec;
        b.tokens = (b.tokens + refill).min(b.burst);

        if b.tokens >= 1.0 {
            b.tokens -= 1.0;
            true
        } else {
            false
        }
    }
}

#[derive(Serialize)]
struct ErrorBody<'a> {
    reason: &'a str,
    message: &'a str,
}

async fn quota_guard(
    State(state): State<GlobalLimiter>,
    req: Request<Body>,
    next: Next,
) -> Response {
    if state.allow() {
        next.run(req).await
    } else {
        // Count quota exhausts for observability and readiness error-window calculations.
        // Metric defined in metrics module with label contract {scope = global|ip|token}.
        crate::metrics::ADMISSION_QUOTA_EXHAUSTED_TOTAL
            .with_label_values(&["global"])
            .inc();

        (
            StatusCode::TOO_MANY_REQUESTS,
            axum::Json(ErrorBody {
                reason: "too_many_requests",
                message: "request rate exceeds configured limit",
            }),
        )
            .into_response()
    }
}

/// Attach the quota limiter layer to the Router.
pub fn attach<S>(router: Router<S>) -> Router<S>
where
    S: Clone + Send + 'static,
{
    // TODO: drive from Config (admission.global_quota.{qps,burst}).
    let limiter = GlobalLimiter::new(500, 1000);
    router.layer(from_fn_with_state(limiter, quota_guard))
}

```

### crates/omnigate/src/auth/capability.rs
<a id="crates-omnigate-src-auth-capability-rs"></a>

```rust

```

### crates/omnigate/src/auth/mod.rs
<a id="crates-omnigate-src-auth-mod-rs"></a>

```rust

```

### crates/omnigate/src/auth/passport_client.rs
<a id="crates-omnigate-src-auth-passportclient-rs"></a>

```rust

```

### crates/omnigate/src/auth/revocation.rs
<a id="crates-omnigate-src-auth-revocation-rs"></a>

```rust

```

### crates/omnigate/src/bootstrap/health_probe.rs
<a id="crates-omnigate-src-bootstrap-healthprobe-rs"></a>

```rust
//! RO:WHAT — Helpers for health/readiness wiring (stubs for future use).
//! RO:WHY  — Keep separation of concerns; Concerns: RES/GOV.
//! RO:INTERACTS — ron_kernel::metrics::{health, readiness}.

pub struct HealthProbe; // future: gates for downstream client binding, queues_ok, etc.

```

### crates/omnigate/src/bootstrap/metrics_server.rs
<a id="crates-omnigate-src-bootstrap-metricsserver-rs"></a>

```rust
//! RO:WHAT — Placeholder to document metrics server behavior (served by ron-kernel Metrics).
//! RO:WHY  — Keep parity with TODO structure; Concerns: GOV/OBS.
//! RO:INTERACTS — ron_kernel::Metrics::serve() started in App::build().
//! RO:INVARIANTS — none here; admin plane lives in kernel exporter.

/// Metrics server is started in `App::build()` via `ron_kernel::Metrics::serve`.
pub struct MetricsServer;

```

### crates/omnigate/src/bootstrap/mod.rs
<a id="crates-omnigate-src-bootstrap-mod-rs"></a>

```rust
//! RO:WHAT — Bootstrap modules: API server, metrics server (via kernel), health probe helpers.
//! RO:WHY  — Keep main.rs tiny; Concerns: RES/PERF (clean layering, quick start/stop).
//! RO:INTERACTS — server.rs (axum serve), metrics_server.rs (delegates to ron-kernel), health_probe.rs.
//! RO:INVARIANTS — single writer per listener; truthful readiness; no blocking in async.

pub mod health_probe;
pub mod metrics_server;
pub mod server;

```

### crates/omnigate/src/bootstrap/server.rs
<a id="crates-omnigate-src-bootstrap-server-rs"></a>

```rust
//! RO:WHAT — Axum HTTP server bootstrap for the API plane.
//! RO:WHY  — Separate from main; Concerns: RES/PERF; handles bind + graceful-ish shutdown.
//! RO:INTERACTS — axum::Router, crate::config::Server, ron-kernel readiness (future toggle).
//! RO:INVARIANTS — bind before marking ready; one server task, one listener; stop cleanly on Ctrl-C.

use axum::Router;
use std::net::SocketAddr;
use tokio::task::JoinHandle;
use tracing::{error, info};

pub async fn serve(
    cfg: crate::config::Server,
    router: Router,
) -> anyhow::Result<(JoinHandle<()>, SocketAddr)> {
    // Bind first to satisfy "bind before ready".
    let listener = tokio::net::TcpListener::bind(cfg.bind).await?;
    let local: SocketAddr = listener.local_addr()?;
    info!(%local, "api listener bound");

    // Axum/Hyper server with graceful shutdown on Ctrl-C.
    // (Main still holds the JoinHandle and can abort on top; this just ensures
    //  a clean drain when Ctrl-C is delivered to the process.)
    let http = axum::serve(listener, router).with_graceful_shutdown(async {
        // Best-effort: if ctrl_c fails, just keep serving.
        if let Err(e) = tokio::signal::ctrl_c().await {
            // Log once; we don't bubble this up because we want the server to continue.
            error!(error=?e, "ctrl-c listener failed in server task");
        }
    });

    let task = tokio::spawn(async move {
        if let Err(e) = http.await {
            // This fires on listener errors or if the accept loop ends unexpectedly.
            tracing::error!(error=?e, "http server stopped with error");
        } else {
            tracing::info!("http server exited");
        }
    });

    Ok((task, local))
}

```

### crates/omnigate/src/config/env.rs
<a id="crates-omnigate-src-config-env-rs"></a>

```rust
//! RO:WHAT — Apply env var overrides to Config.
//! RO:WHY  — 12 Pillars hardening: explicit/typed config; Concerns: GOV.
//! RO:INVARIANTS — Only documented keys; parse-safe; no panics.

use super::Config;
use std::env;

pub fn apply_env_overrides(cfg: &mut Config) -> anyhow::Result<()> {
    if let Ok(v) = env::var("OMNIGATE_BIND") {
        cfg.server.bind = v.parse()?;
    }
    if let Ok(v) = env::var("OMNIGATE_METRICS_ADDR") {
        cfg.server.metrics_addr = v.parse()?;
    }
    if let Ok(v) = env::var("OMNIGATE_AMNESIA") {
        cfg.server.amnesia = matches!(v.as_str(), "1" | "true" | "on" | "yes" | "TRUE");
    }
    Ok(())
}

```

### crates/omnigate/src/config/file.rs
<a id="crates-omnigate-src-config-file-rs"></a>

```rust
//! RO:WHAT — Load Config from TOML file if present (simple search).

use super::Config;
use std::{fs, path::PathBuf};

const DEFAULT_PATHS: &[&str] = &[
    "crates/omnigate/configs/omnigate.toml", // repo-relative (dev)
    "configs/omnigate.toml",                 // crate-relative (installed)
    "/etc/ron/omnigate.toml",                // system
];

pub fn load_from_default_path() -> anyhow::Result<Option<Config>> {
    for p in DEFAULT_PATHS {
        if let Some(cfg) = try_load(PathBuf::from(p))? {
            return Ok(Some(cfg));
        }
    }
    Ok(None)
}

fn try_load(path: PathBuf) -> anyhow::Result<Option<Config>> {
    if !path.exists() {
        return Ok(None);
    }
    let s = fs::read_to_string(&path)?;
    let cfg: Config = toml::from_str::<Config>(&s)?;
    Ok(Some(cfg))
}

```

### crates/omnigate/src/config/mod.rs
<a id="crates-omnigate-src-config-mod-rs"></a>

```rust
//! RO:WHAT   Omnigate configuration model + loaders (env/file) + defaults.
//! RO:INVARS  oap.max_frame_bytes ≤ 1MiB; body caps aligned with middleware guards.

use serde::Deserialize;
use std::{fs, net::SocketAddr, path::Path};

mod env;
mod file;
mod validate;

#[derive(Debug, Clone, Deserialize)]
pub struct Config {
    pub server: Server,
    pub oap: Oap,
    pub admission: Admission,
    pub policy: Policy,
    pub readiness: Readiness,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Server {
    /// API listener bind, e.g. "127.0.0.1:5305"
    pub bind: SocketAddr,
    /// Admin/metrics bind, e.g. "127.0.0.1:9605"
    pub metrics_addr: SocketAddr,
    pub amnesia: bool,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Oap {
    pub max_frame_bytes: u64,
    pub stream_chunk_bytes: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Admission {
    pub global_quota: GlobalQuota,
    pub ip_quota: IpQuota,
    pub fair_queue: FairQueue,
    pub body: BodyCaps,
    pub decompression: Decompress,
}

#[derive(Debug, Clone, Deserialize)]
pub struct GlobalQuota {
    pub qps: u64,
    pub burst: u64,
}
#[derive(Debug, Clone, Deserialize)]
pub struct IpQuota {
    pub enabled: bool,
    pub qps: u64,
    pub burst: u64,
}
#[derive(Debug, Clone, Deserialize)]
pub struct FairQueue {
    pub max_inflight: u64,
    pub weights: Weights,
}
#[derive(Debug, Clone, Deserialize)]
pub struct Weights {
    pub anon: u32,
    pub auth: u32,
    pub admin: u32,
}
#[derive(Debug, Clone, Deserialize)]
pub struct BodyCaps {
    pub max_content_length: u64,
    pub reject_on_missing_length: bool,
}
#[derive(Debug, Clone, Deserialize)]
pub struct Decompress {
    pub allow: Vec<String>,
    pub deny_stacked: bool,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Policy {
    pub enabled: bool,
    pub bundle_path: String,
    pub fail_mode: String,
}
impl Policy {
    pub fn fail_deny(&self) -> bool {
        self.fail_mode.eq_ignore_ascii_case("deny")
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct Readiness {
    pub max_inflight_threshold: u64,
    pub error_rate_429_503_pct: f64,
    pub window_secs: u64,
    pub hold_for_secs: u64,
}

impl Config {
    /// Load config with precedence: CLI `--config <path>` (handled in main) → env overrides → defaults/file.
    pub fn load() -> anyhow::Result<Self> {
        // Try file from default search paths.
        if let Some(cfg) = file::load_from_default_path()? {
            let mut cfg = cfg;
            env::apply_env_overrides(&mut cfg)?;
            validate::validate(&cfg)?;
            // OAP hard limit
            anyhow::ensure!(
                cfg.oap.max_frame_bytes <= 1_048_576,
                "oap.max_frame_bytes > 1MiB not allowed"
            );
            return Ok(cfg);
        }

        // Fallback minimal defaults (safe localhost).
        let mut cfg = Self {
            server: Server {
                bind: "127.0.0.1:5305".parse()?,
                metrics_addr: "127.0.0.1:9605".parse()?,
                amnesia: true,
            },
            oap: Oap {
                max_frame_bytes: 1_048_576,
                stream_chunk_bytes: 65_536,
            },
            admission: Admission {
                global_quota: GlobalQuota {
                    qps: 20_000,
                    burst: 40_000,
                },
                ip_quota: IpQuota {
                    enabled: true,
                    qps: 2_000,
                    burst: 4_000,
                },
                fair_queue: FairQueue {
                    max_inflight: 2_048,
                    weights: Weights {
                        anon: 1,
                        auth: 5,
                        admin: 10,
                    },
                },
                body: BodyCaps {
                    max_content_length: 1_048_576 * 10,
                    reject_on_missing_length: true,
                },
                decompression: Decompress {
                    allow: vec!["identity".into(), "gzip".into()],
                    deny_stacked: true,
                },
            },
            policy: Policy {
                enabled: false,
                bundle_path: "policy.bundle.json".into(),
                fail_mode: "deny".into(),
            },
            readiness: Readiness {
                max_inflight_threshold: 1_800,
                error_rate_429_503_pct: 2.0,
                window_secs: 10,
                hold_for_secs: 30,
            },
        };
        env::apply_env_overrides(&mut cfg)?;
        validate::validate(&cfg)?;
        Ok(cfg)
    }

    /// Explicit file load (used by main when `--config` is provided).
    pub fn from_toml_file<P: AsRef<Path>>(p: P) -> anyhow::Result<Self> {
        let s = fs::read_to_string(p)?;
        let mut cfg: Self = toml::from_str(&s)?;
        env::apply_env_overrides(&mut cfg)?;
        validate::validate(&cfg)?;
        anyhow::ensure!(
            cfg.oap.max_frame_bytes <= 1_048_576,
            "oap.max_frame_bytes > 1MiB not allowed"
        );
        Ok(cfg)
    }
}

```

### crates/omnigate/src/config/reload.rs
<a id="crates-omnigate-src-config-reload-rs"></a>

```rust
//! RO:WHAT — Hot-reload scaffold (listen for kernel ConfigUpdated, apply).
//! RO:WHY  — RON pattern: runtime config changes without restart; Concerns: GOV/RES.
//! RO:INTERACTS — ron-kernel bus events; to be wired in Phase 2.

pub struct Reload; // placeholder for future reload worker

```

### crates/omnigate/src/config/validate.rs
<a id="crates-omnigate-src-config-validate-rs"></a>

```rust
//! RO:WHAT — Validate Config invariants (caps, limits).
//! RO:WHY  — Prevent misconfig from violating protocol/HTTP limits; Concerns: GOV/SEC.
//! RO:INVARIANTS — OAP max_frame=1MiB; body cap ≤1MiB; decompression ≤10x (to be added when body handling lands).

use super::Config;

pub fn validate(_cfg: &Config) -> anyhow::Result<()> {
    // Add concrete checks as data-plane routes land (body caps, timeouts, inflight).
    Ok(())
}

```

### crates/omnigate/src/downstream/dht_client.rs
<a id="crates-omnigate-src-downstream-dhtclient-rs"></a>

```rust
//! RO:WHAT   DHT service client (thin).
//! RO:WHY    Encapsulate K/V provider lookups etc.

use super::{build_client, DsError};
use std::time::Duration;

#[derive(Clone)]
pub struct DhtClient {
    base_url: String,
    client: reqwest::Client,
    connect_timeout: Duration,
    req_timeout: Duration,
}

impl Default for DhtClient {
    fn default() -> Self { Self::new("http://127.0.0.1:5301") }
}

impl DhtClient {
    pub fn new(base_url: &str) -> Self {
        Self {
            base_url: base_url.to_owned(),
            client: build_client(),
            connect_timeout: Duration::from_millis(200),
            req_timeout: Duration::from_secs(2),
        }
    }

    pub async fn healthz(&self) -> Result<String, DsError> {
        let url = format!("{}/healthz", self.base_url.trim_end_matches('/'));
        let res = self.client
            .get(url)
            .connect_timeout(self.connect_timeout)
            .timeout(self.req_timeout)
            .send().await?;
        if res.status().is_success() {
            Ok(res.text().await.unwrap_or_default())
        } else {
            Ok(format!("status={}", res.status().as_u16()))
        }
    }
}

```

### crates/omnigate/src/downstream/error.rs
<a id="crates-omnigate-src-downstream-error-rs"></a>

```rust
//! RO:WHAT   Egress error taxonomy.
//! RO:WHY    Normalize reqwest errors + HTTP status into a small set.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum DsError {
    #[error("http {status}: {body}")]
    Http { status: u16, body: String },
    #[error("network: {0}")]
    Net(#[from] reqwest::Error),
    #[error("serde: {0}")]
    Serde(#[from] serde_json::Error),
}

impl DsError {
    pub fn is_retryable(&self) -> bool {
        match self {
            DsError::Http { status, .. } => (500..600).contains(status),
            DsError::Net(e) => e.is_connect() || e.is_timeout() || e.is_request(),
            DsError::Serde(_) => false,
        }
    }
}

```

### crates/omnigate/src/downstream/hedge.rs
<a id="crates-omnigate-src-downstream-hedge-rs"></a>

```rust
//! RO:WHAT   Hedged requests helper: launch a second attempt after a delay, take first success.
//! RO:WHY    Reduce tail latency for p95+ under occasional stragglers.
//! RO:INVARS  Max two in-flight per call; second attempt only if first hasn't finished.

use super::{DsError, RetryPolicy};
use rand::rngs::StdRng;
use tokio::task::JoinSet;
use std::future::Future;

pub async fn hedge2<F, T>(
    make_call: impl Fn() -> F + Send + Sync + 'static + Clone,
    hedged_after_ms: u64,
) -> Result<T, DsError>
where
    F: Future<Output = Result<T, DsError>> + Send + 'static,
    T: Send + 'static,
{
    let mut js = JoinSet::new();
    js.spawn(make_call.clone()());
    tokio::time::sleep(std::time::Duration::from_millis(hedged_after_ms)).await;
    js.spawn(make_call());

    while let Some(res) = js.join_next().await {
        match res {
            Ok(Ok(v)) => return Ok(v),
            Ok(Err(_)) => continue,
            Err(_) => continue,
        }
    }
    Err(DsError::Net(reqwest::Error::new(
        reqwest::ErrorKind::Request,
        "both hedged attempts failed",
    )))
}

```

### crates/omnigate/src/downstream/index_client.rs
<a id="crates-omnigate-src-downstream-indexclient-rs"></a>

```rust
//! RO:WHAT   Index service client (thin wrapper over reqwest).
//! RO:WHY    Keep service-specific paths/types out of generic code.
//! RO:INTERACTS  GET /healthz, generic JSON GET/POST for later expansion.

use super::{build_client, DsError, RetryPolicy, full_jitter_backoff};
use rand::rngs::StdRng;
use rand::SeedableRng;
use std::time::Duration;

#[derive(Clone)]
pub struct IndexClient {
    base_url: String,
    client: reqwest::Client,
    retry: RetryPolicy,
    connect_timeout: Duration,
    req_timeout: Duration,
}

impl Default for IndexClient {
    fn default() -> Self {
        Self::new("http://127.0.0.1:5304")
    }
}

impl IndexClient {
    pub fn new(base_url: &str) -> Self {
        Self {
            base_url: base_url.to_owned(),
            client: build_client(),
            retry: RetryPolicy::default(),
            connect_timeout: Duration::from_millis(200),
            req_timeout: Duration::from_secs(2),
        }
    }

    pub fn with_retry(mut self, retry: RetryPolicy) -> Self { self.retry = retry; self }

    pub async fn healthz(&self) -> Result<String, DsError> {
        self.get_text("/healthz", None).await
    }

    pub async fn get_json<T: serde::de::DeserializeOwned>(&self, path: &str) -> Result<T, DsError> {
        self.exec::<(), T>("GET", path, None, None).await
    }

    pub async fn post_json<B: serde::Serialize, T: serde::de::DeserializeOwned>(&self, path: &str, body: &B) -> Result<T, DsError> {
        self.exec("POST", path, Some(body), None).await
    }

    pub async fn get_text(&self, path: &str, corr_id: Option<&str>) -> Result<String, DsError> {
        self.exec::<(), String>("GET", path, None, corr_id).await
    }

    async fn exec<B: serde::Serialize, T: serde::de::DeserializeOwned>(
        &self,
        method: &str,
        path: &str,
        body: Option<&B>,
        corr_id: Option<&str>,
    ) -> Result<T, DsError> {
        let url = format!("{}/{}", self.base_url.trim_end_matches('/'), path.trim_start_matches('/'));
        let mut attempt = 1u32;
        let mut rng = StdRng::from_entropy();

        loop {
            let res = {
                let mut req = self.client
                    .request(reqwest::Method::from_bytes(method.as_bytes()).unwrap(), &url)
                    .connect_timeout(self.connect_timeout)
                    .timeout(self.req_timeout);

                if let Some(id) = corr_id {
                    if let Ok(v) = reqwest::header::HeaderValue::from_str(id) {
                        let mut h = req.headers_mut();
                        h.insert("x-correlation-id", v);
                    }
                }
                if let Some(b) = body {
                    req = req.json(b);
                }
                req.send().await
            };

            match res {
                Ok(r) if r.status().is_success() => {
                    if std::any::TypeId::of::<T>() == std::any::TypeId::of::<String>() {
                        // Fast path: text
                        let txt = r.text().await.map_err(DsError::Net)?;
                        // SAFETY: we know T=String at this call site
                        let any = unsafe { std::mem::transmute::<String, T>(txt) };
                        return Ok(any);
                    } else {
                        let txt = r.text().await.map_err(DsError::Net)?;
                        let out = serde_json::from_str::<T>(&txt)?;
                        return Ok(out);
                    }
                }
                Ok(r) => {
                    let status = r.status().as_u16();
                    let body = r.text().await.unwrap_or_default();
                    let err = DsError::Http { status, body };
                    if attempt >= self.retry.max_attempts || !err.is_retryable() {
                        return Err(err);
                    }
                    let sleep = full_jitter_backoff(attempt, self.retry.base_delay, self.retry.max_delay, &mut rng);
                    tokio::time::sleep(sleep).await;
                }
                Err(e) => {
                    let err = DsError::from(e);
                    if attempt >= self.retry.max_attempts || !err.is_retryable() {
                        return Err(err);
                    }
                    let sleep = full_jitter_backoff(attempt, self.retry.base_delay, self.retry.max_delay, &mut rng);
                    tokio::time::sleep(sleep).await;
                }
            }

            attempt += 1;
        }
    }
}

```

### crates/omnigate/src/downstream/latency.rs
<a id="crates-omnigate-src-downstream-latency-rs"></a>

```rust
//! RO:WHAT   Small latency helpers for downstream timing (standalone).
//! RO:WHY    Keep measurement logic trivial to test/mock.

use std::time::{Duration, Instant};

pub struct Timer(Instant);

impl Timer {
    pub fn start() -> Self { Self(Instant::now()) }
    pub fn stop(self) -> Duration { self.0.elapsed() }
}

```

### crates/omnigate/src/downstream/mailbox_client.rs
<a id="crates-omnigate-src-downstream-mailboxclient-rs"></a>

```rust
//! RO:WHAT   Mailbox/notification client (thin).
//! RO:WHY    Keeps notify calls decoupled from core.

use super::{build_client, DsError};
use std::time::Duration;

#[derive(Clone)]
pub struct MailboxClient {
    base_url: String,
    client: reqwest::Client,
    connect_timeout: Duration,
    req_timeout: Duration,
}

impl Default for MailboxClient {
    fn default() -> Self { Self::new("http://127.0.0.1:5310") }
}

impl MailboxClient {
    pub fn new(base_url: &str) -> Self {
        Self {
            base_url: base_url.to_owned(),
            client: build_client(),
            connect_timeout: Duration::from_millis(200),
            req_timeout: Duration::from_secs(2),
        }
    }

    pub async fn healthz(&self) -> Result<String, DsError> {
        let url = format!("{}/healthz", self.base_url.trim_end_matches('/'));
        let res = self.client
            .get(url)
            .connect_timeout(self.connect_timeout)
            .timeout(self.req_timeout)
            .send().await?;
        if res.status().is_success() {
            Ok(res.text().await.unwrap_or_default())
        } else {
            Ok(format!("status={}", res.status().as_u16()))
        }
    }
}

```

### crates/omnigate/src/downstream/mod.rs
<a id="crates-omnigate-src-downstream-mod-rs"></a>

```rust
//! RO:WHAT   Downstream (egress) HTTP client stack for calling RON services.
//! RO:WHY    Centralize retries, timeouts, and error taxonomy; keep wrappers thin.
//! RO:INTERACTS reqwest (rustls), tokio, crate::observability (corr-id later).
//! RO:INVARS  Finite timeouts; 4xx never retried; retries use jitter; no panics.

mod retry;
mod error;

pub mod latency;
pub mod hedge;

pub mod index_client;
pub mod storage_client;
pub mod mailbox_client;
pub mod dht_client;

pub use error::DsError;
pub use retry::{RetryPolicy, full_jitter_backoff};

use std::time::Duration;

/// RO:WHAT Build a default reqwest client suitable for internal calls.
/// RO:WHY  Ensure consistent TLS & connection settings.
pub fn build_client() -> reqwest::Client {
    reqwest::Client::builder()
        .pool_idle_timeout(Duration::from_secs(30))
        .tcp_keepalive(Duration::from_secs(30))
        .use_rustls_tls()
        .build()
        .expect("reqwest client")
}

```

### crates/omnigate/src/downstream/registry.rs
<a id="crates-omnigate-src-downstream-registry-rs"></a>

```rust
//! RO:WHAT   In-memory registry mapping ServiceKind -> Endpoint config.
//! RO:WHY    Late-binding of base URLs and timeouts; simple and explicit.
//! RO:INVARS  Base URLs are absolute; timeouts finite; defaults are localhost dev-safe.

use crate::downstream::types::ServiceKind;
use std::collections::HashMap;
use std::time::Duration;

#[derive(Debug, Clone)]
pub struct EndpointCfg {
    pub base_url: String,          // e.g., "http://127.0.0.1:5304"
    pub connect_timeout: Duration, // TCP connect
    pub timeout: Duration,         // whole request
}

#[derive(Debug, Clone)]
pub struct DownstreamRegistry {
    map: HashMap<ServiceKind, EndpointCfg>,
}

impl DownstreamRegistry {
    pub fn get(&self, k: ServiceKind) -> Option<&EndpointCfg> {
        self.map.get(&k)
    }

    pub fn insert(&mut self, k: ServiceKind, e: EndpointCfg) {
        self.map.insert(k, e);
    }
}

impl Default for DownstreamRegistry {
    fn default() -> Self {
        use ServiceKind::*;
        let mut map = HashMap::new();
        let fast = EndpointCfg {
            base_url: "http://127.0.0.1:5300".into(),
            connect_timeout: Duration::from_millis(200),
            timeout: Duration::from_secs(2),
        };
        // Dev-safe placeholders; change per crate ports as needed.
        map.insert(Index,   EndpointCfg { base_url: "http://127.0.0.1:5304".into(), ..fast.clone() });
        map.insert(Storage, EndpointCfg { base_url: "http://127.0.0.1:5303".into(), ..fast.clone() });
        map.insert(Dht,     EndpointCfg { base_url: "http://127.0.0.1:5301".into(), ..fast.clone() });
        map.insert(Naming,  EndpointCfg { base_url: "http://127.0.0.1:5302".into(), ..fast.clone() });
        map.insert(Overlay, EndpointCfg { base_url: "http://127.0.0.1:5306".into(), ..fast.clone() });
        map.insert(Policy,  EndpointCfg { base_url: "http://127.0.0.1:9609".into(), ..fast.clone() });
        Self { map }
    }
}

```

### crates/omnigate/src/downstream/retry.rs
<a id="crates-omnigate-src-downstream-retry-rs"></a>

```rust
//! RO:WHAT   Retry policy & jittered backoff helpers for outbound HTTP.
//! RO:WHY    Make transient failures tolerable without thundering herd.
//! RO:INVARS  Budgeted attempts; exponential w/ full jitter; never retry 4xx.

use rand::{rngs::StdRng, Rng, SeedableRng};
use std::time::Duration;

#[derive(Debug, Clone)]
pub struct RetryPolicy {
    pub max_attempts: u32,   // total, including first try
    pub base_delay: Duration,
    pub max_delay: Duration,
}

impl Default for RetryPolicy {
    fn default() -> Self {
        Self {
            max_attempts: 3,
            base_delay: Duration::from_millis(50),
            max_delay: Duration::from_millis(600),
        }
    }
}

pub fn full_jitter_backoff(attempt: u32, base: Duration, max: Duration, rng: &mut StdRng) -> Duration {
    let exp = base.saturating_mul(1u32.saturating_shl(attempt.saturating_sub(1).min(10)));
    let cap = std::cmp::min(exp, max);
    let nanos = rng.gen_range(0..=cap.as_nanos() as u128);
    Duration::from_nanos(nanos as u64)
}

pub fn new_rng() -> StdRng { StdRng::from_entropy() }

```

### crates/omnigate/src/downstream/storage_client.rs
<a id="crates-omnigate-src-downstream-storageclient-rs"></a>

```rust
//! RO:WHAT   Storage service client (thin).
//! RO:WHY    Keep storage-specific calls contained here.

use super::{build_client, DsError, RetryPolicy, full_jitter_backoff};
use rand::rngs::StdRng;
use rand::SeedableRng;
use std::time::Duration;

#[derive(Clone)]
pub struct StorageClient {
    base_url: String,
    client: reqwest::Client,
    retry: RetryPolicy,
    connect_timeout: Duration,
    req_timeout: Duration,
}

impl Default for StorageClient {
    fn default() -> Self { Self::new("http://127.0.0.1:5303") }
}

impl StorageClient {
    pub fn new(base_url: &str) -> Self {
        Self {
            base_url: base_url.to_owned(),
            client: build_client(),
            retry: RetryPolicy::default(),
            connect_timeout: Duration::from_millis(200),
            req_timeout: Duration::from_secs(3),
        }
    }

    pub async fn healthz(&self) -> Result<String, DsError> {
        self.get_text("/healthz").await
    }

    pub async fn get_text(&self, path: &str) -> Result<String, DsError> {
        self.exec::<(), String>("GET", path, None).await
    }

    pub async fn post_json<B: serde::Serialize, T: serde::de::DeserializeOwned>(&self, path: &str, body: &B) -> Result<T, DsError> {
        self.exec("POST", path, Some(body)).await
    }

    async fn exec<B: serde::Serialize, T: serde::de::DeserializeOwned>(
        &self,
        method: &str,
        path: &str,
        body: Option<&B>,
    ) -> Result<T, DsError> {
        let url = format!("{}/{}", self.base_url.trim_end_matches('/'), path.trim_start_matches('/'));
        let mut attempt = 1u32;
        let mut rng = StdRng::from_entropy();

        loop {
            let res = {
                let mut req = self.client
                    .request(reqwest::Method::from_bytes(method.as_bytes()).unwrap(), &url)
                    .connect_timeout(self.connect_timeout)
                    .timeout(self.req_timeout);

                if let Some(b) = body { req = req.json(b); }
                req.send().await
            };

            match res {
                Ok(r) if r.status().is_success() => {
                    if std::any::TypeId::of::<T>() == std::any::TypeId::of::<String>() {
                        let txt = r.text().await.map_err(DsError::Net)?;
                        let any = unsafe { std::mem::transmute::<String, T>(txt) };
                        return Ok(any);
                    } else {
                        let txt = r.text().await.map_err(DsError::Net)?;
                        let out = serde_json::from_str::<T>(&txt)?;
                        return Ok(out);
                    }
                }
                Ok(r) => {
                    let status = r.status().as_u16();
                    let body = r.text().await.unwrap_or_default();
                    let err = DsError::Http { status, body };
                    if attempt >= self.retry.max_attempts || !err.is_retryable() {
                        return Err(err);
                    }
                    let sleep = full_jitter_backoff(attempt, self.retry.base_delay, self.retry.max_delay, &mut rng);
                    tokio::time::sleep(sleep).await;
                }
                Err(e) => {
                    let err = DsError::from(e);
                    if attempt >= self.retry.max_attempts || !err.is_retryable() {
                        return Err(err);
                    }
                    let sleep = full_jitter_backoff(attempt, self.retry.base_delay, self.retry.max_delay, &mut rng);
                    tokio::time::sleep(sleep).await;
                }
            }
            attempt += 1;
        }
    }
}

```

### crates/omnigate/src/downstream/types.rs
<a id="crates-omnigate-src-downstream-types-rs"></a>

```rust
//! RO:WHAT   Core enums/types for downstream services.
//! RO:WHY    Keep labels low-cardinality and stable across releases.

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ServiceKind {
    Index,
    Storage,
    Dht,
    Naming,
    Overlay,
    Policy, // if ever queried (bundle host, etc.)
}

impl ServiceKind {
    pub fn as_str(&self) -> &'static str {
        match self {
            ServiceKind::Index => "index",
            ServiceKind::Storage => "storage",
            ServiceKind::Dht => "dht",
            ServiceKind::Naming => "naming",
            ServiceKind::Overlay => "overlay",
            ServiceKind::Policy => "policy",
        }
    }
}

```

### crates/omnigate/src/errors/http_map.rs
<a id="crates-omnigate-src-errors-httpmap-rs"></a>

```rust
//! RO:WHAT   Map admission/policy errors to stable JSON problem docs + helpers.
//! RO:WHY    Clients/SREs need consistent, parseable error envelopes.
//! RO:INTERACTS middleware::{quotas,fair_queue,body_caps,decompress_guard,policy}, admin plane.
//! RO:INVARS  Always include x-request-id upstream; no secret leakage; status matches code.

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;

use super::reasons::Reason;

#[derive(Serialize)]
pub struct Problem<'a> {
    pub code: &'a str,
    pub message: &'a str,
    pub retryable: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retry_after_ms: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<&'a str>,
}

/// Tiny helper used by tests and preflight guards: builds `{reason,message}` JSON with canonical status.
pub fn to_response(reason: Reason, message: &str) -> impl IntoResponse {
    let body = serde_json::json!({
        "reason": reason.key(),
        "message": message,
    });
    (reason.status(), Json(body))
}

pub enum GateError<'a> {
    // Admission
    RateLimitedGlobal { retry_after_ms: u64 },
    RateLimitedIp { retry_after_ms: u64 },
    PayloadTooLarge { limit: u64 },
    UnsupportedEncoding { encoding: &'a str },
    StackedEncodings,
    // Policy
    PolicyDeny { reason: &'a str, status: StatusCode }, // 403 default, 451 for legal blocks
    PolicyError,                                        // 503 when evaluator fails/errors
    // Overload
    Degraded, // 503 when readiness gate is down
}

impl<'a> IntoResponse for GateError<'a> {
    fn into_response(self) -> Response {
        match self {
            GateError::RateLimitedGlobal { retry_after_ms } => {
                let body = Problem {
                    code: "RATE_LIMITED",
                    message: "Global rate limit",
                    retryable: true,
                    retry_after_ms: Some(retry_after_ms),
                    reason: Some(Reason::TooManyRequests.key()),
                };
                (StatusCode::TOO_MANY_REQUESTS, Json(body)).into_response()
            }
            GateError::RateLimitedIp { retry_after_ms } => {
                let body = Problem {
                    code: "RATE_LIMITED",
                    message: "IP quota exceeded",
                    retryable: true,
                    retry_after_ms: Some(retry_after_ms),
                    reason: Some(Reason::TooManyRequests.key()),
                };
                (StatusCode::TOO_MANY_REQUESTS, Json(body)).into_response()
            }
            GateError::PayloadTooLarge { .. } => {
                let body = Problem {
                    code: "PAYLOAD_TOO_LARGE",
                    message: "Body exceeds limit",
                    retryable: false,
                    retry_after_ms: None,
                    reason: Some(Reason::PayloadTooLarge.key()),
                };
                (StatusCode::PAYLOAD_TOO_LARGE, Json(body)).into_response()
            }
            GateError::UnsupportedEncoding { .. } | GateError::StackedEncodings => {
                let body = Problem {
                    code: "UNSUPPORTED_ENCODING",
                    message: "Encoding not allowed",
                    retryable: false,
                    retry_after_ms: None,
                    reason: Some(Reason::UnsupportedMediaType.key()),
                };
                (StatusCode::UNSUPPORTED_MEDIA_TYPE, Json(body)).into_response()
            }
            GateError::PolicyDeny { reason, status } => {
                let body = Problem {
                    code: if status == StatusCode::UNAVAILABLE_FOR_LEGAL_REASONS {
                        "LEGAL_RESTRICTION"
                    } else {
                        "POLICY_DENY"
                    },
                    message: "Access denied",
                    retryable: false,
                    retry_after_ms: None,
                    reason: Some(reason),
                };
                (status, Json(body)).into_response()
            }
            GateError::PolicyError => {
                let body = Problem {
                    code: "POLICY_ERROR",
                    message: "Policy evaluation failed",
                    retryable: true,
                    retry_after_ms: Some(250),
                    reason: Some(Reason::Unavailable.key()),
                };
                (StatusCode::SERVICE_UNAVAILABLE, Json(body)).into_response()
            }
            GateError::Degraded => {
                let body = Problem {
                    code: "SERVICE_DEGRADED",
                    message: "Overload protection",
                    retryable: true,
                    retry_after_ms: Some(250),
                    reason: Some(Reason::Unavailable.key()),
                };
                (StatusCode::SERVICE_UNAVAILABLE, Json(body)).into_response()
            }
        }
    }
}

```

### crates/omnigate/src/errors/mod.rs
<a id="crates-omnigate-src-errors-mod-rs"></a>

```rust
//! RO:WHAT — Error taxonomy + HTTP mapping.
//! RO:WHY  — Deterministic errors (RON invariant); Concerns: DX/GOV.
//! RO:INTERACTS — http_map.rs, reasons.rs.

pub mod http_map;
pub mod reasons;

pub use http_map::{GateError, Problem};
pub use reasons::Reason;

```

### crates/omnigate/src/errors/reasons.rs
<a id="crates-omnigate-src-errors-reasons-rs"></a>

```rust
//! RO:WHAT — Canonical error reason codes for JSON envelopes.
//! RO:WHY  — Stable keys for clients, decoupled from HTTP status texts.

use axum::http::StatusCode;

/// Keep names kebab/underscore compatible — we expose snake_case in JSON.
#[derive(Clone, Copy, Debug)]
pub enum Reason {
    BadRequest,
    Unauthorized,
    Forbidden,
    NotFound,
    Conflict,
    TooManyRequests,
    PayloadTooLarge,
    UnsupportedMediaType, // 415
    Internal,
    Unavailable,
}

impl Reason {
    /// Programmatic, stable key sent in the JSON envelope.
    pub const fn key(self) -> &'static str {
        match self {
            Reason::BadRequest => "bad_request",
            Reason::Unauthorized => "unauthorized",
            Reason::Forbidden => "forbidden",
            Reason::NotFound => "not_found",
            Reason::Conflict => "conflict",
            Reason::TooManyRequests => "too_many_requests",
            Reason::PayloadTooLarge => "payload_too_large",
            Reason::UnsupportedMediaType => "unsupported_media_type",
            Reason::Internal => "internal",
            Reason::Unavailable => "unavailable",
        }
    }

    /// Canonical HTTP mapping.
    pub const fn status(self) -> StatusCode {
        match self {
            Reason::BadRequest => StatusCode::BAD_REQUEST,
            Reason::Unauthorized => StatusCode::UNAUTHORIZED,
            Reason::Forbidden => StatusCode::FORBIDDEN,
            Reason::NotFound => StatusCode::NOT_FOUND,
            Reason::Conflict => StatusCode::CONFLICT,
            Reason::TooManyRequests => StatusCode::TOO_MANY_REQUESTS,
            Reason::PayloadTooLarge => StatusCode::PAYLOAD_TOO_LARGE,
            Reason::UnsupportedMediaType => StatusCode::UNSUPPORTED_MEDIA_TYPE,
            Reason::Internal => StatusCode::INTERNAL_SERVER_ERROR,
            Reason::Unavailable => StatusCode::SERVICE_UNAVAILABLE,
        }
    }
}

```

### crates/omnigate/src/hydration/compose.rs
<a id="crates-omnigate-src-hydration-compose-rs"></a>

```rust

```

### crates/omnigate/src/hydration/mod.rs
<a id="crates-omnigate-src-hydration-mod-rs"></a>

```rust

```

### crates/omnigate/src/hydration/planner.rs
<a id="crates-omnigate-src-hydration-planner-rs"></a>

```rust

```

### crates/omnigate/src/lib.rs
<a id="crates-omnigate-src-lib-rs"></a>

```rust
//! RO:WHAT — Omnigate service library: bootstrap, config, admin plane, and Router wiring.
//! RO:WHY  — P6 Ingress/App BFF foundation; Concerns: SEC/RES/PERF/GOV.
//! RO:INVARIANTS — no locks across .await; single writer per conn.

pub mod admission;
pub mod bootstrap;
pub mod config;
pub mod errors;
pub mod metrics;
pub mod middleware;
pub mod observability;
pub mod routes;
pub mod runtime;
pub mod types;
pub mod zk;

use axum::{extract::State, response::IntoResponse, routing::get, Router};
use ron_kernel::metrics::{health::HealthState, readiness::Readiness};
use ron_kernel::Metrics;
use std::net::SocketAddr;
use tracing::info;

// Metrics registry shorthands
use crate::metrics::registry as mreg;

/// Admin-plane state (health + readiness) for /ops and root handlers.
#[derive(Clone)]
struct AdminState {
    health: HealthState,
    ready: Readiness,
    dev_ready: bool, // read once at startup
}

pub struct App {
    pub router: Router,
    pub admin_addr: SocketAddr,
}

impl App {
    /// Build the main app router and start the admin plane (metrics/health/ready).
    pub async fn build(cfg: config::Config) -> anyhow::Result<Self> {
        // Metrics exporter + admin plane
        let metrics = Metrics::new(false);
        let health = HealthState::new();
        let ready = Readiness::new(health.clone());

        // Serve admin plane (Prometheus /metrics + /healthz + /readyz) on cfg.server.metrics_addr.
        let (_admin_task, admin_addr) = metrics
            .clone()
            .serve(cfg.server.metrics_addr, health.clone(), ready.clone())
            .await
            .map_err(|e| anyhow::anyhow!("{}", e))?;

        // Liveness: process is up & config parsed.
        health.set("omnigate", true);
        health.set("config", true);

        // Readiness: flip the specific "config loaded" gate (what /readyz checks).
        ready.set_config_loaded(true);

        // ---- C) Wire amnesia_mode gauge to config (+ env override) ----
        // Source of truth: config, with optional OMNIGATE_AMNESIA=1|true|on to force it during smoke/dev.
        let amnesia_from_cfg = cfg.server.amnesia;
        let amnesia_from_env = matches!(
            std::env::var("OMNIGATE_AMNESIA").as_deref(),
            Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
        );
        let amnesia_on = amnesia_from_cfg || amnesia_from_env;

        mreg::AMNESIA_MODE.set(if amnesia_on { 1 } else { 0 });
        info!(
            amnesia_from_cfg,
            amnesia_from_env, amnesia_on, "amnesia mode resolved"
        );

        // ---- B) Emit “policy bundle loaded” metric/log (once) ----
        // When a real policy loader is added, move this increment/log to that init point.
        mreg::POLICY_BUNDLE_LOADED_TOTAL.inc();
        info!("policy bundle loaded");

        // Dev-ready override (read once)
        let dev_ready = matches!(
            std::env::var("OMNIGATE_DEV_READY").as_deref(),
            Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
        );
        if dev_ready {
            info!("OMNIGATE_DEV_READY=on — /readyz will report 200 (dev override)");
        }

        let admin_state = AdminState {
            health: health.clone(),
            ready: ready.clone(),
            dev_ready,
        };

        // v1 API (expand in routes/v1/*)
        let api_v1 = Router::new().route("/ping", get(routes::v1::ping));

        // Shared handlers (root and /ops use the same functions)
        async fn healthz(State(st): State<AdminState>) -> impl IntoResponse {
            ron_kernel::metrics::health::healthz_handler(st.health.clone()).await
        }
        async fn readyz(State(st): State<AdminState>) -> impl IntoResponse {
            if st.dev_ready {
                return (axum::http::StatusCode::OK, "ready (dev override)").into_response();
            }
            ron_kernel::metrics::readiness::readyz_handler(st.ready.clone()).await
        }

        // Ops routes (namespaced)
        let ops = Router::new()
            .route("/ops/version", get(routes::ops::version)) // back-compat
            .route("/ops/readyz", get(readyz))
            .route("/ops/healthz", get(healthz))
            .with_state(admin_state.clone());

        // Root aliases (+ /versionz for sanity script/tools)
        let roots = Router::new()
            .route("/versionz", get(routes::ops::versionz))
            .route("/readyz", get(readyz))
            .route("/healthz", get(healthz))
            .with_state(admin_state);

        // Base router → root aliases + /ops + versioned API
        let app_router = Router::new().merge(roots).merge(ops).nest("/v1", api_v1);

        // Middleware stack (corr-id → classify → decompress_guard → body_caps → slow_loris) + HTTP tracing.
        let app_router = middleware::apply(app_router).layer(observability::http_trace_layer());

        Ok(Self {
            router: app_router,
            admin_addr,
        })
    }
}

```

### crates/omnigate/src/main.rs
<a id="crates-omnigate-src-main-rs"></a>

```rust
//! RO:WHAT — Omnigate binary entrypoint: loads config, boots admin plane, serves HTTP.
//! RO:WHY  — Small main to keep logic in lib; Concerns: GOV/RES (truthful health/ready, graceful shutdown).
//! RO:INTERACTS — omnigate::config, omnigate::bootstrap::server; ron-kernel surfaces.
//! RO:INVARIANTS — no locks across .await; graceful shutdown.

use omnigate::{bootstrap, config::Config};
use ron_kernel::wait_for_ctrl_c;
use tracing::{error, info};

// metrics: wire amnesia_mode gauge to config at boot (and on reloads elsewhere)
use omnigate::metrics::registry::AMNESIA_MODE;

#[tokio::main(flavor = "multi_thread")]
async fn main() -> anyhow::Result<()> {
    omnigate::observability::init_tracing();

    // Minimal arg scan so `--config path` works (used by smoke script).
    let mut args = std::env::args().skip(1);
    let mut cfg_path: Option<String> = None;
    while let Some(arg) = args.next() {
        if arg == "--config" {
            if let Some(p) = args.next() {
                cfg_path = Some(p);
            }
            break;
        }
    }

    let cfg = match cfg_path {
        Some(p) => Config::from_toml_file(p),
        None => Config::load(),
    }
    .map_err(|e| {
        error!(error=?e, "failed to load config");
        e
    })?;

    info!(cfg=?cfg, "omnigate config");

    // --- FIX: set `amnesia_mode` gauge from config ---
    // Convention: 1 if amnesia (Micronode) mode is enabled, else 0.
    // If your config nests this boolean elsewhere, adjust the path accordingly.
    AMNESIA_MODE.set(if cfg.server.amnesia { 1 } else { 0 });

    // Build app (starts admin plane via ron-kernel Metrics) and serve the API listener.
    let app = omnigate::App::build(cfg.clone()).await?;

    // Take a local copy of the admin bind BEFORE moving `server` into `serve(...)`.
    let server_cfg = cfg.server; // move the struct once
    let admin_addr = server_cfg.metrics_addr; // SocketAddr is Copy

    let (server_task, bind) = bootstrap::server::serve(server_cfg, app.router).await?;
    info!(%bind, %admin_addr, "omnigate up");

    // ---- Optional background runtime (sample worker) ----
    // Keep this tiny so it never blocks startup/shutdown.
    let workers: Vec<omnigate::runtime::DynWorker> =
        vec![omnigate::runtime::sample::TickWorker::new() as _];
    let supervisor = omnigate::runtime::spawn_supervisor(workers, /* worker_backlog */ 128);

    // Wait for Ctrl-C, then graceful shutdown.
    wait_for_ctrl_c().await;

    // Ask workers to stop and signal shutdown token.
    let _ = supervisor
        .tx_cmd
        .send(omnigate::runtime::SupervisorMsg::Stop);
    supervisor.shutdown.cancel();
    let _ = supervisor.join.await;

    // Best-effort stop the HTTP server; axum::serve has graceful shutdown hooks if needed.
    server_task.abort();
    Ok(())
}

```

### crates/omnigate/src/metrics/gates.rs
<a id="crates-omnigate-src-metrics-gates-rs"></a>

```rust
// crates/omnigate/src/metrics/gates.rs
//! RED/Readiness gate metrics (gauges + counters)

use once_cell::sync::Lazy;
use prometheus::{
    register_gauge, register_int_counter_vec, register_int_gauge, Gauge, IntCounterVec, IntGauge,
};

// Current inflight (requests in service) as seen by the gate.
pub static READY_INFLIGHT_CURRENT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "ready_inflight_current",
        "Current in-flight requests as tracked by readiness policy"
    )
    .expect("register ready_inflight_current")
});

// Rolling error rate (0.0–100.0); store as a plain gauge.
pub static READY_ERROR_RATE_PCT: Lazy<Gauge> = Lazy::new(|| {
    register_gauge!(
        "ready_error_rate_pct",
        "Rolling 429/503 error rate percentage over the readiness window"
    )
    .expect("register ready_error_rate_pct")
});

// Queue saturation flag (0 or 1).
pub static READY_QUEUE_SATURATED: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!("ready_queue_saturated", "Queue saturation flag (0/1)")
        .expect("register ready_queue_saturated")
});

// When ready trips to degraded, count reason.
pub static READY_TRIPS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "ready_trips_total",
        "Count of readiness trips to degraded by reason",
        &["reason"] // inflight | err_rate | queue
    )
    .expect("register ready_trips_total")
});

// Count state transitions (ready -> degraded, degraded -> ready).
pub static READY_STATE_CHANGES_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "ready_state_changes_total",
        "Readiness state changes",
        &["to"] // ready | degraded
    )
    .expect("register ready_state_changes_total")
});

```

### crates/omnigate/src/metrics/mod.rs
<a id="crates-omnigate-src-metrics-mod-rs"></a>

```rust
//! RO:WHAT   Prometheus registry & handles for Omnigate.
//! RO:WHY    Stable counters/histograms backing the metrics contract test.
//! RO:INTERACTS middleware::{quotas,fair_queue,body_caps,decompress_guard,policy}, admin/handlers.
pub mod gates;
pub mod registry;

use once_cell::sync::Lazy;
use prometheus::{register_histogram_vec, register_int_counter_vec, HistogramVec, IntCounterVec};

pub static HTTP_REQS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "http_requests_total",
        "Requests by route/method/status",
        &["route", "method", "status"]
    )
    .expect("register http_requests_total")
});

pub static REQUEST_LATENCY_SECONDS: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "request_latency_seconds",
        "Request latency by route/method",
        &["route", "method"]
    )
    .expect("register request_latency_seconds")
});

pub static ADMISSION_QUOTA_EXHAUSTED_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "admission_quota_exhausted_total",
        "Quota rejections by scope",
        &["scope"] // global|ip|token
    )
    .expect("register admission_quota_exhausted_total")
});

pub static FAIR_Q_EVENTS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "admission_fair_queue_events_total",
        "Fair queue events by type",
        &["event"] // enqueued|dropped
    )
    .expect("register admission_fair_queue_events_total")
});

pub static BODY_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "body_reject_total",
        "Body rejections by reason",
        &["reason"] // oversize|missing_len
    )
    .expect("register body_reject_total")
});

pub static DECOMPRESS_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "decompress_reject_total",
        "Decompression guard rejections",
        &["reason"] // unknown|stacked
    )
    .expect("register decompress_reject_total")
});

pub static POLICY_SHORTCIRCUITS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "policy_middleware_shortcircuits_total",
        "Requests denied by policy middleware",
        &["status"] // 403|451|503
    )
    .expect("register policy_middleware_shortcircuits_total")
});

```

### crates/omnigate/src/metrics/registry.rs
<a id="crates-omnigate-src-metrics-registry-rs"></a>

```rust
//! RO:WHAT   Prometheus registry & handles for Omnigate.
//! RO:WHY    Stable counters/histograms backing the metrics contract test.
//! RO:INTERACTS middleware::{quotas,fair_queue,body_caps,decompress_guard,policy}, http routes, admin plane.
//! RO:INVARS  Base labels elsewhere should include {service,instance,build_version,amnesia}.

use once_cell::sync::Lazy;
use prometheus::{
    register_histogram_vec, register_int_counter, register_int_counter_vec, register_int_gauge,
    HistogramVec, IntCounter, IntCounterVec, IntGauge,
};

/// Gauge reflecting whether we’re running in “amnesia mode” (Micronode/dev style).
/// Convention: 1 = amnesia ON, 0 = OFF. Wire this in App::build from cfg.server.amnesia.
pub static AMNESIA_MODE: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "amnesia_mode",
        "Amnesia (stateless) mode flag: 1 when enabled, else 0"
    )
    .expect("register amnesia_mode")
});

/// Count of times a policy bundle has been successfully loaded (startup/reload).
/// Increment once after policy init so sanity scripts can assert it happened.
pub static POLICY_BUNDLE_LOADED_TOTAL: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "policy_bundle_loaded_total",
        "Policy bundles successfully loaded (startup/reload)"
    )
    .expect("register policy_bundle_loaded_total")
});

pub static HTTP_REQS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "http_requests_total",
        "Requests by route/method/status",
        &["route", "method", "status"]
    )
    .expect("register http_requests_total")
});

pub static REQUEST_LATENCY_SECONDS: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "request_latency_seconds",
        "Request latency by route/method",
        &["route", "method"]
    )
    .expect("register request_latency_seconds")
});

pub static ADMISSION_QUOTA_EXHAUSTED_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "admission_quota_exhausted_total",
        "Quota rejections by scope",
        &["scope"] // global|ip|token
    )
    .expect("register admission_quota_exhausted_total")
});

pub static FAIR_Q_EVENTS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "admission_fair_queue_events_total",
        "Fair queue events by type",
        &["event"] // enqueued|dropped
    )
    .expect("register admission_fair_queue_events_total")
});

pub static BODY_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "body_reject_total",
        "Body rejections by reason",
        &["reason"] // oversize|missing_len
    )
    .expect("register body_reject_total")
});

pub static DECOMPRESS_REJECT_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "decompress_reject_total",
        "Decompression guard rejections",
        &["reason"] // unknown|stacked
    )
    .expect("register decompress_reject_total")
});

pub static POLICY_SHORTCIRCUITS_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "policy_middleware_shortcircuits_total",
        "Requests denied by policy middleware",
        &["status"] // 403|451|503
    )
    .expect("register policy_middleware_shortcircuits_total")
});

```

### crates/omnigate/src/middleware/body_caps.rs
<a id="crates-omnigate-src-middleware-bodycaps-rs"></a>

```rust
//! RO:WHAT — Request body size caps.
//! RO:WHY  — Prevent DoS and enforce hard limits early.
//! RO:BEHAVIOR —
//!   * If `Content-Length` is present and > MAX, short-circuit with 413 JSON using our error map.
//!   * If `Content-Length` is missing or <= MAX, forward but also apply Axum's body limiter
//!     (`DefaultBodyLimit::max`) to protect streaming/unknown sizes.
//!
//! RO:INVARIANTS — Keep MAX aligned with OAP/HTTP caps (default: 1 MiB). Emit metrics for oversize rejects.

use std::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};

use axum::{
    extract::DefaultBodyLimit,
    http::Request,
    response::{IntoResponse, Response},
};
use tower::{Layer, Service};

use crate::errors::{http_map, Reason};

/// Size constants (avoid clippy identity-op).
const KIB: usize = 1024;
const MIB: usize = KIB * KIB;
/// Default max body bytes (1 MiB). Keep in sync with service config later.
const MAX_BYTES: usize = MIB;

/// Public factory returning the composed guard as a tuple of layers,
/// which implements `Layer<Route>` (compatible with `Router::layer`).
pub fn layer() -> (PreflightContentLengthGuardLayer, DefaultBodyLimit) {
    (
        PreflightContentLengthGuardLayer { max: MAX_BYTES },
        DefaultBodyLimit::max(MAX_BYTES),
    )
}

/// Fast-path guard that inspects `Content-Length` and short-circuits with a 413 JSON.
#[derive(Clone, Copy)]
pub struct PreflightContentLengthGuardLayer {
    pub(crate) max: usize,
}

impl<S> Layer<S> for PreflightContentLengthGuardLayer {
    type Service = PreflightContentLengthGuard<S>;
    fn layer(&self, inner: S) -> Self::Service {
        PreflightContentLengthGuard {
            inner,
            max: self.max,
        }
    }
}

#[derive(Clone)]
pub struct PreflightContentLengthGuard<S> {
    inner: S,
    max: usize,
}

impl<S, B> Service<Request<B>> for PreflightContentLengthGuard<S>
where
    S: Service<Request<B>>,
    S::Future: Send + 'static,
    S::Response: IntoResponse,
{
    type Response = Response;
    type Error = S::Error;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        // If Content-Length is present and too big, reject immediately with our envelope.
        if let Some(len) = req
            .headers()
            .get(axum::http::header::CONTENT_LENGTH)
            .and_then(|v| v.to_str().ok())
            .and_then(|s| s.parse::<u64>().ok())
        {
            if len as usize > self.max {
                // Metrics: body oversize reject
                crate::metrics::BODY_REJECT_TOTAL
                    .with_label_values(&["oversize"])
                    .inc();

                let resp = http_map::to_response(
                    Reason::PayloadTooLarge,
                    "request body exceeds configured limit",
                )
                .into_response();
                return Box::pin(async move { Ok(resp) });
            }
        }

        let fut = self.inner.call(req);
        Box::pin(async move {
            let res = fut.await?.into_response();
            Ok(res)
        })
    }
}

```

### crates/omnigate/src/middleware/classify.rs
<a id="crates-omnigate-src-middleware-classify-rs"></a>

```rust
//! RO:WHAT — Response classifier (stub).
//! RO:WHY  — Future: classify errors for metrics; integrate with tower_http::classify.
//! RO:INVARIANTS — Bounded label cardinality; now identity.

use tower::layer::Layer;

/// Identity layer placeholder (no-op).
#[derive(Clone, Copy, Default)]
pub struct NopLayer;

impl<S> Layer<S> for NopLayer {
    type Service = S;
    fn layer(&self, inner: S) -> Self::Service {
        inner
    }
}

pub fn layer() -> NopLayer {
    NopLayer
}

```

### crates/omnigate/src/middleware/corr_id.rs
<a id="crates-omnigate-src-middleware-corrid-rs"></a>

```rust
//! RO:WHAT — Correlation-ID middleware.
//! RO:WHY  — Ensure every request/response is traceable across services.
//! RO:BEHAVIOR — reads `X-Request-Id` / `X-Correlation-Id`, generates if missing,
//!               stores in request extensions, echoes on response.

use std::{
    future::Future,
    pin::Pin,
    sync::atomic::{AtomicU64, Ordering::Relaxed},
    task::{Context, Poll},
    time::{SystemTime, UNIX_EPOCH},
};

use axum::http::{HeaderMap, HeaderValue, Request};
use axum::response::{IntoResponse, Response};
use http::header::HeaderName;
use tower::{layer::Layer, Service};
use tracing::debug;

static NEXT_SEQ: AtomicU64 = AtomicU64::new(1);

const H_REQUEST_ID: &str = "x-request-id";
const H_CORR_ID: &str = "x-correlation-id";

#[derive(Clone, Copy, Default)]
pub struct CorrIdLayer;

pub fn layer() -> CorrIdLayer {
    CorrIdLayer
}

/// Values available to downstream handlers via `req.extensions()`.
#[derive(Clone, Debug)]
pub struct CorrelationIds {
    pub request_id: String,
    pub correlation_id: String,
}

impl<S> Layer<S> for CorrIdLayer {
    type Service = CorrId<S>;
    fn layer(&self, inner: S) -> Self::Service {
        CorrId { inner }
    }
}

#[derive(Clone)]
pub struct CorrId<S> {
    inner: S,
}

impl<S, B> Service<Request<B>> for CorrId<S>
where
    S: Service<Request<B>>,
    S::Future: Send + 'static,
    S::Response: IntoResponse, // allow any axum response type
{
    type Response = Response;
    type Error = S::Error;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, mut req: Request<B>) -> Self::Future {
        // Extract or generate IDs, then stash into extensions.
        let (req_id, corr_id) = extract_or_generate(req.headers());
        req.extensions_mut().insert(CorrelationIds {
            request_id: req_id.clone(),
            correlation_id: corr_id.clone(),
        });

        debug!(request_id = %req_id, correlation_id = %corr_id, "corr_id assigned");

        let add_headers = move |headers: &mut HeaderMap| {
            if !headers.contains_key(H_REQUEST_ID) {
                if let Ok(v) = HeaderValue::from_str(&req_id) {
                    headers.insert(HeaderName::from_static(H_REQUEST_ID), v);
                }
            }
            if !headers.contains_key(H_CORR_ID) {
                if let Ok(v) = HeaderValue::from_str(&corr_id) {
                    headers.insert(HeaderName::from_static(H_CORR_ID), v);
                }
            }
        };

        let fut = self.inner.call(req);
        Box::pin(async move {
            // Convert to a concrete axum Response so we can mutate headers.
            let mut res: Response = fut.await?.into_response();
            add_headers(res.headers_mut());
            Ok(res)
        })
    }
}

/// Pull IDs from headers (case-insensitive); generate if absent.
fn extract_or_generate(headers: &HeaderMap) -> (String, String) {
    let rid = get_header(headers, H_REQUEST_ID);
    let cid = get_header(headers, H_CORR_ID);

    match (rid, cid) {
        (Some(r), Some(c)) => (r, c),
        (Some(r), None) => (r.clone(), r),
        (None, Some(c)) => (generate_id(), c),
        (None, None) => {
            let r = generate_id();
            (r.clone(), r)
        }
    }
}

fn get_header(headers: &HeaderMap, name: &'static str) -> Option<String> {
    headers
        .get(name)
        .and_then(|v| v.to_str().ok().map(|s| s.to_owned()))
}

/// Generate a compact 16-hex ID without extra deps.
fn generate_id() -> String {
    let millis = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_millis())
        .unwrap_or(0);
    let seq = NEXT_SEQ.fetch_add(1, Relaxed) as u128;

    let combined = (millis << 16) ^ (seq & 0xFFFF);
    let mut s = format!("{combined:x}");
    if s.len() > 16 {
        s.truncate(16);
    } else {
        while s.len() < 16 {
            s.insert(0, '0');
        }
    }
    s
}

```

### crates/omnigate/src/middleware/decompress_guard.rs
<a id="crates-omnigate-src-middleware-decompressguard-rs"></a>

```rust
//! RO:WHAT — Decompression guard for request bodies.
//! RO:WHY  — Stop risky encodings and cap potential decompression-bomb expansion at the edge.
//!
//! RO:BEHAVIOR —
//!   • Reject unsupported or stacked encodings with 415 (Unsupported Media Type) using our envelope.
//!   • Allow only: identity (or none), gzip, deflate, br.
//!   • If compressed (gzip/deflate/br) and Content-Length is present, require:
//!         content_length <= MAX_EXPANDED / EXPANSION_CAP
//!     so a worst-case expansion <= MAX_EXPANDED (default 1 MiB).
//!   • Streaming / unknown sizes are still protected by body caps (DefaultBodyLimit) in `body_caps`.
//!
//! RO:INVARIANTS — No decompression here (pure guard). Keep budgets aligned with body caps.

use std::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};

use axum::{
    http::Request,
    response::{IntoResponse, Response},
};
use tower::{Layer, Service};

use crate::errors::{http_map, Reason};

const KIB: usize = 1024;
const MIB: usize = KIB * KIB;

/// Max allowed post-inflate size (should match body cap).
const MAX_EXPANDED: usize = MIB; // 1 MiB

/// Worst-case expansion factor we budget for compressed bodies.
const EXPANSION_CAP: usize = 10;

/// Encodings we accept. Order matters when stacked (we deny stacks for now).
const ENC_IDENTITY: &str = "identity";
const ENC_GZIP: &str = "gzip";
const ENC_DEFLATE: &str = "deflate";
const ENC_BR: &str = "br";

#[derive(Clone, Copy, Default)]
pub struct DecompressGuardLayer;

pub fn layer() -> DecompressGuardLayer {
    DecompressGuardLayer
}

impl<S> Layer<S> for DecompressGuardLayer {
    type Service = DecompressGuard<S>;
    fn layer(&self, inner: S) -> Self::Service {
        DecompressGuard { inner }
    }
}

#[derive(Clone)]
pub struct DecompressGuard<S> {
    inner: S,
}

impl<S, B> Service<Request<B>> for DecompressGuard<S>
where
    S: Service<Request<B>>,
    S::Future: Send + 'static,
    S::Response: IntoResponse,
{
    type Response = Response;
    type Error = S::Error;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        // Parse Content-Encoding (may be comma-separated per RFC). Keep owned Strings locally.
        let enc_header = req
            .headers()
            .get(axum::http::header::CONTENT_ENCODING)
            .and_then(|v| v.to_str().ok())
            .unwrap_or("")
            .trim();

        // Normalize to lowercase, trim, drop empties.
        let encodings: Vec<String> = if enc_header.is_empty() {
            Vec::new()
        } else {
            enc_header
                .split(',')
                .map(|s| s.trim())
                .filter(|s| !s.is_empty())
                .map(|s| s.to_ascii_lowercase())
                .collect()
        };

        // Reject stacked encodings for now (complex, rare, riskier).
        if encodings.len() > 1 {
            // Metrics: stacked encoding reject
            crate::metrics::DECOMPRESS_REJECT_TOTAL
                .with_label_values(&["stacked"])
                .inc();

            let resp = http_map::to_response(
                Reason::UnsupportedMediaType,
                "stacked Content-Encoding not supported",
            )
            .into_response();
            return Box::pin(async move { Ok(resp) });
        }

        // Validate single (or none).
        let is_compressed = if let Some(enc) = encodings.first().map(String::as_str) {
            match enc {
                ENC_IDENTITY => false,
                ENC_GZIP | ENC_DEFLATE | ENC_BR => true,
                // Disallow everything else (e.g., compress, zstd (not negotiated here), etc.)
                _ => {
                    // Metrics: unknown/unsupported encoding reject
                    crate::metrics::DECOMPRESS_REJECT_TOTAL
                        .with_label_values(&["unknown"])
                        .inc();

                    let resp = http_map::to_response(
                        Reason::UnsupportedMediaType,
                        "unsupported Content-Encoding",
                    )
                    .into_response();
                    return Box::pin(async move { Ok(resp) });
                }
            }
        } else {
            false
        };

        // If compressed: enforce conservative expansion budget using Content-Length if present.
        if is_compressed {
            if let Some(cl) = req
                .headers()
                .get(axum::http::header::CONTENT_LENGTH)
                .and_then(|v| v.to_str().ok())
                .and_then(|s| s.parse::<u64>().ok())
            {
                // require compressed_length * EXPANSION_CAP <= MAX_EXPANDED
                if (cl as usize).saturating_mul(EXPANSION_CAP) > MAX_EXPANDED {
                    // Metrics: expansion budget reject
                    crate::metrics::DECOMPRESS_REJECT_TOTAL
                        .with_label_values(&["over_budget"])
                        .inc();

                    let resp = http_map::to_response(
                        Reason::PayloadTooLarge,
                        "compressed body exceeds allowed expansion budget",
                    )
                    .into_response();
                    return Box::pin(async move { Ok(resp) });
                }
            }
            // If no Content-Length, runtime streaming limit in `body_caps` still protects us.
        }

        let fut = self.inner.call(req);
        Box::pin(async move {
            let res = fut.await?.into_response();
            Ok(res)
        })
    }
}

```

### crates/omnigate/src/middleware/mod.rs
<a id="crates-omnigate-src-middleware-mod-rs"></a>

```rust
//! RO:WHAT
//! Omnigate middleware stack assembly.
//!
//! Order matters — inexpensive, shedding layers first.

use axum::Router;

pub mod body_caps;
pub mod classify;
pub mod corr_id;
pub mod decompress_guard;
pub mod slow_loris;

pub fn apply(router: Router) -> Router {
    // NOTE: Admission is currently a no-op shim to keep bounds simple.
    // When fair_queue/quotas are ready, we can call `crate::admission::attach(router)`
    // *before* the rest of the layers.
    router
        // Correlation ID before responses are built.
        .layer(corr_id::layer())
        // Gentle early classification (currently NOP placeholder).
        .layer(classify::layer())
        // Guard against content-encoding pitfalls.
        .layer(decompress_guard::layer())
        // Body size caps & preflight length checks.
        .layer(body_caps::layer())
        // Slow-loris / header timeouts (placeholder for now).
        .layer(slow_loris::layer())
}

```

### crates/omnigate/src/middleware/policy.rs
<a id="crates-omnigate-src-middleware-policy-rs"></a>

```rust
//! RO:WHAT   Thin policy middleware that consults ron-policy Evaluator.
//! RO:WHY    Keep policy out of business handlers; centralize allow/deny.
//! RO:INVARS  Respect config.fail_mode when evaluator unavailable; bounded context; low-cardinality labels.

use std::sync::Arc;

use axum::{extract::Request, http::StatusCode, response::IntoResponse};
use futures_util::future::BoxFuture;
use tower::{Layer, Service};

use crate::errors::GateError;
use crate::metrics::POLICY_SHORTCIRCUITS_TOTAL;
use crate::state::AppState;

#[derive(Clone)]
pub struct PolicyLayer;

impl<S> Layer<S> for PolicyLayer {
    type Service = PolicyService<S>;
    fn layer(&self, inner: S) -> Self::Service { PolicyService { inner } }
}

#[derive(Clone)]
pub struct PolicyService<S> {
    inner: S,
}

impl<S> Service<Request> for PolicyService<S>
where
    S: Service<Request> + Clone + Send + 'static,
    S::Response: IntoResponse + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<Box<dyn std::error::Error + Send + Sync>> + Send + 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = BoxFuture<'static, Result<Self::Response, Self::Error>>;

    fn poll_ready(&mut self, cx: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
        futures_util::ready!(futures_util::future::poll_fn(|cx| self.inner.poll_ready(cx)).poll_unpin(cx));
        std::task::Poll::Ready(Ok(()))
    }

    fn call(&mut self, req: Request) -> Self::Future {
        let mut inner = self.inner.clone();

        BoxFuture::from(async move {
            let state = req.extensions().get::<Arc<AppState>>().cloned();

            if let Some(state) = state {
                if let Some(eval) = state.policy.clone() {
                    // Minimal ron-policy input
                    let method = req.method().as_str().to_owned();
                    let path = req.uri().path().to_owned();
                    let tenant = state.tenant.clone().unwrap_or_else(|| "default".to_string());

                    let ctx = ron_policy::EvalContext {
                        tenant,
                        method,
                        path,
                        region: state.region.clone().unwrap_or_default(),
                        tags: state.tags_for(&req),
                        ..Default::default()
                    };

                    match eval.evaluate(&ctx) {
                        Ok(dec) if dec.effect.is_allow() => inner.call(req).await,
                        Ok(dec) => {
                            let status = if dec.reason.as_deref() == Some("LEGAL") {
                                StatusCode::UNAVAILABLE_FOR_LEGAL_REASONS
                            } else {
                                StatusCode::FORBIDDEN
                            };
                            POLICY_SHORTCIRCUITS_TOTAL.with_label_values(&[status.as_str()]).inc();
                            let resp = GateError::PolicyDeny {
                                reason: dec.reason.as_deref().unwrap_or("DENY"),
                                status,
                            }
                            .into_response();
                            Ok(axum::response::IntoResponse::into_response(resp).into())
                        }
                        Err(_) => {
                            POLICY_SHORTCIRCUITS_TOTAL.with_label_values(&["503"]).inc();
                            let resp = GateError::PolicyError.into_response();
                            Ok(axum::response::IntoResponse::into_response(resp).into())
                        }
                    }
                } else if state.config.policy.fail_deny() {
                    POLICY_SHORTCIRCUITS_TOTAL.with_label_values(&["403"]).inc();
                    let resp = GateError::PolicyDeny {
                        reason: "NO_EVALUATOR",
                        status: StatusCode::FORBIDDEN,
                    }
                    .into_response();
                    return Ok(axum::response::IntoResponse::into_response(resp).into());
                }
            }

            inner.call(req).await
        })
    }
}

```

### crates/omnigate/src/middleware/slow_loris.rs
<a id="crates-omnigate-src-middleware-slowloris-rs"></a>

```rust
//! RO:WHAT — Slow-loris protection (stub).
//! RO:WHY  — Future: per-read header/body timeouts, idle caps; now identity.
//! RO:INVARIANTS — Avoid false positives under load when enabled.

use tower::layer::Layer;

/// Identity layer placeholder (no-op).
#[derive(Clone, Copy, Default)]
pub struct NopLayer;

impl<S> Layer<S> for NopLayer {
    type Service = S;
    fn layer(&self, inner: S) -> Self::Service {
        inner
    }
}

pub fn layer() -> NopLayer {
    NopLayer
}

```

### crates/omnigate/src/observability/logging.rs
<a id="crates-omnigate-src-observability-logging-rs"></a>

```rust

```

### crates/omnigate/src/observability/mod.rs
<a id="crates-omnigate-src-observability-mod-rs"></a>

```rust
//! RO:WHAT — Tracing init + HTTP trace layer.
//! RO:WHY  — Uniform logs + RED metrics; Concerns: OBS/PERF.
//! RO:INVARIANTS — Bounded labels; no PII in logs.

use tower_http::trace::TraceLayer;
use tracing_subscriber::{fmt, EnvFilter};

pub fn init_tracing() {
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).compact().init();
}

pub fn http_trace_layer(
) -> TraceLayer<tower_http::classify::SharedClassifier<tower_http::classify::ServerErrorsAsFailures>>
{
    TraceLayer::new_for_http()
}

```

### crates/omnigate/src/observability/tracing_spans.rs
<a id="crates-omnigate-src-observability-tracingspans-rs"></a>

```rust

```

### crates/omnigate/src/pq/mod.rs
<a id="crates-omnigate-src-pq-mod-rs"></a>

```rust

```

### crates/omnigate/src/pq/negotiate.rs
<a id="crates-omnigate-src-pq-negotiate-rs"></a>

```rust

```

### crates/omnigate/src/readiness/keys.rs
<a id="crates-omnigate-src-readiness-keys-rs"></a>

```rust

```

### crates/omnigate/src/readiness/mod.rs
<a id="crates-omnigate-src-readiness-mod-rs"></a>

```rust
pub mod policy;

```

### crates/omnigate/src/readiness/policy.rs
<a id="crates-omnigate-src-readiness-policy-rs"></a>

```rust
//! RO:WHAT   Compute /readyz based on inflight, 429/503 error rate, queue saturation.
//! RO:WHY    Truthful readiness prevents cascading failure during overload.
//! RO:INVARS Hold degraded state for cfg.hold_for; do not flap rapidly.
//!
//! Notes:
//! - Emits Prometheus metrics (gauges + counters) under `crate::metrics::gates::*`.
//! - We only count a transition when the state actually changes
//!   (i.e., we don't increment on every `ready()` call while already degraded).

use parking_lot::Mutex;
use std::sync::Arc;
use std::time::{Duration, Instant};

// ---- Readiness configuration ------------------------------------------------

#[derive(Clone)]
pub struct ReadyCfg {
    /// Max allowed in-flight requests before we degrade readiness.
    pub max_inflight_threshold: u64,
    /// Rolling 429/503 error rate (percentage, e.g., 2.0 means 2%) to trip readiness.
    pub error_rate_pct: f64,
    /// Window over which error rate is computed.
    pub window: Duration,
    /// How long to hold degraded state before returning to ready (anti-flap).
    pub hold_for: Duration,
}

// ---- Internal state ---------------------------------------------------------

#[derive(Default)]
struct State {
    last_trip: Option<Instant>,
    inflight: u64,
    rolling_err_rate: f64,
    queue_saturated: bool,
}

// ---- Policy -----------------------------------------------------------------

#[derive(Clone, Default)]
pub struct ReadyPolicy {
    cfg: ReadyCfg,
    state: Arc<Mutex<State>>,
}

impl ReadyPolicy {
    pub fn new(cfg: ReadyCfg) -> Self {
        Self {
            cfg,
            state: Default::default(),
        }
    }

    /// Update current in-flight request count (called by admission/queues).
    pub fn update_inflight(&self, v: u64) {
        {
            self.state.lock().inflight = v;
        }
        // Gauge: ready_inflight_current
        crate::metrics::gates::READY_INFLIGHT_CURRENT.set(v as i64);
    }

    /// Update rolling error rate percentage (0.0–100.0) for 429/503s.
    pub fn update_err_rate(&self, pct: f64) {
        {
            self.state.lock().rolling_err_rate = pct;
        }
        // Gauge: ready_error_rate_pct
        crate::metrics::gates::READY_ERROR_RATE_PCT.set(pct);
    }

    /// Mark whether the queue/dispatcher is saturated (backpressure).
    pub fn set_queue_saturated(&self, yes: bool) {
        {
            self.state.lock().queue_saturated = yes;
        }
        // Gauge: ready_queue_saturated (0/1)
        crate::metrics::gates::READY_QUEUE_SATURATED.set(if yes { 1 } else { 0 });
    }

    /// Compute whether the service is currently ready.
    ///
    /// Returns `true` when ready; `false` when degraded.
    /// Holds degraded state for `cfg.hold_for` to avoid flapping.
    pub fn ready(&self) -> bool {
        let mut s = self.state.lock();
        let now = Instant::now();

        // Trip conditions (in priority order to label the reason deterministically).
        let inflight_trip = s.inflight > self.cfg.max_inflight_threshold;
        let err_rate_trip = s.rolling_err_rate >= self.cfg.error_rate_pct;
        let queue_trip = s.queue_saturated;
        let tripped = inflight_trip || err_rate_trip || queue_trip;

        if tripped {
            // Only count a transition when we *enter* degraded (avoid double-counting).
            let entering_degraded = s.last_trip.is_none();
            if entering_degraded {
                // Counter: ready_trips_total{reason=...}
                if inflight_trip {
                    crate::metrics::gates::READY_TRIPS_TOTAL
                        .with_label_values(&["inflight"])
                        .inc();
                } else if err_rate_trip {
                    crate::metrics::gates::READY_TRIPS_TOTAL
                        .with_label_values(&["err_rate"])
                        .inc();
                } else if queue_trip {
                    crate::metrics::gates::READY_TRIPS_TOTAL
                        .with_label_values(&["queue"])
                        .inc();
                }
                // Counter: ready_state_changes_total{to="degraded"}
                crate::metrics::gates::READY_STATE_CHANGES_TOTAL
                    .with_label_values(&["degraded"])
                    .inc();
            }
            s.last_trip = Some(now);
            return false;
        }

        // If previously degraded, enforce hold period before returning to ready.
        if let Some(t) = s.last_trip {
            if now.duration_since(t) < self.cfg.hold_for {
                return false;
            }
            // Transition: degraded -> ready
            s.last_trip = None;
            crate::metrics::gates::READY_STATE_CHANGES_TOTAL
                .with_label_values(&["ready"])
                .inc();
        }

        true
    }
}

```

### crates/omnigate/src/routes/mod.rs
<a id="crates-omnigate-src-routes-mod-rs"></a>

```rust
//! RO:WHAT — Route modules aggregation.
//! RO:WHY  — Keep the tree organized exactly like TODO.
//! RO:INTERACTS — ops.rs, v1::*, future middleware/auth/admission.

pub mod ops;
pub mod v1;

```

### crates/omnigate/src/routes/ops.rs
<a id="crates-omnigate-src-routes-ops-rs"></a>

```rust
//! RO:WHAT — Ops/administration endpoints (version, health, ready).
//! RO:WHY  — Keep admin plane consistent and DTO-stable.
//! RO:INVARIANTS — Shapes match types::dto; no secret/PII in responses.

use crate::types::VersionResponse;
use axum::{response::IntoResponse, Json};

/// GET /versionz (or /ops/version if routed) — returns service version and optional git short hash.
/// Wire shape: VersionResponse { version: String, git: Option<String> }.
pub async fn versionz() -> impl IntoResponse {
    // Prefer compile-time embed from build.rs; fall back to runtime env (CI can export it).
    let git = option_env!("GIT_COMMIT_SHORT")
        .map(|s| s.to_string())
        .or_else(|| std::env::var("GIT_COMMIT_SHORT").ok());

    Json(VersionResponse {
        version: env!("CARGO_PKG_VERSION").to_string(),
        git,
    })
}

/// Back-compat shim so existing router entries calling `routes::ops::version` still work.
pub async fn version() -> impl IntoResponse {
    versionz().await
}

```

### crates/omnigate/src/routes/v1/dht.rs
<a id="crates-omnigate-src-routes-v1-dht-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/facet/feed.rs
<a id="crates-omnigate-src-routes-v1-facet-feed-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/facet/graph.rs
<a id="crates-omnigate-src-routes-v1-facet-graph-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/facet/media.rs
<a id="crates-omnigate-src-routes-v1-facet-media-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/facet/mod.rs
<a id="crates-omnigate-src-routes-v1-facet-mod-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/index.rs
<a id="crates-omnigate-src-routes-v1-index-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/mailbox.rs
<a id="crates-omnigate-src-routes-v1-mailbox-rs"></a>

```rust

```

### crates/omnigate/src/routes/v1/mod.rs
<a id="crates-omnigate-src-routes-v1-mod-rs"></a>

```rust
//! RO:WHAT — v1 public surface (ping, basic read-only checks).
//! RO:WHY  — DTO-stable, tiny confidence checks for clients.
//! RO:INVARIANTS — Never leak internals; ping shape matches PingResponse.

use crate::types::PingResponse;
use axum::{routing::get, Json, Router};

pub fn router() -> Router {
    Router::new().route("/ping", get(ping))
}

/// Public so the top-level router in lib.rs can reference it directly.
pub async fn ping() -> Json<PingResponse> {
    // Current DTO is `{ ok: bool }` — no timestamp field.
    Json(PingResponse { ok: true })
}

```

### crates/omnigate/src/routes/v1/objects.rs
<a id="crates-omnigate-src-routes-v1-objects-rs"></a>

```rust

```

### crates/omnigate/src/runtime/channels.rs
<a id="crates-omnigate-src-runtime-channels-rs"></a>

```rust
//! RO:WHAT — Message channels between supervisor and workers.
//! RO:WHY  — Broadcast down (supervisor→workers), MPSC up (workers→supervisor).

use tokio::sync::{broadcast, mpsc};

#[derive(Debug, Clone)]
pub enum SupervisorMsg {
    /// Ask all workers to stop gracefully.
    Stop,
    /// Future: reload config, etc.
    Nop,
}

#[derive(Debug)]
pub enum WorkerMsg {
    Started(&'static str),
    Stopped(&'static str),
}

pub use broadcast::{Receiver as BcastRx, Sender as BcastTx};
pub use mpsc::{Receiver as MpscRx, Sender as MpscTx};

/// Build the control plane channels.
/// - `worker_backlog`: size of the per-worker upstream MPSC buffer.
pub fn mk_supervisor_bus(
    worker_backlog: usize,
) -> (
    BcastTx<SupervisorMsg>,
    BcastRx<SupervisorMsg>,
    MpscTx<WorkerMsg>,
    MpscRx<WorkerMsg>,
) {
    let (tx_cmd, rx_cmd) = broadcast::channel(16);
    let (up_tx, up_rx) = mpsc::channel(worker_backlog);
    (tx_cmd, rx_cmd, up_tx, up_rx)
}

```

### crates/omnigate/src/runtime/mod.rs
<a id="crates-omnigate-src-runtime-mod-rs"></a>

```rust
//! RO:WHAT — Lightweight runtime layer: supervised background workers + cooperative shutdown.
//! RO:WHY  — Keep App/router lean; side-loops (samplers, refreshers, warmers) live here.
//! RO:INTERACTS — ron-kernel (Bus/Events), Metrics (recorders), admission, policy.
//! RO:INVARIANTS — Single owner per worker task; graceful stop within timeout; no locks across .await.

mod channels;
mod shutdown;
mod supervisor;
mod worker;

pub mod sample;

pub use channels::{mk_supervisor_bus, SupervisorMsg, WorkerMsg};
pub use shutdown::{pair as shutdown_pair, Shutdown, ShutdownTrigger};
pub use supervisor::{spawn_supervisor, SupervisorHandle};
pub use worker::{spawn_worker, DynWorker, Worker};

```

### crates/omnigate/src/runtime/sample.rs
<a id="crates-omnigate-src-runtime-sample-rs"></a>

```rust
//! RO:WHAT — Example worker used by tests and as a template.
//! RO:WHY  — Minimal worker that exits on shutdown or Stop.

use std::{future::Future, pin::Pin, sync::Arc};
use tokio::sync::{broadcast, mpsc};
use tracing::info;

use super::channels::{SupervisorMsg, WorkerMsg};
use super::shutdown::Shutdown;
use super::worker::Worker;

#[derive(Default)]
pub struct TickWorker;

impl TickWorker {
    pub fn new() -> Arc<Self> {
        Arc::new(Self)
    }
}

impl Worker for TickWorker {
    fn name(&self) -> &'static str {
        "tick"
    }

    fn run(
        &self,
        shutdown: Shutdown,
        mut commands: broadcast::Receiver<SupervisorMsg>,
        up_tx: mpsc::Sender<WorkerMsg>,
    ) -> Pin<Box<dyn Future<Output = ()> + Send>> {
        Box::pin(async move {
            loop {
                tokio::select! {
                    _ = shutdown.cancelled() => {
                        break;
                    }
                    Ok(msg) = commands.recv() => {
                        if let SupervisorMsg::Stop = msg {
                            break;
                        }
                    }
                }
            }
            let _ = up_tx.send(WorkerMsg::Stopped("tick")).await;
            info!("tick worker exiting");
        })
    }
}

```

### crates/omnigate/src/runtime/shutdown.rs
<a id="crates-omnigate-src-runtime-shutdown-rs"></a>

```rust
//! RO:WHAT — Cooperative shutdown primitives.
//! RO:WHY  — A tiny CancellationToken wrapper so workers/supervisor can agree on quit.
//! RO:INVARIANTS — Non-blocking; clone is cheap; `cancelled()` is awaitable.

use tokio_util::sync::CancellationToken;

/// Handle that tasks can hold/clone to observe shutdown.
#[derive(Clone)]
pub struct Shutdown {
    token: CancellationToken,
}

/// Trigger used by the supervisor to request shutdown.
#[derive(Clone)]
pub struct ShutdownTrigger {
    token: CancellationToken,
}

/// Construct a (Shutdown, ShutdownTrigger) pair.
pub fn pair() -> (Shutdown, ShutdownTrigger) {
    let token = CancellationToken::new();
    (
        Shutdown {
            token: token.clone(),
        },
        ShutdownTrigger { token },
    )
}

impl Shutdown {
    /// Wait until shutdown is requested.
    pub async fn cancelled(&self) {
        self.token.cancelled().await;
    }
}

impl ShutdownTrigger {
    /// Request shutdown for all holders of the paired `Shutdown`.
    pub fn cancel(&self) {
        self.token.cancel();
    }
}

```

### crates/omnigate/src/runtime/supervisor.rs
<a id="crates-omnigate-src-runtime-supervisor-rs"></a>

```rust
//! RO:WHAT — Spawns and coordinates all workers.
//! RO:WHY  — Single place that can trigger graceful shutdown and fan-out commands.

use tokio::{sync::broadcast, task::JoinHandle};
use tracing::info;

use super::channels::{mk_supervisor_bus, MpscRx, SupervisorMsg};
use super::shutdown::{pair as shutdown_pair, ShutdownTrigger};
use super::worker::{spawn_worker, DynWorker};

pub struct SupervisorHandle {
    pub join: JoinHandle<()>,
    pub tx_cmd: broadcast::Sender<SupervisorMsg>,
    pub shutdown: ShutdownTrigger,
    pub up_rx: MpscRx<super::channels::WorkerMsg>,
}

pub fn spawn_supervisor(workers: Vec<DynWorker>, worker_backlog: usize) -> SupervisorHandle {
    let (tx_cmd, _rx_cmd, up_tx, up_rx) = mk_supervisor_bus(worker_backlog);
    let tx_cmd_for_task = tx_cmd.clone();

    let (shutdown, trigger) = shutdown_pair();

    let join = tokio::spawn(async move {
        // spawn all workers
        let mut joins: Vec<JoinHandle<()>> = Vec::with_capacity(workers.len());
        for w in workers {
            let rx = tx_cmd_for_task.subscribe();
            let j = spawn_worker(w, shutdown.clone(), rx, up_tx.clone());
            joins.push(j);
        }

        // Wait for shutdown, then ask everyone to stop.
        shutdown.cancelled().await;
        let _ = tx_cmd_for_task.send(SupervisorMsg::Stop);

        // Drain joins.
        for j in joins {
            let _ = j.await;
        }
        info!("supervisor exited");
    });

    SupervisorHandle {
        join,
        tx_cmd,
        shutdown: trigger,
        up_rx,
    }
}

```

### crates/omnigate/src/runtime/worker.rs
<a id="crates-omnigate-src-runtime-worker-rs"></a>

```rust
//! RO:WHAT — Worker trait + spawner glue.
//! RO:WHY  — Lets us run heterogeneous background tasks under a supervisor.

use std::{future::Future, pin::Pin, sync::Arc};
use tokio::{
    sync::{broadcast, mpsc},
    task::JoinHandle,
};
use tracing::info;

use super::channels::{SupervisorMsg, WorkerMsg};
use super::shutdown::Shutdown;

/// Vtable for a managed worker.
pub trait Worker: Send + Sync + 'static {
    fn name(&self) -> &'static str;

    fn run(
        &self,
        shutdown: Shutdown,
        commands: broadcast::Receiver<SupervisorMsg>,
        up_tx: mpsc::Sender<WorkerMsg>,
    ) -> Pin<Box<dyn Future<Output = ()> + Send>>;
}

pub type DynWorker = Arc<dyn Worker>;

pub fn spawn_worker(
    w: DynWorker,
    shutdown: Shutdown,
    commands: broadcast::Receiver<SupervisorMsg>,
    up_tx: mpsc::Sender<WorkerMsg>,
) -> JoinHandle<()> {
    let name = w.name();
    tokio::spawn(async move {
        // Let the supervisor know we’re starting.
        let _ = up_tx.send(WorkerMsg::Started(name)).await;

        // Run the worker future to completion.
        let fut = (*w).run(shutdown, commands, up_tx.clone());
        fut.await;

        info!(worker = name, "worker exited");
        // Best-effort notify stop.
        let _ = up_tx.send(WorkerMsg::Stopped(name)).await;
    })
}

```

### crates/omnigate/src/state.rs
<a id="crates-omnigate-src-state-rs"></a>

```rust
//! RO:WHAT   Shared application state container.
//! RO:WHY    Centralize config, policy evaluator, readiness policy, and helpers.

use std::sync::Arc;
use crate::readiness::policy::ReadyPolicy;

#[derive(Clone)]
pub struct AppState {
    pub config: Arc<crate::config::Config>,
    pub ready: ReadyPolicy,
    pub policy: Option<ron_policy::Evaluator>,
    pub tenant: Option<String>,
    pub region: Option<String>,
}

impl AppState {
    pub fn new(config: Arc<crate::config::Config>, ready: ReadyPolicy, policy: Option<ron_policy::Evaluator>) -> Arc<Self> {
        Arc::new(Self { config, ready, policy, tenant: None, region: None })
    }

    pub fn tags_for<B>(&self, _req: &axum::http::Request<B>) -> Vec<String> {
        // Future: pull auth claims or route-classifier tags.
        Vec::new()
    }
}

```

### crates/omnigate/src/types/dto.rs
<a id="crates-omnigate-src-types-dto-rs"></a>

```rust
//! RO:WHAT — Public response DTOs the API returns.
//! RO:WHY  — Tests serialize/deserialize these; keep stable wire shape.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct VersionResponse {
    pub version: String,
    /// Optional short git hash if available.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub git: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct PingResponse {
    pub ok: bool,
}

```

### crates/omnigate/src/types/mod.rs
<a id="crates-omnigate-src-types-mod-rs"></a>

```rust
pub mod dto;

pub use dto::{PingResponse, VersionResponse};

```

### crates/omnigate/src/zk/mod.rs
<a id="crates-omnigate-src-zk-mod-rs"></a>

```rust
//! RO:WHAT — Zero-knowledge–ready envelope surface.
//! RO:WHY  — Carve clean seams (read-only vs mutate) + receipts without committing to a prover.
//! RO:INVARIANTS — No proof code here; only types and gating logic surfaces.

pub mod no_mutate;
pub mod receipts;

pub use no_mutate::{OpClass, OpGuard};
pub use receipts::{Receipt, ReceiptId, ReceiptStatus};

```

### crates/omnigate/src/zk/no_mutate.rs
<a id="crates-omnigate-src-zk-nomutate-rs"></a>

```rust
//! RO:WHAT — Read-only vs Mutate operation gating.
//! RO:WHY  — Allow policy/rate-limit paths to key off operation class.
//! RO:INVARIANTS — Pure classification; no IO; easy to unit test.

/// Operation class used by admissions/policy.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OpClass {
    ReadOnly,
    Mutate,
}

/// Guard object carried in request extensions to mark op class.
#[derive(Debug, Clone, Copy)]
pub struct OpGuard {
    class: OpClass,
}

impl OpGuard {
    pub fn new(class: OpClass) -> Self {
        Self { class }
    }
    pub fn class(&self) -> OpClass {
        self.class
    }
}

```

### crates/omnigate/src/zk/receipts.rs
<a id="crates-omnigate-src-zk-receipts-rs"></a>

```rust
//! RO:WHAT — Generic receipt type for mutating operations.
//! RO:WHY  — Provide durable handle for async/queued mutations without picking a backend yet.
//! RO:INVARIANTS — Opaque ids; monotonic timestamps; status is conservative.

use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

pub type ReceiptId = String;

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ReceiptStatus {
    Accepted,
    Processing,
    Completed,
    Failed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Receipt {
    pub id: ReceiptId,
    pub status: ReceiptStatus,
    pub created_ms: u128,
    pub last_update_ms: u128,
}

impl Receipt {
    pub fn new(id: ReceiptId) -> Self {
        let now = now_ms();
        Self {
            id,
            status: ReceiptStatus::Accepted,
            created_ms: now,
            last_update_ms: now,
        }
    }
    pub fn set_status(&mut self, s: ReceiptStatus) {
        self.status = s;
        self.last_update_ms = now_ms();
    }
}

fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

```

### crates/omnigate/testing/chaos/scenario.yml
<a id="crates-omnigate-testing-chaos-scenario-yml"></a>

```yaml
# Scaffold example for chaos; fill with providers and injections.
injections: []

```

### crates/omnigate/testing/performance/baselines/p95_hydration.json
<a id="crates-omnigate-testing-performance-baselines-p95hydration-json"></a>

```json
{"p95_ms":150}

```

### crates/omnigate/testing/performance/baselines/p95_range.json
<a id="crates-omnigate-testing-performance-baselines-p95range-json"></a>

```json
{"p95_ms":100}

```

### crates/omnigate/testing/performance/hydrate_mix.sh
<a id="crates-omnigate-testing-performance-hydratemix-sh"></a>

```bash
#!/usr/bin/env bash
# Scaffold: put your loadgen here and assert p95 targets.

```

### crates/omnigate/testing/vectors/omnigate/error_413.json
<a id="crates-omnigate-testing-vectors-omnigate-error413-json"></a>

```json

```

### crates/omnigate/testing/vectors/omnigate/range_read.json
<a id="crates-omnigate-testing-vectors-omnigate-rangeread-json"></a>

```json

```

### crates/omnigate/testing/vectors/omnigate/unauth_401.json
<a id="crates-omnigate-testing-vectors-omnigate-unauth401-json"></a>

```json

```

### crates/omnigate/tests/admission_contract.rs
<a id="crates-omnigate-tests-admissioncontract-rs"></a>

```rust
// RO:WHAT
// Contract checks for simple "admission-style" guards wired via `from_fn_with_state`.
// These are *test-only* helpers to make sure our layering semantics and extractor
// signatures are correct under Axum 0.7.

use axum::{
    body::Body,
    extract::State,
    http::{Request, StatusCode},
    middleware::{from_fn_with_state, Next},
    response::{IntoResponse, Response},
    routing::get,
    Router,
};
use std::sync::{
    atomic::{AtomicUsize, Ordering},
    Arc,
};
use tower::ServiceExt;

// ----- Tiny quota guard -------------------------------------------------------

#[derive(Debug, Default)]
struct Tiny {
    // "hard" is a max-requests-left style counter.
    hard: AtomicUsize,
    // "soft" unused in these tiny tests but parked here for parity with previous shape.
    #[allow(dead_code)]
    soft: AtomicUsize,
}

async fn tiny_guard(State(state): State<Arc<Tiny>>, req: Request<Body>, next: Next) -> Response {
    // If no budget left, 429 immediately (cheap shed).
    if state.hard.load(Ordering::Relaxed) == 0 {
        return StatusCode::TOO_MANY_REQUESTS.into_response();
    }
    // Decrement and pass through.
    state.hard.fetch_sub(1, Ordering::Relaxed);
    next.run(req).await
}

// ----- "Once" guard (allow exactly one) --------------------------------------

#[derive(Debug)]
struct Once(AtomicUsize);

async fn once_guard(State(state): State<Arc<Once>>, req: Request<Body>, next: Next) -> Response {
    // First request allowed (counter set to 1), subsequent ones 429.
    if state.0.fetch_sub(1, Ordering::Relaxed) == 0 {
        return StatusCode::TOO_MANY_REQUESTS.into_response();
    }
    next.run(req).await
}

// ----- Tests -----------------------------------------------------------------

#[tokio::test]
async fn tiny_quota_allows_then_429s() {
    // Start with budget=2.
    let tiny = Arc::new(Tiny {
        hard: AtomicUsize::new(2),
        soft: AtomicUsize::new(0),
    });

    let app = Router::new()
        .route("/", get(|| async { "ok" }))
        .layer(from_fn_with_state(tiny.clone(), tiny_guard));

    // First two requests ok…
    let res = app
        .clone()
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::OK);

    let res = app
        .clone()
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::OK);

    // …third should be shed.
    let res = app
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::TOO_MANY_REQUESTS);
}

#[tokio::test]
async fn quota_when_exhausted_429() {
    // Allow exactly one request.
    let once = Arc::new(Once(AtomicUsize::new(1)));

    let app = Router::new()
        .route("/", get(|| async { "ok" }))
        .layer(from_fn_with_state(once.clone(), once_guard));

    // First request OK…
    let res = app
        .clone()
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::OK);

    // …second is 429.
    let res = app
        .oneshot(Request::get("/").body(Body::empty()).unwrap())
        .await
        .unwrap();
    assert_eq!(res.status(), StatusCode::TOO_MANY_REQUESTS);
}

```

### crates/omnigate/tests/dto_serialization.rs
<a id="crates-omnigate-tests-dtoserialization-rs"></a>

```rust
use omnigate::types::dto::{PingResponse, VersionResponse};

#[test]
fn dto_roundtrips() {
    // VersionResponse now: { version, git }
    let v = VersionResponse {
        version: "0.0.0".to_string(),
        git: Some("deadbeef".to_string()),
    };
    let s = serde_json::to_string(&v).unwrap();
    let _: VersionResponse = serde_json::from_str(&s).unwrap();

    // PingResponse now: { ok }
    let p = PingResponse { ok: true };
    let s = serde_json::to_string(&p).unwrap();
    let _: PingResponse = serde_json::from_str(&s).unwrap();
}

```

### crates/omnigate/tests/hardening.rs
<a id="crates-omnigate-tests-hardening-rs"></a>

```rust


```

### crates/omnigate/tests/interop_vectors.rs
<a id="crates-omnigate-tests-interopvectors-rs"></a>

```rust


```

### crates/omnigate/tests/loom_fanout.rs
<a id="crates-omnigate-tests-loomfanout-rs"></a>

```rust


```

### crates/omnigate/tests/metrics_contract.rs
<a id="crates-omnigate-tests-metricscontract-rs"></a>

```rust
//! Ensures /metrics exports required series & labels.
//! Run: cargo test -p omnigate --test metrics_contract

use regex::Regex;

#[test]
fn metrics_shape_is_present() {
    // For CI stability you can replace this with a boot-and-fetch helper.
    let metrics = include_str!("../testing/fixtures/metrics.sample.txt");

    for name in &[
        "http_requests_total",
        "request_latency_seconds",
        "admission_quota_exhausted_total",
        "admission_fair_queue_events_total",
        "body_reject_total",
        "decompress_reject_total",
        "policy_middleware_shortcircuits_total",
    ] {
        assert!(metrics.contains(name), "missing series: {name}");
    }

    let re = Regex::new(
        r#"http_requests_total\{route="[^"]+",method="(GET|POST|PUT|DELETE)",status="\d{3}"\}"#,
    )
    .unwrap();
    assert!(
        re.is_match(metrics),
        "labels missing on http_requests_total"
    );
}

```

### crates/omnigate/tests/middleware_contract.rs
<a id="crates-omnigate-tests-middlewarecontract-rs"></a>

```rust
// RO:WHAT — Contract tests for edge guards (decompress + body caps).
// RO:WHY  — Prevent regressions: unknown/stacked encodings => 415; over-budget compressed => 413;
//           oversized bodies => 413; small ones pass.

use axum::{
    body::{self, Body},
    http::{Request, StatusCode},
    response::IntoResponse,
    Json,
};
use serde_json::json;
use tower::{service_fn, ServiceBuilder, ServiceExt}; // ServiceExt gives us `.oneshot`

// Keep this comfortably above any tiny JSON error envelopes these tests read.
const READ_LIMIT: usize = 256 * 1024;

#[tokio::test]
async fn decompress_guard_unknown_encoding_415() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::decompress_guard::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(axum::http::header::CONTENT_ENCODING, "compress") // not allowed
        .body(Body::from("tiny"))
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::UNSUPPORTED_MEDIA_TYPE);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["reason"], "unsupported_media_type");
}

#[tokio::test]
async fn decompress_guard_stacked_encodings_415() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::decompress_guard::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(axum::http::header::CONTENT_ENCODING, "gzip, br")
        .body(Body::from("tiny"))
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::UNSUPPORTED_MEDIA_TYPE);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["reason"], "unsupported_media_type");
}

#[tokio::test]
async fn decompress_guard_over_budget_413() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::decompress_guard::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    // With EXPANSION_CAP=10 and MAX_EXPANDED=1 MiB, any compressed length > ~104_857 bytes triggers 413.
    let declared_len = 200_000u64;

    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(axum::http::header::CONTENT_ENCODING, "gzip")
        .header(axum::http::header::CONTENT_LENGTH, declared_len.to_string())
        .body(Body::empty())
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::PAYLOAD_TOO_LARGE);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["reason"], "payload_too_large");
}

#[tokio::test]
async fn body_caps_oversized_by_header_413() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::body_caps::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    // 2 MiB > 1 MiB limit -> reject immediately via preflight guard.
    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(
            axum::http::header::CONTENT_LENGTH,
            (2 * 1024 * 1024).to_string(),
        )
        .body(Body::empty())
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::PAYLOAD_TOO_LARGE);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["reason"], "payload_too_large");
}

#[tokio::test]
async fn body_caps_small_ok_200() {
    let svc = ServiceBuilder::new()
        .layer(omnigate::middleware::body_caps::layer())
        .service(service_fn(|_req| async move {
            Ok::<_, std::convert::Infallible>(Json(json!({"ok": true})).into_response())
        }));

    let body_txt = "hello world";
    let req = Request::builder()
        .uri("/test")
        .method("POST")
        .header(
            axum::http::header::CONTENT_LENGTH,
            body_txt.len().to_string(),
        )
        .body(Body::from(body_txt.to_string()))
        .unwrap();

    let resp = svc.oneshot(req).await.unwrap().into_response();
    assert_eq!(resp.status(), StatusCode::OK);

    let bytes = body::to_bytes(resp.into_body(), READ_LIMIT).await.unwrap();
    let v: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
    assert_eq!(v["ok"], true);
}

```

### crates/omnigate/tests/oap_limits.rs
<a id="crates-omnigate-tests-oaplimits-rs"></a>

```rust


```

### crates/omnigate/tests/policy_gate.rs
<a id="crates-omnigate-tests-policygate-rs"></a>

```rust


```

### crates/omnigate/tests/ready_truth.rs
<a id="crates-omnigate-tests-readytruth-rs"></a>

```rust
use std::io::{Read, Write};
use std::net::TcpStream;
use std::path::PathBuf;
use std::time::Duration;

use omnigate::{bootstrap::server, config::Config};

fn http_get_status(addr: &str, path: &str) -> Option<u16> {
    let mut stream = TcpStream::connect(addr).ok()?;
    stream
        .set_read_timeout(Some(Duration::from_millis(800)))
        .ok()?;
    let req = format!(
        "GET {} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n",
        path, addr
    );
    stream.write_all(req.as_bytes()).ok()?;

    let mut buf = Vec::with_capacity(4096);
    stream.read_to_end(&mut buf).ok()?;
    let text = String::from_utf8_lossy(&buf);
    if let Some(status_line) = text.lines().next() {
        let parts: Vec<_> = status_line.split_whitespace().collect();
        if parts.len() >= 2 {
            return parts[1].parse::<u16>().ok();
        }
    }
    None
}

#[tokio::test(flavor = "multi_thread")]
async fn ready_flips_with_config() {
    // Build an absolute path to configs/omnigate.toml relative to THIS crate.
    let cfg_path: PathBuf = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("configs")
        .join("omnigate.toml");

    let cfg = Config::from_toml_file(cfg_path.to_string_lossy().as_ref()).expect("load config");

    // Build the app (admin plane + readiness config gate flip happens in lib.rs).
    let app = omnigate::App::build(cfg.clone()).await.expect("build app");

    // Start the API server; keep the JoinHandle alive for the test lifetime.
    let server_cfg = cfg.server; // move once
    let api_addr = server_cfg.bind;
    let (_task, _bound) = server::serve(server_cfg, app.router).await.expect("serve");

    // Probe /healthz until it is up.
    let api = api_addr.to_string();
    let mut ok = false;
    for _ in 0..100 {
        if let Some(code) = http_get_status(&api, "/healthz") {
            if code == 200 {
                ok = true;
                break;
            }
        }
        tokio::time::sleep(Duration::from_millis(50)).await;
    }
    assert!(ok, "healthz did not come up on {}", api);

    // Truthful readiness should be 200 after config gate flips.
    let mut ready_ok = false;
    for _ in 0..100 {
        if let Some(code) = http_get_status(&api, "/readyz") {
            if code == 200 {
                ready_ok = true;
                break;
            }
        }
        tokio::time::sleep(Duration::from_millis(50)).await;
    }
    assert!(ready_ok, "readyz did not return 200");
}

```

### crates/omnigate/tests/readyz_overload.rs
<a id="crates-omnigate-tests-readyzoverload-rs"></a>

```rust


```

### crates/omnigate/tests/zk_read_only.rs
<a id="crates-omnigate-tests-zkreadonly-rs"></a>

```rust


```

### crates/omnigate/tests/zk_receipts.rs
<a id="crates-omnigate-tests-zkreceipts-rs"></a>

```rust
use omnigate::zk::{OpClass, OpGuard, Receipt, ReceiptStatus};

#[test]
fn receipt_status_transitions_update_time() {
    let mut r = Receipt::new("r1".into());
    let t0 = r.last_update_ms;
    r.set_status(ReceiptStatus::Processing);
    assert!(r.last_update_ms >= t0);
    let t1 = r.last_update_ms;
    r.set_status(ReceiptStatus::Completed);
    assert!(r.last_update_ms >= t1);
}

#[test]
fn opguard_marks_class() {
    let g = OpGuard::new(OpClass::ReadOnly);
    assert_eq!(g.class(), OpClass::ReadOnly);
    let g2 = OpGuard::new(OpClass::Mutate);
    assert_eq!(g2.class(), OpClass::Mutate);
}

```

