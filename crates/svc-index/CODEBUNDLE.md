<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:53:28Z -->
# Code Bundle — `svc-index`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-index/.cargo/config.toml](#crates-svc-index--cargo-config-toml)
- [crates/svc-index/.github/workflows/chaos.yml](#crates-svc-index--github-workflows-chaos-yml)
- [crates/svc-index/.github/workflows/ci.yml](#crates-svc-index--github-workflows-ci-yml)
- [crates/svc-index/.github/workflows/coverage.yml](#crates-svc-index--github-workflows-coverage-yml)
- [crates/svc-index/.github/workflows/fuzz.yml](#crates-svc-index--github-workflows-fuzz-yml)
- [crates/svc-index/.github/workflows/perf-regress.yml](#crates-svc-index--github-workflows-perf-regress-yml)
- [crates/svc-index/.github/workflows/render-mermaid.yml](#crates-svc-index--github-workflows-render-mermaid-yml)
- [crates/svc-index/Cargo.toml](#crates-svc-index-Cargo-toml)
- [crates/svc-index/benches/resolve.rs](#crates-svc-index-benches-resolve-rs)
- [crates/svc-index/deny.toml](#crates-svc-index-deny-toml)
- [crates/svc-index/examples/client.rs](#crates-svc-index-examples-client-rs)
- [crates/svc-index/fuzz/Cargo.toml](#crates-svc-index-fuzz-Cargo-toml)
- [crates/svc-index/fuzz/fuzz.toml](#crates-svc-index-fuzz-fuzz-toml)
- [crates/svc-index/fuzz/fuzz_targets/http_resolve.rs](#crates-svc-index-fuzz-fuzztargets-httpresolve-rs)
- [crates/svc-index/fuzz/fuzz_targets/parse_manifest.rs](#crates-svc-index-fuzz-fuzztargets-parsemanifest-rs)
- [crates/svc-index/scripts/bench_http.sh](#crates-svc-index-scripts-benchhttp-sh)
- [crates/svc-index/scripts/bench_http_release.sh](#crates-svc-index-scripts-benchhttprelease-sh)
- [crates/svc-index/scripts/bench_resolve.sh](#crates-svc-index-scripts-benchresolve-sh)
- [crates/svc-index/scripts/chaos_inject.sh](#crates-svc-index-scripts-chaosinject-sh)
- [crates/svc-index/scripts/mermaid_render.sh](#crates-svc-index-scripts-mermaidrender-sh)
- [crates/svc-index/scripts/smoke.sh](#crates-svc-index-scripts-smoke-sh)
- [crates/svc-index/scripts/smoke_index.sh](#crates-svc-index-scripts-smokeindex-sh)
- [crates/svc-index/scripts/soak.sh](#crates-svc-index-scripts-soak-sh)
- [crates/svc-index/src/app.rs](#crates-svc-index-src-app-rs)
- [crates/svc-index/src/audit/events.rs](#crates-svc-index-src-audit-events-rs)
- [crates/svc-index/src/audit/mod.rs](#crates-svc-index-src-audit-mod-rs)
- [crates/svc-index/src/auth/caps.rs](#crates-svc-index-src-auth-caps-rs)
- [crates/svc-index/src/auth/mod.rs](#crates-svc-index-src-auth-mod-rs)
- [crates/svc-index/src/auth/uds_allow.rs](#crates-svc-index-src-auth-udsallow-rs)
- [crates/svc-index/src/bus/events.rs](#crates-svc-index-src-bus-events-rs)
- [crates/svc-index/src/bus/mod.rs](#crates-svc-index-src-bus-mod-rs)
- [crates/svc-index/src/cache/manifest.rs](#crates-svc-index-src-cache-manifest-rs)
- [crates/svc-index/src/cache/mod.rs](#crates-svc-index-src-cache-mod-rs)
- [crates/svc-index/src/cache/negative.rs](#crates-svc-index-src-cache-negative-rs)
- [crates/svc-index/src/cache/providers.rs](#crates-svc-index-src-cache-providers-rs)
- [crates/svc-index/src/config.rs](#crates-svc-index-src-config-rs)
- [crates/svc-index/src/constants.rs](#crates-svc-index-src-constants-rs)
- [crates/svc-index/src/dht/client.rs](#crates-svc-index-src-dht-client-rs)
- [crates/svc-index/src/dht/hedge.rs](#crates-svc-index-src-dht-hedge-rs)
- [crates/svc-index/src/dht/mod.rs](#crates-svc-index-src-dht-mod-rs)
- [crates/svc-index/src/dht/rank.rs](#crates-svc-index-src-dht-rank-rs)
- [crates/svc-index/src/error.rs](#crates-svc-index-src-error-rs)
- [crates/svc-index/src/http/extractors/capability.rs](#crates-svc-index-src-http-extractors-capability-rs)
- [crates/svc-index/src/http/extractors/corr_id.rs](#crates-svc-index-src-http-extractors-corrid-rs)
- [crates/svc-index/src/http/extractors/limits.rs](#crates-svc-index-src-http-extractors-limits-rs)
- [crates/svc-index/src/http/extractors/mod.rs](#crates-svc-index-src-http-extractors-mod-rs)
- [crates/svc-index/src/http/middleware/body_limits.rs](#crates-svc-index-src-http-middleware-bodylimits-rs)
- [crates/svc-index/src/http/middleware/decompress_guard.rs](#crates-svc-index-src-http-middleware-decompressguard-rs)
- [crates/svc-index/src/http/middleware/mod.rs](#crates-svc-index-src-http-middleware-mod-rs)
- [crates/svc-index/src/http/middleware/rate_limit.rs](#crates-svc-index-src-http-middleware-ratelimit-rs)
- [crates/svc-index/src/http/middleware/trace_layer.rs](#crates-svc-index-src-http-middleware-tracelayer-rs)
- [crates/svc-index/src/http/mod.rs](#crates-svc-index-src-http-mod-rs)
- [crates/svc-index/src/http/routes/admin.rs](#crates-svc-index-src-http-routes-admin-rs)
- [crates/svc-index/src/http/routes/health.rs](#crates-svc-index-src-http-routes-health-rs)
- [crates/svc-index/src/http/routes/metrics.rs](#crates-svc-index-src-http-routes-metrics-rs)
- [crates/svc-index/src/http/routes/mod.rs](#crates-svc-index-src-http-routes-mod-rs)
- [crates/svc-index/src/http/routes/providers.rs](#crates-svc-index-src-http-routes-providers-rs)
- [crates/svc-index/src/http/routes/resolve.rs](#crates-svc-index-src-http-routes-resolve-rs)
- [crates/svc-index/src/http/routes/version.rs](#crates-svc-index-src-http-routes-version-rs)
- [crates/svc-index/src/lib.rs](#crates-svc-index-src-lib-rs)
- [crates/svc-index/src/logging.rs](#crates-svc-index-src-logging-rs)
- [crates/svc-index/src/main.rs](#crates-svc-index-src-main-rs)
- [crates/svc-index/src/net/listener.rs](#crates-svc-index-src-net-listener-rs)
- [crates/svc-index/src/net/mod.rs](#crates-svc-index-src-net-mod-rs)
- [crates/svc-index/src/net/tls.rs](#crates-svc-index-src-net-tls-rs)
- [crates/svc-index/src/net/uds.rs](#crates-svc-index-src-net-uds-rs)
- [crates/svc-index/src/pipeline/mod.rs](#crates-svc-index-src-pipeline-mod-rs)
- [crates/svc-index/src/pipeline/providers.rs](#crates-svc-index-src-pipeline-providers-rs)
- [crates/svc-index/src/pipeline/resolve.rs](#crates-svc-index-src-pipeline-resolve-rs)
- [crates/svc-index/src/router.rs](#crates-svc-index-src-router-rs)
- [crates/svc-index/src/state/metrics.rs](#crates-svc-index-src-state-metrics-rs)
- [crates/svc-index/src/state/mod.rs](#crates-svc-index-src-state-mod-rs)
- [crates/svc-index/src/state/readiness.rs](#crates-svc-index-src-state-readiness-rs)
- [crates/svc-index/src/state/shutdown.rs](#crates-svc-index-src-state-shutdown-rs)
- [crates/svc-index/src/store/keys.rs](#crates-svc-index-src-store-keys-rs)
- [crates/svc-index/src/store/mod.rs](#crates-svc-index-src-store-mod-rs)
- [crates/svc-index/src/store/schema.rs](#crates-svc-index-src-store-schema-rs)
- [crates/svc-index/src/store/sled_store.rs](#crates-svc-index-src-store-sledstore-rs)
- [crates/svc-index/src/telemetry.rs](#crates-svc-index-src-telemetry-rs)
- [crates/svc-index/src/types.rs](#crates-svc-index-src-types-rs)
- [crates/svc-index/src/utils/mod.rs](#crates-svc-index-src-utils-mod-rs)
- [crates/svc-index/src/utils/timeouts.rs](#crates-svc-index-src-utils-timeouts-rs)
- [crates/svc-index/tests/chaos.rs](#crates-svc-index-tests-chaos-rs)
- [crates/svc-index/tests/golden/resolve/not_found.json](#crates-svc-index-tests-golden-resolve-notfound-json)
- [crates/svc-index/tests/golden/resolve/ok_basic.json](#crates-svc-index-tests-golden-resolve-okbasic-json)
- [crates/svc-index/tests/golden/resolve/over_capacity.json](#crates-svc-index-tests-golden-resolve-overcapacity-json)
- [crates/svc-index/tests/golden/resolve/providers_ranked.json](#crates-svc-index-tests-golden-resolve-providersranked-json)
- [crates/svc-index/tests/http_contract.rs](#crates-svc-index-tests-httpcontract-rs)
- [crates/svc-index/tests/integration.rs](#crates-svc-index-tests-integration-rs)
- [crates/svc-index/tests/loom_index.rs](#crates-svc-index-tests-loomindex-rs)
- [crates/svc-index/tests/prop_index.rs](#crates-svc-index-tests-propindex-rs)

### crates/svc-index/.cargo/config.toml
<a id="crates-svc-index--cargo-config-toml"></a>

```toml
# local build defaults — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
[build]
rustflags = []

[target.'cfg(all())']
rustflags = []

[term]
verbose = true

```

### crates/svc-index/.github/workflows/chaos.yml
<a id="crates-svc-index--github-workflows-chaos-yml"></a>

```yaml
name: chaos
on:
  workflow_dispatch: {}
jobs:
  chaos:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'inject latency/drop into mocked DHT during tests; stub only'

```

### crates/svc-index/.github/workflows/ci.yml
<a id="crates-svc-index--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo fmt --all -- --check
      - run: cargo clippy -p svc-index2 -- -D warnings
      - run: cargo test -p svc-index2 --all-features
      - run: cargo deny check

```

### crates/svc-index/.github/workflows/coverage.yml
<a id="crates-svc-index--github-workflows-coverage-yml"></a>

```yaml
name: coverage
on:
  workflow_dispatch: {}
jobs:
  coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: taiki-e/install-action@cargo-llvm-cov
      - run: cargo llvm-cov --workspace --lcov --output-path lcov.info

```

### crates/svc-index/.github/workflows/fuzz.yml
<a id="crates-svc-index--github-workflows-fuzz-yml"></a>

```yaml
name: fuzz
on:
  workflow_dispatch: {}
jobs:
  fuzz:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'run cargo-fuzz locally or in a container; stub only'

```

### crates/svc-index/.github/workflows/perf-regress.yml
<a id="crates-svc-index--github-workflows-perf-regress-yml"></a>

```yaml
name: perf-regress
on:
  workflow_dispatch: {}
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'run Criterion and compare vs baseline; stub only'

```

### crates/svc-index/.github/workflows/render-mermaid.yml
<a id="crates-svc-index--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          for f in $(git ls-files 'crates/svc-index2/docs/*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out"
          done

```

### crates/svc-index/Cargo.toml
<a id="crates-svc-index-Cargo-toml"></a>

```toml
[package]
name = "svc-index"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RustyOnions index service (resolve name/cid -> manifest/providers)."
repository = "https://github.com/your/repo"
keywords = ["rust", "axum", "index", "dht", "blake3"]

[features]
# Keep sled-store as the default (no regressions).
default = ["sled-store"]
sled-store = ["dep:sled"]
# New: in-memory store for tests/CI; off by default.
inmem = []
otel = ["dep:opentelemetry", "dep:tracing-opentelemetry", "dep:opentelemetry-otlp"]
facets = []

[dependencies]
axum = { version = "0.7", features = ["tokio", "http1", "http2", "json"] }
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time", "net", "sync", "io-util"] }
bytes = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
serde_with = "3"
thiserror = "1"
prometheus = "0.14"
once_cell = "1"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt", "ansi"] }
opentelemetry = { version = "0.24", optional = true }
tracing-opentelemetry = { version = "0.26", optional = true }
opentelemetry-otlp = { version = "0.17", optional = true }
http = "1"
headers = "0.4"
ulid = "1"
uuid = { version = "1", features = ["v4", "fast-rng"] }
blake3 = "1"
time = { version = "0.3", features = ["formatting"] }
parking_lot = "0.12"
dashmap = "6"
anyhow = "1"
tower = "0.5"
tower-http = { version = "0.6", features = ["trace"] }
mime = "0.3"
arc-swap = "1"
rand = "0.9"

# New for store + middleware:
bincode = "1"
hex = "0.4"
futures-util = "0.3"

# Optional sled store (kept as-is)
sled = { version = "0.34", optional = true }

[dev-dependencies]
reqwest = { version = "0.12", default-features = false, features = ["json", "rustls-tls-native-roots"] }
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }

```

### crates/svc-index/benches/resolve.rs
<a id="crates-svc-index-benches-resolve-rs"></a>

```rust
// Criterion bench placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
fn main() {}

```

### crates/svc-index/deny.toml
<a id="crates-svc-index-deny-toml"></a>

```toml
# cargo-deny config (baseline) — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
[advisories]
vulnerability = "deny"
yanked = "deny"
unmaintained = "warn"

[bans]
multiple-versions = "warn"

[sources]
unknown-registry = "deny"
unknown-git = "deny"
allow-git = []

```

### crates/svc-index/examples/client.rs
<a id="crates-svc-index-examples-client-rs"></a>

```rust
// example client placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
fn main() {}

```

### crates/svc-index/fuzz/Cargo.toml
<a id="crates-svc-index-fuzz-Cargo-toml"></a>

```toml
[package]
name = "svc-index2-fuzz"
version = "0.0.0"
publish = false
edition = "2021"

[workspace]
members = []

[package.metadata]
cargo-fuzz = true

```

### crates/svc-index/fuzz/fuzz.toml
<a id="crates-svc-index-fuzz-fuzz-toml"></a>

```toml
# fuzz seeds and budgets — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
[http_resolve]
max_total_time = 30

[parse_manifest]
max_total_time = 30

```

### crates/svc-index/fuzz/fuzz_targets/http_resolve.rs
<a id="crates-svc-index-fuzz-fuzztargets-httpresolve-rs"></a>

```rust
// fuzz target placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
fn main() { }

```

### crates/svc-index/fuzz/fuzz_targets/parse_manifest.rs
<a id="crates-svc-index-fuzz-fuzztargets-parsemanifest-rs"></a>

```rust
// fuzz target placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
fn main() { }

```

### crates/svc-index/scripts/bench_http.sh
<a id="crates-svc-index-scripts-benchhttp-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

cargo build -p svc-index

INDEX_BIND="${INDEX_BIND:-127.0.0.1:5304}"
RUST_LOG="${RUST_LOG:-warn}"

target/debug/svc-index >/tmp/svc-index.bench.log 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true' EXIT

# Wait for service
for i in $(seq 1 120); do
  code=$(curl -s -o /dev/null -w "%{http_code}" "http://$INDEX_BIND/healthz" || true)
  [ "$code" = "200" ] && break
  sleep 0.05
done

bench_wrk() {
  wrk -t4 -c64 -d15s "http://$INDEX_BIND/healthz"
  echo
  wrk -t4 -c64 -d15s "http://$INDEX_BIND/version"
  echo
  wrk -t4 -c32 -d15s "http://$INDEX_BIND/metrics"
}

bench_hey() {
  hey -z 15s -c 64 "http://$INDEX_BIND/healthz"
  echo
  hey -z 15s -c 64 "http://$INDEX_BIND/version"
  echo
  hey -z 15s -c 32 "http://$INDEX_BIND/metrics"
}

bench_pure() {
  one() {
    URL="$1"; CONC="$2"; DUR="$3"
    end=$(( $(date +%s) + DUR ))
    tmpdir="$(mktemp -d)"
    pids=()
    for w in $(seq 1 "$CONC"); do
      (
        cnt=0
        while [ "$(date +%s)" -lt "$end" ]; do
          curl -s -o /dev/null "$URL" || true
          cnt=$((cnt+1))
        done
        echo "$cnt" > "$tmpdir/$w.count"
      ) &
      pids+=("$!")
    done
    for p in "${pids[@]}"; do wait "$p"; done
    total=0
    for f in "$tmpdir"/*.count; do
      [ -f "$f" ] || continue
      n=$(cat "$f")
      total=$((total + n))
    done
    rm -rf "$tmpdir"
    rps=$(awk "BEGIN { printf \"%.1f\", $total/$DUR }")
    echo "purebash url=$URL conc=$CONC dur=${DUR}s total_reqs=$total rps=$rps"
  }
  one "http://$INDEX_BIND/healthz" 64 15
  echo
  one "http://$INDEX_BIND/version" 64 15
  echo
  one "http://$INDEX_BIND/metrics" 32 15
}

if command -v wrk >/dev/null 2>&1; then
  bench_wrk
elif command -v hey >/dev/null 2>&1; then
  bench_hey
else
  bench_pure
fi

```

### crates/svc-index/scripts/bench_http_release.sh
<a id="crates-svc-index-scripts-benchhttprelease-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

cargo build -p svc-index --release

INDEX_BIND="${INDEX_BIND:-127.0.0.1:5304}"
RUST_LOG="${RUST_LOG:-warn}"

target/release/svc-index >/tmp/svc-index.bench.release.log 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true' EXIT

# wait for server
for i in $(seq 1 200); do
  code=$(curl -s -o /dev/null -w "%{http_code}" "http://$INDEX_BIND/healthz" || true)
  [ "$code" = "200" ] && break
  sleep 0.05
done

warmup() {
  D=${1:-5}
  end=$(( $(date +%s) + D ))
  while [ "$(date +%s)" -lt "$end" ]; do curl -s -o /dev/null "http://$INDEX_BIND/healthz" || true; done
}

run_wrk() {
  echo "wrk /healthz"
  wrk -t4 -c128 -d30s "http://$INDEX_BIND/healthz"
  echo
  echo "wrk /version"
  wrk -t4 -c128 -d30s "http://$INDEX_BIND/version"
  echo
  echo "wrk /metrics"
  wrk -t4 -c64  -d30s "http://$INDEX_BIND/metrics"
}

run_hey() {
  echo "hey /healthz"
  hey -z 30s -c 128 "http://$INDEX_BIND/healthz"
  echo
  echo "hey /version"
  hey -z 30s -c 128 "http://$INDEX_BIND/version"
  echo
  echo "hey /metrics"
  hey -z 30s -c 64  "http://$INDEX_BIND/metrics"
}

run_pure() {
  one() {
    URL="$1"; CONC="$2"; DUR="$3"
    end=$(( $(date +%s) + DUR ))
    tmpdir="$(mktemp -d)"
    pids=()
    for w in $(seq 1 "$CONC"); do
      (
        cnt=0
        while [ "$(date +%s)" -lt "$end" ]; do curl -s -o /dev/null "$URL" || true; cnt=$((cnt+1)); done
        echo "$cnt" > "$tmpdir/$w.count"
      ) & pids+=("$!")
    done
    for p in "${pids[@]}"; do wait "$p"; done
    total=0
    for f in "$tmpdir"/*.count; do [ -f "$f" ] && total=$(( total + $(cat "$f") )); done
    rm -rf "$tmpdir"
    rps=$(awk "BEGIN { printf \"%.1f\", $total/$DUR }")
    echo "purebash url=$URL conc=$CONC dur=${DUR}s total_reqs=$total rps=$rps"
  }
  one "http://$INDEX_BIND/healthz" 128 30
  echo
  one "http://$INDEX_BIND/version" 128 30
  echo
  one "http://$INDEX_BIND/metrics" 64  30
}

warmup 5

if command -v wrk >/dev/null 2>&1; then
  run_wrk
elif command -v hey >/dev/null 2>&1; then
  run_hey
else
  run_pure
fi

```

### crates/svc-index/scripts/bench_resolve.sh
<a id="crates-svc-index-scripts-benchresolve-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "bench: would run Criterion on benches/resolve.rs with datasets"

```

### crates/svc-index/scripts/chaos_inject.sh
<a id="crates-svc-index-scripts-chaosinject-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "chaos: would inject latency/drop into mocked DHT for tests"

```

### crates/svc-index/scripts/mermaid_render.sh
<a id="crates-svc-index-scripts-mermaidrender-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "render: would run mmdc for docs/*.mmd -> *.svg"

```

### crates/svc-index/scripts/smoke.sh
<a id="crates-svc-index-scripts-smoke-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Smoke test for svc-index: boot and hit endpoints.
# RO:WHY  — CI/local quick check without magic sleeps.

set -euo pipefail
BIND="${BIND:-127.0.0.1:5304}"
BIN="${BIN:-cargo run -p svc-index}"
LOG="/tmp/svc-index.log"

$BIN > "$LOG" 2>&1 &
PID=$!

deadline=$((SECONDS+10))
until curl -fsS "http://$BIND/readyz" >/dev/null; do
  [[ $SECONDS -gt $deadline ]] && { echo "readyz timeout"; kill $PID || true; exit 1; }
  sleep 0.2
done

curl -fsS "http://$BIND/healthz" | grep -q ok
curl -fsS "http://$BIND/version" | grep -q svc-index
curl -fsS "http://$BIND/resolve/name:hello" || true
curl -fsS "http://$BIND/providers/b3:0000000000000000000000000000000000000000000000000000000000000000" || true

kill $PID || true
echo "✅ svc-index smoke passed"

```

### crates/svc-index/scripts/smoke_index.sh
<a id="crates-svc-index-scripts-smokeindex-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

cargo fmt -p svc-index
cargo clippy -p svc-index --no-deps -- -D warnings
cargo build -p svc-index

INDEX_BIND="${INDEX_BIND:-127.0.0.1:5304}"
RUST_LOG="${RUST_LOG:-info}"

target/debug/svc-index >/tmp/svc-index.log 2>&1 &
PID=$!

trap 'kill $PID >/dev/null 2>&1 || true' EXIT

for i in $(seq 1 60); do
  code=$(curl -s -o /dev/null -w "%{http_code}" "http://$INDEX_BIND/healthz" || true)
  [ "$code" = "200" ] && break
  sleep 0.1
done

CID_ZERO="b3:0000000000000000000000000000000000000000000000000000000000000000"

curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/healthz"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/readyz"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/version"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/resolve/name:does-not-exist"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/providers/not-a-cid"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/providers/$CID_ZERO"

kill $PID

```

### crates/svc-index/scripts/soak.sh
<a id="crates-svc-index-scripts-soak-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "soak: would run a short soak test and write histograms to artifacts/"

```

### crates/svc-index/src/app.rs
<a id="crates-svc-index-src-app-rs"></a>

```rust
//! App wiring helpers (bootstrap)

use crate::state::AppState;
use std::sync::Arc;
use tracing::info;

impl AppState {
    pub async fn bootstrap(state: Arc<AppState>) -> Arc<AppState> {
        // Verify deps here later; for MVP, set ready immediately.
        state.health.mark_ready();
        info!("svc-index ready");
        state
    }
}

```

### crates/svc-index/src/audit/events.rs
<a id="crates-svc-index-src-audit-events-rs"></a>

```rust
// audit events placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/audit/mod.rs
<a id="crates-svc-index-src-audit-mod-rs"></a>

```rust
//! RO:WHAT — Audit emit stubs.

pub mod events {
    pub fn emit(_kind: &str, _msg: &str) {}
}

```

### crates/svc-index/src/auth/caps.rs
<a id="crates-svc-index-src-auth-caps-rs"></a>

```rust
// capability policies placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/auth/mod.rs
<a id="crates-svc-index-src-auth-mod-rs"></a>

```rust
//! RO:WHAT — Placeholder for capability checks (macaroon etc).

pub mod caps {
    pub fn check_read() -> bool {
        true
    }
    pub fn check_admin() -> bool {
        false
    } // TODO
}
pub mod uds_allow {} // placeholder

```

### crates/svc-index/src/auth/uds_allow.rs
<a id="crates-svc-index-src-auth-udsallow-rs"></a>

```rust
// uds allowlist placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/bus/events.rs
<a id="crates-svc-index-src-bus-events-rs"></a>

```rust
// bus events placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/bus/mod.rs
<a id="crates-svc-index-src-bus-mod-rs"></a>

```rust
//! RO:WHAT — Bus event stubs (tie to ron-bus later).

pub mod events {
    #[derive(Clone, Debug)]
    pub enum BusEvent {
        ConfigUpdated,
        Shutdown,
    }
}

```

### crates/svc-index/src/cache/manifest.rs
<a id="crates-svc-index-src-cache-manifest-rs"></a>

```rust
// manifest cache placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/cache/mod.rs
<a id="crates-svc-index-src-cache-mod-rs"></a>

```rust
//! RO:WHAT — Tiny TTL cache for resolves/providers.
//! RO:WHY  — Read-optimized service; avoid hot DHT/DB hits.
//! RO:INVARIANTS — bounded by TTL only (simple MVP).

use dashmap::DashMap;
use std::time::{Duration, Instant};

pub struct IndexCache {
    ttl: Duration,
    resolve: DashMap<String, (crate::types::ResolveResponse, Instant)>,
    providers: DashMap<String, (crate::types::ProvidersResponse, Instant)>,
}

impl IndexCache {
    pub fn new(ttl_secs: u64) -> Self {
        Self {
            ttl: Duration::from_secs(ttl_secs),
            resolve: DashMap::new(),
            providers: DashMap::new(),
        }
    }

    pub fn get_resolve(&self, key: &str) -> Option<crate::types::ResolveResponse> {
        self.resolve.get(key).and_then(|v| {
            let (val, ins) = v.value();
            if ins.elapsed() <= self.ttl {
                Some(val.clone())
            } else {
                None
            }
        })
    }
    pub fn put_resolve(&self, key: String, val: crate::types::ResolveResponse) {
        self.resolve.insert(key, (val, Instant::now()));
    }

    pub fn get_providers(&self, cid: &str) -> Option<crate::types::ProvidersResponse> {
        self.providers.get(cid).and_then(|v| {
            let (val, ins) = v.value();
            if ins.elapsed() <= self.ttl {
                Some(val.clone())
            } else {
                None
            }
        })
    }
    pub fn put_providers(&self, cid: String, val: crate::types::ProvidersResponse) {
        self.providers.insert(cid, (val, Instant::now()));
    }
}

```

### crates/svc-index/src/cache/negative.rs
<a id="crates-svc-index-src-cache-negative-rs"></a>

```rust
// negative cache placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/cache/providers.rs
<a id="crates-svc-index-src-cache-providers-rs"></a>

```rust
// providers cache placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/config.rs
<a id="crates-svc-index-src-config-rs"></a>

```rust
//! RO:WHAT — Load and validate service configuration (env + optional file).
//! RO:WHY  — Governance & Hardening defaults (timeouts, limits).

use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Config {
    pub bind: String,
    pub body_cap_bytes: usize,
    pub cache_ttl_secs: u64,
    pub ready_dep_timeout_ms: u64,
    pub enable_sled: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            bind: "127.0.0.1:5304".into(),
            body_cap_bytes: 1024 * 1024, // 1 MiB
            cache_ttl_secs: 30,
            ready_dep_timeout_ms: 1500,
            enable_sled: true,
        }
    }
}

impl Config {
    pub fn load() -> anyhow::Result<Self> {
        let mut cfg = Config::default();
        if let Ok(v) = std::env::var("BIND") {
            cfg.bind = v;
        }
        if let Ok(v) = std::env::var("BODY_CAP_BYTES") {
            cfg.body_cap_bytes = v.parse().unwrap_or(cfg.body_cap_bytes);
        }
        if let Ok(v) = std::env::var("CACHE_TTL_SECS") {
            cfg.cache_ttl_secs = v.parse().unwrap_or(cfg.cache_ttl_secs);
        }
        if let Ok(v) = std::env::var("READY_DEP_TIMEOUT_MS") {
            cfg.ready_dep_timeout_ms = v.parse().unwrap_or(cfg.ready_dep_timeout_ms);
        }
        if let Ok(v) = std::env::var("ENABLE_SLED") {
            cfg.enable_sled = v == "1" || v.eq_ignore_ascii_case("true");
        }
        Ok(cfg)
    }
}

```

### crates/svc-index/src/constants.rs
<a id="crates-svc-index-src-constants-rs"></a>

```rust
//! RO:WHAT — Service-wide constants (OAP/HTTP bounds, header keys).

pub const OAP_MAX_FRAME_BYTES: usize = 1024 * 1024; // 1 MiB
pub const STORAGE_STREAM_CHUNK_HINT: usize = 64 * 1024;

pub const HDR_CORR_ID: &str = "x-corr-id";
pub const HDR_IDEMPOTENCY_KEY: &str = "idempotency-key";

/// Default max accepted body size for inbound HTTP requests (bytes).
/// Set to 1 MiB. Keep aligned with CONFIG.md defaults and body_limits middleware.
pub const MAX_BODY_BYTES: usize = 1_048_576; // 1 MiB

```

### crates/svc-index/src/dht/client.rs
<a id="crates-svc-index-src-dht-client-rs"></a>

```rust
//! RO:WHAT — DHT client stub for provider lookups (to be wired to svc-dht).

use crate::types::ProviderEntry;

#[derive(Clone, Default)]
pub struct DhtClient;

impl DhtClient {
    pub fn new() -> Self {
        Self
    }
    pub async fn providers_for(&self, _cid: &str, limit: usize) -> Vec<ProviderEntry> {
        vec![ProviderEntry {
            id: "local://stub".into(),
            region: Some("local".into()),
            score: 0.5,
        }]
        .into_iter()
        .take(limit)
        .collect()
    }
}

```

### crates/svc-index/src/dht/hedge.rs
<a id="crates-svc-index-src-dht-hedge-rs"></a>

```rust
// hedged lookups placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/dht/mod.rs
<a id="crates-svc-index-src-dht-mod-rs"></a>

```rust
pub mod client;
pub mod rank;

```

### crates/svc-index/src/dht/rank.rs
<a id="crates-svc-index-src-dht-rank-rs"></a>

```rust
//! RO:WHAT — Simple ranking heuristics placeholder.

use crate::types::ProviderEntry;

pub fn rank(mut v: Vec<ProviderEntry>) -> Vec<ProviderEntry> {
    v.sort_by(|a, b| b.score.total_cmp(&a.score));
    v
}

```

### crates/svc-index/src/error.rs
<a id="crates-svc-index-src-error-rs"></a>

```rust
//! Service error type ↔ HTTP mapping.

use crate::types::ErrorResponse;
use axum::{http::StatusCode, response::IntoResponse, Json};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum SvcError {
    #[error("not_found")]
    NotFound,
    #[error("bad_request: {0}")]
    BadRequest(String),
    #[error("over_capacity")]
    OverCapacity,
    #[error("upstream_unready")]
    UpstreamUnready,
    #[error("unauthorized")]
    Unauthorized,
    #[error("forbidden")]
    Forbidden,
    #[error("internal")]
    Internal(anyhow::Error),
}

impl IntoResponse for SvcError {
    fn into_response(self) -> axum::response::Response {
        let (status, code, message): (StatusCode, &'static str, String) = match self {
            SvcError::NotFound => (StatusCode::NOT_FOUND, "not_found", "Not found".to_string()),
            SvcError::BadRequest(m) => (StatusCode::BAD_REQUEST, "bad_request", m),
            SvcError::OverCapacity => (
                StatusCode::TOO_MANY_REQUESTS,
                "over_capacity",
                "Over capacity".to_string(),
            ),
            SvcError::UpstreamUnready => (
                StatusCode::SERVICE_UNAVAILABLE,
                "upstream_unready",
                "Upstream not ready".to_string(),
            ),
            SvcError::Unauthorized => (
                StatusCode::UNAUTHORIZED,
                "unauthorized",
                "Unauthorized".to_string(),
            ),
            SvcError::Forbidden => (StatusCode::FORBIDDEN, "forbidden", "Forbidden".to_string()),
            SvcError::Internal(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "internal",
                "Internal error".to_string(),
            ),
        };
        (
            status,
            Json(ErrorResponse {
                code: code.into(),
                message,
            }),
        )
            .into_response()
    }
}

```

### crates/svc-index/src/http/extractors/capability.rs
<a id="crates-svc-index-src-http-extractors-capability-rs"></a>

```rust
//! RO:WHAT — Capability placeholder (no-op for public GETs).
#[derive(Clone, Copy)]
pub struct Capability;

```

### crates/svc-index/src/http/extractors/corr_id.rs
<a id="crates-svc-index-src-http-extractors-corrid-rs"></a>

```rust
//! RO:WHAT — Simple correlation id generator/injector for responses.

use axum::{http::HeaderValue, response::Response};
use ulid::Ulid;

pub fn add_corr_id(mut r: Response) -> Response {
    let id = Ulid::new().to_string();
    r.headers_mut()
        .insert("x-corr-id", HeaderValue::from_str(&id).unwrap());
    r
}

```

### crates/svc-index/src/http/extractors/limits.rs
<a id="crates-svc-index-src-http-extractors-limits-rs"></a>

```rust
//! RO:WHAT — Request body cap placeholder (Hardening v2.0).

#[derive(Clone, Copy)]
pub struct BodyLimits {
    pub max_bytes: usize,
}

```

### crates/svc-index/src/http/extractors/mod.rs
<a id="crates-svc-index-src-http-extractors-mod-rs"></a>

```rust
//! RO:WHAT — Extractors module root.

pub mod capability;
pub mod corr_id;
pub mod limits;

```

### crates/svc-index/src/http/middleware/body_limits.rs
<a id="crates-svc-index-src-http-middleware-bodylimits-rs"></a>

```rust
//! RO:WHAT — Body size cap middleware placeholder (MVP).
//! RO:WHY  — Hardening v2.0 will wire strict limits per extractor/route.
//! NOTE: Using identity layer for now to avoid unused imports/warnings.

pub fn layer(_max: usize) -> tower::layer::util::Identity {
    tower::layer::util::Identity::new()
}

```

### crates/svc-index/src/http/middleware/decompress_guard.rs
<a id="crates-svc-index-src-http-middleware-decompressguard-rs"></a>

```rust
// decompress ratio guard middleware placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/http/middleware/mod.rs
<a id="crates-svc-index-src-http-middleware-mod-rs"></a>

```rust
//! RO:WHAT — Middleware module root.

pub mod body_limits;
pub mod trace_layer;

```

### crates/svc-index/src/http/middleware/rate_limit.rs
<a id="crates-svc-index-src-http-middleware-ratelimit-rs"></a>

```rust
// rate limit middleware placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/http/middleware/trace_layer.rs
<a id="crates-svc-index-src-http-middleware-tracelayer-rs"></a>

```rust
//! Tower HTTP TraceLayer (Axum + tower-http 0.6.x).
//! Minimal sane defaults using DefaultMakeSpan at INFO level.

use tower_http::classify::{ServerErrorsAsFailures, SharedClassifier};
use tower_http::trace::{
    DefaultMakeSpan, DefaultOnBodyChunk, DefaultOnEos, DefaultOnFailure, DefaultOnRequest,
    DefaultOnResponse, TraceLayer,
};
use tracing::Level;

/// Return a concrete, cloneable TraceLayer with the default classifier
/// (treat 5xx as failures) and the default span builder at INFO.
pub fn layer() -> TraceLayer<
    SharedClassifier<ServerErrorsAsFailures>,
    DefaultMakeSpan,
    DefaultOnRequest,
    DefaultOnResponse,
    DefaultOnBodyChunk,
    DefaultOnEos,
    DefaultOnFailure,
> {
    TraceLayer::new_for_http().make_span_with(DefaultMakeSpan::new().level(Level::INFO))
}

```

### crates/svc-index/src/http/mod.rs
<a id="crates-svc-index-src-http-mod-rs"></a>

```rust
//! RO:WHAT — HTTP module root: submodules for routes, extractors, middleware.

pub mod extractors;
pub mod middleware;
pub mod routes;

```

### crates/svc-index/src/http/routes/admin.rs
<a id="crates-svc-index-src-http-routes-admin-rs"></a>

```rust
//! Admin endpoints (MVP): reindex/pin stubs + name→CID seeding.
//! Adds: X-Admin-Token guard, strict b3 validator, name: normalization.

use axum::{
    extract::State,
    http::{HeaderMap, StatusCode},
    response::IntoResponse,
    Json,
};
use serde::Deserialize;
use std::sync::Arc;

use crate::{error::SvcError, AppState};

pub async fn reindex() -> impl IntoResponse {
    (StatusCode::ACCEPTED, "queued")
}

pub async fn pin() -> impl IntoResponse {
    (StatusCode::ACCEPTED, "queued")
}

#[derive(Deserialize)]
pub struct SeedBody {
    /// Name key. If missing "name:" prefix, it will be added.
    pub name: String,
    /// Content ID (BLAKE3) of the manifest to associate.
    pub cid: String,
}

#[inline]
fn is_b3(s: &str) -> bool {
    let s = s.strip_prefix("b3:").unwrap_or("");
    s.len() == 64 && s.bytes().all(|b| matches!(b, b'0'..=b'9'|b'a'..=b'f'))
}

/// PUT /admin/seed { "name": "hello", "cid": "b3:<64hex>" }
///
/// - requires header X-Admin-Token equal to env INDEX_ADMIN_TOKEN
/// - normalizes name to "name:<value>" if not already prefixed
/// - validates CID as b3:<64hex>
/// - stores mapping so /resolve/name:<value> works
pub async fn seed(
    State(state): State<Arc<AppState>>,
    headers: HeaderMap,
    Json(body): Json<SeedBody>,
) -> Result<impl IntoResponse, SvcError> {
    // Token guard (simple pre-beta protection)
    let required = std::env::var("INDEX_ADMIN_TOKEN").unwrap_or_default();
    let provided = headers
        .get("X-Admin-Token")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();

    if required.is_empty() || provided != required {
        return Err(SvcError::Unauthorized);
    }

    if !is_b3(&body.cid) {
        return Err(SvcError::BadRequest("invalid cid".into()));
    }

    let name = if body.name.starts_with("name:") {
        body.name
    } else {
        format!("name:{}", body.name)
    };

    state.store.put_manifest(&name, &body.cid);

    Ok((
        StatusCode::ACCEPTED,
        Json(serde_json::json!({ "ok": true, "name": name, "cid": body.cid })),
    ))
}

```

### crates/svc-index/src/http/routes/health.rs
<a id="crates-svc-index-src-http-routes-health-rs"></a>

```rust
//! /healthz and /readyz

use crate::AppState;
use axum::{extract::State, http::StatusCode, response::IntoResponse};
use std::sync::Arc;

pub async fn healthz() -> impl IntoResponse {
    (StatusCode::OK, "ok")
}

pub async fn readyz(State(state): State<Arc<AppState>>) -> impl IntoResponse {
    if state.health.all_ready() {
        (StatusCode::OK, "ready").into_response()
    } else {
        (
            StatusCode::SERVICE_UNAVAILABLE,
            [("Retry-After", "1")],
            "booting",
        )
            .into_response()
    }
}

```

### crates/svc-index/src/http/routes/metrics.rs
<a id="crates-svc-index-src-http-routes-metrics-rs"></a>

```rust
//! /metrics

use crate::AppState;
use axum::{
    extract::State,
    response::{IntoResponse, Response},
};
use std::sync::Arc;

pub async fn metrics(State(state): State<Arc<AppState>>) -> Response {
    match state.metrics.render() {
        Ok(s) => s.into_response(),
        Err(_) => axum::http::StatusCode::INTERNAL_SERVER_ERROR.into_response(),
    }
}

```

### crates/svc-index/src/http/routes/mod.rs
<a id="crates-svc-index-src-http-routes-mod-rs"></a>

```rust
pub mod admin;
pub mod health;
pub mod metrics;
pub mod providers;
pub mod resolve;
pub mod version;

```

### crates/svc-index/src/http/routes/providers.rs
<a id="crates-svc-index-src-http-routes-providers-rs"></a>

```rust
//! GET /providers/:cid
//! RO:WHY  Return 404 when no providers are found. Preserve body shape.
//! RO:INVARIANTS Only status code changes on miss; JSON fields unchanged.

use crate::{error::SvcError, pipeline, AppState};
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use std::collections::HashMap;
use std::sync::Arc;

pub async fn providers(
    Path(cid): Path<String>,
    Query(q): Query<HashMap<String, String>>,
    State(state): State<Arc<AppState>>,
) -> Result<impl IntoResponse, SvcError> {
    let limit = q
        .get("limit")
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(5);

    let out = pipeline::providers::run(state, &cid, limit).await?;

    if out.providers.is_empty() {
        return Ok((StatusCode::NOT_FOUND, Json(out)).into_response());
    }

    Ok(Json(out).into_response())
}

```

### crates/svc-index/src/http/routes/resolve.rs
<a id="crates-svc-index-src-http-routes-resolve-rs"></a>

```rust
//! GET /resolve/:key
//! RO:WHY  Return 404 for well-formed misses (manifest:null AND providers:[]).
//! RO:INVARIANTS Keep the JSON body identical; only the HTTP status changes.

use std::sync::Arc;

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use serde_json::Value;

use crate::{error::SvcError, pipeline, AppState};

pub async fn resolve(
    Path(key): Path<String>,
    State(state): State<Arc<AppState>>,
) -> Result<impl IntoResponse, SvcError> {
    let out = pipeline::resolve::run(state, &key, false).await?;

    // miss := manifest == null && providers == []
    let miss = match serde_json::to_value(&out) {
        Ok(Value::Object(map)) => {
            let manifest_is_null = map.get("manifest").is_some_and(|m| m.is_null());
            let providers_empty = map
                .get("providers")
                .and_then(|p| p.as_array())
                .is_none_or(|arr| arr.is_empty());
            manifest_is_null && providers_empty
        }
        _ => false,
    };

    if miss {
        return Ok((StatusCode::NOT_FOUND, Json(out)).into_response());
    }

    Ok(Json(out).into_response())
}

```

### crates/svc-index/src/http/routes/version.rs
<a id="crates-svc-index-src-http-routes-version-rs"></a>

```rust
//! /version

pub async fn version() -> String {
    format!("svc-index/{}", env!("CARGO_PKG_VERSION"))
}

```

### crates/svc-index/src/lib.rs
<a id="crates-svc-index-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]

// Public modules
pub mod app;
pub mod audit;
pub mod auth;
pub mod bus;
pub mod cache;
pub mod config;
pub mod constants;
pub mod dht;
pub mod error;
pub mod http;
pub mod logging;
pub mod net;
pub mod pipeline;
pub mod router;
pub mod state;
pub mod store;
pub mod telemetry;
pub mod types;
pub mod utils;

// Re-exports
pub use config::Config;
pub use router::build_router;
pub use state::AppState; // <-- from state, not app

```

### crates/svc-index/src/logging.rs
<a id="crates-svc-index-src-logging-rs"></a>

```rust
//! RO:WHAT — Tracing subscriber initialization with EnvFilter.
//! RO:WHY  — Observability baseline.
//! RO:CONFIG — RUST_LOG; defaults to info,hyper=warn.

use tracing_subscriber::{fmt, EnvFilter};

pub fn init() {
    let env = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,hyper=warn,tower_http=warn"));
    fmt().with_env_filter(env).compact().init();
}

```

### crates/svc-index/src/main.rs
<a id="crates-svc-index-src-main-rs"></a>

```rust
//! RO:WHAT — svc-index entry: config → state → router → server (Axum 0.7).
//! RO:WHY  — Avoid stateful Router at serve-time; inject state with `.with_state`.
//! RO:INTERACTS — crate::{config, state, router, logging}.
//! RO:INVARIANTS — single bind; AppState behind Arc; graceful shutdown.

use std::{net::SocketAddr, sync::Arc};

use tokio::net::TcpListener;
use tokio::signal;
use tracing::{error, info, warn};

use svc_index::{build_router, config::Config, logging, AppState};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 0) logging/telemetry
    logging::init();

    // 1) Load config
    let cfg = Config::load()?;

    // 2) Build shared state
    let state: Arc<AppState> = Arc::new(AppState::new(cfg.clone()).await?);

    // 3) Optional bootstrap gates (flip readiness, warm caches, etc.)
    let state = AppState::bootstrap(state).await;

    // 4) Build router WITHOUT state and inject state at the end
    //    This turns Router<Arc<AppState>> → Router<()>, which Axum 0.7 can serve.
    let app = build_router().with_state(state.clone());

    // 5) Bind (+ env override) + serve
    //    Respect INDEX_BIND if present; otherwise use cfg.bind; fallback to 127.0.0.1:5304.
    let bind_str = std::env::var("INDEX_BIND").unwrap_or_else(|_| cfg.bind.clone());
    let bind: SocketAddr = bind_str
        .parse()
        .unwrap_or_else(|_| SocketAddr::from(([127, 0, 0, 1], 5304)));

    let listener: TcpListener = TcpListener::bind(bind).await?;
    info!(
        version = env!("CARGO_PKG_VERSION"),
        %bind,
        "svc-index starting"
    );

    // Serve with graceful shutdown
    let server = axum::serve(listener, app).with_graceful_shutdown(shutdown_signal());
    if let Err(e) = server.await {
        error!(error=?e, "server error");
    }

    Ok(())
}

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        use tokio::signal::unix::{signal, SignalKind};
        signal(SignalKind::terminate())
            .expect("failed to install SIGTERM handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }

    warn!("shutdown signal received");
}

```

### crates/svc-index/src/net/listener.rs
<a id="crates-svc-index-src-net-listener-rs"></a>

```rust
// http listener bootstrap placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/net/mod.rs
<a id="crates-svc-index-src-net-mod-rs"></a>

```rust
//! RO:WHAT — Net placeholders (UDS/TLS if needed later).
pub mod listener {}
pub mod uds {}
pub mod tls {}

```

### crates/svc-index/src/net/tls.rs
<a id="crates-svc-index-src-net-tls-rs"></a>

```rust
// tls server config placeholder (tokio_rustls::rustls::ServerConfig) — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/net/uds.rs
<a id="crates-svc-index-src-net-uds-rs"></a>

```rust
// uds server setup placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/pipeline/mod.rs
<a id="crates-svc-index-src-pipeline-mod-rs"></a>

```rust
pub mod providers;
pub mod resolve;

```

### crates/svc-index/src/pipeline/providers.rs
<a id="crates-svc-index-src-pipeline-providers-rs"></a>

```rust
//! RO:WHAT — Providers pipeline: cid -> ranked provider list (MVP).
//! RO:WHY  Validate CID, pull from DHT, filter synthetic stubs, rank, clamp, cache.
//! RO:INVARIANTS Do not synthesize providers; never cache stub entries.

use crate::{error::SvcError, types::ProvidersResponse, AppState};
use std::sync::Arc;

#[inline]
fn is_b3(s: &str) -> bool {
    let s = s.strip_prefix("b3:").unwrap_or("");
    s.len() == 64 && s.bytes().all(|b| matches!(b, b'0'..=b'9' | b'a'..=b'f'))
}

pub async fn run(
    state: Arc<AppState>,
    cid: &str,
    limit: usize,
) -> Result<ProvidersResponse, SvcError> {
    // 1) Validate input (malformed -> 400)
    if !is_b3(cid) {
        return Err(SvcError::BadRequest("invalid cid".into()));
    }

    // 2) Cache fast-path (already a cleaned object)
    if let Some(cached) = state.cache.get_providers(cid) {
        return Ok(cached);
    }

    // 3) Query DHT (upper-bound to avoid large allocations)
    let lim = limit.clamp(1, 32);
    let mut providers = state.dht.providers_for(cid, lim).await;

    // 4) Remove any synthetic stub providers
    providers.retain(|p| p.id != "local://stub");

    // 5) Rank descending by score
    providers.sort_by(|a, b| b.score.total_cmp(&a.score));

    // 6) Truncate after filtering; mark truncated truthfully
    let truncated = providers.len() > lim;
    if truncated {
        providers.truncate(lim);
    }

    // 7) Build response (no synthesis)
    let resp = ProvidersResponse {
        cid: cid.to_string(),
        providers,
        truncated,
        etag: None,
    };

    // 8) Cache cleaned response
    state.cache.put_providers(cid.to_string(), resp.clone());

    Ok(resp)
}

```

### crates/svc-index/src/pipeline/resolve.rs
<a id="crates-svc-index-src-pipeline-resolve-rs"></a>

```rust
//! RO:WHAT — Resolve pipeline: key (name|b3) -> manifest + providers (MVP).
//! RO:WHY  — Encapsulate read-optimized logic with cache & store.

use crate::{
    error::SvcError,
    types::{ProviderEntry, ResolveResponse},
    AppState,
};
use std::sync::Arc;

#[inline]
fn is_b3(s: &str) -> bool {
    let s = s.strip_prefix("b3:").unwrap_or("");
    s.len() == 64 && s.bytes().all(|b| matches!(b, b'0'..=b'9'|b'a'..=b'f'))
}

pub async fn run(
    state: Arc<AppState>,
    key: &str,
    fresh: bool,
) -> Result<ResolveResponse, SvcError> {
    if !is_b3(key) && !key.starts_with("name:") {
        return Err(SvcError::BadRequest("invalid key".into()));
    }
    if !fresh {
        if let Some(cached) = state.cache.get_resolve(key) {
            return Ok(cached);
        }
    }

    // Manifest lookup (store is authority for names; b3 maps to itself in MVP)
    let manifest = if is_b3(key) {
        Some(key.to_string())
    } else {
        state.store.get_manifest(key)
    };

    // Provider set (stubbed to DHT client)
    let providers = if let Some(cid) = manifest.as_ref() {
        state.dht.providers_for(cid, 5).await
    } else {
        Vec::<ProviderEntry>::new()
    };

    let resp = ResolveResponse {
        key: key.to_string(),
        manifest,
        providers,
        etag: None,
        cached: false,
    };
    state.cache.put_resolve(key.to_string(), resp.clone());
    Ok(resp)
}

```

### crates/svc-index/src/router.rs
<a id="crates-svc-index-src-router-rs"></a>

```rust
//! RO:WHAT — HTTP router (routes + middleware).
//! RO:WHY  — Keep as Router<Arc<AppState>>; main.rs injects state via .with_state(...).
//! RO:INVARIANTS — Handlers use State<Arc<AppState>>.

use std::sync::Arc;

use axum::{routing::get, Router};

use crate::{
    constants::MAX_BODY_BYTES,
    http::{middleware, routes},
    state::AppState,
};

pub fn build_router() -> Router<Arc<AppState>> {
    let api = Router::new()
        .route("/healthz", get(routes::health::healthz))
        .route("/readyz", get(routes::health::readyz))
        .route("/version", get(routes::version::version))
        .route("/metrics", get(routes::metrics::metrics))
        // Generic key resolver: supports "name:*" or "b3:*"
        .route("/resolve/:key", get(routes::resolve::resolve))
        .route("/providers/:cid", get(routes::providers::providers));

    Router::new()
        .nest("/", api)
        .layer(middleware::trace_layer::layer())
        .layer(middleware::body_limits::layer(MAX_BODY_BYTES))
}

```

### crates/svc-index/src/state/metrics.rs
<a id="crates-svc-index-src-state-metrics-rs"></a>

```rust
//! RO:WHAT — Prometheus metrics registry and golden histograms.
//! RO:WHY  — Observability; consistent metric names.

use prometheus::{Encoder, Histogram, HistogramOpts, IntCounterVec, Opts, Registry, TextEncoder};

pub struct Metrics {
    pub registry: Registry,
    pub http_requests_total: IntCounterVec,
    pub request_latency_seconds: Histogram,
    pub rejected_total: IntCounterVec,
}

impl Metrics {
    pub fn new() -> anyhow::Result<Self> {
        let registry = Registry::new();
        let http_requests_total = IntCounterVec::new(
            Opts::new("http_requests_total", "HTTP request count"),
            &["route", "method", "status"],
        )?;
        let request_latency_seconds = Histogram::with_opts(HistogramOpts::new(
            "request_latency_seconds",
            "Request latency",
        ))?;
        let rejected_total = IntCounterVec::new(
            Opts::new("rejected_total", "Rejected requests by reason"),
            &["reason"],
        )?;
        registry.register(Box::new(http_requests_total.clone()))?;
        registry.register(Box::new(request_latency_seconds.clone()))?;
        registry.register(Box::new(rejected_total.clone()))?;
        Ok(Self {
            registry,
            http_requests_total,
            request_latency_seconds,
            rejected_total,
        })
    }

    pub fn render(&self) -> anyhow::Result<String> {
        let mut buf = Vec::new();
        let enc = TextEncoder::new();
        enc.encode(&self.registry.gather(), &mut buf)?;
        Ok(String::from_utf8(buf).unwrap_or_default())
    }
}

```

### crates/svc-index/src/state/mod.rs
<a id="crates-svc-index-src-state-mod-rs"></a>

```rust
//! RO:WHAT — AppState: health, metrics, cfg, cache, store, dht client.
//! RO:WHY  — Centralized handles; ready/health truth.
//! RO:INVARIANTS — set ready last; clone handles; register metrics once.

pub mod metrics;
pub mod readiness;
pub mod shutdown;

use crate::{cache, config::Config, dht::client::DhtClient, store::Store};

pub struct AppState {
    pub cfg: Config,
    pub health: readiness::HealthState,
    pub metrics: metrics::Metrics,
    pub cache: cache::IndexCache,
    pub store: Store,
    pub dht: DhtClient,
}

impl AppState {
    pub async fn new(cfg: Config) -> anyhow::Result<Self> {
        let metrics = metrics::Metrics::new()?;
        let health = readiness::HealthState::new();
        let cache = cache::IndexCache::new(cfg.cache_ttl_secs);
        let store = Store::new(cfg.enable_sled)?;
        let dht = DhtClient::new();

        Ok(Self {
            cfg,
            health,
            metrics,
            cache,
            store,
            dht,
        })
    }
}

```

### crates/svc-index/src/state/readiness.rs
<a id="crates-svc-index-src-state-readiness-rs"></a>

```rust
//! RO:WHAT — Health/Readiness gate with truthful signals.

use std::sync::atomic::{AtomicBool, Ordering};

#[derive(Clone)]
pub struct HealthState {
    ready: std::sync::Arc<AtomicBool>,
}

impl Default for HealthState {
    fn default() -> Self {
        Self {
            ready: std::sync::Arc::new(AtomicBool::new(false)),
        }
    }
}

impl HealthState {
    pub fn new() -> Self {
        Self::default()
    }
    pub fn mark_ready(&self) {
        self.ready.store(true, Ordering::SeqCst);
    }
    pub fn mark_not_ready(&self) {
        self.ready.store(false, Ordering::SeqCst);
    }
    pub fn all_ready(&self) -> bool {
        self.ready.load(std::sync::atomic::Ordering::SeqCst)
    }
}

```

### crates/svc-index/src/state/shutdown.rs
<a id="crates-svc-index-src-state-shutdown-rs"></a>

```rust
// graceful shutdown placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/store/keys.rs
<a id="crates-svc-index-src-store-keys-rs"></a>

```rust
// keyspace layout placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/store/mod.rs
<a id="crates-svc-index-src-store-mod-rs"></a>

```rust
//! Store abstraction; sled-backed (feature) or in-memory.

mod sled_store; // declare the sibling module within `store/`

#[derive(Clone)]
pub enum Store {
    #[cfg(feature = "sled-store")]
    Sled(self::sled_store::SledStore),
    Memory(self::sled_store::MemStore),
}

impl Store {
    pub fn new(enable_sled: bool) -> anyhow::Result<Self> {
        if cfg!(feature = "sled-store") && enable_sled {
            Ok(Self::Sled(self::sled_store::SledStore::open()?))
        } else {
            Ok(Self::Memory(self::sled_store::MemStore::default()))
        }
    }

    pub fn get_manifest(&self, key: &str) -> Option<String> {
        match self {
            #[cfg(feature = "sled-store")]
            Store::Sled(s) => s.get_manifest(key),
            Store::Memory(m) => m.get_manifest(key),
        }
    }

    pub fn put_manifest(&self, key: &str, cid: &str) {
        match self {
            #[cfg(feature = "sled-store")]
            Store::Sled(s) => s.put_manifest(key, cid),
            Store::Memory(m) => m.put_manifest(key, cid),
        }
    }
}

```

### crates/svc-index/src/store/schema.rs
<a id="crates-svc-index-src-store-schema-rs"></a>

```rust
// schema versions & migrations placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/store/sled_store.rs
<a id="crates-svc-index-src-store-sledstore-rs"></a>

```rust
//! Sled-backed (or in-memory) key→manifest store (MVP).
//! Changes: honor RON_INDEX_DB env; flush after writes for durability.

#[cfg(feature = "sled-store")]
#[derive(Clone)]
pub struct SledStore {
    /// Tree that holds key → manifest CID
    man: sled::Tree,
    _db: sled::Db,
}

#[cfg(feature = "sled-store")]
impl SledStore {
    pub fn open() -> anyhow::Result<Self> {
        let path = std::env::var("RON_INDEX_DB").unwrap_or_else(|_| "svc-index.db".into());
        let db = sled::open(path)?;
        let man = db.open_tree("manifest")?;
        Ok(Self { man, _db: db })
    }
    pub fn get_manifest(&self, key: &str) -> Option<String> {
        self.man
            .get(key.as_bytes())
            .ok()
            .flatten()
            .and_then(|ivec| String::from_utf8(ivec.to_vec()).ok())
    }
    pub fn put_manifest(&self, key: &str, cid: &str) {
        let _ = self.man.insert(key.as_bytes(), cid.as_bytes());
        let _ = self.man.flush(); // ensure durability for beta MVP
    }
}

#[derive(Clone, Default)]
pub struct MemStore {
    map: std::sync::Arc<parking_lot::RwLock<std::collections::HashMap<String, String>>>,
}

impl MemStore {
    pub fn get_manifest(&self, key: &str) -> Option<String> {
        self.map.read().get(key).cloned()
    }
    pub fn put_manifest(&self, key: &str, cid: &str) {
        self.map.write().insert(key.to_string(), cid.to_string());
    }
}

```

### crates/svc-index/src/telemetry.rs
<a id="crates-svc-index-src-telemetry-rs"></a>

```rust
//! RO:WHAT — OpenTelemetry glue (optional feature).
//! RO:WHY  — Trace export to OTLP if enabled.
//! RO:CONFIG — OTEL_EXPORTER_OTLP_ENDPOINT, etc.
//! RO:TEST — manual in perf/chaos workflows.

#[cfg(feature = "otel")]
pub mod otel {
    use opentelemetry::sdk::trace as sdktrace;
    use opentelemetry::KeyValue;
    use tracing_subscriber::layer::SubscriberExt;
    use tracing_subscriber::Registry;

    pub fn init(service_name: &str) {
        let tracer = opentelemetry_otlp::new_pipeline()
            .tracing()
            .with_trace_config(
                sdktrace::config().with_resource(opentelemetry::sdk::Resource::new(vec![
                    KeyValue::new("service.name", service_name.to_string()),
                ])),
            )
            .install_batch(opentelemetry::runtime::Tokio)
            .expect("install otlp");

        let telem = tracing_opentelemetry::layer().with_tracer(tracer);
        let subscriber = Registry::default().with(telem);
        tracing::subscriber::set_global_default(subscriber).ok();
    }
}

```

### crates/svc-index/src/types.rs
<a id="crates-svc-index-src-types-rs"></a>

```rust
//! RO:WHAT — DTOs for HTTP responses/requests.
//! RO:WHY  — Interop hygiene; `#[serde(deny_unknown_fields)]`.
//! RO:INVARIANTS — b3: hex shape; stable error taxonomy.
//! RO:SECURITY — no secrets in payloads.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ResolveResponse {
    pub key: String,              // name:* or b3:<hex>
    pub manifest: Option<String>, // usually a CID of a manifest
    pub providers: Vec<ProviderEntry>,
    pub etag: Option<String>, // "b3:<hex>" when applicable
    pub cached: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ProviderEntry {
    pub id: String, // provider id (e.g., node addr)
    pub region: Option<String>,
    pub score: f32, // ranking hint
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ProvidersResponse {
    pub cid: String, // b3:<hex>
    pub providers: Vec<ProviderEntry>,
    pub truncated: bool,
    pub etag: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ErrorResponse {
    pub code: String, // "not_found" | "over_capacity" | ...
    pub message: String,
}

```

### crates/svc-index/src/utils/mod.rs
<a id="crates-svc-index-src-utils-mod-rs"></a>

```rust
//! RO:WHAT — utils module root.
//! RO:WHY  — Houses common helpers (timeouts, etc).

pub mod timeouts;

```

### crates/svc-index/src/utils/timeouts.rs
<a id="crates-svc-index-src-utils-timeouts-rs"></a>

```rust
//! RO:WHAT — Common timeout helpers.
//! RO:WHY  — Keep await-time discipline explicit.

use tokio::time::{timeout, Duration};

pub async fn with_timeout<F, T>(ms: u64, fut: F) -> Result<T, ()>
where
    F: std::future::Future<Output = T>,
{
    timeout(Duration::from_millis(ms), fut)
        .await
        .map_err(|_| ())
}

```

### crates/svc-index/tests/chaos.rs
<a id="crates-svc-index-tests-chaos-rs"></a>

```rust
// chaos tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn chaos_placeholder() {
    assert!(true);
}

```

### crates/svc-index/tests/golden/resolve/not_found.json
<a id="crates-svc-index-tests-golden-resolve-notfound-json"></a>

```json
{ "case": "not_found", "expect": 404 }\n
```

### crates/svc-index/tests/golden/resolve/ok_basic.json
<a id="crates-svc-index-tests-golden-resolve-okbasic-json"></a>

```json
{ "case": "ok_basic", "expect": "Resolved" }\n
```

### crates/svc-index/tests/golden/resolve/over_capacity.json
<a id="crates-svc-index-tests-golden-resolve-overcapacity-json"></a>

```json
{ "case": "over_capacity", "expect": 429 }\n
```

### crates/svc-index/tests/golden/resolve/providers_ranked.json
<a id="crates-svc-index-tests-golden-resolve-providersranked-json"></a>

```json
{ "case": "providers_ranked", "expect": ["p1","p2"] }\n
```

### crates/svc-index/tests/http_contract.rs
<a id="crates-svc-index-tests-httpcontract-rs"></a>

```rust
// http contract tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn http_contract_placeholder() {
    assert!(true);
}

```

### crates/svc-index/tests/integration.rs
<a id="crates-svc-index-tests-integration-rs"></a>

```rust
// integration tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn integration_placeholder() {
    assert!(true);
}

```

### crates/svc-index/tests/loom_index.rs
<a id="crates-svc-index-tests-loomindex-rs"></a>

```rust
// loom tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn loom_placeholder() {
    assert!(true);
}

```

### crates/svc-index/tests/prop_index.rs
<a id="crates-svc-index-tests-propindex-rs"></a>

```rust
// property tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn prop_placeholder() {
    assert!(true);
}

```

