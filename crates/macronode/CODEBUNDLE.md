<!-- Generated by scripts/make_crate_codex.sh on 2025-11-22T01:56:29Z -->
# Code Bundle — `macronode`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/macronode/.github/workflows/ci.yml](#crates-macronode--github-workflows-ci-yml)
- [crates/macronode/.github/workflows/render-mermaid.yml](#crates-macronode--github-workflows-render-mermaid-yml)
- [crates/macronode/Cargo.toml](#crates-macronode-Cargo-toml)
- [crates/macronode/benches/admin_paths_latency.rs](#crates-macronode-benches-adminpathslatency-rs)
- [crates/macronode/scripts/dump_http_surface.sh](#crates-macronode-scripts-dumphttpsurface-sh)
- [crates/macronode/scripts/dump_metrics_names.sh](#crates-macronode-scripts-dumpmetricsnames-sh)
- [crates/macronode/scripts/render_mermaid.sh](#crates-macronode-scripts-rendermermaid-sh)
- [crates/macronode/src/bus/events.rs](#crates-macronode-src-bus-events-rs)
- [crates/macronode/src/bus/mod.rs](#crates-macronode-src-bus-mod-rs)
- [crates/macronode/src/cli/args.rs](#crates-macronode-src-cli-args-rs)
- [crates/macronode/src/cli/check.rs](#crates-macronode-src-cli-check-rs)
- [crates/macronode/src/cli/config_print.rs](#crates-macronode-src-cli-configprint-rs)
- [crates/macronode/src/cli/config_validate.rs](#crates-macronode-src-cli-configvalidate-rs)
- [crates/macronode/src/cli/doctor.rs](#crates-macronode-src-cli-doctor-rs)
- [crates/macronode/src/cli/mod.rs](#crates-macronode-src-cli-mod-rs)
- [crates/macronode/src/cli/run.rs](#crates-macronode-src-cli-run-rs)
- [crates/macronode/src/cli/version.rs](#crates-macronode-src-cli-version-rs)
- [crates/macronode/src/config/cli_overlay.rs](#crates-macronode-src-config-clioverlay-rs)
- [crates/macronode/src/config/env_overlay.rs](#crates-macronode-src-config-envoverlay-rs)
- [crates/macronode/src/config/hot_reload.rs](#crates-macronode-src-config-hotreload-rs)
- [crates/macronode/src/config/load.rs](#crates-macronode-src-config-load-rs)
- [crates/macronode/src/config/mod.rs](#crates-macronode-src-config-mod-rs)
- [crates/macronode/src/config/schema.rs](#crates-macronode-src-config-schema-rs)
- [crates/macronode/src/config/validate.rs](#crates-macronode-src-config-validate-rs)
- [crates/macronode/src/errors.rs](#crates-macronode-src-errors-rs)
- [crates/macronode/src/facets/mod.rs](#crates-macronode-src-facets-mod-rs)
- [crates/macronode/src/facets/permits.rs](#crates-macronode-src-facets-permits-rs)
- [crates/macronode/src/facets/quotas.rs](#crates-macronode-src-facets-quotas-rs)
- [crates/macronode/src/http_admin/handlers/healthz.rs](#crates-macronode-src-httpadmin-handlers-healthz-rs)
- [crates/macronode/src/http_admin/handlers/metrics.rs](#crates-macronode-src-httpadmin-handlers-metrics-rs)
- [crates/macronode/src/http_admin/handlers/mod.rs](#crates-macronode-src-httpadmin-handlers-mod-rs)
- [crates/macronode/src/http_admin/handlers/readyz.rs](#crates-macronode-src-httpadmin-handlers-readyz-rs)
- [crates/macronode/src/http_admin/handlers/reload.rs](#crates-macronode-src-httpadmin-handlers-reload-rs)
- [crates/macronode/src/http_admin/handlers/shutdown.rs](#crates-macronode-src-httpadmin-handlers-shutdown-rs)
- [crates/macronode/src/http_admin/handlers/status.rs](#crates-macronode-src-httpadmin-handlers-status-rs)
- [crates/macronode/src/http_admin/handlers/version.rs](#crates-macronode-src-httpadmin-handlers-version-rs)
- [crates/macronode/src/http_admin/middleware/auth.rs](#crates-macronode-src-httpadmin-middleware-auth-rs)
- [crates/macronode/src/http_admin/middleware/mod.rs](#crates-macronode-src-httpadmin-middleware-mod-rs)
- [crates/macronode/src/http_admin/middleware/rate_limit.rs](#crates-macronode-src-httpadmin-middleware-ratelimit-rs)
- [crates/macronode/src/http_admin/middleware/request_id.rs](#crates-macronode-src-httpadmin-middleware-requestid-rs)
- [crates/macronode/src/http_admin/middleware/timeout.rs](#crates-macronode-src-httpadmin-middleware-timeout-rs)
- [crates/macronode/src/http_admin/mod.rs](#crates-macronode-src-httpadmin-mod-rs)
- [crates/macronode/src/http_admin/router.rs](#crates-macronode-src-httpadmin-router-rs)
- [crates/macronode/src/main.rs](#crates-macronode-src-main-rs)
- [crates/macronode/src/observability/logging.rs](#crates-macronode-src-observability-logging-rs)
- [crates/macronode/src/observability/metrics.rs](#crates-macronode-src-observability-metrics-rs)
- [crates/macronode/src/observability/mod.rs](#crates-macronode-src-observability-mod-rs)
- [crates/macronode/src/pq/hybrid.rs](#crates-macronode-src-pq-hybrid-rs)
- [crates/macronode/src/pq/mod.rs](#crates-macronode-src-pq-mod-rs)
- [crates/macronode/src/readiness/deps.rs](#crates-macronode-src-readiness-deps-rs)
- [crates/macronode/src/readiness/mod.rs](#crates-macronode-src-readiness-mod-rs)
- [crates/macronode/src/readiness/probes.rs](#crates-macronode-src-readiness-probes-rs)
- [crates/macronode/src/security/amnesia.rs](#crates-macronode-src-security-amnesia-rs)
- [crates/macronode/src/security/macaroon.rs](#crates-macronode-src-security-macaroon-rs)
- [crates/macronode/src/security/mod.rs](#crates-macronode-src-security-mod-rs)
- [crates/macronode/src/security/tls.rs](#crates-macronode-src-security-tls-rs)
- [crates/macronode/src/services/mod.rs](#crates-macronode-src-services-mod-rs)
- [crates/macronode/src/services/registry.rs](#crates-macronode-src-services-registry-rs)
- [crates/macronode/src/services/spawn.rs](#crates-macronode-src-services-spawn-rs)
- [crates/macronode/src/services/svc_dht.rs](#crates-macronode-src-services-svcdht-rs)
- [crates/macronode/src/services/svc_gateway.rs](#crates-macronode-src-services-svcgateway-rs)
- [crates/macronode/src/services/svc_index.rs](#crates-macronode-src-services-svcindex-rs)
- [crates/macronode/src/services/svc_mailbox.rs](#crates-macronode-src-services-svcmailbox-rs)
- [crates/macronode/src/services/svc_overlay.rs](#crates-macronode-src-services-svcoverlay-rs)
- [crates/macronode/src/services/svc_storage.rs](#crates-macronode-src-services-svcstorage-rs)
- [crates/macronode/src/supervisor/backoff.rs](#crates-macronode-src-supervisor-backoff-rs)
- [crates/macronode/src/supervisor/crash_policy.rs](#crates-macronode-src-supervisor-crashpolicy-rs)
- [crates/macronode/src/supervisor/health_reporter.rs](#crates-macronode-src-supervisor-healthreporter-rs)
- [crates/macronode/src/supervisor/lifecycle.rs](#crates-macronode-src-supervisor-lifecycle-rs)
- [crates/macronode/src/supervisor/mod.rs](#crates-macronode-src-supervisor-mod-rs)
- [crates/macronode/src/supervisor/shutdown.rs](#crates-macronode-src-supervisor-shutdown-rs)
- [crates/macronode/src/types.rs](#crates-macronode-src-types-rs)
- [crates/macronode/src/util/dur.rs](#crates-macronode-src-util-dur-rs)
- [crates/macronode/src/util/sizes.rs](#crates-macronode-src-util-sizes-rs)
- [crates/macronode/tests/admin_smoke.rs](#crates-macronode-tests-adminsmoke-rs)
- [crates/macronode/tests/metrics_contract.rs](#crates-macronode-tests-metricscontract-rs)
- [crates/macronode/tests/readiness_drain.rs](#crates-macronode-tests-readinessdrain-rs)

### crates/macronode/.github/workflows/ci.yml
<a id="crates-macronode--github-workflows-ci-yml"></a>

```yaml

```

### crates/macronode/.github/workflows/render-mermaid.yml
<a id="crates-macronode--github-workflows-render-mermaid-yml"></a>

```yaml

```

### crates/macronode/Cargo.toml
<a id="crates-macronode-Cargo-toml"></a>

```toml
[package]
name = "macronode"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[[bin]]
name = "macronode"
path = "src/main.rs"

[dependencies]
# Core RON-CORE crates this node will coordinate.
ron-kernel  = { path = "../ron-kernel" }
ron-proto   = { path = "../ron-proto" }
oap         = { path = "../oap" }
svc-storage = { path = "../svc-storage" }
svc-index   = { path = "../svc-index" }

# Network & messaging planes (to be fully wired in next slices).
svc-overlay = { path = "../svc-overlay" }
svc-dht     = { path = "../svc-dht" }
svc-mailbox = { path = "../svc-mailbox" }

# Transport layer for overlay/DHT (TCP/TLS/Tor via features).
ron-transport = { path = "../ron-transport" }

# Async and HTTP stack
tokio = { version = "1.38", features = ["macros", "rt-multi-thread", "signal", "time", "net"] }
axum  = { version = "0.7", features = ["http1", "http2", "json", "tokio"] }
tower = "0.5"
http  = "1"

# Observability
tracing            = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }
prometheus         = "0.14"

# Config / serde
serde           = { version = "1", features = ["derive"] }
serde_json      = "1"
toml            = "0.8"
humantime       = "2.1"
humantime-serde = "1.1"

# Error handling
thiserror = "1"
anyhow    = "1"

# Misc
parking_lot = "0.12"

[dev-dependencies]
reqwest = { version = "0.12", features = ["rustls-tls-native-roots", "json"] }
tokio   = { version = "1.38", features = ["macros", "rt-multi-thread", "time", "net"] }

[[bench]]
name = "admin_paths_latency"
harness = false
path = "benches/admin_paths_latency.rs"
```

### crates/macronode/benches/admin_paths_latency.rs
<a id="crates-macronode-benches-adminpathslatency-rs"></a>

```rust
//! RO:WHAT — Ad-hoc latency probe for macronode admin endpoints.
//! RO:WHY  — Quick, zero-setup way to see per-path latency from a single client.
//!
//! HOW TO USE
//! ----------
//! 1) Make sure macronode is running, e.g.:
//!      RUST_LOG=info cargo run -p macronode -- run --config macronode.toml
//! 2) In another terminal, run:
//!      cargo bench -p macronode --bench admin_paths_latency
//!
//! By default this targets http://127.0.0.1:8080. Override with:
//!      RON_HTTP_ADDR=127.0.0.1:9090 cargo bench -p macronode --bench admin_paths_latency
//!
//! This is a plain binary bench; we’re not using the unstable `#[bench]`
//! harness or Criterion here — just a small async client.

use std::time::{Duration, Instant};

use reqwest::Client;

const DEFAULT_ADDR: &str = "127.0.0.1:8080";

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = std::env::var("RON_HTTP_ADDR").unwrap_or_else(|_| DEFAULT_ADDR.to_string());
    let base = format!("http://{addr}");

    println!();
    println!("macronode admin latency probe");
    println!("  base = {base}");
    println!("  (override with RON_HTTP_ADDR=host:port)");
    println!();

    let client = Client::builder()
        .pool_idle_timeout(Some(Duration::from_secs(5)))
        .timeout(Duration::from_secs(2))
        .build()?;

    let paths = [
        "/healthz",
        "/readyz",
        "/version",
        "/metrics",
        "/api/v1/status",
    ];

    for path in paths {
        let url = format!("{base}{path}");
        let start = Instant::now();
        let resp = client.get(&url).send().await;
        let elapsed = start.elapsed();

        match resp {
            Ok(r) => {
                println!("{:<18} {:>3}  {:>8.3?}", path, r.status().as_u16(), elapsed);
            }
            Err(e) => {
                println!("{:<18} ERR  {:>8.3?}  ({e})", path, elapsed);
            }
        }
    }

    println!();
    Ok(())
}

```

### crates/macronode/scripts/dump_http_surface.sh
<a id="crates-macronode-scripts-dumphttpsurface-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Dump macronode admin HTTP surface.
# RO:WHY  — Quick visibility into /version, /healthz, /readyz, /metrics, /api/v1/status.
# RO:INVARIANTS —
#   - Never fails hard if optional tools (jq) are missing.
#   - Uses RON_HTTP_ADDR if set, otherwise 127.0.0.1:8080.

set -euo pipefail

ADDR="${RON_HTTP_ADDR:-127.0.0.1:8080}"
BASE="http://${ADDR}"

say() { printf '[macronode] %s\n' "$*"; }

say "Dumping admin HTTP surface from ${BASE}"

has_jq=0
if command -v jq >/dev/null 2>&1; then
  has_jq=1
fi

echo
say "GET /version"
if [[ "${has_jq}" == "1" ]]; then
  curl -sS "${BASE}/version" | jq . || true
else
  curl -sS "${BASE}/version" || true
fi
echo

say "GET /healthz"
curl -sS "${BASE}/healthz" || true
echo

say "GET /readyz"
curl -sS "${BASE}/readyz" || true
echo

say "HEAD /metrics (first headers)"
curl -sSI "${BASE}/metrics" | sed -n '1,15p' || true
echo

say "GET /api/v1/status"
if [[ "${has_jq}" == "1" ]]; then
  curl -sS "${BASE}/api/v1/status" | jq . || true
else
  curl -sS "${BASE}/api/v1/status" || true
fi
echo

say "Done."

```

### crates/macronode/scripts/dump_metrics_names.sh
<a id="crates-macronode-scripts-dumpmetricsnames-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Extract unique Prometheus metric names from /metrics.
# RO:WHY  — Quick sanity check on exposed metrics without digging through all samples.
# RO:INVARIANTS —
#   - Does not assume any specific metric set; just prints the current names.
#   - Uses RON_HTTP_ADDR if set, otherwise 127.0.0.1:8080.

set -euo pipefail

ADDR="${RON_HTTP_ADDR:-127.0.0.1:8080}"
BASE="http://${ADDR}"

say() { printf '[macronode] %s\n' "$*"; }

say "Fetching metrics from ${BASE}/metrics"

curl -sS "${BASE}/metrics" \
  | grep -E '^[a-zA-Z_][a-zA-Z0-9_:]*[[:space:]]' \
  | cut -d' ' -f1 \
  | sort -u

say "Done."

```

### crates/macronode/scripts/render_mermaid.sh
<a id="crates-macronode-scripts-rendermermaid-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Render Mermaid diagrams for macronode docs.
# RO:WHY  — Keep architecture docs (graphs/flows) in sync and easy to regenerate.
# RO:INVARIANTS —
#   - Operates only inside this crate (crates/macronode/docs).
#   - No-op if docs/ or any *.mmd files do not exist.
#   - Requires mermaid-cli (mmdc) if you want actual renders.

set -euo pipefail

CRATE_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
DOCS_DIR="${CRATE_ROOT}/docs"

say() { printf '[macronode] %s\n' "$*"; }
warn() { printf '[macronode][warn] %s\n' "$*" >&2; }

if [[ ! -d "${DOCS_DIR}" ]]; then
  warn "docs/ directory not found at ${DOCS_DIR} — nothing to render."
  exit 0
fi

if ! command -v mmdc >/dev/null 2>&1; then
  warn "mermaid-cli (mmdc) not found."
  warn "Install via: npm install -g @mermaid-js/mermaid-cli"
  exit 1
fi

shopt -s nullglob
files=( "${DOCS_DIR}"/*.mmd )
if (( ${#files[@]} == 0 )); then
  warn "No *.mmd files found under ${DOCS_DIR} — nothing to render."
  exit 0
fi

for src in "${files[@]}"; do
  out="${src%.mmd}.svg"
  say "rendering ${src} -> ${out}"
  mmdc -i "${src}" -o "${out}"
done

say "All Mermaid diagrams rendered."

```

### crates/macronode/src/bus/events.rs
<a id="crates-macronode-src-bus-events-rs"></a>

```rust
//! RO:WHAT — Typed events emitted on Macronode’s internal bus.
//! RO:WHY  — Keep the event surface small and aligned with the kernel’s
//!           `KernelEvent` so services can reason about a single enum.
//! RO:INVARIANTS —
//!   - We do not invent new event types here; we alias the canonical
//!     `ron-kernel::KernelEvent` so the control plane stays coherent.
//!   - Higher-level “topic groups” (overlay, storage, etc.) are modeled
//!     as variants/fields on `KernelEvent` in `ron-kernel`, not here.
//!
//! RO:INTERACTS —
//!   - `crate::bus::NodeBus` publishes/subscribes these events.
//!   - Supervisor and services will eventually publish things like
//!     `ConfigUpdated`, `ServiceCrashed`, etc. onto this bus.

use ron_kernel::KernelEvent;

/// Node-level event type carried by the Macronode bus.
///
/// For now this is *exactly* the kernel’s `KernelEvent` so there is a
/// single, shared event taxonomy across the project.
pub type NodeEvent = KernelEvent;

// Re-export for convenience so callers can `use crate::bus::KernelEvent;`
/// Re-export of the canonical kernel event type.
pub use ron_kernel::KernelEvent;

```

### crates/macronode/src/bus/mod.rs
<a id="crates-macronode-src-bus-mod-rs"></a>

```rust
// crates/macronode/src/bus/mod.rs

//! RO:WHAT — Lightweight broadcast bus wrapper for Macronode.
//! RO:WHY  — Provide bounded, lag-aware pub/sub over `NodeEvent` without
//!           leaking `tokio::sync::broadcast` details across the crate.
//!
//! RO:INVARIANTS —
//!   - Bus is bounded; senders see an error if subscribers lag too far.
//!   - Consumers must handle `Lagged` by reconciling from a snapshot
//!     (supervisor/status endpoints can always provide an up-to-date view).
//!   - The API is intentionally tiny: `publish` + `subscribe`.
//!
//! RO:INTERACTS —
//!   - Will be threaded into `Supervisor` in a later step so that
//!     supervisor, services, and admin handlers can exchange events.
//!   - Event type is `NodeEvent` (an alias for `ron_kernel::KernelEvent`).

// This module intentionally shapes a future-facing API (NodeBus/NodeEvent)
// that is not wired anywhere *yet*. We allow dead_code here so that
// `cargo clippy -D warnings` stays green while we incrementally integrate
// the bus into supervisor/services in later slices.
#![allow(dead_code)]

use std::fmt;

use tokio::sync::broadcast;

/// Canonical event type carried by the Macronode bus.
///
/// For now this is *exactly* the kernel’s `KernelEvent` so there is a
/// single, shared event taxonomy across the project.
pub type NodeEvent = ron_kernel::KernelEvent;

/// Default channel capacity for the node bus.
///
/// This is deliberately modest; we want backpressure via `Lagged` errors
/// instead of unbounded growth. We can tune this later if needed.
const DEFAULT_CAPACITY: usize = 1024;

/// Cloneable handle to the Macronode event bus.
///
/// Internally, this wraps a `tokio::sync::broadcast::Sender<NodeEvent>`.
/// Subscribers obtain a `broadcast::Receiver<NodeEvent>` via `subscribe()`.
#[derive(Clone)]
pub struct NodeBus {
    tx: broadcast::Sender<NodeEvent>,
}

impl NodeBus {
    /// Create a new bus with the given bounded capacity.
    pub fn with_capacity(capacity: usize) -> Self {
        let (tx, _rx) = broadcast::channel(capacity);
        Self { tx }
    }

    /// Create a new bus with a sensible default capacity.
    pub fn new() -> Self {
        Self::with_capacity(DEFAULT_CAPACITY)
    }

    /// Publish an event to all subscribers.
    ///
    /// Returns `Ok(())` on success or a `SendError` if there were no
    /// active subscribers or if the channel was otherwise unable to
    /// accept the event.
    pub fn publish(&self, event: NodeEvent) -> Result<(), broadcast::error::SendError<NodeEvent>> {
        self.tx.send(event)?;
        Ok(())
    }

    /// Subscribe to the stream of node events.
    ///
    /// Callers **must** be prepared to handle `RecvError::Lagged(_)` on
    /// the returned receiver by re-syncing from a snapshot (e.g. via
    /// `/api/v1/status`) before continuing.
    pub fn subscribe(&self) -> broadcast::Receiver<NodeEvent> {
        self.tx.subscribe()
    }

    /// Access the underlying sender for advanced integrations.
    ///
    /// Most code should prefer `publish()` instead of using this directly.
    pub fn sender(&self) -> broadcast::Sender<NodeEvent> {
        self.tx.clone()
    }
}

impl fmt::Debug for NodeBus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // We intentionally don’t expose internal channel state here.
        f.debug_struct("NodeBus").finish_non_exhaustive()
    }
}

```

### crates/macronode/src/cli/args.rs
<a id="crates-macronode-src-cli-args-rs"></a>

```rust
//! RO:WHAT — Macronode CLI command/option types.
//! RO:WHY  — Keep the CLI surface explicit and testable without tying
//!           directly to a particular parsing crate.
//! RO:INVARIANTS —
//!   - `Cli::parse()` is a tiny, predictable parser over `std::env::args`.
//!   - Unknown commands fall back to `run` with a warning.
//!   - For `run`, we parse a small subset of flags by hand.

#[derive(Debug, Clone)]
pub enum Command {
    /// Run the Macronode host (admin HTTP + services).
    Run(RunOpts),
    /// Print version/build information and exit.
    Version,
    /// Validate environment/config and exit.
    Check,
    /// Print effective redacted config.
    ConfigPrint,
    /// Validate a supplied config file without starting the node.
    ConfigValidate,
    /// Run diagnostics bundle (fs/dns/time drift/ports).
    Doctor,
}

/// Options for the `run` subcommand.
///
/// NOTE: Fields are intentionally conservative for now; we keep them
/// around so the CLI surface is stable while we gradually implement
/// overlays. `#[allow(dead_code)]` keeps clippy happy under `-D warnings`
/// until all fields are used.
#[allow(dead_code)]
#[derive(Debug, Clone, Default)]
pub struct RunOpts {
    /// Optional path to a config file (`--config`).
    pub config_path: Option<String>,
    /// Optional bind override for admin HTTP (`--http-addr`).
    pub http_addr: Option<String>,
    /// Optional bind override for metrics (`--metrics-addr`).
    pub metrics_addr: Option<String>,
    /// Optional log level override (`--log-level`).
    pub log_level: Option<String>,
    /// Optional amnesia flag (`--amnesia`).
    pub amnesia: Option<bool>,
}

impl RunOpts {
    /// Parse flags for the `run` command from a slice of arguments.
    ///
    /// Supported flags (MVP):
    ///   --config PATH
    ///   --http-addr ADDR
    ///   --log-level LEVEL
    ///
    /// Unknown flags are ignored with a warning.
    pub fn from_args(args: &[String]) -> Self {
        let mut opts = RunOpts::default();
        let mut i = 0;

        while i < args.len() {
            match args[i].as_str() {
                "--config" => {
                    if let Some(val) = args.get(i + 1) {
                        opts.config_path = Some(val.clone());
                        i += 1;
                    } else {
                        eprintln!("macronode: --config requires a path argument");
                    }
                }
                "--http-addr" => {
                    if let Some(val) = args.get(i + 1) {
                        opts.http_addr = Some(val.clone());
                        i += 1;
                    } else {
                        eprintln!("macronode: --http-addr requires an address argument");
                    }
                }
                "--log-level" => {
                    if let Some(val) = args.get(i + 1) {
                        opts.log_level = Some(val.clone());
                        i += 1;
                    } else {
                        eprintln!("macronode: --log-level requires a level argument");
                    }
                }
                "--metrics-addr" => {
                    if let Some(val) = args.get(i + 1) {
                        opts.metrics_addr = Some(val.clone());
                        i += 1;
                    } else {
                        eprintln!("macronode: --metrics-addr requires an address argument");
                    }
                }
                "--amnesia" => {
                    // For now we accept `--amnesia` as a bare flag and treat it as true.
                    opts.amnesia = Some(true);
                }
                other => {
                    // Ignore unknown flags for now, but let the operator know.
                    if other.starts_with('-') {
                        eprintln!(
                            "macronode: ignoring unknown flag `{other}` on `run` (see README CLI section)"
                        );
                    }
                }
            }

            i += 1;
        }

        opts
    }
}

/// Top-level CLI wrapper.
#[derive(Debug, Clone)]
pub struct Cli {
    pub cmd: Command,
}

impl Cli {
    /// Parse CLI arguments into a `Cli` value.
    ///
    /// Today we:
    ///   - Look at the first positional argument to decide the subcommand.
    ///   - For `run`, parse a small set of flags from the remaining args.
    pub fn parse() -> Self {
        let mut args = std::env::args().skip(1);
        let sub = args.next();

        let cmd = match sub.as_deref() {
            None => {
                // No subcommand; treat as `run` with default options.
                Command::Run(RunOpts::default())
            }
            Some("run") => {
                let rest: Vec<String> = args.collect();
                let opts = RunOpts::from_args(&rest);
                Command::Run(opts)
            }
            Some("version") | Some("--version") | Some("-V") => Command::Version,
            Some("check") => Command::Check,
            Some("config") => match args.next().as_deref() {
                Some("print") => Command::ConfigPrint,
                Some("validate") => Command::ConfigValidate,
                other => {
                    eprintln!(
                        "macronode: expected `config print` or `config validate`, got {:?}; \
                         defaulting to `config print`",
                        other
                    );
                    Command::ConfigPrint
                }
            },
            Some("doctor") => Command::Doctor,
            Some(other) => {
                eprintln!(
                    "macronode: unknown command `{other}`, defaulting to `run` (see README CLI section)"
                );
                Command::Run(RunOpts::default())
            }
        };

        Cli { cmd }
    }
}

```

### crates/macronode/src/cli/check.rs
<a id="crates-macronode-src-cli-check-rs"></a>

```rust
//! RO:WHAT — Implementation of the `check` subcommand.
//! RO:WHY  — Fast validation of config/env without starting listeners.
//! RO:INVARIANTS —
//!   - Returns non-error only if config loads successfully.

use crate::{config::load_config, errors::Result};

pub fn run() -> Result<()> {
    let cfg = load_config()?;
    println!(
        "macronode check: OK (http_addr={}, metrics_addr={}, log_level={})",
        cfg.http_addr, cfg.metrics_addr, cfg.log_level
    );
    Ok(())
}

```

### crates/macronode/src/cli/config_print.rs
<a id="crates-macronode-src-cli-configprint-rs"></a>

```rust
//! RO:WHAT — Implementation of `config print`.
//! RO:WHY  — Give operators a way to see the **effective** config after
//!           defaults, optional file (RON_CONFIG/MACRO_CONFIG), and env
//!           overlays have been applied.

use crate::{config::load_config, errors::Result};

pub fn run() -> Result<()> {
    let cfg = load_config()?;
    let json = serde_json::to_string_pretty(&cfg)?;
    println!("{json}");
    Ok(())
}

```

### crates/macronode/src/cli/config_validate.rs
<a id="crates-macronode-src-cli-configvalidate-rs"></a>

```rust
//! RO:WHAT — Implementation of `config validate`.
//! RO:WHY  — Off-line validation of config without starting listeners.
//! RO:NOTE — Uses the same loader as `config print`/`check`, which merges
//!           defaults + optional file (via `RON_CONFIG`) + env overlays.

use crate::{config::load_config, errors::Result};

pub fn run() -> Result<()> {
    let _cfg = load_config()?;
    println!("macronode config validate: OK (file/env-based config)");
    Ok(())
}

```

### crates/macronode/src/cli/doctor.rs
<a id="crates-macronode-src-cli-doctor-rs"></a>

```rust
//! RO:WHAT — Implementation of the `doctor` subcommand (MVP stub).
//! RO:WHY  — Placeholder for richer diagnostics (fs/dns/time drift/ports).

use crate::errors::Result;

pub fn run() -> Result<()> {
    println!("macronode doctor: stub (diagnostics not yet implemented)");
    Ok(())
}

```

### crates/macronode/src/cli/mod.rs
<a id="crates-macronode-src-cli-mod-rs"></a>

```rust
//! RO:WHAT — Macronode CLI surface and entrypoint.
//! RO:WHY  — Provide a stable operator-facing CLI (`run`, `version`, `check`,
//!           `config print|validate`, `doctor`) without committing to a
//!           specific argument parser crate yet.
//! RO:INVARIANTS —
//!   - Parsing is intentionally minimal but deterministic.
//!   - All subcommands return `errors::Result<()>` so main can stay boring.

pub mod args;
pub mod check;
pub mod config_print;
pub mod config_validate;
pub mod doctor;
pub mod run;
pub mod version;

use crate::errors::Result;
pub use args::{Cli, Command, RunOpts};

/// Parse CLI args and dispatch to the selected subcommand.
pub async fn entrypoint() -> Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Command::Run(opts) => run::run(opts).await,
        Command::Version => {
            version::run();
            Ok(())
        }
        Command::Check => check::run(),
        Command::ConfigPrint => config_print::run(),
        Command::ConfigValidate => config_validate::run(),
        Command::Doctor => doctor::run(),
    }
}

```

### crates/macronode/src/cli/run.rs
<a id="crates-macronode-src-cli-run-rs"></a>

```rust
//! RO:WHAT — Implementation of the `run` subcommand.
//! RO:WHY  — Bridge between CLI surface and the existing runtime wiring
//!           (config, logging, readiness, admin HTTP, supervisor).
//! RO:INVARIANTS —
//!   - Config pipeline: defaults -> file (optional) -> env -> CLI overlays.
//!   - `RunOpts` is the only source of CLI overrides.
//!   - HTTP admin server uses graceful shutdown on Ctrl-C.

use std::{sync::Arc, time::Instant};

use axum::Router;
use ron_kernel::wait_for_ctrl_c;
use tokio::net::TcpListener;
use tracing::{error, info};

use crate::{
    bus::NodeBus,
    config::{
        cli_overlay::{apply_cli_overlays, CliOverlay},
        load_effective_config,
    },
    errors::Result,
    http_admin,
    observability::logging,
    readiness::ReadyProbes,
    supervisor::{ShutdownToken, Supervisor},
    types::AppState,
};

use super::RunOpts;

/// Execute the `run` subcommand.
pub async fn run(opts: RunOpts) -> Result<()> {
    // 1) Load config (defaults + optional file from CLI/env + env).
    //
    // Precedence for file path:
    //   1) CLI --config
    //   2) RON_CONFIG / MACRO_CONFIG (inside load_effective_config)
    let base_cfg = load_effective_config(opts.config_path.as_deref())?;

    // 2) Build CLI overlay from RunOpts and apply it.
    let overlay = CliOverlay {
        http_addr: opts.http_addr.clone(),
        metrics_addr: opts.metrics_addr.clone(),
        log_level: opts.log_level.clone(),
    };
    let cfg = apply_cli_overlays(base_cfg, &overlay)?;

    // 3) Initialize logging with config log level (RUST_LOG can still override).
    logging::init(&cfg.log_level);

    // 4) Build shared readiness probes and shutdown token.
    let probes = Arc::new(ReadyProbes::new());
    let shutdown_token = ShutdownToken::new();

    // Metrics are already served via `/metrics` as soon as the admin router
    // is bound, so we can treat this as "bound" from the perspective of
    // readiness once the listener is active.
    //
    // NOTE: `cfg.metrics_addr` is now plumbed through config/env/CLI but we
    // still serve metrics on the admin listener for this slice. A future
    // slice can spin a dedicated metrics listener when `metrics_addr != http_addr`.
    probes.set_metrics_bound(true);

    // 5) Start supervised services. Successful spawn marks deps_ok.
    let supervisor = Supervisor::new(probes.clone(), shutdown_token.clone());
    supervisor.start().await?;

    // 6) Build intra-node event bus.
    //
    // RO:WHAT — local bus for KernelEvent traffic (ConfigUpdated, Health, etc.).
    // RO:WHY  — lets admin handlers and supervisor/services communicate without
    //           tight coupling. In this slice we only use it from /reload.
    let bus = NodeBus::new();

    // 7) Build shared application state for HTTP handlers.
    let state = AppState {
        cfg: Arc::new(cfg.clone()),
        probes: probes.clone(),
        bus,
        started_at: Instant::now(),
    };

    // 8) Bind HTTP admin listener.
    let listener = TcpListener::bind(cfg.http_addr).await?;
    probes.set_listeners_bound(true);
    probes.set_cfg_loaded(true);

    let router: Router = http_admin::router::build_router(state);

    info!("macronode admin listening on {}", cfg.http_addr);

    // 9) Run HTTP admin server with graceful shutdown on Ctrl-C.
    let shutdown_signal = async move {
        wait_for_ctrl_c().await;
        info!("macronode: shutdown signal received, draining admin server");
        shutdown_token.trigger();
    };

    if let Err(err) = axum::serve(listener, router)
        .with_graceful_shutdown(shutdown_signal)
        .await
    {
        error!("macronode admin server error: {err}");
    }

    info!("macronode: admin server exited, shutdown complete");

    Ok(())
}

```

### crates/macronode/src/cli/version.rs
<a id="crates-macronode-src-cli-version-rs"></a>

```rust
//! RO:WHAT — Implementation of the `version` subcommand.
//! RO:WHY  — Provide a simple CLI-friendly equivalent to `/version`.

use crate::types::BuildInfo;

/// Print version information to stdout.
///
/// Shape matches the `/version` HTTP payload, minus the API version.
pub fn run() {
    let info = BuildInfo::current();
    println!(
        "service={service} version={version} git_sha={git_sha} build_ts={build_ts} rustc={rustc} msrv={msrv}",
        service = info.service,
        version = info.version,
        git_sha = info.git_sha,
        build_ts = info.build_ts,
        rustc = info.rustc,
        msrv = info.msrv,
    );
}

```

### crates/macronode/src/config/cli_overlay.rs
<a id="crates-macronode-src-config-clioverlay-rs"></a>

```rust
//! RO:WHAT — CLI overlays for Macronode config.
//! RO:WHY  — Let `macronode run` flags override defaults/env in a single place.
//! RO:INVARIANTS —
//!   - Only overrides fields that are explicitly set on `CliOverlay`.
//!   - Never panics on bad input; errors bubble as `Error::Config`.
//!   - If `--http-addr` is set and `--metrics-addr` is not, metrics inherits
//!     the HTTP bind, mirroring the env behavior.

use std::net::SocketAddr;

use crate::errors::{Error, Result};

use super::schema::Config;

/// Minimal set of config fields that can be overridden via CLI.
///
/// This deliberately mirrors the subset of `RunOpts` we support today.
/// We keep it here (in the config module) to avoid a circular dependency
/// on `crate::cli`.
#[derive(Debug, Default, Clone)]
pub struct CliOverlay {
    pub http_addr: Option<String>,
    pub metrics_addr: Option<String>,
    pub log_level: Option<String>,
}

pub fn apply_cli_overlays(mut cfg: Config, overlay: &CliOverlay) -> Result<Config> {
    // HTTP addr override
    if let Some(addr_str) = overlay.http_addr.as_deref() {
        let addr: SocketAddr = addr_str
            .parse()
            .map_err(|e| Error::config(format!("invalid --http-addr {addr_str:?}: {e}")))?;
        cfg.http_addr = addr;

        // If operator set an HTTP override but did not explicitly set a metrics
        // override, keep the "metrics inherits HTTP" invariant.
        if overlay.metrics_addr.is_none() {
            cfg.metrics_addr = addr;
        }
    }

    // Metrics addr override
    if let Some(addr_str) = overlay.metrics_addr.as_deref() {
        let addr: SocketAddr = addr_str
            .parse()
            .map_err(|e| Error::config(format!("invalid --metrics-addr {addr_str:?}: {e}")))?;
        cfg.metrics_addr = addr;
    }

    // Log level override
    if let Some(level) = overlay.log_level.as_ref() {
        if !level.trim().is_empty() {
            cfg.log_level = level.clone();
        }
    }

    Ok(cfg)
}

```

### crates/macronode/src/config/env_overlay.rs
<a id="crates-macronode-src-config-envoverlay-rs"></a>

```rust
//! RO:WHAT — Environment overlays for Macronode config.
//! RO:WHY  — Separate side-effectful env reading from pure config logic.
//! RO:INVARIANTS —
//!   - Never panics on bad env; all issues bubble as `Error::Config`.
//!   - Aliases `MACRO_*` are supported for one minor with a warning.
//!   - `metrics_addr` inherits `http_addr` when no explicit metrics env is set.

use std::{env, net::SocketAddr};

use humantime::parse_duration;

use crate::errors::{Error, Result};

use super::schema::Config;

/// Apply environment-based overlays to a `Config` value.
///
/// Supported env vars:
///   - `RON_HTTP_ADDR` / `MACRO_HTTP_ADDR`
///   - `RON_METRICS_ADDR` / `MACRO_METRICS_ADDR`
///   - `RON_LOG`
///   - `RON_READ_TIMEOUT` / `MACRO_READ_TIMEOUT`
///   - `RON_WRITE_TIMEOUT` / `MACRO_WRITE_TIMEOUT`
///   - `RON_IDLE_TIMEOUT` / `MACRO_IDLE_TIMEOUT`
pub fn apply_env_overlays(mut cfg: Config) -> Result<Config> {
    let mut metrics_overridden = false;

    // Metrics addr — may override HTTP if explicitly set.
    if let Some(val) = first_of(&["RON_METRICS_ADDR", "MACRO_METRICS_ADDR"]) {
        let addr: SocketAddr = val
            .parse()
            .map_err(|e| Error::config(format!("invalid metrics addr {val:?}: {e}")))?;
        cfg.metrics_addr = addr;
        metrics_overridden = true;
    }

    // HTTP addr — if set and metrics were not explicitly overridden, we keep
    // the invariant that metrics inherits HTTP by default.
    if let Some(val) = first_of(&["RON_HTTP_ADDR", "MACRO_HTTP_ADDR"]) {
        let addr: SocketAddr = val
            .parse()
            .map_err(|e| Error::config(format!("invalid HTTP addr {val:?}: {e}")))?;
        cfg.http_addr = addr;
        if !metrics_overridden {
            cfg.metrics_addr = addr;
        }
    }

    // Log level
    if let Ok(val) = env::var("RON_LOG") {
        if !val.trim().is_empty() {
            cfg.log_level = val;
        }
    }

    // Timeouts
    if let Some(val) = first_of(&["RON_READ_TIMEOUT", "MACRO_READ_TIMEOUT"]) {
        cfg.read_timeout = parse_duration_checked("read_timeout", &val)?;
    }

    if let Some(val) = first_of(&["RON_WRITE_TIMEOUT", "MACRO_WRITE_TIMEOUT"]) {
        cfg.write_timeout = parse_duration_checked("write_timeout", &val)?;
    }

    if let Some(val) = first_of(&["RON_IDLE_TIMEOUT", "MACRO_IDLE_TIMEOUT"]) {
        cfg.idle_timeout = parse_duration_checked("idle_timeout", &val)?;
    }

    Ok(cfg)
}

fn first_of(keys: &[&str]) -> Option<String> {
    for key in keys {
        if let Ok(v) = env::var(key) {
            if !v.trim().is_empty() {
                if key.starts_with("MACRO_") {
                    eprintln!(
                        "[macronode-config] WARNING: {key} is deprecated; \
                         prefer the RON_* variant instead."
                    );
                }
                return Some(v);
            }
        }
    }
    None
}

fn parse_duration_checked(field: &str, input: &str) -> Result<std::time::Duration> {
    parse_duration(input).map_err(|e| {
        Error::config(format!(
            "invalid duration for {field}: {input:?} ({e}) \
             — expected forms like \"10s\", \"500ms\", \"1m\""
        ))
    })
}

```

### crates/macronode/src/config/hot_reload.rs
<a id="crates-macronode-src-config-hotreload-rs"></a>

```rust
//! RO:WHAT — Config hot-reload stub.
//! RO:WHY  — `/api/v1/reload` calls this; later it will re-read config file/env.
//!
//! RO:INVARIANTS —
//!   - Non-blocking.
//!   - Does *not* mutate live config yet (will be replaced when we wire reload).

use crate::config::schema::Config;
use tracing::info;

pub fn hot_reload(_cfg: &Config) -> Result<(), String> {
    info!("macronode config hot_reload(): stub (no-op)");
    Ok(())
}

```

### crates/macronode/src/config/load.rs
<a id="crates-macronode-src-config-load-rs"></a>

```rust
//! RO:WHAT — Config load pipeline for Macronode.
//! RO:WHY  — Centralize config loading so CLI and runtime share precedence,
//!           env overlays, and validation.
//! RO:INVARIANTS —
//!   - Always start from `Config::default()`.
//!   - Precedence for config sources:
//!       1) Defaults
//!       2) Optional file from CLI `--config` or env (`RON_CONFIG` / `MACRO_CONFIG`)
//!       3) Env overlays (`RON_*` + `MACRO_*` aliases)
//!   - Validation always runs before returning a config to callers.
//!
//! RO:CONFIG SOURCES —
//!   - `--config PATH` (CLI) has highest precedence for the file path.
//!   - If no CLI path is supplied, `RON_CONFIG` is honored.
//!   - `MACRO_CONFIG` is accepted for one minor with a warning.

use std::{env, fs, path::Path};

use crate::errors::{Error, Result};

use super::{env_overlay::apply_env_overlays, schema::Config, validate::validate_config};

/// Load config using defaults + **optional file from env** + env overlays.
///
/// This is what non-`run` CLI commands (`check`, `config print`,
/// `config validate`) use: they do not accept `--config` themselves, but
/// operators can still provide a file via `RON_CONFIG`/`MACRO_CONFIG`.
pub fn load_config() -> Result<Config> {
    load_effective_config(None)
}

/// Load config using an explicit file path (if provided), then env overlays.
///
/// This is the low-level helper used by the higher-level
/// `load_effective_config`. Precedence inside this function is:
///
///   1) `Config::default()`
///   2) Optional file (if `file_path` is `Some(_)`)
///   3) Env overlays
///
/// Validation is always run before the config is returned.
pub fn load_config_with_file(file_path: Option<&str>) -> Result<Config> {
    let mut cfg = Config::default();

    if let Some(path) = file_path {
        let path = Path::new(path);
        cfg = load_from_file(path)?;
    }

    let cfg = apply_env_overlays(cfg)?;
    validate_config(&cfg)?;
    Ok(cfg)
}

/// Load the **effective** config, combining CLI and env-level file paths.
///
/// Precedence for the config *file path* is:
///
///   1) CLI `--config PATH` (if supplied)
///   2) `RON_CONFIG` (if set and non-empty)
///   3) `MACRO_CONFIG` (deprecated alias; emits a warning)
///
/// After the file (if any) is applied, env overlays and validation are run.
pub fn load_effective_config(cli_file_path: Option<&str>) -> Result<Config> {
    let chosen_path = match cli_file_path {
        Some(p) => Some(p.to_string()),
        None => env_config_path(),
    };

    load_config_with_file(chosen_path.as_deref())
}

/// Discover a config file path from env (`RON_CONFIG` / `MACRO_CONFIG`).
///
/// Returns `Some(path)` if a non-empty value is found, otherwise `None`.
fn env_config_path() -> Option<String> {
    if let Ok(val) = env::var("RON_CONFIG") {
        let trimmed = val.trim();
        if !trimmed.is_empty() {
            return Some(trimmed.to_owned());
        }
    }

    // Temporary compatibility alias for older docs/scripts.
    if let Ok(val) = env::var("MACRO_CONFIG") {
        let trimmed = val.trim();
        if !trimmed.is_empty() {
            eprintln!(
                "macronode: MACRO_CONFIG is deprecated; prefer RON_CONFIG for config file path"
            );
            return Some(trimmed.to_owned());
        }
    }

    None
}

/// Load a `Config` from a TOML or JSON file.
///
/// - If the extension is `.toml`, parse as TOML.
/// - If the extension is `.json`, parse as JSON.
/// - Otherwise, try TOML first, then JSON, and include both errors on failure.
fn load_from_file(path: &Path) -> Result<Config> {
    let raw = fs::read_to_string(path).map_err(|e| {
        Error::config(format!(
            "failed to read config file {}: {e}",
            path.display()
        ))
    })?;

    let ext = path
        .extension()
        .and_then(|s| s.to_str())
        .map(|s| s.to_ascii_lowercase())
        .unwrap_or_default();

    let parsed: Result<Config> = match ext.as_str() {
        "toml" => toml::from_str(&raw).map_err(|e| {
            Error::config(format!(
                "failed to parse TOML config {}: {e}",
                path.display()
            ))
        }),
        "json" => serde_json::from_str(&raw).map_err(|e| {
            Error::config(format!(
                "failed to parse JSON config {}: {e}",
                path.display()
            ))
        }),
        _ => {
            // Unknown extension: try TOML first, then JSON, and include both errors.
            let toml_err = toml::from_str::<Config>(&raw).map_err(|e| e.to_string());
            match toml_err {
                Ok(cfg) => Ok(cfg),
                Err(t_err) => {
                    let json_err = serde_json::from_str::<Config>(&raw).map_err(|e| e.to_string());
                    match json_err {
                        Ok(cfg) => Ok(cfg),
                        Err(j_err) => Err(Error::config(format!(
                            "failed to parse config {} as TOML or JSON:\n  TOML error: {t_err}\n  JSON error: {j_err}",
                            path.display()
                        ))),
                    }
                }
            }
        }
    };

    parsed
}

```

### crates/macronode/src/config/mod.rs
<a id="crates-macronode-src-config-mod-rs"></a>

```rust
//! RO:WHAT — Config module root for Macronode.
//! RO:WHY  — Centralize schema + loaders (env/file/CLI overlays).
//! RO:INVARIANTS —
//!   - `Config` is the single source of truth for runtime settings.
//!   - Callers use `load_config()` or `load_effective_config()`; no ad-hoc
//!     env/file access sprinkled around the crate.

pub mod cli_overlay;
pub mod env_overlay;
pub mod hot_reload;
pub mod load;
pub mod schema;
pub mod validate;

// Public facade:
// - `Config` type
// - `load_config()` for non-run CLI commands (env + optional file)
// - `load_effective_config()` for `run` (CLI --config + env)
// - `hot_reload()` used by `/api/v1/reload` handler.
pub use hot_reload::hot_reload;
pub use load::{load_config, load_effective_config};
pub use schema::Config;

```

### crates/macronode/src/config/schema.rs
<a id="crates-macronode-src-config-schema-rs"></a>

```rust
//! RO:WHAT — Minimal config schema for Macronode.
//! RO:WHY  — Bind HTTP admin, metrics, timeouts, and log level with sane
//!           defaults.
//! RO:INTERACTS —
//!   - Loaded via `config::load_config()` / `load_config_with_file()`.
//!   - Passed into runtime state and admin HTTP stack.

use serde::{Deserialize, Serialize};
use std::{net::SocketAddr, time::Duration};

fn default_http_addr() -> SocketAddr {
    "127.0.0.1:8080"
        .parse()
        .expect("default 127.0.0.1:8080 must parse")
}

fn default_metrics_addr() -> SocketAddr {
    // By default we bind metrics on the same address as the admin HTTP plane.
    default_http_addr()
}

fn default_log_level() -> String {
    "info".to_string()
}

fn default_read_timeout() -> Duration {
    Duration::from_secs(10)
}

fn default_write_timeout() -> Duration {
    Duration::from_secs(10)
}

fn default_idle_timeout() -> Duration {
    Duration::from_secs(60)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct Config {
    /// HTTP admin bind address (`RON_HTTP_ADDR` / `MACRO_HTTP_ADDR`).
    #[serde(default = "default_http_addr")]
    pub http_addr: SocketAddr,

    /// Metrics bind address (`RON_METRICS_ADDR` / `MACRO_METRICS_ADDR`).
    ///
    /// Invariants:
    ///   - Defaults to the same value as `http_addr`.
    ///   - Env/CLI overlays may override it independently.
    #[serde(default = "default_metrics_addr")]
    pub metrics_addr: SocketAddr,

    /// Log level (fan-out via `RUST_LOG` env in logging bootstrap).
    #[serde(default = "default_log_level")]
    pub log_level: String,

    /// HTTP read timeout.
    ///
    /// File-config form uses humantime strings like `"5s"`, `"500ms"`, `"1m"`.
    /// Env overlay still respects `RON_READ_TIMEOUT` / `MACRO_READ_TIMEOUT`
    /// with the same humantime semantics.
    #[serde(default = "default_read_timeout", with = "humantime_serde")]
    pub read_timeout: Duration,

    /// HTTP write timeout.
    #[serde(default = "default_write_timeout", with = "humantime_serde")]
    pub write_timeout: Duration,

    /// HTTP idle timeout.
    #[serde(default = "default_idle_timeout", with = "humantime_serde")]
    pub idle_timeout: Duration,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            http_addr: default_http_addr(),
            metrics_addr: default_metrics_addr(),
            log_level: default_log_level(),
            read_timeout: default_read_timeout(),
            write_timeout: default_write_timeout(),
            idle_timeout: default_idle_timeout(),
        }
    }
}

```

### crates/macronode/src/config/validate.rs
<a id="crates-macronode-src-config-validate-rs"></a>

```rust
//! RO:WHAT — Config validation for Macronode.
//! RO:WHY  — Centralize invariants (ports, timeouts, limits) so we can
//!           evolve them without touching callers.
//! RO:INVARIANTS —
//!   - All durations must be > 0.
//!   - HTTP addr must be a valid SocketAddr (already enforced earlier).

use crate::errors::{Error, Result};

use super::schema::Config;

/// Validate a fully materialized config.
///
/// Returns `Ok(())` if the config is usable, or `Error::Config` with a
/// human-readable message if any invariant is violated.
pub fn validate_config(cfg: &Config) -> Result<()> {
    if cfg.read_timeout.as_millis() == 0 {
        return Err(Error::config("read_timeout must be > 0"));
    }
    if cfg.write_timeout.as_millis() == 0 {
        return Err(Error::config("write_timeout must be > 0"));
    }
    if cfg.idle_timeout.as_millis() == 0 {
        return Err(Error::config("idle_timeout must be > 0"));
    }

    Ok(())
}

```

### crates/macronode/src/errors.rs
<a id="crates-macronode-src-errors-rs"></a>

```rust
//! RO:WHAT — Error type and Result alias for Macronode.
//! RO:WHY  — Keep error plumbing boring and consistent across modules.
//! RO:INVARIANTS —
//!   - All fallible public fns in this crate return `errors::Result<T>`.
//!   - Config parsing collapses to `Error::Config` with human-readable messages.

use thiserror::Error;

/// Crate-local Result alias.
pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, Error)]
pub enum Error {
    /// Configuration issues (env/file/cli overlays).
    #[error("config error: {0}")]
    Config(String),

    /// I/O errors (sockets, files, etc.).
    #[error(transparent)]
    Io(#[from] std::io::Error),

    /// JSON serialization / formatting issues.
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),

    /// Catch-all for higher level composition until we tighten types.
    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

impl Error {
    pub fn config<S: Into<String>>(msg: S) -> Self {
        Error::Config(msg.into())
    }
}

```

### crates/macronode/src/facets/mod.rs
<a id="crates-macronode-src-facets-mod-rs"></a>

```rust
// crates/macronode/src/facets/mod.rs

//! RO:WHAT — Facet helpers for Macronode (permits, quotas, etc.).
//! RO:WHY  — Provide a small, crate-local façade around admission/quotas so
//!           higher layers can talk in terms of `PermitRequest` / `QuotaRequest`
//!           without depending on the eventual policy engine wiring.
//!
//! RO:INVARIANTS —
//!   - This module is intentionally tiny and mostly type re-exports.
//!   - It is OK for these types to be "unused" inside this crate for now;
//!     they are part of the public surface we are shaping for future use.
//!   - No I/O, no global state: pure data types and helpers only.
//!
//! RO:STATUS —
//!   - `permits` and `quotas` are currently simple data containers.
//!   - Enforcement is NOT yet wired into admin handlers or services; that
//!     will come when we introduce real admission control.

// These re-exports are part of the shaped API surface for macronode, and
// clippy will flag them as "unused" until we start plumbing them through
// the admin handlers and services. We explicitly allow that here so
// `cargo clippy -D warnings` stays green during the incremental build.
#![allow(unused_imports)]

pub mod permits;
pub mod quotas;

// Re-export the core facet types so callers can use
// `macronode::facets::{PermitRequest, PermitDecision, ...}`.
pub use permits::{PermitDecision, PermitKind, PermitRequest};
pub use quotas::{QuotaDecision, QuotaKey, QuotaRequest, QuotaWindow};

```

### crates/macronode/src/facets/permits.rs
<a id="crates-macronode-src-facets-permits-rs"></a>

```rust
//! RO:WHAT — Permit vocabulary for Macronode admission control.
//! RO:WHY  — Give us a tiny, crate-local language for “may this caller do
//!           X?” without committing to any particular policy backend.
//!
//! RO:INVARIANTS —
//!   - Pure data types; no I/O, no global state.
//!   - Safe to round-trip through JSON/TOML if needed later.

#![allow(dead_code)]

/// Coarse-grained operation the caller is attempting.
///
/// This is intentionally small and MACRO-local; richer detail belongs in
/// the policy layer (e.g. ron-policy, auth/kms services).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PermitKind {
    /// POST /api/v1/shutdown on the admin plane.
    AdminShutdown,
    /// POST /api/v1/reload on the admin plane.
    AdminReload,
    /// Inbound request on the gateway plane (svc-gateway).
    GatewayIngress,
    /// Read from storage plane (svc-storage).
    StorageRead,
    /// Write to storage plane (svc-storage).
    StorageWrite,
    /// Delete from storage plane (svc-storage).
    StorageDelete,
    /// Catch-all hook for future callers (feature flags, experiements).
    Custom(&'static str),
}

/// Minimal request context passed to a permit evaluator.
///
/// Foundation cut keeps this tiny. Higher layers can wrap this with richer
/// context (capability tokens, tenant IDs, paths, etc.) as needed.
#[derive(Debug, Clone)]
pub struct PermitRequest {
    /// Which logical operation is being attempted.
    pub kind: PermitKind,
    /// Optional identity for the caller (e.g. tenant/user ID).
    pub subject: Option<String>,
    /// Optional opaque capability/macaroon token (already parsed at edges).
    pub capability: Option<String>,
    /// Optional resource hint (e.g. HTTP path, bucket name).
    pub resource: Option<String>,
}

impl PermitRequest {
    #[must_use]
    pub fn new(kind: PermitKind) -> Self {
        Self {
            kind,
            subject: None,
            capability: None,
            resource: None,
        }
    }

    #[must_use]
    pub fn with_subject<S: Into<String>>(mut self, subject: S) -> Self {
        self.subject = Some(subject.into());
        self
    }

    #[must_use]
    pub fn with_capability<S: Into<String>>(mut self, cap: S) -> Self {
        self.capability = Some(cap.into());
        self
    }

    #[must_use]
    pub fn with_resource<S: Into<String>>(mut self, res: S) -> Self {
        self.resource = Some(res.into());
        self
    }
}

/// Result of a permit check.
///
/// This remains deliberately simple; a future slice could add structured
/// denial reasons or audit codes.
#[derive(Debug, Clone)]
pub enum PermitDecision {
    /// Operation is allowed to proceed.
    Allow,
    /// Operation is denied, with a human-readable reason.
    Deny { reason: String },
}

impl PermitDecision {
    /// Convenience helper to construct a denial.
    #[must_use]
    pub fn deny<S: Into<String>>(reason: S) -> Self {
        PermitDecision::Deny {
            reason: reason.into(),
        }
    }

    /// Returns true if the decision is an allow.
    #[must_use]
    pub const fn is_allowed(&self) -> bool {
        matches!(self, PermitDecision::Allow)
    }
}

```

### crates/macronode/src/facets/quotas.rs
<a id="crates-macronode-src-facets-quotas-rs"></a>

```rust
//! RO:WHAT — Quota vocabulary for Macronode admission control.
//! RO:WHY  — Provide a tiny, MACRO-local language for “how much is this
//!           caller allowed to do?” (rate limits, burst windows, etc.).
//!
//! RO:STATUS —
//!   - Foundation slice: pure types only, no counters or storage.
//!   - Evaluation engine will live alongside policy/registry later.
//!
//! RO:INVARIANTS —
//!   - All types are small and clone-friendly.
//!   - No direct dependency on any particular metrics or storage backend.

#![allow(dead_code)]

use std::time::Duration;

/// Logical window over which a quota applies.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum QuotaWindow {
    PerSecond,
    PerMinute,
    PerHour,
    PerDay,
    /// Custom-sized window for future extensions.
    Custom(Duration),
}

/// Stable key identifying a quota bucket.
///
/// Typical examples:
///   - subject = "tenant:abc", category = "gateway-requests"
///   - subject = "ip:203.0.113.1", category = "admin-shutdown"
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct QuotaKey {
    /// Entity being limited (user/tenant/IP/etc.).
    pub subject: String,
    /// Logical category (gateway, admin, storage, etc.).
    pub category: String,
}

impl QuotaKey {
    #[must_use]
    pub fn new<S: Into<String>, C: Into<String>>(subject: S, category: C) -> Self {
        Self {
            subject: subject.into(),
            category: category.into(),
        }
    }
}

/// Request to consume some quota from a bucket.
#[derive(Debug, Clone)]
pub struct QuotaRequest {
    /// Which bucket to charge.
    pub key: QuotaKey,
    /// How large this operation is, in arbitrary units (e.g. “1 request” or
    /// “N bytes”). Interpretation is up to the evaluator.
    pub cost: u64,
    /// Window the quota is evaluated over.
    pub window: QuotaWindow,
}

impl QuotaRequest {
    #[must_use]
    pub fn new(key: QuotaKey, cost: u64, window: QuotaWindow) -> Self {
        Self { key, cost, window }
    }
}

/// Result of a quota evaluation.
#[derive(Debug, Clone)]
pub enum QuotaDecision {
    /// Operation may proceed; remaining is a best-effort hint.
    Allow { remaining: Option<u64> },
    /// Operation is over quota; `retry_after` suggests when to try again.
    Deny { retry_after: Option<Duration> },
}

impl QuotaDecision {
    /// Returns true if this operation is allowed.
    #[must_use]
    pub const fn is_allowed(&self) -> bool {
        matches!(self, QuotaDecision::Allow { .. })
    }
}

```

### crates/macronode/src/http_admin/handlers/healthz.rs
<a id="crates-macronode-src-httpadmin-handlers-healthz-rs"></a>

```rust
//! RO:WHAT — `/healthz` liveness handler.
//! RO:WHY  — Simple "is the process alive" probe.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct Checks<'a> {
    event_loop: &'a str,
    clock: &'a str,
}

#[derive(Serialize)]
struct HealthBody<'a> {
    ok: bool,
    checks: Checks<'a>,
}

pub async fn handler() -> impl IntoResponse {
    let checks = Checks {
        event_loop: "ok",
        clock: "ok",
    };

    Json(HealthBody { ok: true, checks })
}

```

### crates/macronode/src/http_admin/handlers/metrics.rs
<a id="crates-macronode-src-httpadmin-handlers-metrics-rs"></a>

```rust
//! RO:WHAT — `/metrics` handler (Prometheus text).
//! RO:WHY  — Single scrape surface for admin metrics.

use crate::observability::metrics::encode_prometheus;
use axum::{http::StatusCode, response::IntoResponse};

pub async fn handler() -> impl IntoResponse {
    let body = encode_prometheus();
    (StatusCode::OK, body)
}

```

### crates/macronode/src/http_admin/handlers/mod.rs
<a id="crates-macronode-src-httpadmin-handlers-mod-rs"></a>

```rust
//! RO:WHAT — Admin HTTP handlers for Macronode.

pub mod healthz;
pub mod metrics;
pub mod reload;
pub mod shutdown;
pub mod status;
pub mod version;

```

### crates/macronode/src/http_admin/handlers/readyz.rs
<a id="crates-macronode-src-httpadmin-handlers-readyz-rs"></a>

```rust
//! RO:WHAT — Axum adapter for `/readyz`.
//! RO:WHY  — Delegate to `readiness::handler` with shared probes.

use std::sync::Arc;

use axum::response::IntoResponse;

use crate::readiness::{self, ReadyProbes};

pub async fn handler(probes: Arc<ReadyProbes>) -> impl IntoResponse {
    readiness::handler(probes).await
}

```

### crates/macronode/src/http_admin/handlers/reload.rs
<a id="crates-macronode-src-httpadmin-handlers-reload-rs"></a>

```rust
//! RO:WHAT — `/api/v1/reload` handler.
//! RO:WHY  — Trigger config hot reload (stub v1) and emit a bus event.
//!
//! RO:INVARIANTS —
//!   - Must run under admin auth middleware.
//!   - Uses `config::hot_reload()` (stub for now).
//!   - Async safe; returns 202-style semantics (we currently reply 200 OK).

use axum::{response::IntoResponse, Json};
use serde::Serialize;
use tracing::info;

use crate::{bus::NodeEvent, config, types::AppState};

#[derive(Serialize)]
struct ReloadResp {
    status: &'static str,
}

pub async fn handler(
    axum::extract::State(state): axum::extract::State<AppState>,
) -> impl IntoResponse {
    info!("macronode admin: reload requested");

    // Call into our stub for now — later will reload config + emit events.
    if let Err(e) = config::hot_reload(&state.cfg) {
        info!("macronode admin: reload failed: {e}");
    }

    // Emit a ConfigUpdated event on the intra-node bus.
    //
    // NOTE: Version is currently stubbed as 0. Once we track config epochs
    // or generation IDs, this should carry the real version.
    if let Err(send_err) = state.bus.publish(NodeEvent::ConfigUpdated { version: 0 }) {
        info!("macronode admin: failed to publish ConfigUpdated event on bus: {send_err:?}");
    }

    Json(ReloadResp {
        status: "reload triggered",
    })
}

```

### crates/macronode/src/http_admin/handlers/shutdown.rs
<a id="crates-macronode-src-httpadmin-handlers-shutdown-rs"></a>

```rust
//! RO:WHAT — `/api/v1/shutdown` handler.
//! RO:WHY  — Allow operators to trigger a controlled process exit via HTTP.
//!           MVP: respond 202, then exit the process after a short delay so
//!           callers see a clean response before shutdown completes.

use std::time::Duration;

use axum::{http::StatusCode, response::IntoResponse, Json};
use serde::Serialize;
use tokio::time::sleep;
use tracing::info;

#[derive(Serialize)]
struct ShutdownBody<'a> {
    status: &'a str,
    delay_ms: u64,
}

/// POST `/api/v1/shutdown`
///
/// Semantics (MVP):
/// - Immediately returns `202 Accepted` with a small JSON payload.
/// - In the background, waits for a short delay and then calls `std::process::exit(0)`.
/// - This is a coarse, process-wide shutdown; we will replace this with
///   proper supervisor-driven graceful shutdown in a later pass.
pub async fn handler() -> impl IntoResponse {
    let delay_ms: u64 = 500;

    // Fire-and-forget task that will terminate the process shortly after
    // the HTTP response has been sent.
    tokio::spawn(async move {
        info!(
            "macronode admin: /api/v1/shutdown requested; exiting in {} ms",
            delay_ms
        );
        sleep(Duration::from_millis(delay_ms)).await;

        // NOTE: This is intentionally blunt for the first pass. A later
        // revision will coordinate shutdown through the supervisor so
        // services can drain gracefully.
        std::process::exit(0);
    });

    (
        StatusCode::ACCEPTED,
        Json(ShutdownBody {
            status: "shutdown scheduled",
            delay_ms,
        }),
    )
}

```

### crates/macronode/src/http_admin/handlers/status.rs
<a id="crates-macronode-src-httpadmin-handlers-status-rs"></a>

```rust
//! RO:WHAT — `/api/v1/status` handler.
//! RO:WHY  — Give operators a basic runtime + readiness + service snapshot
//!           in one call.
//!
//! RO:INTERACTS —
//!   - Uses `AppState` for config + probes + start time.
//!   - Reuses the same readiness logic as `/readyz` via `ReadyProbes::snapshot()`.
//!
//! RO:INVARIANTS —
//!   - `ready` field matches the `required_ready()` gate used by `/readyz`.
//!   - `deps` mirrors the `/readyz` dependency labels (config/network/gateway/storage).
//!   - `services` is a low-cardinality map of core services macronode supervises.
//!   - No blocking I/O; cheap and safe to call frequently.

use std::{collections::BTreeMap, time::Instant};

use axum::{response::IntoResponse, Json};
use serde::Serialize;

use crate::{observability::metrics::update_macronode_metrics, types::AppState};

#[derive(Serialize)]
struct StatusDeps {
    config: &'static str,
    network: &'static str,
    gateway: &'static str,
    storage: &'static str,
}

#[derive(Serialize)]
struct StatusBody {
    /// Seconds since this macronode process started.
    uptime_seconds: u64,
    /// Profile name for this node (always "macronode" for this crate).
    profile: &'static str,
    /// Admin HTTP bind address (where `/healthz`/`/readyz`/`/metrics` live).
    http_addr: String,
    /// Metrics bind address (currently shares the admin listener, but kept
    /// separate at the config level for future slices).
    metrics_addr: String,
    /// Effective log level for this process.
    log_level: String,
    /// Whether the node considers itself "ready" according to the same
    /// gates used by `/readyz`.
    ready: bool,
    /// Per-dependency status, mirroring `/readyz`.
    deps: StatusDeps,
    /// Per-service summary.
    ///
    /// Keys:
    ///   - "svc-gateway"
    ///   - "svc-storage"
    ///   - "svc-index"
    ///   - "svc-mailbox"
    ///   - "svc-overlay"
    ///   - "svc-dht"
    ///
    /// Values are simple strings for now:
    ///   - "ok"      — service is bound and reported healthy/coarse-ok.
    ///   - "pending" — service has not yet met its readiness condition.
    ///   - "stub"    — service is a placeholder worker without real health.
    services: BTreeMap<String, String>,
}

pub async fn handler(state: axum::extract::State<AppState>) -> impl IntoResponse {
    let AppState {
        cfg,
        probes,
        started_at,
        ..
    } = state.0;

    let uptime = Instant::now()
        .saturating_duration_since(started_at)
        .as_secs();

    let snap = probes.snapshot();
    let ready = snap.required_ready();

    // Keep metrics in sync with what we present via status.
    update_macronode_metrics(uptime, ready);

    let deps = StatusDeps {
        config: if snap.cfg_loaded { "loaded" } else { "pending" },
        network: if snap.listeners_bound {
            "ok"
        } else {
            "pending"
        },
        gateway: if snap.gateway_bound { "ok" } else { "pending" },
        // Today deps_ok flips true once gateway + storage + index workers are spawned.
        storage: if snap.deps_ok { "ok" } else { "pending" },
    };

    let mut services = BTreeMap::new();

    // Gateway: real listener + readiness bit.
    services.insert(
        "svc-gateway".to_string(),
        if snap.gateway_bound { "ok" } else { "pending" }.to_string(),
    );

    // Storage + index: now real embedded HTTP services; we treat them as "ok"
    // once deps_ok is true (spawn_all() only flips this after wiring them).
    let deps_status = if snap.deps_ok { "ok" } else { "pending" };

    services.insert("svc-storage".to_string(), deps_status.to_string());
    services.insert("svc-index".to_string(), deps_status.to_string());

    // Remaining services are still stub workers in this slice.
    services.insert("svc-mailbox".to_string(), "stub".to_string());
    services.insert("svc-overlay".to_string(), "stub".to_string());
    services.insert("svc-dht".to_string(), "stub".to_string());

    Json(StatusBody {
        uptime_seconds: uptime,
        profile: "macronode",
        http_addr: cfg.http_addr.to_string(),
        metrics_addr: cfg.metrics_addr.to_string(),
        log_level: cfg.log_level.clone(),
        ready,
        deps,
        services,
    })
}

```

### crates/macronode/src/http_admin/handlers/version.rs
<a id="crates-macronode-src-httpadmin-handlers-version-rs"></a>

```rust
//! RO:WHAT — `/version` handler for Macronode.
//! RO:WHY  — Provide build provenance and HTTP API version.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

use crate::types::BuildInfo;

#[derive(Serialize)]
struct ApiInfo<'a> {
    http: &'a str,
}

#[derive(Serialize)]
struct VersionBody<'a> {
    service: &'a str,
    version: &'a str,
    git_sha: &'a str,
    build_ts: &'a str,
    rustc: &'a str,
    msrv: &'a str,
    api: ApiInfo<'a>,
}

pub async fn handler() -> impl IntoResponse {
    let info = BuildInfo::current();

    let body = VersionBody {
        service: info.service,
        version: info.version,
        git_sha: info.git_sha,
        build_ts: info.build_ts,
        rustc: info.rustc,
        msrv: info.msrv,
        api: ApiInfo { http: "v1" },
    };

    Json(body)
}

```

### crates/macronode/src/http_admin/middleware/auth.rs
<a id="crates-macronode-src-httpadmin-middleware-auth-rs"></a>

```rust
//! RO:WHAT — Admin auth middleware.
//! RO:WHY  — Guard sensitive POST endpoints (`/api/v1/shutdown`, `/api/v1/reload`).
//!
//! RO:INVARIANTS —
//!   - If `RON_ADMIN_TOKEN` is set, sensitive endpoints require
//!     `Authorization: Bearer <token>`.
//!   - If bound to loopback AND no token is set, we ALLOW but WARN.
//!   - If bound to NON-loopback AND no token is set, we BLOCK unless
//!     `MACRONODE_DEV_INSECURE=1`.
//!   - `MACRONODE_DEV_INSECURE=1` bypasses everything (dev ergonomics).

use axum::{
    body::Body,
    http::{header::AUTHORIZATION, Method, Request, StatusCode},
    middleware::Next,
    response::Response,
};
use std::net::IpAddr;
use tracing::{info, warn};

pub async fn layer(req: Request<Body>, next: Next) -> Result<Response, StatusCode> {
    // Only guard POST /shutdown & POST /reload
    let method = req.method().clone();
    let path = req.uri().path().to_string();

    let needs_guard =
        method == Method::POST && (path == "/api/v1/shutdown" || path == "/api/v1/reload");

    if !needs_guard {
        return Ok(next.run(req).await);
    }

    // Explicit dev bypass
    if dev_insecure() {
        warn!("MACRONODE_DEV_INSECURE=1 — bypassing admin auth for {method} {path}");
        return Ok(next.run(req).await);
    }

    // Determine if the admin listener is loopback-only
    let is_loopback = match req.headers().get("host").and_then(|h| h.to_str().ok()) {
        Some(host) => host
            .parse::<IpAddr>()
            .map(|ip| ip.is_loopback())
            .unwrap_or(true),
        None => true,
    };

    // Determine token
    let expected_token = std::env::var("RON_ADMIN_TOKEN")
        .ok()
        .filter(|t| !t.is_empty());

    match expected_token {
        Some(expected) => {
            // Token required — validate header
            let auth_header = req
                .headers()
                .get(AUTHORIZATION)
                .and_then(|h| h.to_str().ok());

            let ok = auth_header
                .and_then(|v| v.strip_prefix("Bearer "))
                .map(|v| v == expected)
                .unwrap_or(false);

            if !ok {
                warn!("unauthorized {method} {path} — missing/invalid token");
                return Err(StatusCode::UNAUTHORIZED);
            }

            info!("authorized admin {method} {path}");
            Ok(next.run(req).await)
        }

        None => {
            // No token set
            if is_loopback {
                warn!("RON_ADMIN_TOKEN is not set — allowing admin action on loopback {method} {path}");
                Ok(next.run(req).await)
            } else {
                warn!("BLOCKED admin action — RON_ADMIN_TOKEN missing + non-loopback bind {method} {path}");
                Err(StatusCode::UNAUTHORIZED)
            }
        }
    }
}

fn dev_insecure() -> bool {
    matches!(
        std::env::var("MACRONODE_DEV_INSECURE").as_deref(),
        Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
    )
}

```

### crates/macronode/src/http_admin/middleware/mod.rs
<a id="crates-macronode-src-httpadmin-middleware-mod-rs"></a>

```rust
//! RO:WHAT — Admin HTTP middleware for Macronode.
//! RO:WHY  — Cross-cutting behaviors around the admin router.
//!
//! RO:INVARIANTS —
//!   - Middlewares are pure functions over `Request<Body>` and `Next`.
//!   - No panics on malformed headers; we fail closed where appropriate.
//!   - Admin auth is opt-in via `RON_ADMIN_TOKEN` but loudly logs when unset.

pub mod auth;
pub mod rate_limit;
pub mod request_id;
pub mod timeout;

```

### crates/macronode/src/http_admin/middleware/rate_limit.rs
<a id="crates-macronode-src-httpadmin-middleware-ratelimit-rs"></a>

```rust
//! RO:WHAT — Rate limiting middleware (placeholder).
//! RO:WHY  — Anchor point for future per-endpoint throttling.
//!
//! RO:INVARIANTS —
//!   - Currently a no-op pass-through.
//!   - Safe to extend later with token buckets / IP-based limits.

use axum::{
    body::Body,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};

pub async fn layer(req: Request<Body>, next: Next) -> Result<Response, StatusCode> {
    // TODO: Implement per-endpoint/IP rate limiting once we have config knobs.
    Ok(next.run(req).await)
}

```

### crates/macronode/src/http_admin/middleware/request_id.rs
<a id="crates-macronode-src-httpadmin-middleware-requestid-rs"></a>

```rust
//! RO:WHAT — X-Request-Id middleware.
//! RO:WHY  — Give every request/response a stable request ID for tracing.
//!
//! RO:INVARIANTS —
//!   - If the client sends `x-request-id`, we preserve it.
//!   - Otherwise we generate a simple process-unique ID.

use std::time::{SystemTime, UNIX_EPOCH};

use axum::{
    body::Body,
    http::{header::HeaderName, HeaderValue, Request, StatusCode},
    middleware::Next,
    response::Response,
};
use tracing::trace;

const X_REQUEST_ID: &str = "x-request-id";

pub async fn layer(mut req: Request<Body>, next: Next) -> Result<Response, StatusCode> {
    let header_name = HeaderName::from_static(X_REQUEST_ID);

    // If there is no request-id, generate one and attach it to the request.
    if !req.headers().contains_key(&header_name) {
        let id = gen_request_id();
        if let Ok(v) = HeaderValue::from_str(&id) {
            req.headers_mut().insert(&header_name, v);
        }
    }

    // Grab an OWNED copy of the request-id for logging and response echo.
    let id_for_log: String = req
        .headers()
        .get(&header_name)
        .and_then(|v| v.to_str().ok())
        .map(|s| s.to_string())
        .unwrap_or_else(|| "<missing>".to_string());

    trace!(request_id = %id_for_log, "macronode admin: handling request");

    // Move the request into the next layer/handler.
    let mut res = next.run(req).await;

    // Echo the request-id back on the response if not already set.
    if !res.headers().contains_key(&header_name) {
        if let Ok(v) = HeaderValue::from_str(&id_for_log) {
            res.headers_mut().insert(&header_name, v);
        }
    }

    Ok(res)
}

fn gen_request_id() -> String {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default();
    // Not cryptographically strong — just unique-ish for tracing.
    format!("macronode-{}", now.as_nanos())
}

```

### crates/macronode/src/http_admin/middleware/timeout.rs
<a id="crates-macronode-src-httpadmin-middleware-timeout-rs"></a>

```rust
//! RO:WHAT — Simple per-request timeout middleware.
//! RO:WHY  — Prevent hung /admin calls from blocking probes forever.
//!
//! RO:INVARIANTS —
//!   - Uses a conservative fixed timeout for now.
//!   - Returns `504 Gateway Timeout` on expiry.

use std::time::Duration;

use axum::{
    body::Body,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use tokio::time::timeout;
use tracing::warn;

// For now this is a static admin timeout. We can later wire this to
// `Config` (e.g., `admin_timeout`) if we want it to be configurable.
const ADMIN_TIMEOUT: Duration = Duration::from_secs(10);

pub async fn layer(req: Request<Body>, next: Next) -> Result<Response, StatusCode> {
    match timeout(ADMIN_TIMEOUT, next.run(req)).await {
        Ok(resp) => Ok(resp),
        Err(_) => {
            warn!(
                "macronode admin: request timed out after {:?}",
                ADMIN_TIMEOUT
            );
            Err(StatusCode::GATEWAY_TIMEOUT)
        }
    }
}

```

### crates/macronode/src/http_admin/mod.rs
<a id="crates-macronode-src-httpadmin-mod-rs"></a>

```rust
//! RO:WHAT — HTTP admin/observability plane for Macronode.
//! RO:WHY  — Expose `/version`, `/healthz`, `/readyz`, `/metrics`, and basic admin APIs.
//! RO:INTERACTS —
//!   - `AppState` for config + probes.
//!   - `observability::metrics` for Prometheus encoding.

pub mod handlers;
pub mod middleware;
pub mod router;

```

### crates/macronode/src/http_admin/router.rs
<a id="crates-macronode-src-httpadmin-router-rs"></a>

```rust
//! RO:WHAT — Router builder for Macronode admin plane.

use std::sync::Arc;

use axum::{
    middleware::from_fn,
    routing::{get, post},
    Router,
};

use crate::{
    http_admin::middleware::{auth, rate_limit, request_id, timeout},
    readiness::{self, ReadyProbes},
    types::AppState,
};

pub fn build_router(state: AppState) -> Router {
    let probes: Arc<ReadyProbes> = state.probes.clone();

    let base = Router::new()
        .route(
            "/version",
            get(crate::http_admin::handlers::version::handler),
        )
        .route(
            "/healthz",
            get(crate::http_admin::handlers::healthz::handler),
        )
        .route(
            "/readyz",
            get(move || {
                let probes = probes.clone();
                readiness::handler(probes)
            }),
        )
        .route(
            "/metrics",
            get(crate::http_admin::handlers::metrics::handler),
        )
        .route(
            "/api/v1/status",
            get(crate::http_admin::handlers::status::handler),
        )
        .route(
            "/api/v1/reload",
            post(crate::http_admin::handlers::reload::handler),
        )
        .route(
            "/api/v1/shutdown",
            post(crate::http_admin::handlers::shutdown::handler),
        )
        .with_state(state);

    // Middleware stack:
    base.layer(from_fn(rate_limit::layer))
        .layer(from_fn(auth::layer)) // only applies to guarded paths
        .layer(from_fn(timeout::layer))
        .layer(from_fn(request_id::layer))
}

```

### crates/macronode/src/main.rs
<a id="crates-macronode-src-main-rs"></a>

```rust
//! RO:WHAT — Binary entrypoint for Macronode.
//! RO:WHY  — Wire config, logging, readiness, admin HTTP plane, and supervisor.
//! RO:INVARIANTS —
//!   - No public Rust API (binary-only crate).
//!   - Admin HTTP is truthful by default; dev overrides are explicit.

#![forbid(unsafe_code)]

mod bus;
mod cli;
mod config;
mod errors;
mod http_admin;
mod observability;
mod readiness;
mod services;
mod supervisor;
mod types;

use crate::errors::Result;

#[tokio::main]
async fn main() -> Result<()> {
    cli::entrypoint().await
}

```

### crates/macronode/src/observability/logging.rs
<a id="crates-macronode-src-observability-logging-rs"></a>

```rust
//! RO:WHAT — Tracing subscriber initialization for Macronode.
//! RO:WHY  — Deterministic logs with env filter and JSON-friendly format.

use tracing_subscriber::{fmt, EnvFilter};

pub fn init(log_level: &str) {
    let default = format!("macronode={log_level},info");
    let filter = std::env::var("RUST_LOG").unwrap_or(default);

    let _ = fmt().with_env_filter(EnvFilter::new(filter)).try_init();
}

```

### crates/macronode/src/observability/metrics.rs
<a id="crates-macronode-src-observability-metrics-rs"></a>

```rust
//! RO:WHAT — Metrics plumbing for Macronode.
//! RO:WHY  — Keep a home for Prometheus registration and HTTP-layer metrics.
//! RO:INVARIANTS —
//!   - Metric families are registered against the default Prometheus registry.
//!   - This module is safe to call from multiple threads; registration is
//!     guarded so we only build metric handles once.

use std::sync::OnceLock;

use prometheus::{Encoder, Gauge, Opts, TextEncoder};

/// Simple macronode metric set.
///
/// We keep this intentionally tiny for now: just uptime + ready flag.
/// This is enough to make `/metrics` non-empty and to give operators
/// a quick at-a-glance signal without pulling `/api/v1/status`.
struct MacronodeMetrics {
    uptime_seconds: Gauge,
    ready: Gauge,
}

static METRICS: OnceLock<MacronodeMetrics> = OnceLock::new();

fn metrics() -> &'static MacronodeMetrics {
    METRICS.get_or_init(|| {
        let uptime_opts = Opts::new(
            "macronode_uptime_seconds",
            "Seconds since this macronode process started.",
        )
        .namespace("ron");

        let ready_opts = Opts::new(
            "macronode_ready",
            "1 if macronode reports ready=true, 0 otherwise.",
        )
        .namespace("ron");

        let uptime_seconds = Gauge::with_opts(uptime_opts).expect("macronode_uptime_seconds gauge");
        let ready = Gauge::with_opts(ready_opts).expect("macronode_ready gauge");

        // Register with the default registry; failures here are fatal because
        // they indicate programmer error (duplicate names, etc.).
        prometheus::register(Box::new(uptime_seconds.clone()))
            .expect("register macronode_uptime_seconds");
        prometheus::register(Box::new(ready.clone())).expect("register macronode_ready");

        MacronodeMetrics {
            uptime_seconds,
            ready,
        }
    })
}

/// Update macronode-local metrics.
///
/// This is cheap enough to call whenever we build `/api/v1/status`, so we
/// keep the call surface simple: the admin path passes in its computed
/// uptime + readiness bit.
pub fn update_macronode_metrics(uptime_seconds: u64, ready: bool) {
    let m = metrics();
    m.uptime_seconds.set(uptime_seconds as f64);
    m.ready.set(if ready { 1.0 } else { 0.0 });
}

/// Encode all registered metrics in Prometheus text format.
///
/// This is intentionally minimal for the first pass; other crates in the
/// workspace may also register metrics against the default registry.
pub fn encode_prometheus() -> String {
    let metric_families = prometheus::gather();
    let encoder = TextEncoder::new();
    let mut buf = Vec::new();
    if let Err(err) = encoder.encode(&metric_families, &mut buf) {
        eprintln!("[macronode-metrics] encode error: {err}");
        return String::new();
    }

    String::from_utf8(buf).unwrap_or_default()
}

```

### crates/macronode/src/observability/mod.rs
<a id="crates-macronode-src-observability-mod-rs"></a>

```rust
//! RO:WHAT — Observability surfaces for Macronode.
//! RO:WHY  — Keep main/bootstrap clean; centralize logging/metrics wiring.
//! RO:INVARIANTS —
//!   - Logging is initialized exactly once per process.
//!   - Metrics module is present (even if initially a stub) so `/metrics` works.

pub mod logging;
pub mod metrics;

```

### crates/macronode/src/pq/hybrid.rs
<a id="crates-macronode-src-pq-hybrid-rs"></a>

```rust
//! RO:WHAT — Stub types for hybrid PQ keying configuration.
//! RO:WHY  — Keep the *shape* of PQ integration stable while we defer
//!           the actual cryptography and transport/KMS wiring to other
//!           crates (ron-transport, ron-kms, svc-gateway, svc-overlay).
//!
//! RO:STATUS —
//!   - Foundation slice; no crypto, no external dependencies.
//!   - Safe to extend once PQ libraries and envelopes are chosen.
//!
//! RO:INVARIANTS —
//!   - This module is purely descriptive and carries no secrets.
//!   - Default configuration is conservative (no PQ suite selected).

/// Logical identifier for a PQ-capable hybrid algorithm suite.
///
/// Foundation cut keeps this stringly-typed; once we lock in a concrete
/// set of KEM/sign combos (e.g. "x25519+mlkem768"), we can substitute a
/// richer enum or newtype.
pub type SuiteId = &'static str;

/// Minimal configuration describing which PQ suite (if any) this node
/// prefers for **hybrid** operation.
///
/// This is intentionally small and self-contained. Downstream crates
/// will decide how to interpret and enforce it at the transport and
/// KMS layers.
#[derive(Debug, Clone)]
pub struct HybridConfig {
    /// Selected hybrid suite identifier (e.g. "x25519+mlkem768").
    ///
    /// `None` means "no PQ preference" and is the current default.
    pub suite: Option<SuiteId>,
}

impl Default for HybridConfig {
    fn default() -> Self {
        // Foundation: do not force PQ on; macronode will remain classical
        // until operators enable PQ at the edges and downstream planes
        // are wired to support it.
        Self { suite: None }
    }
}

```

### crates/macronode/src/pq/mod.rs
<a id="crates-macronode-src-pq-mod-rs"></a>

```rust
//! RO:WHAT — Post-quantum (PQ) posture helpers for Macronode.
//! RO:WHY  — Interpret env/config flags into a simple runtime enum that
//!           higher layers (TLS, KMS, gateway/overlay) can inspect once
//!           they grow PQ support.
//!
//! RO:INVARIANTS —
//!   - This module performs *no* cryptographic operations.
//!   - Default posture is `PqPosture::Off` to preserve interop until
//!     operators explicitly opt in.
//!   - Unknown/invalid mode strings never panic; they map to `Off` with
//!     a best-effort warning to stderr.
//!
//! RO:CONFIG —
//!   - Env: `RON_PQ_MODE` (foundation cut)
//!       * "off" (default)  → PqPosture::Off
//!       * "hybrid"         → PqPosture::Hybrid
//!     Additional aliases: "0"/"false"/"" → Off, "1"/"true"/"on" → Hybrid.
//!
//! Future slices can add integration with structured config
//! (`config::schema` and overlays) once PQ is wired downstream.

use std::env;

/// Runtime PQ posture for this macronode process.
///
/// Foundation slice keeps this intentionally small: either PQ is off, or we
/// allow a **hybrid** posture where classical + PQ can both be used by
/// lower layers once they are ready.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PqPosture {
    /// PQ disabled; classical-only handshakes/keys.
    Off,
    /// Hybrid posture (classical + PQ), where downstream planes can
    /// negotiate PQ-enabled edges when peers support it.
    Hybrid,
}

impl PqPosture {
    /// Derive posture from the `RON_PQ_MODE` environment variable.
    ///
    /// This is intentionally forgiving and never panics: unrecognised
    /// values simply fall back to `Off` and emit a best-effort warning.
    #[must_use]
    pub fn from_env() -> Self {
        match env::var("RON_PQ_MODE") {
            Ok(raw) => Self::from_str(raw.trim()),
            Err(_) => PqPosture::Off,
        }
    }

    /// Parse posture from a string, accepting a few convenient aliases.
    ///
    /// Known values (case-insensitive):
    ///   - "off", "0", "false", ""       → Off
    ///   - "hybrid", "on", "1", "true"   → Hybrid
    #[must_use]
    pub fn from_str(raw: &str) => Self {
        let lowered = raw.to_ascii_lowercase();
        match lowered.as_str() {
            "" | "off" | "0" | "false" | "disabled" => PqPosture::Off,
            "hybrid" | "on" | "1" | "true" | "enabled" => PqPosture::Hybrid,
            other => {
                // Foundation cut: we don't have tracing plumbed into this
                // module yet, so log to stderr. Later we can route this
                // through `tracing::warn!` once call-sites exist.
                eprintln!(
                    "[macronode-pq] RON_PQ_MODE={other:?} not recognised; defaulting to Off"
                );
                PqPosture::Off
            }
        }
    }

    /// Convenience boolean for feature gating.
    #[must_use]
    pub const fn is_enabled(self) -> bool {
        !matches!(self, PqPosture::Off)
    }
}

#[cfg(test)]
mod tests {
    use super::PqPosture;

    #[test]
    fn from_str_off_aliases() {
        for v in ["", "off", "OFF", "0", "false", "FALSE", "disabled"] {
            assert_eq!(PqPosture::from_str(v), PqPosture::Off, "value={v:?}");
        }
    }

    #[test]
    fn from_str_hybrid_aliases() {
        for v in ["hybrid", "HYBRID", "1", "on", "ON", "true", "TRUE", "enabled"] {
            assert_eq!(PqPosture::from_str(v), PqPosture::Hybrid, "value={v:?}");
        }
    }

    #[test]
    fn unknown_values_fall_back_to_off() {
        assert_eq!(PqPosture::from_str("weird-mode"), PqPosture::Off);
    }
}

```

### crates/macronode/src/readiness/deps.rs
<a id="crates-macronode-src-readiness-deps-rs"></a>

```rust
// crates/macronode/src/readiness/deps.rs

//! RO:WHAT — JSON shapes and helpers for `/readyz` dependency reporting.
//! RO:WHY  — Keep HTTP response wiring separate from probe mechanics, while
//!           preserving a stable JSON contract for tests and operators.
//!
//! High-level JSON shape:
//!   {
//!     "ready": bool,
//!     "deps": {
//!       "config":  "loaded" | "pending",
//!       "network": "ok" | "pending",
//!       "gateway": "ok" | "pending",
//!       "storage": "ok" | "pending",
//!       "index":   "ok" | "pending",
//!       "overlay": "ok" | "pending",
//!       "mailbox": "ok" | "pending",
//!       "dht":     "ok" | "pending"
//!     },
//!     "mode": "truthful" | "dev-forced"
//!   }

use serde::Serialize;

use super::probes::ReadySnapshot;

/// Dependency state block for `/readyz`.
#[derive(Serialize)]
pub(super) struct ReadyDeps<'a> {
    pub(super) config: &'a str,
    pub(super) network: &'a str,
    pub(super) gateway: &'a str,
    pub(super) storage: &'a str,
    pub(super) index: &'a str,
    pub(super) overlay: &'a str,
    pub(super) mailbox: &'a str,
    pub(super) dht: &'a str,
}

/// Top-level `/readyz` response body.
#[derive(Serialize)]
pub(super) struct ReadyBody<'a> {
    pub(super) ready: bool,
    pub(super) deps: ReadyDeps<'a>,
    pub(super) mode: &'a str,
}

impl<'a> ReadyDeps<'a> {
    /// Construct dependency view from a snapshot.
    ///
    /// Mapping:
    ///   - config  ← cfg_loaded → "loaded"/"pending"
    ///   - network ← listeners_bound → "ok"/"pending"
    ///   - gateway ← gateway_bound → "ok"/"pending"
    ///   - storage ← deps_ok → "ok"/"pending"
    ///   - index   ← index_bound → "ok"/"pending"
    ///   - overlay ← overlay_bound → "ok"/"pending"
    ///   - mailbox ← mailbox_bound → "ok"/"pending"
    ///   - dht     ← dht_bound → "ok"/"pending"
    #[must_use]
    pub(super) fn from_snapshot(snap: &'a ReadySnapshot) -> Self {
        ReadyDeps {
            config: if snap.cfg_loaded { "loaded" } else { "pending" },
            network: if snap.listeners_bound {
                "ok"
            } else {
                "pending"
            },
            gateway: if snap.gateway_bound { "ok" } else { "pending" },
            storage: if snap.deps_ok { "ok" } else { "pending" },
            index: if snap.index_bound { "ok" } else { "pending" },
            overlay: if snap.overlay_bound { "ok" } else { "pending" },
            mailbox: if snap.mailbox_bound { "ok" } else { "pending" },
            dht: if snap.dht_bound { "ok" } else { "pending" },
        }
    }
}

impl<'a> ReadyBody<'a> {
    /// Helper to keep handler code small and readable.
    #[must_use]
    pub(super) fn new(ready: bool, deps: ReadyDeps<'a>, mode: &'a str) -> Self {
        ReadyBody { ready, deps, mode }
    }
}

```

### crates/macronode/src/readiness/mod.rs
<a id="crates-macronode-src-readiness-mod-rs"></a>

```rust
// crates/macronode/src/readiness/mod.rs

//! RO:WHAT — Readiness probes and `/readyz` handler for Macronode.
//! RO:WHY  — Truthful, operator-friendly readiness for orchestration
//!           (K8s/systemd/CI) with a clean separation of concerns.
//!
//! RO:INVARIANTS —
//!   Essential gates for ready=true: listeners_bound && cfg_loaded && deps_ok && gateway_bound.
//!   Per-service bits (index/overlay/mailbox/dht) are tracked and exposed in the JSON `deps`
//!   payload but do not gate readiness yet.
//!   Dev override: MACRONODE_DEV_READY=1 forces `ready=true` while still exposing actual
//!   dependency states in the body.

mod deps;
mod probes;

pub use probes::ReadyProbes;

use axum::{
    http::{HeaderMap, HeaderValue, StatusCode},
    response::IntoResponse,
    Json,
};
use std::sync::Arc;

use self::deps::{ReadyBody, ReadyDeps};

/// Check whether the dev override is enabled via `MACRONODE_DEV_READY`.
fn dev_override_enabled() -> bool {
    matches!(
        std::env::var("MACRONODE_DEV_READY").as_deref(),
        Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
    )
}

/// Axum handler for `/readyz`.
///
/// Responsibilities:
///   - Snapshot probes (cheap, lock-free).
///   - Apply dev override semantics.
///   - Map snapshot → JSON deps/body using `deps` helpers.
///   - Attach `Retry-After` when not ready in truthful mode.
pub async fn handler(probes: Arc<ReadyProbes>) -> impl IntoResponse {
    // Dev override: force ready=true, but still report what Macronode knows
    // about each dependency so operators can see "what's actually happening".
    if dev_override_enabled() {
        let snap = probes.snapshot();
        let deps = ReadyDeps::from_snapshot(&snap);
        let body = ReadyBody::new(true, deps, "dev-forced");

        return (StatusCode::OK, Json(body)).into_response();
    }

    // Truthful mode: rely on the required_ready() invariant and surface
    // dependency states directly.
    let snap = probes.snapshot();
    let ok = snap.required_ready();
    let deps = ReadyDeps::from_snapshot(&snap);

    let mut headers = HeaderMap::new();
    if !ok {
        // Friendly hint to orchestrators / callers to back off before retrying.
        headers.insert("Retry-After", HeaderValue::from_static("5"));
    }

    let body = ReadyBody::new(ok, deps, "truthful");
    let status = if ok {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };

    (status, headers, Json(body)).into_response()
}

```

### crates/macronode/src/readiness/probes.rs
<a id="crates-macronode-src-readiness-probes-rs"></a>

```rust
// crates/macronode/src/readiness/probes.rs

//! RO:WHAT — In-process readiness probes and snapshot type.
//! RO:WHY  — Cheap, concurrency-friendly source of truth for `/readyz` and
//!           future status endpoints.
//!
//! RO:INVARIANTS —
//!   - All flags are atomic booleans with Release/Acquire semantics.
//!   - `required_ready()` encodes the essential gates for reporting
//!     `ready == true` in truthful mode.
//!   - Per-service bits (index/overlay/mailbox/dht) are tracked but do not
//!     gate readiness yet; they are surfaced in JSON only.

use serde::Serialize;
use std::sync::atomic::{AtomicBool, Ordering};

#[derive(Debug)]
pub struct ReadyProbes {
    // Essential gates
    listeners_bound: AtomicBool,
    cfg_loaded: AtomicBool,
    metrics_bound: AtomicBool,
    deps_ok: AtomicBool,
    gateway_bound: AtomicBool,

    // Per-service bits (informational for now)
    index_bound: AtomicBool,
    overlay_bound: AtomicBool,
    mailbox_bound: AtomicBool,
    dht_bound: AtomicBool,
}

impl ReadyProbes {
    /// Construct a fresh probe set with all gates set to `false`.
    #[must_use]
    pub fn new() -> Self {
        Self {
            listeners_bound: AtomicBool::new(false),
            cfg_loaded: AtomicBool::new(false),
            metrics_bound: AtomicBool::new(false),
            deps_ok: AtomicBool::new(false),
            gateway_bound: AtomicBool::new(false),
            index_bound: AtomicBool::new(false),
            overlay_bound: AtomicBool::new(false),
            mailbox_bound: AtomicBool::new(false),
            dht_bound: AtomicBool::new(false),
        }
    }

    // --- Essential gate setters ---

    pub fn set_listeners_bound(&self, v: bool) {
        self.listeners_bound.store(v, Ordering::Release);
    }

    pub fn set_cfg_loaded(&self, v: bool) {
        self.cfg_loaded.store(v, Ordering::Release);
    }

    pub fn set_metrics_bound(&self, v: bool) {
        self.metrics_bound.store(v, Ordering::Release);
    }

    pub fn set_deps_ok(&self, v: bool) {
        self.deps_ok.store(v, Ordering::Release);
    }

    pub fn set_gateway_bound(&self, v: bool) {
        self.gateway_bound.store(v, Ordering::Release);
    }

    // --- Per-service setters (informational) ---

    pub fn set_index_bound(&self, v: bool) {
        self.index_bound.store(v, Ordering::Release);
    }

    pub fn set_overlay_bound(&self, v: bool) {
        self.overlay_bound.store(v, Ordering::Release);
    }

    pub fn set_mailbox_bound(&self, v: bool) {
        self.mailbox_bound.store(v, Ordering::Release);
    }

    pub fn set_dht_bound(&self, v: bool) {
        self.dht_bound.store(v, Ordering::Release);
    }

    /// Take a consistent snapshot for use by HTTP handlers / metrics.
    #[must_use]
    pub fn snapshot(&self) -> ReadySnapshot {
        ReadySnapshot {
            listeners_bound: self.listeners_bound.load(Ordering::Acquire),
            cfg_loaded: self.cfg_loaded.load(Ordering::Acquire),
            metrics_bound: self.metrics_bound.load(Ordering::Acquire),
            deps_ok: self.deps_ok.load(Ordering::Acquire),
            gateway_bound: self.gateway_bound.load(Ordering::Acquire),
            index_bound: self.index_bound.load(Ordering::Acquire),
            overlay_bound: self.overlay_bound.load(Ordering::Acquire),
            mailbox_bound: self.mailbox_bound.load(Ordering::Acquire),
            dht_bound: self.dht_bound.load(Ordering::Acquire),
        }
    }
}

impl Default for ReadyProbes {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct ReadySnapshot {
    pub listeners_bound: bool,
    pub cfg_loaded: bool,
    pub metrics_bound: bool,
    pub deps_ok: bool,
    pub gateway_bound: bool,
    pub index_bound: bool,
    pub overlay_bound: bool,
    pub mailbox_bound: bool,
    pub dht_bound: bool,
}

impl ReadySnapshot {
    /// Essential readiness gates for reporting `"ready": true`.
    ///
    /// Deliberately *does not* include per-service bits yet. Once the
    /// non-core planes are wired and stable, we can tighten this gate.
    #[must_use]
    pub fn required_ready(&self) -> bool {
        self.listeners_bound && self.cfg_loaded && self.deps_ok && self.gateway_bound
    }
}

```

### crates/macronode/src/security/amnesia.rs
<a id="crates-macronode-src-security-amnesia-rs"></a>

```rust
//! RO:WHAT — Amnesia posture helpers for Macronode.
//! RO:WHY  — Provide a single source of truth for how "amnesia mode" is
//!           interpreted so config / CLI / services stay consistent.
//! RO:INVARIANTS —
//!   - `Persistent` is the default for Macronode (unlike Micronode).
//!   - `Amnesic` is a best-effort "RAM-first, no durable residue" posture.

#![allow(dead_code)]

/// High-level amnesia posture for this process.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AmnesiaMode {
    /// Normal mode: services are allowed to persist state to disk.
    Persistent,
    /// Best-effort amnesia: avoid durable state, prefer RAM-only caches.
    Amnesic,
}

impl AmnesiaMode {
    /// Returns true if the node should avoid writing persistent state.
    #[must_use]
    pub const fn is_amnesic(self) -> bool {
        matches!(self, AmnesiaMode::Amnesic)
    }
}

/// Classify the mode from a simple boolean flag (e.g. config/CLI/env).
///
/// This keeps the rest of the code from re-encoding the boolean semantics
/// in multiple places.
#[must_use]
pub fn classify_amnesia(enabled: bool) -> AmnesiaMode {
    if enabled {
        AmnesiaMode::Amnesic
    } else {
        AmnesiaMode::Persistent
    }
}

```

### crates/macronode/src/security/macaroon.rs
<a id="crates-macronode-src-security-macaroon-rs"></a>

```rust
//! RO:WHAT — Opaque capability-token wrapper for Macronode.
//! RO:WHY  — Macronode itself does not parse or verify macaroons/JWTs;
//!           it just treats them as opaque bearer tokens that downstream
//!           services (KMS/auth) can validate.
//! RO:INVARIANTS —
//!   - This module never logs token contents.
//!   - Parsing is intentionally minimal: higher layers decide semantics.

#![allow(dead_code)]

/// Opaque capability or macaroon-style token.
///
/// In this crate we treat the token as an opaque string. Verification and
/// interpretation belong to dedicated auth/KMS services.
#[derive(Debug, Clone)]
pub struct CapabilityToken {
    raw: String,
}

impl CapabilityToken {
    /// Construct a token from a raw bearer string (without the "Bearer " prefix).
    #[must_use]
    pub fn new<S: Into<String>>(raw: S) -> Self {
        Self { raw: raw.into() }
    }

    /// View the underlying token bytes.
    #[must_use]
    pub fn as_str(&self) -> &str {
        &self.raw
    }
}

/// Parse a `Authorization` header value into a bearer token, if present.
///
/// This is intentionally tiny and does not validate the token format.
#[must_use]
pub fn parse_bearer_header(header: &str) -> Option<CapabilityToken> {
    // Common forms:
    //   "Bearer abc123"
    //   "bearer abc123"
    let trimmed = header.trim();
    let prefix_lower = "bearer ";

    if trimmed.len() <= prefix_lower.len() {
        return None;
    }

    if trimmed.to_ascii_lowercase().starts_with(prefix_lower) {
        let token = &trimmed[prefix_lower.len()..];
        if token.is_empty() {
            None
        } else {
            Some(CapabilityToken::new(token))
        }
    } else {
        None
    }
}

```

### crates/macronode/src/security/mod.rs
<a id="crates-macronode-src-security-mod-rs"></a>

```rust
//! RO:WHAT — Security utilities for Macronode.
//! RO:WHY  — Central home for amnesia posture, TLS options, and capability
//!           token helpers. This keeps security-related logic coherent and
//!           discoverable without bloating `main` or HTTP modules.
//! RO:INVARIANTS —
//!   - This module is pure helper surface; it does not perform I/O by itself.
//!   - Higher layers remain responsible for actually enforcing policies.

#![allow(dead_code)]

pub(crate) mod amnesia;
pub(crate) mod macaroon;
pub(crate) mod tls;

pub(crate) use amnesia::{classify_amnesia, AmnesiaMode};
pub(crate) use tls::{TlsConfig, TlsMode};

```

### crates/macronode/src/security/tls.rs
<a id="crates-macronode-src-security-tls-rs"></a>

```rust
//! RO:WHAT — TLS configuration helpers for Macronode.
//! RO:WHY  — Provide a small, self-contained representation of TLS posture
//!           so admin/gateway planes can be upgraded to TLS without each
//!           caller reinventing config parsing logic.
//! RO:INVARIANTS —
//!   - This module does **not** perform any I/O by itself.
//!   - The actual listener binding and rustls integration live elsewhere.

#![allow(dead_code)]

use std::path::{Path, PathBuf};

/// TLS mode for a given listener.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TlsMode {
    /// TLS is disabled; listener uses plain TCP.
    Disabled,
    /// TLS is enabled with a certificate/key pair.
    Enabled,
}

/// High-level TLS configuration for a listener.
#[derive(Debug, Clone)]
pub struct TlsConfig {
    mode: TlsMode,
    cert_path: Option<PathBuf>,
    key_path: Option<PathBuf>,
}

impl TlsConfig {
    /// Construct a disabled TLS configuration.
    #[must_use]
    pub const fn disabled() -> Self {
        Self {
            mode: TlsMode::Disabled,
            cert_path: None,
            key_path: None,
        }
    }

    /// Construct an enabled TLS configuration with the given paths.
    #[must_use]
    pub fn enabled(cert_path: PathBuf, key_path: PathBuf) -> Self {
        Self {
            mode: TlsMode::Enabled,
            cert_path: Some(cert_path),
            key_path: Some(key_path),
        }
    }

    /// Returns true if TLS is enabled.
    #[must_use]
    pub const fn is_enabled(&self) -> bool {
        matches!(self.mode, TlsMode::Enabled)
    }

    /// Accessor for the certificate path, if any.
    #[must_use]
    pub fn cert_path(&self) -> Option<&Path> {
        self.cert_path.as_deref()
    }

    /// Accessor for the private key path, if any.
    #[must_use]
    pub fn key_path(&self) -> Option<&Path> {
        self.key_path.as_deref()
    }
}

```

### crates/macronode/src/services/mod.rs
<a id="crates-macronode-src-services-mod-rs"></a>

```rust
//! RO:WHAT — Macronode managed services surface.
//! RO:WHY  — Single place to define which internal services (gateway, overlay,
//!           storage, index, mailbox, dht, etc.) this node composes.
//! RO:INVARIANTS —
//!   - Slice 1 only exposes `spawn_all()` and per-service stubs.
//!   - Future slices will add real service wiring and health reporting.

pub mod spawn;
pub mod svc_dht;
pub mod svc_gateway;
pub mod svc_index;
pub mod svc_mailbox;
pub mod svc_overlay;
pub mod svc_storage;

pub use spawn::spawn_all;

```

### crates/macronode/src/services/registry.rs
<a id="crates-macronode-src-services-registry-rs"></a>

```rust
//! RO:WHAT — In-memory registry of Macronode managed services.
//! RO:WHY  — Give `/api/v1/status` and the supervisor a shared place to
//!           track which services exist and their coarse health.
//! RO:INVARIANTS —
//!   - Registry is in-memory only; macronode owns no persistent data.
//!   - Service names are small static strings; no user input here.

#![allow(dead_code)]

use std::collections::BTreeMap;

/// Coarse status for a composed service.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ServiceStatus {
    /// Present but not yet doing real work (today's stubs).
    Stub,
    /// In the process of starting up.
    Starting,
    /// Fully running and healthy.
    Running,
    /// In the process of draining for shutdown.
    Draining,
    /// Failed permanently; requires operator intervention.
    Failed,
}

/// Simple registry mapping service name → status.
#[derive(Debug, Default)]
pub struct ServiceRegistry {
    inner: BTreeMap<&'static str, ServiceStatus>,
}

impl ServiceRegistry {
    /// Update the status for a named service.
    pub fn set_status(&mut self, name: &'static str, status: ServiceStatus) {
        self.inner.insert(name, status);
    }

    /// Fetch the status for a named service, if known.
    #[must_use]
    pub fn get_status(&self, name: &'static str) -> Option<ServiceStatus> {
        self.inner.get(name).copied()
    }

    /// Take a snapshot of all service statuses for serialization or logging.
    #[must_use]
    pub fn snapshot(&self) -> BTreeMap<&'static str, ServiceStatus> {
        self.inner.clone()
    }
}

```

### crates/macronode/src/services/spawn.rs
<a id="crates-macronode-src-services-spawn-rs"></a>

```rust
// crates/macronode/src/services/spawn.rs

//! RO:WHAT — Single entrypoint to spawn all managed Macronode services.
//! RO:WHY  — Keep supervisor wiring centralized so we can:
//!           * track JoinHandles for crash logging,
//!           * thread readiness probes into services,
//!           * pass shutdown tokens for graceful drain later.
//!
//! RO:INVARIANTS —
//!   - This slice still runs services until process shutdown (no restarts).
//!   - `ReadyProbes::set_deps_ok(true)` is flipped once workers are spawned;
//!     per-service bits (index/overlay/mailbox/dht) are flipped by the
//!     individual service modules.
//!   - No service-specific logic leaks into the supervisor; this module
//!     just coordinates spawns.

use std::sync::Arc;

use tracing::info;

use crate::{
    errors::Result,
    readiness::ReadyProbes,
    supervisor::{ManagedTask, ShutdownToken},
};

/// Spawn all managed services.
///
/// Today this is still “fire-and-forget”: each service runs until process
/// shutdown. We collect the JoinHandles as `ManagedTask`s so the Supervisor
/// can monitor exits and log them. No restart policies wired yet.
pub async fn spawn_all(
    probes: Arc<ReadyProbes>,
    shutdown: ShutdownToken,
) -> Result<Vec<ManagedTask>> {
    info!("macronode supervisor: spawn_all (starting service workers)");

    let tasks: Vec<ManagedTask> = vec![
        // Gateway: real HTTP ingress, marks gateway_bound=true when listener binds.
        crate::services::svc_gateway::spawn(probes.clone()),
        // svc-index: real embedded HTTP server using svc-index crate.
        // Flips index_bound=true once its listener binds.
        crate::services::svc_index::spawn(probes.clone()),
        // Remaining services are still stub workers; they just loop until shutdown.
        // Each one flips its own per-service readiness bit when the worker starts.
        crate::services::svc_overlay::spawn(probes.clone(), shutdown.clone()),
        crate::services::svc_storage::spawn(shutdown.clone()),
        crate::services::svc_mailbox::spawn(probes.clone(), shutdown.clone()),
        crate::services::svc_dht::spawn(probes.clone(), shutdown),
    ];

    // All deps are considered "ok" once their workers have been spawned.
    // At this slice we don’t yet distinguish per-dep gating in `required_ready()`.
    probes.set_deps_ok(true);

    Ok(tasks)
}

```

### crates/macronode/src/services/svc_dht.rs
<a id="crates-macronode-src-services-svcdht-rs"></a>

```rust
// crates/macronode/src/services/svc_dht.rs

//! RO:WHAT — Macronode wrapper for the DHT/routing plane.
//! RO:WHY  — Reserve a config-aware home for DHT workers so macronode can
//!           coordinate them without owning DHT internals.
//! RO:INVARIANTS —
//!   - Worker runs until shutdown is requested via `ShutdownToken`.
//!   - Bind address is resolved once and logged for operator introspection.
//!   - This module owns only host wiring; DHT semantics live in `svc-dht`.
//!
//! RO:FUTURE —
//!   - Call into `svc-dht` lib entrypoint with:
//!       * A transport handle (ron-transport).
//!       * Bus handle for overlay/DHT events.
//!       * ShutdownToken.
//!   - Expose routing health and table stats via metrics and `/status`.

use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;

use tokio::time::sleep;
use tracing::{error, info};

use crate::{
    readiness::ReadyProbes,
    supervisor::{ManagedTask, ShutdownToken},
};

/// Default bind for the DHT plane (local-only in this slice).
const DEFAULT_DHT_ADDR: &str = "127.0.0.1:5302";

/// Resolve the bind address for the DHT plane.
///
/// Env override:
///   - `RON_DHT_ADDR=IP:PORT`
fn resolve_bind_addr() -> SocketAddr {
    match std::env::var("RON_DHT_ADDR") {
        Ok(raw) => match raw.trim().parse::<SocketAddr>() {
            Ok(addr) => {
                info!("svc-dht: using RON_DHT_ADDR={addr}");
                addr
            }
            Err(err) => {
                error!(
                    "svc-dht: invalid RON_DHT_ADDR={raw:?}, \
                     falling back to {DEFAULT_DHT_ADDR}: {err}"
                );
                DEFAULT_DHT_ADDR
                    .parse()
                    .expect("DEFAULT_DHT_ADDR must be a valid SocketAddr")
            }
        },
        Err(_) => DEFAULT_DHT_ADDR
            .parse()
            .expect("DEFAULT_DHT_ADDR must be a valid SocketAddr"),
    }
}

/// Spawn the DHT worker.
///
/// For now this is a stub loop that just logs the resolved address and
/// waits on the shutdown token.
pub fn spawn(probes: Arc<ReadyProbes>, shutdown: ShutdownToken) -> ManagedTask {
    let handle = tokio::spawn(async move {
        let addr = resolve_bind_addr();
        info!(
            %addr,
            "svc-dht: started (host shell, waiting for real svc-dht wiring)"
        );

        // Flip the per-service readiness bit once the worker has started.
        probes.set_dht_bound(true);

        while !shutdown.is_triggered() {
            sleep(Duration::from_secs(5)).await;
        }

        info!("svc-dht: shutdown requested, exiting worker");
    });

    ManagedTask::new("svc-dht", handle)
}

```

### crates/macronode/src/services/svc_gateway.rs
<a id="crates-macronode-src-services-svcgateway-rs"></a>

```rust
//! RO:WHAT — Macronode HTTP ingress (svc-gateway MVP).
//! RO:WHY  — Stand up actual ingress listener + mark readiness correctly.
//! RO:INVARIANTS —
//!   - Binds to 127.0.0.1:8090 by default (override via RON_GATEWAY_ADDR).
//!   - Sets `gateway_bound=true` on successful bind to feed `/readyz` + status.
//!   - No locks held across `.await`.

use std::sync::Arc;
use std::{net::SocketAddr, str::FromStr};

use axum::{response::IntoResponse, routing::get, Json, Router};
use serde::Serialize;
use tokio::net::TcpListener;
use tracing::{error, info};

use crate::readiness::ReadyProbes;
use crate::supervisor::ManagedTask;

#[derive(Debug, Serialize)]
struct PingBody {
    ok: bool,
    service: &'static str,
    profile: &'static str,
}

async fn ping_handler() -> impl IntoResponse {
    Json(PingBody {
        ok: true,
        service: "svc-gateway",
        profile: "macronode",
    })
}

/// Resolve the bind address for the gateway plane.
///
/// Env override:
///   - `RON_GATEWAY_ADDR=IP:PORT`
fn resolve_bind_addr() -> SocketAddr {
    const DEFAULT_ADDR: &str = "127.0.0.1:8090";

    if let Ok(raw) = std::env::var("RON_GATEWAY_ADDR") {
        match SocketAddr::from_str(raw.trim()) {
            Ok(addr) => {
                info!("svc-gateway: using RON_GATEWAY_ADDR={addr}");
                return addr;
            }
            Err(err) => {
                error!(
                    "svc-gateway: invalid RON_GATEWAY_ADDR={raw:?}, \
                     falling back to {DEFAULT_ADDR}: {err}"
                );
            }
        }
    }

    SocketAddr::from_str(DEFAULT_ADDR).expect("DEFAULT_ADDR must be a valid SocketAddr")
}

/// Spawn the gateway HTTP ingress server.
///
/// Returns a `ManagedTask` wrapping the JoinHandle so the supervisor can
/// log when this service exits. Behavior is otherwise identical to the
/// previous fire-and-forget slice.
pub fn spawn(probes: Arc<ReadyProbes>) -> ManagedTask {
    let handle = tokio::spawn(async move {
        let addr = resolve_bind_addr();

        let listener = match TcpListener::bind(addr).await {
            Ok(listener) => {
                info!("svc-gateway: listening on {addr}");
                probes.set_gateway_bound(true);
                listener
            }
            Err(err) => {
                error!("svc-gateway: failed to bind to {addr}: {err}");
                return;
            }
        };

        let app = Router::new().route("/ingress/ping", get(ping_handler));

        if let Err(err) = axum::serve(listener, app).await {
            error!("svc-gateway: server error: {err}");
        } else {
            info!("svc-gateway: server exited cleanly");
        }
    });

    ManagedTask::new("svc-gateway", handle)
}

```

### crates/macronode/src/services/svc_index.rs
<a id="crates-macronode-src-services-svcindex-rs"></a>

```rust
// crates/macronode/src/services/svc_index.rs

//! RO:WHAT — Macronode wiring for svc-index (real HTTP server).
//! RO:WHY  — Stand up svc-index inside Macronode using its own Config/AppState/router.
//! RO:INVARIANTS —
//!   - Uses svc-index crate as the source of truth (Config/AppState/build_router).
//!   - Binds to the same address logic as svc-index/bin (INDEX_BIND or cfg.bind or 127.0.0.1:5304).
//!   - Does *not* yet participate in graceful shutdown; process exit stops the server.
//!   - Readiness for macronode remains governed by ReadyProbes; `deps_ok` is set
//!     in `spawn_all()`, and `index_bound` is flipped once the listener binds.

use std::{net::SocketAddr, sync::Arc};

use axum::Router;
use tokio::net::TcpListener;
use tracing::{error, info};

use crate::{readiness::ReadyProbes, supervisor::ManagedTask};

// Re-exported API from svc-index crate.
// lib.rs exposes:
//   pub use config::Config;
//   pub use router::build_router;
//   pub use state::AppState;
use svc_index::{
    build_router as build_index_router, AppState as IndexAppState, Config as IndexConfig,
};

/// Spawn the embedded svc-index HTTP server.
///
/// We take `ReadyProbes` so we can integrate svc-index into the macronode
/// readiness story (e.g., `index_bound=true` once the listener is bound).
/// Shutdown is still coarse: when macronode exits, this task ends.
///
/// NOTE: This intentionally mirrors `crates/svc-index/src/main.rs`’s flow:
///   config → state → bootstrap → router.with_state → TcpListener → axum::serve.
pub fn spawn(probes: Arc<ReadyProbes>) -> ManagedTask {
    let handle = tokio::spawn(async move {
        // 1) Load svc-index config (env + defaults).
        let cfg = match IndexConfig::load() {
            Ok(cfg) => cfg,
            Err(err) => {
                error!(?err, "svc-index (embedded): failed to load config");
                return;
            }
        };

        // 2) Build shared Arc<AppState>.
        let state: Arc<IndexAppState> = match IndexAppState::new(cfg.clone()).await {
            Ok(s) => Arc::new(s),
            Err(err) => {
                error!(?err, "svc-index (embedded): failed to build AppState");
                return;
            }
        };

        // 3) Bootstrap (index warmup / caches / readiness gates).
        let state = IndexAppState::bootstrap(state).await;

        // 4) Build router and inject state at the end (Axum 0.7 pattern).
        let app: Router = build_index_router().with_state(state.clone());

        // 5) Bind address: INDEX_BIND env > cfg.bind > 127.0.0.1:5304.
        let bind_str = std::env::var("INDEX_BIND").unwrap_or_else(|_| cfg.bind.clone());
        let bind: SocketAddr = bind_str
            .parse()
            .unwrap_or_else(|_| SocketAddr::from(([127, 0, 0, 1], 5304)));

        let listener: TcpListener = match TcpListener::bind(bind).await {
            Ok(l) => {
                // Flip the per-service readiness bit once the listener is bound.
                probes.set_index_bound(true);

                info!(
                    version = env!("CARGO_PKG_VERSION"),
                    %bind,
                    "svc-index (embedded) starting"
                );
                l
            }
            Err(err) => {
                error!(?err, %bind, "svc-index (embedded): failed to bind");
                return;
            }
        };

        // 6) Serve. For now we *don’t* wire macronode’s ShutdownToken in; when
        // the process exits, the server stops. That keeps behavior simple and
        // matches other embedded services at this slice.
        //
        // We use Router -> IntoMakeService pattern to avoid the generic
        // axum::serve<Router<Arc<AppState>>> bound issues.
        let make_svc = app.into_make_service();

        if let Err(err) = axum::serve(listener, make_svc).await {
            error!(?err, "svc-index (embedded): server error");
        } else {
            info!("svc-index (embedded): server exited cleanly");
        }
    });

    ManagedTask::new("svc-index", handle)
}

```

### crates/macronode/src/services/svc_mailbox.rs
<a id="crates-macronode-src-services-svcmailbox-rs"></a>

```rust
// crates/macronode/src/services/svc_mailbox.rs

//! RO:WHAT — Macronode wrapper for the mailbox plane.
//! RO:WHY  — Reserve a real home for queued message delivery / mailbox semantics
//!           with config-aware bind addresses and clean shutdown wiring.
//! RO:INVARIANTS —
//!   - Worker runs until shutdown is requested via `ShutdownToken`.
//!   - No locks are held across `.await` (once we add async work here).
//!   - This module owns *only* host-level wiring; the real mailbox logic will
//!     live in `svc-mailbox` crate once that lib surface is ready.
//!
//! RO:FUTURE —
//!   - Swap the internal loop to call into `svc-mailbox` crate (HTTP/transport)
//!     without changing the supervisor or `spawn_all` signatures.
//!   - Emit health/metrics via ron-metrics once mailbox has a proper surface.

use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;

use tokio::time::sleep;
use tracing::{error, info};

use crate::{
    readiness::ReadyProbes,
    supervisor::{ManagedTask, ShutdownToken},
};

/// Default bind for the mailbox plane (local-only in this slice).
const DEFAULT_MAILBOX_ADDR: &str = "127.0.0.1:5304";

/// Resolve the bind address for the mailbox plane.
///
/// Today this is purely informational: we log the resolved address so that
/// when `svc-mailbox` is wired in, it already has a stable config surface.
///
/// Env override:
///   - `RON_MAILBOX_ADDR=IP:PORT`
fn resolve_bind_addr() -> SocketAddr {
    match std::env::var("RON_MAILBOX_ADDR") {
        Ok(raw) => match raw.trim().parse::<SocketAddr>() {
            Ok(addr) => {
                info!("svc-mailbox: using RON_MAILBOX_ADDR={addr}");
                addr
            }
            Err(err) => {
                error!(
                    "svc-mailbox: invalid RON_MAILBOX_ADDR={raw:?}, \
                     falling back to {DEFAULT_MAILBOX_ADDR}: {err}"
                );
                DEFAULT_MAILBOX_ADDR
                    .parse()
                    .expect("DEFAULT_MAILBOX_ADDR must be a valid SocketAddr")
            }
        },
        Err(_) => DEFAULT_MAILBOX_ADDR
            .parse()
            .expect("DEFAULT_MAILBOX_ADDR must be a valid SocketAddr"),
    }
}

/// Spawn the mailbox worker.
///
/// This keeps behavior simple and test-friendly while giving us a stable
/// attach point for the future `svc-mailbox` integration.
pub fn spawn(probes: Arc<ReadyProbes>, shutdown: ShutdownToken) -> ManagedTask {
    let handle = tokio::spawn(async move {
        let addr = resolve_bind_addr();
        info!(
            %addr,
            "svc-mailbox: started (host shell, waiting for real svc-mailbox wiring)"
        );

        // Flip the per-service readiness bit once the worker has started.
        probes.set_mailbox_bound(true);

        // Lightweight wait loop; no busy-spin.
        while !shutdown.is_triggered() {
            sleep(Duration::from_secs(5)).await;
        }

        info!("svc-mailbox: shutdown requested, exiting worker");
    });

    ManagedTask::new("svc-mailbox", handle)
}

```

### crates/macronode/src/services/svc_overlay.rs
<a id="crates-macronode-src-services-svcoverlay-rs"></a>

```rust
// crates/macronode/src/services/svc_overlay.rs

//! RO:WHAT — Macronode wrapper for the overlay plane.
//! RO:WHY  — Provide a config-aware shell for overlay / gossip / connection
//!           management so we can later drop in the real `svc-overlay` crate
//!           without touching the supervisor surface.
//! RO:INVARIANTS —
//!   - Worker runs until shutdown is requested via `ShutdownToken`.
//!   - Bind address is resolved once at startup and logged.
//!   - No locks held across `.await` in this slice.
//!
//! RO:FUTURE —
//!   - Call into `svc-overlay` lib entrypoint with:
//!       * TransportConfig (from ron-transport)
//!       * Bus handle (for health/crash events)
//!       * ShutdownToken
//!   - Surface overlay health into `/api/v1/status` and Prometheus.

use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;

use tokio::time::sleep;
use tracing::{error, info};

use crate::{
    readiness::ReadyProbes,
    supervisor::{ManagedTask, ShutdownToken},
};

/// Default bind for the overlay plane (local-only in this slice).
const DEFAULT_OVERLAY_ADDR: &str = "127.0.0.1:5301";

/// Resolve the bind address for the overlay plane.
///
/// Env override:
///   - `RON_OVERLAY_ADDR=IP:PORT`
fn resolve_bind_addr() -> SocketAddr {
    match std::env::var("RON_OVERLAY_ADDR") {
        Ok(raw) => match raw.trim().parse::<SocketAddr>() {
            Ok(addr) => {
                info!("svc-overlay: using RON_OVERLAY_ADDR={addr}");
                addr
            }
            Err(err) => {
                error!(
                    "svc-overlay: invalid RON_OVERLAY_ADDR={raw:?}, \
                     falling back to {DEFAULT_OVERLAY_ADDR}: {err}"
                );
                DEFAULT_OVERLAY_ADDR
                    .parse()
                    .expect("DEFAULT_OVERLAY_ADDR must be a valid SocketAddr")
            }
        },
        Err(_) => DEFAULT_OVERLAY_ADDR
            .parse()
            .expect("DEFAULT_OVERLAY_ADDR must be a valid SocketAddr"),
    }
}

/// Spawn the overlay worker.
///
/// This keeps behavior simple and test-friendly while giving us a stable
/// attach point for the future `svc-overlay` integration.
pub fn spawn(probes: Arc<ReadyProbes>, shutdown: ShutdownToken) -> ManagedTask {
    let handle = tokio::spawn(async move {
        let addr = resolve_bind_addr();
        info!(
            %addr,
            "svc-overlay: started (host shell, waiting for real svc-overlay wiring)"
        );

        // Flip the per-service readiness bit once the worker has started.
        probes.set_overlay_bound(true);

        while !shutdown.is_triggered() {
            sleep(Duration::from_secs(5)).await;
        }

        info!("svc-overlay: shutdown requested, exiting worker");
    });

    ManagedTask::new("svc-overlay", handle)
}

```

### crates/macronode/src/services/svc_storage.rs
<a id="crates-macronode-src-services-svcstorage-rs"></a>

```rust
//! RO:WHAT — Macronode embedded svc-storage HTTP server.
//! RO:WHY  — Run the CAS storage plane (svc-storage) in-process as part of the
//!           macronode profile, instead of a separate process.
//! RO:INVARIANTS —
//!   - Binds to 127.0.0.1:5303 by default (override via RON_STORAGE_ADDR).
//!   - Uses in-memory MemoryStorage backend only in this slice (no disk I/O).
//!   - No locks held across `.await`; storage crate owns all HTTP details.

use std::net::SocketAddr;
use std::sync::Arc;

use tokio::task;
use tracing::{error, info};

use crate::supervisor::{ManagedTask, ShutdownToken};
use svc_storage::http::{extractors::AppState, server::serve_http};
use svc_storage::storage::{MemoryStorage, Storage};

/// Resolve the bind address for the embedded storage HTTP server.
///
/// Default: `127.0.0.1:5303`  
/// Override: `RON_STORAGE_ADDR=IP:PORT`
fn resolve_bind_addr() -> SocketAddr {
    const DEFAULT_ADDR: &str = "127.0.0.1:5303";

    match std::env::var("RON_STORAGE_ADDR") {
        Ok(raw) => match raw.trim().parse::<SocketAddr>() {
            Ok(addr) => {
                info!("svc-storage: using RON_STORAGE_ADDR={addr}");
                addr
            }
            Err(err) => {
                error!(
                    "svc-storage: invalid RON_STORAGE_ADDR={raw:?}, \
                     falling back to {DEFAULT_ADDR}: {err}"
                );
                DEFAULT_ADDR
                    .parse()
                    .expect("DEFAULT_ADDR must be a valid SocketAddr")
            }
        },
        Err(_) => DEFAULT_ADDR
            .parse()
            .expect("DEFAULT_ADDR must be a valid SocketAddr"),
    }
}

/// Spawn the embedded svc-storage HTTP server.
///
/// We now return a `ManagedTask` so the supervisor can watch the JoinHandle.
/// `shutdown` is still unused because `serve_http` does not yet accept a
/// shutdown signal; process exit tears it down.
pub fn spawn(_shutdown: ShutdownToken) -> ManagedTask {
    let handle = task::spawn(async move {
        let addr = resolve_bind_addr();

        info!("svc-storage: listening on {addr} (embedded in macronode)");

        // In-memory store (matches svc-storage/bin main wiring).
        let store: Arc<dyn Storage> = Arc::new(MemoryStorage::default());
        let state = AppState { store };

        // Delegate to svc-storage's HTTP server.
        match serve_http(addr, state).await {
            Ok(()) => {
                info!("svc-storage: server exited cleanly");
            }
            Err(err) => {
                error!("svc-storage: server error: {err:#}");
            }
        }
    });

    ManagedTask::new("svc-storage", handle)
}

```

### crates/macronode/src/supervisor/backoff.rs
<a id="crates-macronode-src-supervisor-backoff-rs"></a>

```rust
//! RO:WHAT — Exponential backoff helper for service restarts.
//! RO:WHY  — Give the supervisor a small, testable primitive to decide how
//!           long to wait before restarting a crashed worker.
//! RO:INVARIANTS —
//!   - Backoff never panics; it clamps at `max_delay`.
//!   - All math is done with safe, bounded integers.

#![allow(dead_code)]

use std::time::Duration;

/// Simple exponential backoff policy.
///
/// This is intentionally small; more elaborate jitter/strategy can be added
/// later without changing call sites.
#[derive(Debug, Clone)]
pub struct Backoff {
    base_delay: Duration,
    max_delay: Duration,
    attempt: u32,
}

impl Backoff {
    /// Construct a new backoff policy with the given base and max delay.
    #[must_use]
    pub fn new(base_delay: Duration, max_delay: Duration) -> Self {
        Self {
            base_delay,
            max_delay,
            attempt: 0,
        }
    }

    /// Reset the attempt counter back to zero.
    pub fn reset(&mut self) {
        self.attempt = 0;
    }

    /// Compute the next delay.
    ///
    /// Roughly: `delay = base_delay * 2^attempt`, clamped at `max_delay`.
    /// The attempt counter is incremented after each call.
    #[must_use]
    pub fn next_delay(&mut self) -> Duration {
        // 2^attempt as a u32, clamped so we never shift by >= 32.
        let exp = self.attempt.min(31);
        let factor: u32 = 1u32.checked_shl(exp).unwrap_or(u32::MAX);

        let candidate = self.base_delay.saturating_mul(factor);
        self.attempt = self.attempt.saturating_add(1);

        if candidate > self.max_delay {
            self.max_delay
        } else {
            candidate
        }
    }
}

```

### crates/macronode/src/supervisor/crash_policy.rs
<a id="crates-macronode-src-supervisor-crashpolicy-rs"></a>

```rust
//! RO:WHAT — Crash policy helper for the macronode supervisor.
//! RO:WHY  — Decide whether we should restart a crashing service based on
//!           how many times it has crashed within a rolling time window.
//! RO:INVARIANTS —
//!   - We only look at crashes within a sliding window (e.g. last 60s).
//!   - If the number of recent crashes exceeds `max_restarts`, we stop
//!     restarting and mark the service as permanently failed.
//!   - This module is *pure* logic: it has no side effects and can be
//!     unit-tested independently.
//!
//! RO:INTERACTS —
//!   - Intended to be used by `Supervisor` when a service task exits.
//!   - `crash_times` should be maintained by the supervisor as a log of
//!     `Instant`s when each service crashed.
//!
//! RO:NOTES —
//!   - This is groundwork: at the moment the supervisor still only spawns
//!     services once. Wiring this into the actual restart loop is a
//!     future slice so we keep behavior identical for now.

use std::time::{Duration, Instant};

/// Simple crash policy: allow up to `max_restarts` crashes within a
/// rolling `window` duration.
///
/// Example:
///   - `max_restarts = 5`
///   - `window = 60s`
///
/// If a service crashes 6+ times within the last 60 seconds, we should
/// stop trying to restart it and surface a permanent failure upstream.
#[derive(Debug, Clone, Copy)]
pub struct CrashPolicy {
    max_restarts: usize,
    window: Duration,
}

impl CrashPolicy {
    /// Construct a new crash policy.
    ///
    /// * `max_restarts` — maximum allowed crashes within `window`
    /// * `window`       — time window we consider "recent"
    pub fn new(max_restarts: usize, window: Duration) -> Self {
        CrashPolicy {
            max_restarts,
            window,
        }
    }

    /// Maximum allowed restarts within the window.
    pub fn max_restarts(&self) -> usize {
        self.max_restarts
    }

    /// Rolling window length used when counting recent crashes.
    pub fn window(&self) -> Duration {
        self.window
    }

    /// Decide whether we should attempt another restart *now* given the
    /// crash history for a service.
    ///
    /// * `crash_times` — slice of `Instant`s when this service crashed.
    ///   The supervisor owns and maintains this log.
    /// * `now`         — current time, usually `Instant::now()`.
    ///
    /// Returns `true` if we are still within the allowed restart budget
    /// for the configured window, `false` if we should stop restarting.
    pub fn should_restart(&self, crash_times: &[Instant], now: Instant) -> bool {
        // Compute the beginning of the window. On the off chance that
        // `now < window` (very early in process lifetime), we treat the
        // window start as `now` so that every crash is considered "recent"
        // and we still honor `max_restarts`.
        let window_start = now.checked_sub(self.window).unwrap_or(now);

        // Count crashes that occurred within [window_start, now].
        let recent = crash_times
            .iter()
            .copied()
            .filter(|&t| t >= window_start)
            .count();

        recent <= self.max_restarts
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn allows_restarts_below_threshold() {
        let policy = CrashPolicy::new(3, Duration::from_secs(60));
        let now = Instant::now();

        // Two crashes in the window, threshold is three.
        let crashes = vec![now - Duration::from_secs(10), now - Duration::from_secs(20)];

        assert!(policy.should_restart(&crashes, now));
    }

    #[test]
    fn denies_restarts_above_threshold() {
        let policy = CrashPolicy::new(3, Duration::from_secs(60));
        let now = Instant::now();

        // Four crashes all within the last 60 seconds.
        let crashes = vec![
            now - Duration::from_secs(5),
            now - Duration::from_secs(10),
            now - Duration::from_secs(20),
            now - Duration::from_secs(30),
        ];

        assert!(!policy.should_restart(&crashes, now));
    }

    #[test]
    fn ignores_crashes_outside_window() {
        let policy = CrashPolicy::new(2, Duration::from_secs(30));
        let now = Instant::now();

        // One very old crash (outside window), two recent ones.
        let crashes = vec![
            now - Duration::from_secs(300),
            now - Duration::from_secs(5),
            now - Duration::from_secs(10),
        ];

        // Only the two recent crashes should count → still within budget.
        assert!(policy.should_restart(&crashes, now));
    }
}

```

### crates/macronode/src/supervisor/health_reporter.rs
<a id="crates-macronode-src-supervisor-healthreporter-rs"></a>

```rust
//! RO:WHAT — Health reporting helper for Macronode supervisor.
//! RO:WHY  — Provide a small adapter object that can fan supervisor state
//!           into readiness probes or structured status maps.
//! RO:INVARIANTS —
//!   - This module is pure; it does not spawn tasks or own timers.

#![allow(dead_code)]

use std::collections::BTreeMap;

/// High-level status of a logical service.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ServiceHealth {
    Stub,
    Starting,
    Running,
    Draining,
    Failed,
}

impl ServiceHealth {
    #[must_use]
    pub const fn is_healthy(self) -> bool {
        matches!(self, ServiceHealth::Running | ServiceHealth::Draining)
    }
}

/// Aggregated view of service health used for `/api/v1/status`.
#[derive(Debug, Default)]
pub struct HealthSnapshot {
    services: BTreeMap<&'static str, ServiceHealth>,
}

impl HealthSnapshot {
    /// Record or update the health for a named service.
    pub fn set_service(&mut self, name: &'static str, health: ServiceHealth) {
        self.services.insert(name, health);
    }

    /// Immutable view of the underlying map for serialization or logging.
    #[must_use]
    pub fn services(&self) -> &BTreeMap<&'static str, ServiceHealth> {
        &self.services
    }
}

```

### crates/macronode/src/supervisor/lifecycle.rs
<a id="crates-macronode-src-supervisor-lifecycle-rs"></a>

```rust
//! RO:WHAT — Lifecycle primitives for supervised service tasks.
//! RO:WHY  — Provide a small abstraction for representing a running worker
//!           (JoinHandle + metadata) without yet implementing crash detection.
//! RO:INVARIANTS —
//!   - Zero side effects today.
//!   - No panics; noop watch() until the next slice.
//!   - Forward-compatible with crash detection and restart loops.

#![allow(dead_code)]

use std::fmt;
use tokio::task::JoinHandle;

/// High-level state of a supervised service.
///
/// This is intentionally simple; we'll expand once restart flows land.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LifecycleState {
    Starting,
    Running,
    Stopping,
    Stopped,
}

/// A managed worker task.
///
/// Right now this is just a placeholder so that Supervisor can begin to
/// track per-service join handles without altering behavior.
pub struct ManagedTask {
    pub service_name: &'static str,
    pub handle: JoinHandle<()>,
}

impl ManagedTask {
    /// Construct a new managed worker.
    #[must_use]
    pub fn new(service_name: &'static str, handle: JoinHandle<()>) -> Self {
        Self {
            service_name,
            handle,
        }
    }

    /// Placeholder: later this will become the crash detection hook.
    ///
    /// For now it simply awaits the handle and swallows any JoinError so
    /// existing test behavior is unaffected.
    pub async fn watch(self) {
        let _ = self.handle.await;
        // In a future step:
        //   - detect crash vs clean exit
        //   - update probes
        //   - notify supervisor restart loop
    }
}

impl fmt::Debug for ManagedTask {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ManagedTask")
            .field("service_name", &self.service_name)
            .finish()
    }
}

```

### crates/macronode/src/supervisor/mod.rs
<a id="crates-macronode-src-supervisor-mod-rs"></a>

```rust
//! RO:WHAT — Process supervisor scaffold for Macronode.
//! RO:WHY  — Central place to coordinate service startup/shutdown.
//! RO:INVARIANTS —
//!   - Crash policy + backoff are wired but *not yet* used to restart tasks.
//!   - Graceful shutdown orchestration is still a future slice.
//!   - Health reporting to readiness/admin planes is still a future slice.
//!   - This slice *adds* task watchers that log service exits, but they do
//!     NOT restart services or mutate readiness yet.

#![allow(dead_code)]

mod backoff;
mod crash_policy;
mod health_reporter;
mod lifecycle;
mod shutdown;

use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};

use crate::{errors::Result, readiness::ReadyProbes, services};

pub use lifecycle::ManagedTask;
pub use shutdown::ShutdownToken;

use backoff::Backoff;
use crash_policy::CrashPolicy;
use health_reporter::HealthSnapshot;
use lifecycle::LifecycleState;
use tracing::{error, info};

/// Macronode process supervisor (MVP).
///
/// Currently minimal: only boots services. This module now also contains the
/// internal logic for combining CrashPolicy + Backoff into a restart
/// decision API. In this slice we additionally attach *watchers* to service
/// tasks so we log when they exit, but we still DO NOT restart anything.
#[derive(Debug)]
pub struct Supervisor {
    /// Shared readiness probes used by admin plane and readiness endpoints.
    probes: Arc<ReadyProbes>,
    /// Cooperative shutdown token shared with all managed services.
    shutdown: ShutdownToken,
    /// Coarse lifecycle state.
    lifecycle: LifecycleState,
    /// Aggregated view of per-service health.
    health: HealthSnapshot,
    /// Policy controlling restart aggressiveness.
    crash_policy: CrashPolicy,
    /// Exponential backoff state used between restarts.
    backoff: Backoff,
    /// Rolling crash timestamps per logical service name.
    ///
    /// This log is consulted by `crash_policy.should_restart(...)` to decide
    /// whether a service is still within its restart budget.
    crash_log: HashMap<&'static str, Vec<Instant>>,
}

impl Supervisor {
    /// Construct a new supervisor handle.
    pub fn new(probes: Arc<ReadyProbes>, shutdown: ShutdownToken) -> Self {
        let crash_policy = CrashPolicy::new(5, Duration::from_secs(60));
        let backoff = Backoff::new(Duration::from_secs(1), Duration::from_secs(30));

        Supervisor {
            probes,
            shutdown,
            lifecycle: LifecycleState::Starting,
            health: HealthSnapshot::default(),
            crash_policy,
            backoff,
            crash_log: HashMap::new(),
        }
    }

    /// Start all managed services.
    ///
    /// This now delegates to `services::spawn_all`, receives a vector of
    /// `ManagedTask` handles, and attaches lightweight watcher tasks that
    /// simply log when services exit (cleanly, cancelled, or crashed).
    /// There is STILL no restart logic in this slice.
    pub async fn start(&self) -> Result<()> {
        let tasks: Vec<ManagedTask> =
            services::spawn_all(self.probes.clone(), self.shutdown.clone()).await?;

        self.spawn_watchers(tasks);
        Ok(())
    }

    /// Attach background watchers to each managed service task.
    ///
    /// Each watcher:
    ///   - awaits the JoinHandle
    ///   - logs on clean exit, cancellation, or crash
    ///   - does NOT restart or mutate readiness yet
    fn spawn_watchers(&self, tasks: Vec<ManagedTask>) {
        for task in tasks {
            let service = task.service_name;
            let handle = task.handle;

            tokio::spawn(async move {
                match handle.await {
                    Ok(()) => {
                        info!(
                            %service,
                            "macronode supervisor: service task exited cleanly"
                        );
                    }
                    Err(err) if err.is_cancelled() => {
                        info!(
                            %service,
                            "macronode supervisor: service task cancelled (likely shutdown)"
                        );
                    }
                    Err(err) => {
                        error!(
                            %service,
                            %err,
                            "macronode supervisor: service task crashed"
                        );
                    }
                }
            });
        }
    }

    // ---------------------------------------------------------------------
    //  Crash policy + backoff glue (internal API, not used for restarts yet)
    // ---------------------------------------------------------------------

    /// Record a crash event for a service.
    ///
    /// This is a pure bookkeeping method: it appends `Instant::now()` to the
    /// crash log for `service`. A future watcher loop will call this whenever
    /// a worker task exits with an error or panic.
    pub fn record_crash(&mut self, service: &'static str) {
        let now = Instant::now();
        let entry = self.crash_log.entry(service).or_default();
        entry.push(now);
    }

    /// Decide how long to wait before restarting a crashed service.
    ///
    /// Returns:
    ///   - `Some(delay)` if we are still within the restart budget for
    ///     `service`, where `delay` is derived from the exponential backoff.
    ///   - `None` if we should *not* restart anymore (permanent failure).
    ///
    /// This method is intentionally side-effect-free except for advancing
    /// the backoff state; it does not spawn tasks or toggle readiness flags.
    pub fn restart_delay(&mut self, service: &'static str) -> Option<Duration> {
        let now = Instant::now();

        let crashes = self
            .crash_log
            .get(service)
            .map(Vec::as_slice)
            .unwrap_or(&[]);

        // If we've exceeded the allowed number of restarts within the window,
        // bail out and let the caller surface a permanent failure.
        if !self.crash_policy.should_restart(crashes, now) {
            return None;
        }

        // Otherwise we are allowed to restart; advance the backoff sequence.
        Some(self.backoff.next_delay())
    }

    /// Reset backoff state and optionally clear crash history.
    ///
    /// For now we only reset the backoff counter and leave the crash log
    /// intact. A future slice may choose to clear `crash_log` entries for
    /// services that have been healthy for long enough.
    pub fn reset_backoff(&mut self) {
        self.backoff.reset();
    }
}

impl Default for Supervisor {
    fn default() -> Self {
        Supervisor::new(Arc::new(ReadyProbes::new()), ShutdownToken::new())
    }
}

```

### crates/macronode/src/supervisor/shutdown.rs
<a id="crates-macronode-src-supervisor-shutdown-rs"></a>

```rust
//! RO:WHAT — Simple cooperative shutdown token for Macronode.
//! RO:WHY  — Give the supervisor and services a shared, cheap way to
//!           coordinate graceful shutdown without pulling in extra deps.
//! RO:INVARIANTS —
//!   - `trigger()` is idempotent.
//!   - `is_triggered()` is lock-free and wait-free.

use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};

/// Cheap, cloneable shutdown token.
///
/// This does not provide async notification; workers are expected to
/// periodically call `is_triggered()` inside their own loops.
#[derive(Clone, Debug)]
pub struct ShutdownToken {
    inner: Arc<AtomicBool>,
}

impl ShutdownToken {
    /// Construct a new token in the "not triggered" state.
    pub fn new() -> Self {
        Self {
            inner: Arc::new(AtomicBool::new(false)),
        }
    }

    /// Signal shutdown to all holders of this token.
    pub fn trigger(&self) {
        self.inner.store(true, Ordering::Release);
    }

    /// Check whether shutdown has been requested.
    pub fn is_triggered(&self) -> bool {
        self.inner.load(Ordering::Acquire)
    }
}

impl Default for ShutdownToken {
    fn default() -> Self {
        Self::new()
    }
}

```

### crates/macronode/src/types.rs
<a id="crates-macronode-src-types-rs"></a>

```rust
//! RO:WHAT — Shared runtime types for Macronode.
//! RO:WHY  — Keep main/http modules thin by centralizing state and build info.

use std::{sync::Arc, time::Instant};

use crate::{bus::NodeBus, config::Config, readiness::ReadyProbes};

#[derive(Clone)]
pub struct AppState {
    pub cfg: Arc<Config>,
    pub probes: Arc<ReadyProbes>,
    /// Intra-node event bus used for KernelEvent traffic (config updates,
    /// health changes, crash notices, etc.).
    pub bus: NodeBus,
    pub started_at: Instant,
}

/// Build-time info used by `/version`.
///
/// We keep this minimal for now; once a build script is in place
/// we can plumb git SHA, build timestamp, and rustc/msrv versions.
pub struct BuildInfo {
    pub service: &'static str,
    pub version: &'static str,
    pub git_sha: &'static str,
    pub build_ts: &'static str,
    pub rustc: &'static str,
    pub msrv: &'static str,
}

impl BuildInfo {
    pub fn current() -> Self {
        Self {
            service: "macronode",
            version: env!("CARGO_PKG_VERSION"),
            git_sha: "unknown",
            build_ts: "unknown",
            rustc: "unknown",
            msrv: "1.80.0",
        }
    }
}

```

### crates/macronode/src/util/dur.rs
<a id="crates-macronode-src-util-dur-rs"></a>

```rust
//! RO:WHAT — Duration helpers for Macronode.
//! RO:WHY  — Avoid sprinkling raw `Duration::from_secs` calls and magic
//!           numbers (like 1000) throughout the codebase.
//! RO:INVARIANTS —
//!   - Helpers are thin wrappers over `std::time::Duration`.
//!   - Parsing helpers never panic; they return `Result`.

#![allow(dead_code)]

use std::num::ParseIntError;
use std::time::Duration;

/// Construct a duration from whole milliseconds.
#[must_use]
pub const fn millis(ms: u64) -> Duration {
    Duration::from_millis(ms)
}

/// Construct a duration from whole seconds.
#[must_use]
pub const fn seconds(secs: u64) -> Duration {
    Duration::from_secs(secs)
}

/// Construct a duration from whole minutes.
#[must_use]
pub const fn minutes(mins: u64) -> Duration {
    Duration::from_secs(mins * 60)
}

/// Parse a duration expressed as whole seconds (e.g. from an env var).
///
/// Whitespace is trimmed; invalid inputs yield a `ParseIntError`.
pub fn parse_seconds(input: &str) -> Result<Duration, ParseIntError> {
    let secs: u64 = input.trim().parse()?;
    Ok(Duration::from_secs(secs))
}

```

### crates/macronode/src/util/sizes.rs
<a id="crates-macronode-src-util-sizes-rs"></a>

```rust
//! RO:WHAT — Byte-size helpers for Macronode.
//! RO:WHY  — Make size-related config and limits more readable (MiB/GiB)
//!           and avoid repeating 1024 * 1024 everywhere.
//! RO:INVARIANTS —
//!   - Helpers are simple arithmetic and never panic on normal inputs.

#![allow(dead_code)]

/// 1 KiB in bytes.
pub const KIB: u64 = 1024;
/// 1 MiB in bytes.
pub const MIB: u64 = 1024 * 1024;
/// 1 GiB in bytes.
pub const GIB: u64 = 1024 * 1024 * 1024;

/// Return `n` kibibytes in bytes.
#[must_use]
pub const fn kib(n: u64) -> u64 {
    n * KIB
}

/// Return `n` mebibytes in bytes.
#[must_use]
pub const fn mib(n: u64) -> u64 {
    n * MIB
}

/// Return `n` gibibytes in bytes.
#[must_use]
pub const fn gib(n: u64) -> u64 {
    n * GIB
}

```

### crates/macronode/tests/admin_smoke.rs
<a id="crates-macronode-tests-adminsmoke-rs"></a>

```rust
//! RO:WHAT — End-to-end smoke test for the Macronode admin plane.
//! RO:WHY  — Prove that `/version`, `/healthz`, `/readyz`, `/metrics`,
//!           `/api/v1/status`, and `/api/v1/shutdown` all behave sanely.
//!
//! This test boots the real `macronode` binary via `CARGO_BIN_EXE_macronode`,
//! waits for it to come up, hits the core admin endpoints, and then shuts the
//! node down via the HTTP control surface.

use std::process::{Child, Command, Stdio};
use std::time::Duration;

use anyhow::{anyhow, Context, Result};
use reqwest::Client;
use serde_json::Value;
use tokio::time::sleep;

const ADMIN_PORT: u16 = 18080;
const GATEWAY_PORT: u16 = 18090;

/// Spawn the macronode binary and wait until the **full admin HTTP stack** is
/// available by polling `/version`, not just `/healthz`.
///
/// `/healthz` only proves that the event loop is alive; `/version` requires
/// the admin listener, router, and middleware stack to be bound and serving.
async fn spawn_macronode() -> Result<(Child, Client, String)> {
    let bin = env!("CARGO_BIN_EXE_macronode");

    let mut cmd = Command::new(bin);
    cmd.arg("run")
        .env("RUST_LOG", "info,macronode=debug")
        // Per-test ports to avoid collisions when tests run in parallel.
        .env("RON_HTTP_ADDR", format!("127.0.0.1:{ADMIN_PORT}"))
        .env("RON_GATEWAY_ADDR", format!("127.0.0.1:{GATEWAY_PORT}"))
        // Keep test output quiet by default.
        .stdout(Stdio::null())
        .stderr(Stdio::null());

    let child = cmd.spawn().context("failed to spawn macronode binary")?;

    let client = Client::builder()
        .timeout(Duration::from_secs(5))
        .build()
        .context("failed to build reqwest client")?;

    let base = format!("http://127.0.0.1:{ADMIN_PORT}");

    // Wait for `/version` to go green, which implies the full HTTP stack is up.
    for _ in 0..50 {
        match client.get(format!("{base}/version")).send().await {
            Ok(resp) if resp.status().is_success() => return Ok((child, client, base)),
            _ => sleep(Duration::from_millis(200)).await,
        }
    }

    Err(anyhow!("macronode did not expose /version in time"))
}

async fn shutdown_macronode(mut child: Child, client: &Client, base: &str) -> Result<()> {
    let resp = client
        .post(format!("{base}/api/v1/shutdown"))
        .send()
        .await
        .context("failed to call /api/v1/shutdown")?;

    // Log status/body when tests are run with --nocapture or RUST_LOG on.
    let status = resp.status();
    let body_text = resp.text().await.unwrap_or_default();
    eprintln!("[admin_smoke] /shutdown status={status} body={body_text}");

    // Give the process a few seconds to exit cleanly.
    for _ in 0..50 {
        if let Ok(Some(_status)) = child.try_wait() {
            return Ok(());
        }
        sleep(Duration::from_millis(200)).await;
    }

    // If it is still running, kill it to avoid hanging tests.
    let _ = child.kill();
    Err(anyhow!("macronode did not exit cleanly after /shutdown"))
}

#[tokio::test(flavor = "multi_thread")]
async fn admin_plane_smoke() -> Result<()> {
    let (child, client, base) = spawn_macronode().await?;

    // /version
    let resp = client
        .get(format!("{base}/version"))
        .send()
        .await
        .context("GET /version failed")?;
    assert!(resp.status().is_success());
    let body: Value = resp.json().await.context("decode /version body")?;
    // /version contract: includes `service: "macronode"` plus build info.
    assert_eq!(body["service"], "macronode");
    assert!(body["version"].is_string());
    assert!(body["git_sha"].is_string());
    assert!(body["api"]["http"].is_string());

    // /healthz
    let resp = client
        .get(format!("{base}/healthz"))
        .send()
        .await
        .context("GET /healthz failed")?;
    assert!(resp.status().is_success());
    let body: Value = resp.json().await.context("decode /healthz body")?;
    assert_eq!(body["ok"], true);

    // /readyz
    let resp = client
        .get(format!("{base}/readyz"))
        .send()
        .await
        .context("GET /readyz failed")?;
    assert!(
        resp.status().is_success(),
        "expected /readyz 200 when node is up"
    );
    let body: Value = resp.json().await.context("decode /readyz body")?;
    assert_eq!(body["ready"], true);
    // Basic sanity on deps.
    assert_eq!(body["deps"]["config"], "loaded");
    assert_eq!(body["deps"]["network"], "ok");
    assert_eq!(body["deps"]["gateway"], "ok");

    // /metrics
    let resp = client
        .get(format!("{base}/metrics"))
        .send()
        .await
        .context("GET /metrics failed")?;
    assert!(resp.status().is_success(), "/metrics must return 200 OK");

    let headers = resp.headers().clone();
    let text = resp.text().await.context("decode /metrics body")?;

    // Content-type should be text/plain; charset=utf-8 (Axum default for String).
    if let Some(ct) = headers.get(reqwest::header::CONTENT_TYPE) {
        let ct = ct.to_str().unwrap_or_default();
        assert!(
            ct.starts_with("text/plain"),
            "expected text/plain content-type for /metrics, got {ct}"
        );
    }

    // We don't yet enforce that the metrics body is non-empty, only that it is
    // reasonably small and successfully returned as text.
    assert!(
        text.len() < 1024 * 1024,
        "/metrics body should not exceed 1 MiB in tests"
    );

    // /api/v1/status
    let resp = client
        .get(format!("{base}/api/v1/status"))
        .send()
        .await
        .context("GET /api/v1/status failed")?;
    assert!(resp.status().is_success());
    let body: Value = resp.json().await.context("decode /api/v1/status body")?;
    // Status contract: uses `profile: "macronode"` (not `service`).
    assert_eq!(body["profile"], "macronode");
    assert!(body["uptime_seconds"].as_f64().unwrap_or(0.0) >= 0.0);
    // We expect a services map with at least gateway present.
    let services = body["services"].as_object().expect("services map present");
    assert!(
        services.contains_key("svc-gateway"),
        "status.services should contain svc-gateway"
    );

    // Drive shutdown through the HTTP surface.
    shutdown_macronode(child, &client, &base).await?;

    Ok(())
}

```

### crates/macronode/tests/metrics_contract.rs
<a id="crates-macronode-tests-metricscontract-rs"></a>

```rust
//! RO:WHAT — Contract test for the `/metrics` surface.
//! RO:WHY  — Ensure Macronode always exposes a Prometheus text endpoint,
//!           even before we add richer metric series.

use std::process::{Child, Command, Stdio};
use std::time::Duration;

use anyhow::{anyhow, Context, Result};
use reqwest::Client;
use tokio::time::sleep;

const ADMIN_PORT: u16 = 18081;
const GATEWAY_PORT: u16 = 18091;

async fn spawn_macronode() -> Result<(Child, Client, String)> {
    let bin = env!("CARGO_BIN_EXE_macronode");

    let mut cmd = Command::new(bin);
    cmd.arg("run")
        .env("RUST_LOG", "info,macronode=debug")
        .env("RON_HTTP_ADDR", format!("127.0.0.1:{ADMIN_PORT}"))
        .env("RON_GATEWAY_ADDR", format!("127.0.0.1:{GATEWAY_PORT}"))
        .stdout(Stdio::null())
        .stderr(Stdio::null());

    let child = cmd.spawn().context("failed to spawn macronode binary")?;

    let client = Client::builder()
        .timeout(Duration::from_secs(5))
        .build()
        .context("failed to build reqwest client")?;

    let base = format!("http://127.0.0.1:{ADMIN_PORT}");

    // Wait for `/healthz` to be OK.
    for _ in 0..50 {
        match client.get(format!("{base}/healthz")).send().await {
            Ok(resp) if resp.status().is_success() => return Ok((child, client, base)),
            _ => sleep(Duration::from_millis(200)).await,
        }
    }

    Err(anyhow!("macronode did not become healthy in time"))
}

async fn shutdown_macronode(mut child: Child) {
    // Best-effort kill; this test is only concerned that /metrics is present.
    for _ in 0..10 {
        if let Ok(Some(_)) = child.try_wait() {
            return;
        }
        sleep(Duration::from_millis(100)).await;
    }
    let _ = child.kill();
}

#[tokio::test(flavor = "multi_thread")]
async fn metrics_endpoint_exists_and_is_text() -> Result<()> {
    let (child, client, base) = spawn_macronode().await?;

    let resp = client
        .get(format!("{base}/metrics"))
        .send()
        .await
        .context("GET /metrics failed")?;
    assert!(resp.status().is_success(), "/metrics must return 200 OK");

    let headers = resp.headers().clone();
    let body = resp.text().await.context("decode /metrics body")?;

    // Content-type should be text/plain; charset=utf-8 (Axum default for String).
    if let Some(ct) = headers.get(reqwest::header::CONTENT_TYPE) {
        let ct = ct.to_str().unwrap_or_default();
        assert!(
            ct.starts_with("text/plain"),
            "expected text/plain content-type for /metrics, got {ct}"
        );
    }

    // Even if we have no custom metrics yet, the body should not be enormous
    // and should be valid UTF-8 text.
    assert!(
        body.len() < 1024 * 1024,
        "metrics body should not exceed 1 MiB in tests"
    );

    shutdown_macronode(child).await;
    Ok(())
}

```

### crates/macronode/tests/readiness_drain.rs
<a id="crates-macronode-tests-readinessdrain-rs"></a>

```rust
//! RO:WHAT  — Contract tests for `/readyz` truthfulness vs dev-forced mode.
//! RO:WHY   — Ensure orchestrators (K8s/systemd/CI) can trust readiness, and
//!            that the dev override flag behaves exactly as documented.
//!
//! RO:INVARIANTS —
//!   - Truthful mode: `MACRONODE_DEV_READY` is *not* set in the child env.
//!       * `/readyz` eventually returns HTTP 200 with `"mode":"truthful"` and
//!         `"ready":true` once the node has finished booting.
//!   - Dev-forced mode: `MACRONODE_DEV_READY=1` in the child env.
//!       * `/readyz` quickly returns HTTP 200 with `"ready":true` even if some
//!         deps are still pending; `mode` should be either `"dev-forced"` or
//!         `"truthful"` depending on how far the node has progressed.
//!
//! These tests never rely on a config file path. All config comes from
//! environment variables passed to the spawned child, just like the
//! `admin_smoke` and `metrics_contract` tests.

use std::process::{Child, Command, Stdio};
use std::time::{Duration, Instant};

use reqwest::{Client, StatusCode};
use serde_json::Value;
use tokio::time::sleep;

// Use dedicated ports so we don't collide with other tests.
const ADMIN_PORT: u16 = 18082;
const GATEWAY_PORT: u16 = 18092;

/// Spawn a macronode child process with a controlled environment.
///
/// If `dev_ready` is:
///   - `None`        => ensure `MACRONODE_DEV_READY` is *removed* from the child env.
///   - `Some(true)`  => set `MACRONODE_DEV_READY=1`.
///   - `Some(false)` => set `MACRONODE_DEV_READY=0` (does NOT trigger dev mode).
fn spawn_macronode(dev_ready: Option<bool>) -> Child {
    let bin = env!("CARGO_BIN_EXE_macronode");

    let mut cmd = Command::new(bin);
    cmd.arg("run")
        // Keep logs visible enough for debugging without being spammy.
        .env("RUST_LOG", "info,macronode=debug")
        // Configure admin + gateway addresses via env (no config file).
        .env("RON_HTTP_ADDR", format!("127.0.0.1:{ADMIN_PORT}"))
        .env("RON_GATEWAY_ADDR", format!("127.0.0.1:{GATEWAY_PORT}"))
        // Silence child stdout/stderr by default (tests can use --nocapture if desired).
        .stdout(Stdio::null())
        .stderr(Stdio::null());

    match dev_ready {
        None => {
            cmd.env_remove("MACRONODE_DEV_READY");
        }
        Some(true) => {
            cmd.env("MACRONODE_DEV_READY", "1");
        }
        Some(false) => {
            cmd.env("MACRONODE_DEV_READY", "0");
        }
    }

    cmd.spawn().expect("failed to spawn macronode child")
}

/// Poll `/readyz` until it reports the expected mode + ready flag, or time out.
///
/// This function is tolerant of early connection failures (e.g. TCP
/// connection refused while the admin listener is still binding) and treats
/// them as "not ready yet".
async fn wait_for_readyz_mode(
    client: &Client,
    admin_base: &str,
    expected_mode: &str,
    expected_ready: bool,
    overall_timeout: Duration,
) {
    let deadline = Instant::now() + overall_timeout;

    loop {
        match client.get(&format!("{admin_base}/readyz")).send().await {
            Ok(resp) => {
                let status = resp.status();
                let body: Value = resp
                    .json()
                    .await
                    .expect("failed to parse /readyz JSON body");

                let mode = body
                    .get("mode")
                    .and_then(Value::as_str)
                    .unwrap_or_default()
                    .to_string();
                let ready = body.get("ready").and_then(Value::as_bool).unwrap_or(false);

                if mode == expected_mode && ready == expected_ready && status == StatusCode::OK {
                    // Reached desired state.
                    return;
                }
            }
            Err(_e) => {
                // Connection refused / timeout: admin plane not up yet.
                // Treat as "not ready yet" and keep polling until deadline.
            }
        }

        if Instant::now() >= deadline {
            panic!(
                "/readyz never reached mode={expected_mode:?}, ready={expected_ready} \
                 within {:?}",
                overall_timeout
            );
        }

        sleep(Duration::from_millis(100)).await;
    }
}

/// POST `/api/v1/shutdown` and wait for the child process to exit.
///
/// For these tests we only require that the node terminates in a bounded
/// amount of time. We do *not* enforce that the exit code is zero, since
/// dev/test profiles may choose to exit with non-zero codes for various
/// reasons (e.g. simulated faults).
async fn shutdown_and_wait(client: &Client, admin_base: &str, child: &mut Child) {
    let resp = client
        .post(&format!("{admin_base}/api/v1/shutdown"))
        .send()
        .await
        .expect("failed to send /shutdown");

    assert!(
        resp.status().is_success(),
        "/shutdown did not return success, got {}",
        resp.status()
    );

    let deadline = Instant::now() + Duration::from_secs(10);

    loop {
        if let Some(status) = child.try_wait().expect("failed to poll child status") {
            eprintln!("[readiness_drain] macronode exited after /shutdown: {status}");
            // Do not assert on success; for readiness tests we only care that
            // the process actually terminates within the timeout.
            return;
        }

        if Instant::now() >= deadline {
            panic!("macronode did not exit within timeout after /shutdown");
        }

        sleep(Duration::from_millis(100)).await;
    }
}

#[tokio::test(flavor = "multi_thread")]
async fn readyz_truthful_mode_eventually_ready() {
    // Spawn WITHOUT dev override; explicitly remove MACRONODE_DEV_READY from
    // the child env so we are not affected by whatever the parent shell has.
    let mut child = spawn_macronode(None);
    let client = Client::new();
    let admin_base = format!("http://127.0.0.1:{ADMIN_PORT}");

    // In truthful mode we expect:
    //   { "mode": "truthful", "ready": true }
    // within a reasonable timeout.
    wait_for_readyz_mode(
        &client,
        &admin_base,
        "truthful",
        true,
        Duration::from_secs(20),
    )
    .await;

    shutdown_and_wait(&client, &admin_base, &mut child).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn readyz_dev_forced_mode() {
    // Spawn WITH dev override enabled only in the child env.
    let mut child = spawn_macronode(Some(true));
    let client = Client::new();
    let admin_base = format!("http://127.0.0.1:{ADMIN_PORT}");

    // In dev-forced mode we care primarily that readiness flips to true quickly.
    // The mode string may be "dev-forced" early, then "truthful" once all deps
    // are genuinely ready; either is acceptable as long as ready=true.
    let overall_timeout = Duration::from_secs(10);
    let deadline = Instant::now() + overall_timeout;

    loop {
        match client.get(&format!("{admin_base}/readyz")).send().await {
            Ok(resp) => {
                if resp.status() == StatusCode::OK {
                    let body: Value = resp
                        .json()
                        .await
                        .expect("failed to parse /readyz JSON body");

                    let ready = body.get("ready").and_then(Value::as_bool).unwrap_or(false);

                    if ready {
                        let mode = body
                            .get("mode")
                            .and_then(Value::as_str)
                            .unwrap_or_default()
                            .to_string();

                        // Sanity: mode should be one of the known variants.
                        assert!(
                            mode == "dev-forced" || mode == "truthful",
                            "unexpected /readyz mode in dev-forced test: {mode}"
                        );

                        shutdown_and_wait(&client, &admin_base, &mut child).await;
                        return;
                    }
                }
            }
            Err(_e) => {
                // Listener not up yet; keep trying until deadline.
            }
        }

        if Instant::now() >= deadline {
            panic!(
                "/readyz never reached ready=true within {:?} (dev-forced test)",
                overall_timeout
            );
        }

        sleep(Duration::from_millis(100)).await;
    }
}

```

