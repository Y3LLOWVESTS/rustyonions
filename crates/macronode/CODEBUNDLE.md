<!-- Generated by scripts/make_crate_codex.sh on 2025-11-20T19:39:56Z -->
# Code Bundle — `macronode`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/macronode/.github/workflows/ci.yml](#crates-macronode--github-workflows-ci-yml)
- [crates/macronode/.github/workflows/render-mermaid.yml](#crates-macronode--github-workflows-render-mermaid-yml)
- [crates/macronode/Cargo.toml](#crates-macronode-Cargo-toml)
- [crates/macronode/benches/admin_paths_latency.rs](#crates-macronode-benches-adminpathslatency-rs)
- [crates/macronode/scripts/dump_http_surface.sh](#crates-macronode-scripts-dumphttpsurface-sh)
- [crates/macronode/scripts/dump_metrics_names.sh](#crates-macronode-scripts-dumpmetricsnames-sh)
- [crates/macronode/scripts/render_mermaid.sh](#crates-macronode-scripts-rendermermaid-sh)
- [crates/macronode/src/bus/events.rs](#crates-macronode-src-bus-events-rs)
- [crates/macronode/src/bus/mod.rs](#crates-macronode-src-bus-mod-rs)
- [crates/macronode/src/cli/args.rs](#crates-macronode-src-cli-args-rs)
- [crates/macronode/src/cli/check.rs](#crates-macronode-src-cli-check-rs)
- [crates/macronode/src/cli/config_print.rs](#crates-macronode-src-cli-configprint-rs)
- [crates/macronode/src/cli/config_validate.rs](#crates-macronode-src-cli-configvalidate-rs)
- [crates/macronode/src/cli/doctor.rs](#crates-macronode-src-cli-doctor-rs)
- [crates/macronode/src/cli/mod.rs](#crates-macronode-src-cli-mod-rs)
- [crates/macronode/src/cli/run.rs](#crates-macronode-src-cli-run-rs)
- [crates/macronode/src/cli/version.rs](#crates-macronode-src-cli-version-rs)
- [crates/macronode/src/config/cli_overlay.rs](#crates-macronode-src-config-clioverlay-rs)
- [crates/macronode/src/config/env_overlay.rs](#crates-macronode-src-config-envoverlay-rs)
- [crates/macronode/src/config/hot_reload.rs](#crates-macronode-src-config-hotreload-rs)
- [crates/macronode/src/config/load.rs](#crates-macronode-src-config-load-rs)
- [crates/macronode/src/config/mod.rs](#crates-macronode-src-config-mod-rs)
- [crates/macronode/src/config/schema.rs](#crates-macronode-src-config-schema-rs)
- [crates/macronode/src/config/validate.rs](#crates-macronode-src-config-validate-rs)
- [crates/macronode/src/errors.rs](#crates-macronode-src-errors-rs)
- [crates/macronode/src/facets/mod.rs](#crates-macronode-src-facets-mod-rs)
- [crates/macronode/src/facets/permits.rs](#crates-macronode-src-facets-permits-rs)
- [crates/macronode/src/facets/quotas.rs](#crates-macronode-src-facets-quotas-rs)
- [crates/macronode/src/http_admin/handlers/healthz.rs](#crates-macronode-src-httpadmin-handlers-healthz-rs)
- [crates/macronode/src/http_admin/handlers/metrics.rs](#crates-macronode-src-httpadmin-handlers-metrics-rs)
- [crates/macronode/src/http_admin/handlers/mod.rs](#crates-macronode-src-httpadmin-handlers-mod-rs)
- [crates/macronode/src/http_admin/handlers/readyz.rs](#crates-macronode-src-httpadmin-handlers-readyz-rs)
- [crates/macronode/src/http_admin/handlers/reload.rs](#crates-macronode-src-httpadmin-handlers-reload-rs)
- [crates/macronode/src/http_admin/handlers/shutdown.rs](#crates-macronode-src-httpadmin-handlers-shutdown-rs)
- [crates/macronode/src/http_admin/handlers/status.rs](#crates-macronode-src-httpadmin-handlers-status-rs)
- [crates/macronode/src/http_admin/handlers/version.rs](#crates-macronode-src-httpadmin-handlers-version-rs)
- [crates/macronode/src/http_admin/middleware/auth.rs](#crates-macronode-src-httpadmin-middleware-auth-rs)
- [crates/macronode/src/http_admin/middleware/mod.rs](#crates-macronode-src-httpadmin-middleware-mod-rs)
- [crates/macronode/src/http_admin/middleware/rate_limit.rs](#crates-macronode-src-httpadmin-middleware-ratelimit-rs)
- [crates/macronode/src/http_admin/middleware/request_id.rs](#crates-macronode-src-httpadmin-middleware-requestid-rs)
- [crates/macronode/src/http_admin/middleware/timeout.rs](#crates-macronode-src-httpadmin-middleware-timeout-rs)
- [crates/macronode/src/http_admin/mod.rs](#crates-macronode-src-httpadmin-mod-rs)
- [crates/macronode/src/http_admin/router.rs](#crates-macronode-src-httpadmin-router-rs)
- [crates/macronode/src/main.rs](#crates-macronode-src-main-rs)
- [crates/macronode/src/observability/logging.rs](#crates-macronode-src-observability-logging-rs)
- [crates/macronode/src/observability/metrics.rs](#crates-macronode-src-observability-metrics-rs)
- [crates/macronode/src/observability/mod.rs](#crates-macronode-src-observability-mod-rs)
- [crates/macronode/src/pq/hybrid.rs](#crates-macronode-src-pq-hybrid-rs)
- [crates/macronode/src/pq/mod.rs](#crates-macronode-src-pq-mod-rs)
- [crates/macronode/src/readiness/deps.rs](#crates-macronode-src-readiness-deps-rs)
- [crates/macronode/src/readiness/mod.rs](#crates-macronode-src-readiness-mod-rs)
- [crates/macronode/src/security/amnesia.rs](#crates-macronode-src-security-amnesia-rs)
- [crates/macronode/src/security/macaroon.rs](#crates-macronode-src-security-macaroon-rs)
- [crates/macronode/src/security/mod.rs](#crates-macronode-src-security-mod-rs)
- [crates/macronode/src/security/tls.rs](#crates-macronode-src-security-tls-rs)
- [crates/macronode/src/services/mod.rs](#crates-macronode-src-services-mod-rs)
- [crates/macronode/src/services/registry.rs](#crates-macronode-src-services-registry-rs)
- [crates/macronode/src/services/spawn.rs](#crates-macronode-src-services-spawn-rs)
- [crates/macronode/src/services/svc_dht.rs](#crates-macronode-src-services-svcdht-rs)
- [crates/macronode/src/services/svc_gateway.rs](#crates-macronode-src-services-svcgateway-rs)
- [crates/macronode/src/services/svc_index.rs](#crates-macronode-src-services-svcindex-rs)
- [crates/macronode/src/services/svc_mailbox.rs](#crates-macronode-src-services-svcmailbox-rs)
- [crates/macronode/src/services/svc_overlay.rs](#crates-macronode-src-services-svcoverlay-rs)
- [crates/macronode/src/services/svc_storage.rs](#crates-macronode-src-services-svcstorage-rs)
- [crates/macronode/src/supervisor/backoff.rs](#crates-macronode-src-supervisor-backoff-rs)
- [crates/macronode/src/supervisor/crash_policy.rs](#crates-macronode-src-supervisor-crashpolicy-rs)
- [crates/macronode/src/supervisor/health_reporter.rs](#crates-macronode-src-supervisor-healthreporter-rs)
- [crates/macronode/src/supervisor/lifecycle.rs](#crates-macronode-src-supervisor-lifecycle-rs)
- [crates/macronode/src/supervisor/mod.rs](#crates-macronode-src-supervisor-mod-rs)
- [crates/macronode/src/supervisor/shutdown.rs](#crates-macronode-src-supervisor-shutdown-rs)
- [crates/macronode/src/types.rs](#crates-macronode-src-types-rs)
- [crates/macronode/src/util/dur.rs](#crates-macronode-src-util-dur-rs)
- [crates/macronode/src/util/sizes.rs](#crates-macronode-src-util-sizes-rs)
- [crates/macronode/tests/admin_smoke.rs](#crates-macronode-tests-adminsmoke-rs)
- [crates/macronode/tests/metrics_contract.rs](#crates-macronode-tests-metricscontract-rs)
- [crates/macronode/tests/readiness_drain.rs](#crates-macronode-tests-readinessdrain-rs)

### crates/macronode/.github/workflows/ci.yml
<a id="crates-macronode--github-workflows-ci-yml"></a>

```yaml

```

### crates/macronode/.github/workflows/render-mermaid.yml
<a id="crates-macronode--github-workflows-render-mermaid-yml"></a>

```yaml

```

### crates/macronode/Cargo.toml
<a id="crates-macronode-Cargo-toml"></a>

```toml
[package]
name = "macronode"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[[bin]]
name = "macronode"
path = "src/main.rs"

[dependencies]
# Core RON-CORE crates this node will coordinate.
ron-kernel = { path = "../ron-kernel" }
ron-proto  = { path = "../ron-proto" }
oap        = { path = "../oap" }

# Async and HTTP stack
tokio = { version = "1.38", features = ["macros", "rt-multi-thread", "signal", "time", "net"] }
axum  = { version = "0.7", features = ["http1", "http2", "json", "tokio"] }
tower = "0.4"
http  = "0.2"

# Observability
tracing            = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }
prometheus         = "0.14"

# Config / serde
serde           = { version = "1", features = ["derive"] }
serde_json      = "1"
toml            = "0.8"
humantime       = "2.1"
humantime-serde = "1.1"

# Error handling
thiserror = "1"
anyhow    = "1"

# Misc
parking_lot = "0.12"

[dev-dependencies]
reqwest = { version = "0.12", features = ["rustls-tls-native-roots", "json"] }
tokio   = { version = "1.38", features = ["macros", "rt-multi-thread", "time", "net"] }

```

### crates/macronode/benches/admin_paths_latency.rs
<a id="crates-macronode-benches-adminpathslatency-rs"></a>

```rust


```

### crates/macronode/scripts/dump_http_surface.sh
<a id="crates-macronode-scripts-dumphttpsurface-sh"></a>

```bash

```

### crates/macronode/scripts/dump_metrics_names.sh
<a id="crates-macronode-scripts-dumpmetricsnames-sh"></a>

```bash

```

### crates/macronode/scripts/render_mermaid.sh
<a id="crates-macronode-scripts-rendermermaid-sh"></a>

```bash

```

### crates/macronode/src/bus/events.rs
<a id="crates-macronode-src-bus-events-rs"></a>

```rust

```

### crates/macronode/src/bus/mod.rs
<a id="crates-macronode-src-bus-mod-rs"></a>

```rust

```

### crates/macronode/src/cli/args.rs
<a id="crates-macronode-src-cli-args-rs"></a>

```rust
//! RO:WHAT — Macronode CLI command/option types.
//! RO:WHY  — Keep the CLI surface explicit and testable without tying
//!           directly to a particular parsing crate.
//! RO:INVARIANTS —
//!   - `Cli::parse()` is a tiny, predictable parser over `std::env::args`.
//!   - Unknown commands fall back to `run` with a warning.
//!   - For `run`, we parse a small subset of flags by hand.

#[derive(Debug, Clone)]
pub enum Command {
    /// Run the Macronode host (admin HTTP + services).
    Run(RunOpts),
    /// Print version/build information and exit.
    Version,
    /// Validate environment/config and exit.
    Check,
    /// Print effective redacted config.
    ConfigPrint,
    /// Validate a supplied config file without starting the node.
    ConfigValidate,
    /// Run diagnostics bundle (fs/dns/time drift/ports).
    Doctor,
}

/// Options for the `run` subcommand.
///
/// NOTE: Fields are intentionally conservative for now; we keep them
/// around so the CLI surface is stable while we gradually implement
/// overlays. `#[allow(dead_code)]` keeps clippy happy under `-D warnings`
/// until all fields are used.
#[allow(dead_code)]
#[derive(Debug, Clone, Default)]
pub struct RunOpts {
    /// Optional path to a config file (`--config`).
    pub config_path: Option<String>,
    /// Optional bind override for admin HTTP (`--http-addr`).
    pub http_addr: Option<String>,
    /// Optional bind override for metrics (`--metrics-addr`).
    pub metrics_addr: Option<String>,
    /// Optional log level override (`--log-level`).
    pub log_level: Option<String>,
    /// Optional amnesia flag (`--amnesia`).
    pub amnesia: Option<bool>,
}

impl RunOpts {
    /// Parse flags for the `run` command from a slice of arguments.
    ///
    /// Supported flags (MVP):
    ///   --config PATH
    ///   --http-addr ADDR
    ///   --log-level LEVEL
    ///
    /// Unknown flags are ignored with a warning.
    pub fn from_args(args: &[String]) -> Self {
        let mut opts = RunOpts::default();
        let mut i = 0;

        while i < args.len() {
            match args[i].as_str() {
                "--config" => {
                    if let Some(val) = args.get(i + 1) {
                        opts.config_path = Some(val.clone());
                        i += 1;
                    } else {
                        eprintln!("macronode: --config requires a path argument");
                    }
                }
                "--http-addr" => {
                    if let Some(val) = args.get(i + 1) {
                        opts.http_addr = Some(val.clone());
                        i += 1;
                    } else {
                        eprintln!("macronode: --http-addr requires an address argument");
                    }
                }
                "--log-level" => {
                    if let Some(val) = args.get(i + 1) {
                        opts.log_level = Some(val.clone());
                        i += 1;
                    } else {
                        eprintln!("macronode: --log-level requires a level argument");
                    }
                }
                "--metrics-addr" => {
                    if let Some(val) = args.get(i + 1) {
                        opts.metrics_addr = Some(val.clone());
                        i += 1;
                    } else {
                        eprintln!("macronode: --metrics-addr requires an address argument");
                    }
                }
                "--amnesia" => {
                    // For now we accept `--amnesia` as a bare flag and treat it as true.
                    opts.amnesia = Some(true);
                }
                other => {
                    // Ignore unknown flags for now, but let the operator know.
                    if other.starts_with('-') {
                        eprintln!(
                            "macronode: ignoring unknown flag `{other}` on `run` (see README CLI section)"
                        );
                    }
                }
            }

            i += 1;
        }

        opts
    }
}

/// Top-level CLI wrapper.
#[derive(Debug, Clone)]
pub struct Cli {
    pub cmd: Command,
}

impl Cli {
    /// Parse CLI arguments into a `Cli` value.
    ///
    /// Today we:
    ///   - Look at the first positional argument to decide the subcommand.
    ///   - For `run`, parse a small set of flags from the remaining args.
    pub fn parse() -> Self {
        let mut args = std::env::args().skip(1);
        let sub = args.next();

        let cmd = match sub.as_deref() {
            None => {
                // No subcommand; treat as `run` with default options.
                Command::Run(RunOpts::default())
            }
            Some("run") => {
                let rest: Vec<String> = args.collect();
                let opts = RunOpts::from_args(&rest);
                Command::Run(opts)
            }
            Some("version") | Some("--version") | Some("-V") => Command::Version,
            Some("check") => Command::Check,
            Some("config") => match args.next().as_deref() {
                Some("print") => Command::ConfigPrint,
                Some("validate") => Command::ConfigValidate,
                other => {
                    eprintln!(
                        "macronode: expected `config print` or `config validate`, got {:?}; \
                         defaulting to `config print`",
                        other
                    );
                    Command::ConfigPrint
                }
            },
            Some("doctor") => Command::Doctor,
            Some(other) => {
                eprintln!(
                    "macronode: unknown command `{other}`, defaulting to `run` (see README CLI section)"
                );
                Command::Run(RunOpts::default())
            }
        };

        Cli { cmd }
    }
}

```

### crates/macronode/src/cli/check.rs
<a id="crates-macronode-src-cli-check-rs"></a>

```rust
//! RO:WHAT — Implementation of the `check` subcommand.
//! RO:WHY  — Fast validation of config/env without starting listeners.
//! RO:INVARIANTS —
//!   - Returns non-error only if config loads successfully.

use crate::{config::load_config, errors::Result};

pub fn run() -> Result<()> {
    let cfg = load_config()?;
    println!(
        "macronode check: OK (http_addr={}, metrics_addr={}, log_level={})",
        cfg.http_addr, cfg.metrics_addr, cfg.log_level
    );
    Ok(())
}

```

### crates/macronode/src/cli/config_print.rs
<a id="crates-macronode-src-cli-configprint-rs"></a>

```rust
//! RO:WHAT — Implementation of `config print`.
//! RO:WHY  — Give operators a way to see the **effective** config after
//!           defaults, optional file (RON_CONFIG/MACRO_CONFIG), and env
//!           overlays have been applied.

use crate::{config::load_config, errors::Result};

pub fn run() -> Result<()> {
    let cfg = load_config()?;
    let json = serde_json::to_string_pretty(&cfg)?;
    println!("{json}");
    Ok(())
}

```

### crates/macronode/src/cli/config_validate.rs
<a id="crates-macronode-src-cli-configvalidate-rs"></a>

```rust
//! RO:WHAT — Implementation of `config validate`.
//! RO:WHY  — Off-line validation of config without starting listeners.
//! RO:NOTE — Uses the same loader as `config print`/`check`, which merges
//!           defaults + optional file (via `RON_CONFIG`) + env overlays.

use crate::{config::load_config, errors::Result};

pub fn run() -> Result<()> {
    let _cfg = load_config()?;
    println!("macronode config validate: OK (file/env-based config)");
    Ok(())
}

```

### crates/macronode/src/cli/doctor.rs
<a id="crates-macronode-src-cli-doctor-rs"></a>

```rust
//! RO:WHAT — Implementation of the `doctor` subcommand (MVP stub).
//! RO:WHY  — Placeholder for richer diagnostics (fs/dns/time drift/ports).

use crate::errors::Result;

pub fn run() -> Result<()> {
    println!("macronode doctor: stub (diagnostics not yet implemented)");
    Ok(())
}

```

### crates/macronode/src/cli/mod.rs
<a id="crates-macronode-src-cli-mod-rs"></a>

```rust
//! RO:WHAT — Macronode CLI surface and entrypoint.
//! RO:WHY  — Provide a stable operator-facing CLI (`run`, `version`, `check`,
//!           `config print|validate`, `doctor`) without committing to a
//!           specific argument parser crate yet.
//! RO:INVARIANTS —
//!   - Parsing is intentionally minimal but deterministic.
//!   - All subcommands return `errors::Result<()>` so main can stay boring.

pub mod args;
pub mod check;
pub mod config_print;
pub mod config_validate;
pub mod doctor;
pub mod run;
pub mod version;

use crate::errors::Result;
pub use args::{Cli, Command, RunOpts};

/// Parse CLI args and dispatch to the selected subcommand.
pub async fn entrypoint() -> Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Command::Run(opts) => run::run(opts).await,
        Command::Version => {
            version::run();
            Ok(())
        }
        Command::Check => check::run(),
        Command::ConfigPrint => config_print::run(),
        Command::ConfigValidate => config_validate::run(),
        Command::Doctor => doctor::run(),
    }
}

```

### crates/macronode/src/cli/run.rs
<a id="crates-macronode-src-cli-run-rs"></a>

```rust
//! RO:WHAT — Implementation of the `run` subcommand.
//! RO:WHY  — Bridge between CLI surface and the existing runtime wiring
//!           (config, logging, readiness, admin HTTP, supervisor).
//! RO:INVARIANTS —
//!   - Config pipeline: defaults -> file (optional) -> env -> CLI overlays.
//!   - `RunOpts` is the only source of CLI overrides.
//!   - HTTP admin server uses graceful shutdown on Ctrl-C.

use std::{sync::Arc, time::Instant};

use axum::Router;
use ron_kernel::wait_for_ctrl_c;
use tokio::net::TcpListener;
use tracing::{error, info};

use crate::{
    config::{
        cli_overlay::{apply_cli_overlays, CliOverlay},
        load_effective_config,
    },
    errors::Result,
    http_admin,
    observability::logging,
    readiness::ReadyProbes,
    supervisor::{ShutdownToken, Supervisor},
    types::AppState,
};

use super::RunOpts;

/// Execute the `run` subcommand.
pub async fn run(opts: RunOpts) -> Result<()> {
    // 1) Load config (defaults + optional file from CLI/env + env).
    //
    // Precedence for file path:
    //   1) CLI --config
    //   2) RON_CONFIG / MACRO_CONFIG (inside load_effective_config)
    let base_cfg = load_effective_config(opts.config_path.as_deref())?;

    // 2) Build CLI overlay from RunOpts and apply it.
    let overlay = CliOverlay {
        http_addr: opts.http_addr.clone(),
        metrics_addr: opts.metrics_addr.clone(),
        log_level: opts.log_level.clone(),
    };
    let cfg = apply_cli_overlays(base_cfg, &overlay)?;

    // 3) Initialize logging with config log level (RUST_LOG can still override).
    logging::init(&cfg.log_level);

    // 4) Build shared readiness probes and shutdown token.
    let probes = Arc::new(ReadyProbes::new());
    let shutdown_token = ShutdownToken::new();

    // Metrics are already served via `/metrics` as soon as the admin router
    // is bound, so we can treat this as "bound" from the perspective of
    // readiness once the listener is active.
    //
    // NOTE: `cfg.metrics_addr` is now plumbed through config/env/CLI but we
    // still serve metrics on the admin listener for this slice. A future
    // slice can spin a dedicated metrics listener when `metrics_addr != http_addr`.
    probes.set_metrics_bound(true);

    // 5) Start supervised services. Successful spawn marks deps_ok.
    let supervisor = Supervisor::new(probes.clone(), shutdown_token.clone());
    supervisor.start().await?;

    // 6) Build shared application state for HTTP handlers.
    let state = AppState {
        cfg: Arc::new(cfg.clone()),
        probes: probes.clone(),
        started_at: Instant::now(),
    };

    // 7) Bind HTTP admin listener.
    let listener = TcpListener::bind(cfg.http_addr).await?;
    probes.set_listeners_bound(true);
    probes.set_cfg_loaded(true);

    let router: Router = http_admin::router::build_router(state);

    info!("macronode admin listening on {}", cfg.http_addr);

    // 8) Run HTTP admin server with graceful shutdown on Ctrl-C.
    let shutdown_signal = async move {
        wait_for_ctrl_c().await;
        info!("macronode: shutdown signal received, draining admin server");
        shutdown_token.trigger();
    };

    if let Err(err) = axum::serve(listener, router)
        .with_graceful_shutdown(shutdown_signal)
        .await
    {
        error!("macronode admin server error: {err}");
    }

    info!("macronode: admin server exited, shutdown complete");

    Ok(())
}

```

### crates/macronode/src/cli/version.rs
<a id="crates-macronode-src-cli-version-rs"></a>

```rust
//! RO:WHAT — Implementation of the `version` subcommand.
//! RO:WHY  — Provide a simple CLI-friendly equivalent to `/version`.

use crate::types::BuildInfo;

/// Print version information to stdout.
///
/// Shape matches the `/version` HTTP payload, minus the API version.
pub fn run() {
    let info = BuildInfo::current();
    println!(
        "service={service} version={version} git_sha={git_sha} build_ts={build_ts} rustc={rustc} msrv={msrv}",
        service = info.service,
        version = info.version,
        git_sha = info.git_sha,
        build_ts = info.build_ts,
        rustc = info.rustc,
        msrv = info.msrv,
    );
}

```

### crates/macronode/src/config/cli_overlay.rs
<a id="crates-macronode-src-config-clioverlay-rs"></a>

```rust
//! RO:WHAT — CLI overlays for Macronode config.
//! RO:WHY  — Let `macronode run` flags override defaults/env in a single place.
//! RO:INVARIANTS —
//!   - Only overrides fields that are explicitly set on `CliOverlay`.
//!   - Never panics on bad input; errors bubble as `Error::Config`.
//!   - If `--http-addr` is set and `--metrics-addr` is not, metrics inherits
//!     the HTTP bind, mirroring the env behavior.

use std::net::SocketAddr;

use crate::errors::{Error, Result};

use super::schema::Config;

/// Minimal set of config fields that can be overridden via CLI.
///
/// This deliberately mirrors the subset of `RunOpts` we support today.
/// We keep it here (in the config module) to avoid a circular dependency
/// on `crate::cli`.
#[derive(Debug, Default, Clone)]
pub struct CliOverlay {
    pub http_addr: Option<String>,
    pub metrics_addr: Option<String>,
    pub log_level: Option<String>,
}

pub fn apply_cli_overlays(mut cfg: Config, overlay: &CliOverlay) -> Result<Config> {
    // HTTP addr override
    if let Some(addr_str) = overlay.http_addr.as_deref() {
        let addr: SocketAddr = addr_str
            .parse()
            .map_err(|e| Error::config(format!("invalid --http-addr {addr_str:?}: {e}")))?;
        cfg.http_addr = addr;

        // If operator set an HTTP override but did not explicitly set a metrics
        // override, keep the "metrics inherits HTTP" invariant.
        if overlay.metrics_addr.is_none() {
            cfg.metrics_addr = addr;
        }
    }

    // Metrics addr override
    if let Some(addr_str) = overlay.metrics_addr.as_deref() {
        let addr: SocketAddr = addr_str
            .parse()
            .map_err(|e| Error::config(format!("invalid --metrics-addr {addr_str:?}: {e}")))?;
        cfg.metrics_addr = addr;
    }

    // Log level override
    if let Some(level) = overlay.log_level.as_ref() {
        if !level.trim().is_empty() {
            cfg.log_level = level.clone();
        }
    }

    Ok(cfg)
}

```

### crates/macronode/src/config/env_overlay.rs
<a id="crates-macronode-src-config-envoverlay-rs"></a>

```rust
//! RO:WHAT — Environment overlays for Macronode config.
//! RO:WHY  — Separate side-effectful env reading from pure config logic.
//! RO:INVARIANTS —
//!   - Never panics on bad env; all issues bubble as `Error::Config`.
//!   - Aliases `MACRO_*` are supported for one minor with a warning.
//!   - `metrics_addr` inherits `http_addr` when no explicit metrics env is set.

use std::{env, net::SocketAddr};

use humantime::parse_duration;

use crate::errors::{Error, Result};

use super::schema::Config;

/// Apply environment-based overlays to a `Config` value.
///
/// Supported env vars:
///   - `RON_HTTP_ADDR` / `MACRO_HTTP_ADDR`
///   - `RON_METRICS_ADDR` / `MACRO_METRICS_ADDR`
///   - `RON_LOG`
///   - `RON_READ_TIMEOUT` / `MACRO_READ_TIMEOUT`
///   - `RON_WRITE_TIMEOUT` / `MACRO_WRITE_TIMEOUT`
///   - `RON_IDLE_TIMEOUT` / `MACRO_IDLE_TIMEOUT`
pub fn apply_env_overlays(mut cfg: Config) -> Result<Config> {
    let mut metrics_overridden = false;

    // Metrics addr — may override HTTP if explicitly set.
    if let Some(val) = first_of(&["RON_METRICS_ADDR", "MACRO_METRICS_ADDR"]) {
        let addr: SocketAddr = val
            .parse()
            .map_err(|e| Error::config(format!("invalid metrics addr {val:?}: {e}")))?;
        cfg.metrics_addr = addr;
        metrics_overridden = true;
    }

    // HTTP addr — if set and metrics were not explicitly overridden, we keep
    // the invariant that metrics inherits HTTP by default.
    if let Some(val) = first_of(&["RON_HTTP_ADDR", "MACRO_HTTP_ADDR"]) {
        let addr: SocketAddr = val
            .parse()
            .map_err(|e| Error::config(format!("invalid HTTP addr {val:?}: {e}")))?;
        cfg.http_addr = addr;
        if !metrics_overridden {
            cfg.metrics_addr = addr;
        }
    }

    // Log level
    if let Ok(val) = env::var("RON_LOG") {
        if !val.trim().is_empty() {
            cfg.log_level = val;
        }
    }

    // Timeouts
    if let Some(val) = first_of(&["RON_READ_TIMEOUT", "MACRO_READ_TIMEOUT"]) {
        cfg.read_timeout = parse_duration_checked("read_timeout", &val)?;
    }

    if let Some(val) = first_of(&["RON_WRITE_TIMEOUT", "MACRO_WRITE_TIMEOUT"]) {
        cfg.write_timeout = parse_duration_checked("write_timeout", &val)?;
    }

    if let Some(val) = first_of(&["RON_IDLE_TIMEOUT", "MACRO_IDLE_TIMEOUT"]) {
        cfg.idle_timeout = parse_duration_checked("idle_timeout", &val)?;
    }

    Ok(cfg)
}

fn first_of(keys: &[&str]) -> Option<String> {
    for key in keys {
        if let Ok(v) = env::var(key) {
            if !v.trim().is_empty() {
                if key.starts_with("MACRO_") {
                    eprintln!(
                        "[macronode-config] WARNING: {key} is deprecated; \
                         prefer the RON_* variant instead."
                    );
                }
                return Some(v);
            }
        }
    }
    None
}

fn parse_duration_checked(field: &str, input: &str) -> Result<std::time::Duration> {
    parse_duration(input).map_err(|e| {
        Error::config(format!(
            "invalid duration for {field}: {input:?} ({e}) \
             — expected forms like \"10s\", \"500ms\", \"1m\""
        ))
    })
}

```

### crates/macronode/src/config/hot_reload.rs
<a id="crates-macronode-src-config-hotreload-rs"></a>

```rust
//! RO:WHAT — Config hot-reload stub.
//! RO:WHY  — `/api/v1/reload` calls this; later it will re-read config file/env.
//!
//! RO:INVARIANTS —
//!   - Non-blocking.
//!   - Does *not* mutate live config yet (will be replaced when we wire reload).

use crate::config::schema::Config;
use tracing::info;

pub fn hot_reload(_cfg: &Config) -> Result<(), String> {
    info!("macronode config hot_reload(): stub (no-op)");
    Ok(())
}

```

### crates/macronode/src/config/load.rs
<a id="crates-macronode-src-config-load-rs"></a>

```rust
//! RO:WHAT — Config load pipeline for Macronode.
//! RO:WHY  — Centralize config loading so CLI and runtime share precedence,
//!           env overlays, and validation.
//! RO:INVARIANTS —
//!   - Always start from `Config::default()`.
//!   - Precedence for config sources:
//!       1) Defaults
//!       2) Optional file from CLI `--config` or env (`RON_CONFIG` / `MACRO_CONFIG`)
//!       3) Env overlays (`RON_*` + `MACRO_*` aliases)
//!   - Validation always runs before returning a config to callers.
//!
//! RO:CONFIG SOURCES —
//!   - `--config PATH` (CLI) has highest precedence for the file path.
//!   - If no CLI path is supplied, `RON_CONFIG` is honored.
//!   - `MACRO_CONFIG` is accepted for one minor with a warning.

use std::{env, fs, path::Path};

use crate::errors::{Error, Result};

use super::{env_overlay::apply_env_overlays, schema::Config, validate::validate_config};

/// Load config using defaults + **optional file from env** + env overlays.
///
/// This is what non-`run` CLI commands (`check`, `config print`,
/// `config validate`) use: they do not accept `--config` themselves, but
/// operators can still provide a file via `RON_CONFIG`/`MACRO_CONFIG`.
pub fn load_config() -> Result<Config> {
    load_effective_config(None)
}

/// Load config using an explicit file path (if provided), then env overlays.
///
/// This is the low-level helper used by the higher-level
/// `load_effective_config`. Precedence inside this function is:
///
///   1) `Config::default()`
///   2) Optional file (if `file_path` is `Some(_)`)
///   3) Env overlays
///
/// Validation is always run before the config is returned.
pub fn load_config_with_file(file_path: Option<&str>) -> Result<Config> {
    let mut cfg = Config::default();

    if let Some(path) = file_path {
        let path = Path::new(path);
        cfg = load_from_file(path)?;
    }

    let cfg = apply_env_overlays(cfg)?;
    validate_config(&cfg)?;
    Ok(cfg)
}

/// Load the **effective** config, combining CLI and env-level file paths.
///
/// Precedence for the config *file path* is:
///
///   1) CLI `--config PATH` (if supplied)
///   2) `RON_CONFIG` (if set and non-empty)
///   3) `MACRO_CONFIG` (deprecated alias; emits a warning)
///
/// After the file (if any) is applied, env overlays and validation are run.
pub fn load_effective_config(cli_file_path: Option<&str>) -> Result<Config> {
    let chosen_path = match cli_file_path {
        Some(p) => Some(p.to_string()),
        None => env_config_path(),
    };

    load_config_with_file(chosen_path.as_deref())
}

/// Discover a config file path from env (`RON_CONFIG` / `MACRO_CONFIG`).
///
/// Returns `Some(path)` if a non-empty value is found, otherwise `None`.
fn env_config_path() -> Option<String> {
    if let Ok(val) = env::var("RON_CONFIG") {
        let trimmed = val.trim();
        if !trimmed.is_empty() {
            return Some(trimmed.to_owned());
        }
    }

    // Temporary compatibility alias for older docs/scripts.
    if let Ok(val) = env::var("MACRO_CONFIG") {
        let trimmed = val.trim();
        if !trimmed.is_empty() {
            eprintln!(
                "macronode: MACRO_CONFIG is deprecated; prefer RON_CONFIG for config file path"
            );
            return Some(trimmed.to_owned());
        }
    }

    None
}

/// Load a `Config` from a TOML or JSON file.
///
/// - If the extension is `.toml`, parse as TOML.
/// - If the extension is `.json`, parse as JSON.
/// - Otherwise, try TOML first, then JSON, and include both errors on failure.
fn load_from_file(path: &Path) -> Result<Config> {
    let raw = fs::read_to_string(path).map_err(|e| {
        Error::config(format!(
            "failed to read config file {}: {e}",
            path.display()
        ))
    })?;

    let ext = path
        .extension()
        .and_then(|s| s.to_str())
        .map(|s| s.to_ascii_lowercase())
        .unwrap_or_default();

    let parsed: Result<Config> = match ext.as_str() {
        "toml" => toml::from_str(&raw).map_err(|e| {
            Error::config(format!(
                "failed to parse TOML config {}: {e}",
                path.display()
            ))
        }),
        "json" => serde_json::from_str(&raw).map_err(|e| {
            Error::config(format!(
                "failed to parse JSON config {}: {e}",
                path.display()
            ))
        }),
        _ => {
            // Unknown extension: try TOML first, then JSON, and include both errors.
            let toml_err = toml::from_str::<Config>(&raw).map_err(|e| e.to_string());
            match toml_err {
                Ok(cfg) => Ok(cfg),
                Err(t_err) => {
                    let json_err = serde_json::from_str::<Config>(&raw).map_err(|e| e.to_string());
                    match json_err {
                        Ok(cfg) => Ok(cfg),
                        Err(j_err) => Err(Error::config(format!(
                            "failed to parse config {} as TOML or JSON:\n  TOML error: {t_err}\n  JSON error: {j_err}",
                            path.display()
                        ))),
                    }
                }
            }
        }
    };

    parsed
}

```

### crates/macronode/src/config/mod.rs
<a id="crates-macronode-src-config-mod-rs"></a>

```rust
//! RO:WHAT — Config module root for Macronode.
//! RO:WHY  — Centralize schema + loaders (env/file/CLI overlays).
//! RO:INVARIANTS —
//!   - `Config` is the single source of truth for runtime settings.
//!   - Callers use `load_config()` or `load_effective_config()`; no ad-hoc
//!     env/file access sprinkled around the crate.

pub mod cli_overlay;
pub mod env_overlay;
pub mod hot_reload;
pub mod load;
pub mod schema;
pub mod validate;

// Public facade:
// - `Config` type
// - `load_config()` for non-run CLI commands (env + optional file)
// - `load_effective_config()` for `run` (CLI --config + env)
// - `hot_reload()` used by `/api/v1/reload` handler.
pub use hot_reload::hot_reload;
pub use load::{load_config, load_effective_config};
pub use schema::Config;

```

### crates/macronode/src/config/schema.rs
<a id="crates-macronode-src-config-schema-rs"></a>

```rust
//! RO:WHAT — Minimal config schema for Macronode.
//! RO:WHY  — Bind HTTP admin, metrics, timeouts, and log level with sane
//!           defaults.
//! RO:INTERACTS —
//!   - Loaded via `config::load_config()` / `load_config_with_file()`.
//!   - Passed into runtime state and admin HTTP stack.

use serde::{Deserialize, Serialize};
use std::{net::SocketAddr, time::Duration};

fn default_http_addr() -> SocketAddr {
    "127.0.0.1:8080"
        .parse()
        .expect("default 127.0.0.1:8080 must parse")
}

fn default_metrics_addr() -> SocketAddr {
    // By default we bind metrics on the same address as the admin HTTP plane.
    default_http_addr()
}

fn default_log_level() -> String {
    "info".to_string()
}

fn default_read_timeout() -> Duration {
    Duration::from_secs(10)
}

fn default_write_timeout() -> Duration {
    Duration::from_secs(10)
}

fn default_idle_timeout() -> Duration {
    Duration::from_secs(60)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct Config {
    /// HTTP admin bind address (`RON_HTTP_ADDR` / `MACRO_HTTP_ADDR`).
    #[serde(default = "default_http_addr")]
    pub http_addr: SocketAddr,

    /// Metrics bind address (`RON_METRICS_ADDR` / `MACRO_METRICS_ADDR`).
    ///
    /// Invariants:
    ///   - Defaults to the same value as `http_addr`.
    ///   - Env/CLI overlays may override it independently.
    #[serde(default = "default_metrics_addr")]
    pub metrics_addr: SocketAddr,

    /// Log level (fan-out via `RUST_LOG` env in logging bootstrap).
    #[serde(default = "default_log_level")]
    pub log_level: String,

    /// HTTP read timeout.
    ///
    /// File-config form uses humantime strings like `"5s"`, `"500ms"`, `"1m"`.
    /// Env overlay still respects `RON_READ_TIMEOUT` / `MACRO_READ_TIMEOUT`
    /// with the same humantime semantics.
    #[serde(default = "default_read_timeout", with = "humantime_serde")]
    pub read_timeout: Duration,

    /// HTTP write timeout.
    #[serde(default = "default_write_timeout", with = "humantime_serde")]
    pub write_timeout: Duration,

    /// HTTP idle timeout.
    #[serde(default = "default_idle_timeout", with = "humantime_serde")]
    pub idle_timeout: Duration,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            http_addr: default_http_addr(),
            metrics_addr: default_metrics_addr(),
            log_level: default_log_level(),
            read_timeout: default_read_timeout(),
            write_timeout: default_write_timeout(),
            idle_timeout: default_idle_timeout(),
        }
    }
}

```

### crates/macronode/src/config/validate.rs
<a id="crates-macronode-src-config-validate-rs"></a>

```rust
//! RO:WHAT — Config validation for Macronode.
//! RO:WHY  — Centralize invariants (ports, timeouts, limits) so we can
//!           evolve them without touching callers.
//! RO:INVARIANTS —
//!   - All durations must be > 0.
//!   - HTTP addr must be a valid SocketAddr (already enforced earlier).

use crate::errors::{Error, Result};

use super::schema::Config;

/// Validate a fully materialized config.
///
/// Returns `Ok(())` if the config is usable, or `Error::Config` with a
/// human-readable message if any invariant is violated.
pub fn validate_config(cfg: &Config) -> Result<()> {
    if cfg.read_timeout.as_millis() == 0 {
        return Err(Error::config("read_timeout must be > 0"));
    }
    if cfg.write_timeout.as_millis() == 0 {
        return Err(Error::config("write_timeout must be > 0"));
    }
    if cfg.idle_timeout.as_millis() == 0 {
        return Err(Error::config("idle_timeout must be > 0"));
    }

    Ok(())
}

```

### crates/macronode/src/errors.rs
<a id="crates-macronode-src-errors-rs"></a>

```rust
//! RO:WHAT — Error type and Result alias for Macronode.
//! RO:WHY  — Keep error plumbing boring and consistent across modules.
//! RO:INVARIANTS —
//!   - All fallible public fns in this crate return `errors::Result<T>`.
//!   - Config parsing collapses to `Error::Config` with human-readable messages.

use thiserror::Error;

/// Crate-local Result alias.
pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, Error)]
pub enum Error {
    /// Configuration issues (env/file/cli overlays).
    #[error("config error: {0}")]
    Config(String),

    /// I/O errors (sockets, files, etc.).
    #[error(transparent)]
    Io(#[from] std::io::Error),

    /// JSON serialization / formatting issues.
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),

    /// Catch-all for higher level composition until we tighten types.
    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

impl Error {
    pub fn config<S: Into<String>>(msg: S) -> Self {
        Error::Config(msg.into())
    }
}

```

### crates/macronode/src/facets/mod.rs
<a id="crates-macronode-src-facets-mod-rs"></a>

```rust

```

### crates/macronode/src/facets/permits.rs
<a id="crates-macronode-src-facets-permits-rs"></a>

```rust

```

### crates/macronode/src/facets/quotas.rs
<a id="crates-macronode-src-facets-quotas-rs"></a>

```rust

```

### crates/macronode/src/http_admin/handlers/healthz.rs
<a id="crates-macronode-src-httpadmin-handlers-healthz-rs"></a>

```rust
//! RO:WHAT — `/healthz` liveness handler.
//! RO:WHY  — Simple "is the process alive" probe.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct Checks<'a> {
    event_loop: &'a str,
    clock: &'a str,
}

#[derive(Serialize)]
struct HealthBody<'a> {
    ok: bool,
    checks: Checks<'a>,
}

pub async fn handler() -> impl IntoResponse {
    let checks = Checks {
        event_loop: "ok",
        clock: "ok",
    };

    Json(HealthBody { ok: true, checks })
}

```

### crates/macronode/src/http_admin/handlers/metrics.rs
<a id="crates-macronode-src-httpadmin-handlers-metrics-rs"></a>

```rust
//! RO:WHAT — `/metrics` handler (Prometheus text).
//! RO:WHY  — Single scrape surface for admin metrics.

use crate::observability::metrics::encode_prometheus;
use axum::{http::StatusCode, response::IntoResponse};

pub async fn handler() -> impl IntoResponse {
    let body = encode_prometheus();
    (StatusCode::OK, body)
}

```

### crates/macronode/src/http_admin/handlers/mod.rs
<a id="crates-macronode-src-httpadmin-handlers-mod-rs"></a>

```rust
//! RO:WHAT — Admin HTTP handlers for Macronode.

pub mod healthz;
pub mod metrics;
pub mod reload;
pub mod shutdown;
pub mod status;
pub mod version;

```

### crates/macronode/src/http_admin/handlers/readyz.rs
<a id="crates-macronode-src-httpadmin-handlers-readyz-rs"></a>

```rust
//! RO:WHAT — Axum adapter for `/readyz`.
//! RO:WHY  — Delegate to `readiness::handler` with shared probes.

use std::sync::Arc;

use axum::response::IntoResponse;

use crate::readiness::{self, ReadyProbes};

pub async fn handler(probes: Arc<ReadyProbes>) -> impl IntoResponse {
    readiness::handler(probes).await
}

```

### crates/macronode/src/http_admin/handlers/reload.rs
<a id="crates-macronode-src-httpadmin-handlers-reload-rs"></a>

```rust
//! RO:WHAT — `/api/v1/reload` handler.
//! RO:WHY  — Trigger config hot reload (stub v1).
//!
//! RO:INVARIANTS —
//!   - Must run under admin auth middleware.
//!   - Uses `config::hot_reload()` (stub for now).
//!   - Async safe; returns 202 Accepted for symmetry with shutdown.

use axum::{response::IntoResponse, Json};
use serde::Serialize;
use tracing::info;

use crate::{config, types::AppState};

#[derive(Serialize)]
struct ReloadResp {
    status: &'static str,
}

pub async fn handler(
    axum::extract::State(state): axum::extract::State<AppState>,
) -> impl IntoResponse {
    info!("macronode admin: reload requested");

    // Call into our stub for now — later will reload config + emit events
    if let Err(e) = config::hot_reload(&state.cfg) {
        info!("macronode admin: reload failed: {e}");
    }

    Json(ReloadResp {
        status: "reload triggered",
    })
}

```

### crates/macronode/src/http_admin/handlers/shutdown.rs
<a id="crates-macronode-src-httpadmin-handlers-shutdown-rs"></a>

```rust
//! RO:WHAT — `/api/v1/shutdown` handler.
//! RO:WHY  — Allow operators to trigger a controlled process exit via HTTP.
//!           MVP: respond 202, then exit the process after a short delay so
//!           callers see a clean response before shutdown completes.

use std::time::Duration;

use axum::{http::StatusCode, response::IntoResponse, Json};
use serde::Serialize;
use tokio::time::sleep;
use tracing::info;

#[derive(Serialize)]
struct ShutdownBody<'a> {
    status: &'a str,
    delay_ms: u64,
}

/// POST `/api/v1/shutdown`
///
/// Semantics (MVP):
/// - Immediately returns `202 Accepted` with a small JSON payload.
/// - In the background, waits for a short delay and then calls `std::process::exit(0)`.
/// - This is a coarse, process-wide shutdown; we will replace this with
///   proper supervisor-driven graceful shutdown in a later pass.
pub async fn handler() -> impl IntoResponse {
    let delay_ms: u64 = 500;

    // Fire-and-forget task that will terminate the process shortly after
    // the HTTP response has been sent.
    tokio::spawn(async move {
        info!(
            "macronode admin: /api/v1/shutdown requested; exiting in {} ms",
            delay_ms
        );
        sleep(Duration::from_millis(delay_ms)).await;

        // NOTE: This is intentionally blunt for the first pass. A later
        // revision will coordinate shutdown through the supervisor so
        // services can drain gracefully.
        std::process::exit(0);
    });

    (
        StatusCode::ACCEPTED,
        Json(ShutdownBody {
            status: "shutdown scheduled",
            delay_ms,
        }),
    )
}

```

### crates/macronode/src/http_admin/handlers/status.rs
<a id="crates-macronode-src-httpadmin-handlers-status-rs"></a>

```rust
//! RO:WHAT — `/api/v1/status` handler.
//! RO:WHY  — Give operators a basic runtime + readiness + service snapshot
//!           in one call.
//!
//! RO:INTERACTS —
//!   - Uses `AppState` for config + probes + start time.
//!   - Reuses the same readiness logic as `/readyz` via `ReadyProbes::snapshot()`.
//!
//! RO:INVARIANTS —
//!   - `ready` field matches the `required_ready()` gate used by `/readyz`.
//!   - `deps` mirrors the `/readyz` dependency labels (config/network/gateway/storage).
//!   - `services` is a low-cardinality map of core services macronode supervises.
//!   - No blocking I/O; cheap and safe to call frequently.

use std::{collections::BTreeMap, time::Instant};

use axum::{response::IntoResponse, Json};
use serde::Serialize;

use crate::types::AppState;

#[derive(Serialize)]
struct StatusDeps {
    config: &'static str,
    network: &'static str,
    gateway: &'static str,
    storage: &'static str,
}

#[derive(Serialize)]
struct StatusBody {
    /// Seconds since this macronode process started.
    uptime_seconds: u64,
    /// Profile name for this node (always "macronode" for this crate).
    profile: &'static str,
    /// Admin HTTP bind address (where `/healthz`/`/readyz`/`/metrics` live).
    http_addr: String,
    /// Metrics bind address (currently shares the admin listener, but kept
    /// separate at the config level for future slices).
    metrics_addr: String,
    /// Effective log level for this process.
    log_level: String,
    /// Whether the node considers itself "ready" according to the same
    /// gates used by `/readyz`.
    ready: bool,
    /// Per-dependency status, mirroring `/readyz`.
    deps: StatusDeps,
    /// Per-service summary (stubbed for now for non-gateway services).
    ///
    /// Keys:
    ///   - "svc-gateway"
    ///   - "svc-storage"
    ///   - "svc-index"
    ///   - "svc-mailbox"
    ///   - "svc-overlay"
    ///   - "svc-dht"
    ///
    /// Values are simple strings for now:
    ///   - "ok"      — service is bound and reported healthy.
    ///   - "pending" — service has not yet met its readiness condition.
    ///   - "stub"    — service is a placeholder worker without real health.
    services: BTreeMap<String, String>,
}

pub async fn handler(state: axum::extract::State<AppState>) -> impl IntoResponse {
    let AppState {
        cfg,
        probes,
        started_at,
        ..
    } = state.0;

    let uptime = Instant::now()
        .saturating_duration_since(started_at)
        .as_secs();

    let snap = probes.snapshot();
    let ready = snap.required_ready();

    let deps = StatusDeps {
        config: if snap.cfg_loaded { "loaded" } else { "pending" },
        network: if snap.listeners_bound {
            "ok"
        } else {
            "pending"
        },
        gateway: if snap.gateway_bound { "ok" } else { "pending" },
        storage: if snap.deps_ok { "ok" } else { "pending" },
    };

    // For now, only `svc-gateway` has a real bound listener that we can
    // reflect directly. The rest are stub workers, but we still expose
    // them so operators see the intended composition.
    let mut services = BTreeMap::new();

    services.insert(
        "svc-gateway".to_string(),
        if snap.gateway_bound { "ok" } else { "pending" }.to_string(),
    );
    services.insert("svc-storage".to_string(), "stub".to_string());
    services.insert("svc-index".to_string(), "stub".to_string());
    services.insert("svc-mailbox".to_string(), "stub".to_string());
    services.insert("svc-overlay".to_string(), "stub".to_string());
    services.insert("svc-dht".to_string(), "stub".to_string());

    Json(StatusBody {
        uptime_seconds: uptime,
        profile: "macronode",
        http_addr: cfg.http_addr.to_string(),
        metrics_addr: cfg.metrics_addr.to_string(),
        log_level: cfg.log_level.clone(),
        ready,
        deps,
        services,
    })
}

```

### crates/macronode/src/http_admin/handlers/version.rs
<a id="crates-macronode-src-httpadmin-handlers-version-rs"></a>

```rust
//! RO:WHAT — `/version` handler for Macronode.
//! RO:WHY  — Provide build provenance and HTTP API version.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

use crate::types::BuildInfo;

#[derive(Serialize)]
struct ApiInfo<'a> {
    http: &'a str,
}

#[derive(Serialize)]
struct VersionBody<'a> {
    service: &'a str,
    version: &'a str,
    git_sha: &'a str,
    build_ts: &'a str,
    rustc: &'a str,
    msrv: &'a str,
    api: ApiInfo<'a>,
}

pub async fn handler() -> impl IntoResponse {
    let info = BuildInfo::current();

    let body = VersionBody {
        service: info.service,
        version: info.version,
        git_sha: info.git_sha,
        build_ts: info.build_ts,
        rustc: info.rustc,
        msrv: info.msrv,
        api: ApiInfo { http: "v1" },
    };

    Json(body)
}

```

### crates/macronode/src/http_admin/middleware/auth.rs
<a id="crates-macronode-src-httpadmin-middleware-auth-rs"></a>

```rust
//! RO:WHAT — Admin auth middleware.
//! RO:WHY  — Guard sensitive POST endpoints (`/api/v1/shutdown`, `/api/v1/reload`).
//!
//! RO:INVARIANTS —
//!   - If `RON_ADMIN_TOKEN` is set, sensitive endpoints require
//!     `Authorization: Bearer <token>`.
//!   - If bound to loopback AND no token is set, we ALLOW but WARN.
//!   - If bound to NON-loopback AND no token is set, we BLOCK unless
//!     `MACRONODE_DEV_INSECURE=1`.
//!   - `MACRONODE_DEV_INSECURE=1` bypasses everything (dev ergonomics).

use axum::{
    body::Body,
    http::{header::AUTHORIZATION, Method, Request, StatusCode},
    middleware::Next,
    response::Response,
};
use std::net::IpAddr;
use tracing::{info, warn};

pub async fn layer(req: Request<Body>, next: Next) -> Result<Response, StatusCode> {
    // Only guard POST /shutdown & POST /reload
    let method = req.method().clone();
    let path = req.uri().path().to_string();

    let needs_guard =
        method == Method::POST && (path == "/api/v1/shutdown" || path == "/api/v1/reload");

    if !needs_guard {
        return Ok(next.run(req).await);
    }

    // Explicit dev bypass
    if dev_insecure() {
        warn!("MACRONODE_DEV_INSECURE=1 — bypassing admin auth for {method} {path}");
        return Ok(next.run(req).await);
    }

    // Determine if the admin listener is loopback-only
    let is_loopback = match req.headers().get("host").and_then(|h| h.to_str().ok()) {
        Some(host) => host
            .parse::<IpAddr>()
            .map(|ip| ip.is_loopback())
            .unwrap_or(true),
        None => true,
    };

    // Determine token
    let expected_token = std::env::var("RON_ADMIN_TOKEN")
        .ok()
        .filter(|t| !t.is_empty());

    match expected_token {
        Some(expected) => {
            // Token required — validate header
            let auth_header = req
                .headers()
                .get(AUTHORIZATION)
                .and_then(|h| h.to_str().ok());

            let ok = auth_header
                .and_then(|v| v.strip_prefix("Bearer "))
                .map(|v| v == expected)
                .unwrap_or(false);

            if !ok {
                warn!("unauthorized {method} {path} — missing/invalid token");
                return Err(StatusCode::UNAUTHORIZED);
            }

            info!("authorized admin {method} {path}");
            Ok(next.run(req).await)
        }

        None => {
            // No token set
            if is_loopback {
                warn!("RON_ADMIN_TOKEN is not set — allowing admin action on loopback {method} {path}");
                Ok(next.run(req).await)
            } else {
                warn!("BLOCKED admin action — RON_ADMIN_TOKEN missing + non-loopback bind {method} {path}");
                Err(StatusCode::UNAUTHORIZED)
            }
        }
    }
}

fn dev_insecure() -> bool {
    matches!(
        std::env::var("MACRONODE_DEV_INSECURE").as_deref(),
        Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
    )
}

```

### crates/macronode/src/http_admin/middleware/mod.rs
<a id="crates-macronode-src-httpadmin-middleware-mod-rs"></a>

```rust
//! RO:WHAT — Admin HTTP middleware for Macronode.
//! RO:WHY  — Cross-cutting behaviors around the admin router.
//!
//! RO:INVARIANTS —
//!   - Middlewares are pure functions over `Request<Body>` and `Next`.
//!   - No panics on malformed headers; we fail closed where appropriate.
//!   - Admin auth is opt-in via `RON_ADMIN_TOKEN` but loudly logs when unset.

pub mod auth;
pub mod rate_limit;
pub mod request_id;
pub mod timeout;

```

### crates/macronode/src/http_admin/middleware/rate_limit.rs
<a id="crates-macronode-src-httpadmin-middleware-ratelimit-rs"></a>

```rust
//! RO:WHAT — Rate limiting middleware (placeholder).
//! RO:WHY  — Anchor point for future per-endpoint throttling.
//!
//! RO:INVARIANTS —
//!   - Currently a no-op pass-through.
//!   - Safe to extend later with token buckets / IP-based limits.

use axum::{
    body::Body,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};

pub async fn layer(req: Request<Body>, next: Next) -> Result<Response, StatusCode> {
    // TODO: Implement per-endpoint/IP rate limiting once we have config knobs.
    Ok(next.run(req).await)
}

```

### crates/macronode/src/http_admin/middleware/request_id.rs
<a id="crates-macronode-src-httpadmin-middleware-requestid-rs"></a>

```rust
//! RO:WHAT — X-Request-Id middleware.
//! RO:WHY  — Give every request/response a stable request ID for tracing.
//!
//! RO:INVARIANTS —
//!   - If the client sends `x-request-id`, we preserve it.
//!   - Otherwise we generate a simple process-unique ID.

use std::time::{SystemTime, UNIX_EPOCH};

use axum::{
    body::Body,
    http::{header::HeaderName, HeaderValue, Request, StatusCode},
    middleware::Next,
    response::Response,
};
use tracing::trace;

const X_REQUEST_ID: &str = "x-request-id";

pub async fn layer(mut req: Request<Body>, next: Next) -> Result<Response, StatusCode> {
    let header_name = HeaderName::from_static(X_REQUEST_ID);

    // If there is no request-id, generate one and attach it to the request.
    if !req.headers().contains_key(&header_name) {
        let id = gen_request_id();
        if let Ok(v) = HeaderValue::from_str(&id) {
            req.headers_mut().insert(&header_name, v);
        }
    }

    // Grab an OWNED copy of the request-id for logging and response echo.
    let id_for_log: String = req
        .headers()
        .get(&header_name)
        .and_then(|v| v.to_str().ok())
        .map(|s| s.to_string())
        .unwrap_or_else(|| "<missing>".to_string());

    trace!(request_id = %id_for_log, "macronode admin: handling request");

    // Move the request into the next layer/handler.
    let mut res = next.run(req).await;

    // Echo the request-id back on the response if not already set.
    if !res.headers().contains_key(&header_name) {
        if let Ok(v) = HeaderValue::from_str(&id_for_log) {
            res.headers_mut().insert(&header_name, v);
        }
    }

    Ok(res)
}

fn gen_request_id() -> String {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default();
    // Not cryptographically strong — just unique-ish for tracing.
    format!("macronode-{}", now.as_nanos())
}

```

### crates/macronode/src/http_admin/middleware/timeout.rs
<a id="crates-macronode-src-httpadmin-middleware-timeout-rs"></a>

```rust
//! RO:WHAT — Simple per-request timeout middleware.
//! RO:WHY  — Prevent hung /admin calls from blocking probes forever.
//!
//! RO:INVARIANTS —
//!   - Uses a conservative fixed timeout for now.
//!   - Returns `504 Gateway Timeout` on expiry.

use std::time::Duration;

use axum::{
    body::Body,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use tokio::time::timeout;
use tracing::warn;

// For now this is a static admin timeout. We can later wire this to
// `Config` (e.g., `admin_timeout`) if we want it to be configurable.
const ADMIN_TIMEOUT: Duration = Duration::from_secs(10);

pub async fn layer(req: Request<Body>, next: Next) -> Result<Response, StatusCode> {
    match timeout(ADMIN_TIMEOUT, next.run(req)).await {
        Ok(resp) => Ok(resp),
        Err(_) => {
            warn!(
                "macronode admin: request timed out after {:?}",
                ADMIN_TIMEOUT
            );
            Err(StatusCode::GATEWAY_TIMEOUT)
        }
    }
}

```

### crates/macronode/src/http_admin/mod.rs
<a id="crates-macronode-src-httpadmin-mod-rs"></a>

```rust
//! RO:WHAT — HTTP admin/observability plane for Macronode.
//! RO:WHY  — Expose `/version`, `/healthz`, `/readyz`, `/metrics`, and basic admin APIs.
//! RO:INTERACTS —
//!   - `AppState` for config + probes.
//!   - `observability::metrics` for Prometheus encoding.

pub mod handlers;
pub mod middleware;
pub mod router;

```

### crates/macronode/src/http_admin/router.rs
<a id="crates-macronode-src-httpadmin-router-rs"></a>

```rust
//! RO:WHAT — Router builder for Macronode admin plane.

use std::sync::Arc;

use axum::{
    middleware::from_fn,
    routing::{get, post},
    Router,
};

use crate::{
    http_admin::middleware::{auth, rate_limit, request_id, timeout},
    readiness::{self, ReadyProbes},
    types::AppState,
};

pub fn build_router(state: AppState) -> Router {
    let probes: Arc<ReadyProbes> = state.probes.clone();

    let base = Router::new()
        .route(
            "/version",
            get(crate::http_admin::handlers::version::handler),
        )
        .route(
            "/healthz",
            get(crate::http_admin::handlers::healthz::handler),
        )
        .route(
            "/readyz",
            get(move || {
                let probes = probes.clone();
                readiness::handler(probes)
            }),
        )
        .route(
            "/metrics",
            get(crate::http_admin::handlers::metrics::handler),
        )
        .route(
            "/api/v1/status",
            get(crate::http_admin::handlers::status::handler),
        )
        .route(
            "/api/v1/reload",
            post(crate::http_admin::handlers::reload::handler),
        )
        .route(
            "/api/v1/shutdown",
            post(crate::http_admin::handlers::shutdown::handler),
        )
        .with_state(state);

    // Middleware stack:
    base.layer(from_fn(rate_limit::layer))
        .layer(from_fn(auth::layer)) // only applies to guarded paths
        .layer(from_fn(timeout::layer))
        .layer(from_fn(request_id::layer))
}

```

### crates/macronode/src/main.rs
<a id="crates-macronode-src-main-rs"></a>

```rust
//! RO:WHAT — Binary entrypoint for Macronode.
//! RO:WHY  — Wire config, logging, readiness, admin HTTP plane, and supervisor.
//! RO:INVARIANTS —
//!   - No public Rust API (binary-only crate).
//!   - Admin HTTP is truthful by default; dev overrides are explicit.

#![forbid(unsafe_code)]

mod cli;
mod config;
mod errors;
mod http_admin;
mod observability;
mod readiness;
mod services;
mod supervisor;
mod types;

use crate::errors::Result;

#[tokio::main]
async fn main() -> Result<()> {
    cli::entrypoint().await
}

```

### crates/macronode/src/observability/logging.rs
<a id="crates-macronode-src-observability-logging-rs"></a>

```rust
//! RO:WHAT — Tracing subscriber initialization for Macronode.
//! RO:WHY  — Deterministic logs with env filter and JSON-friendly format.

use tracing_subscriber::{fmt, EnvFilter};

pub fn init(log_level: &str) {
    let default = format!("macronode={log_level},info");
    let filter = std::env::var("RUST_LOG").unwrap_or(default);

    let _ = fmt().with_env_filter(EnvFilter::new(filter)).try_init();
}

```

### crates/macronode/src/observability/metrics.rs
<a id="crates-macronode-src-observability-metrics-rs"></a>

```rust
//! RO:WHAT — Metrics plumbing for Macronode (stub v1).
//! RO:WHY  — Keep a home for Prometheus registration and HTTP-layer metrics.
//! RO:INVARIANTS —
//!   - Module exists so tests can evolve without touching the rest of the app.
//!   - Metric families are all registered against the default Prometheus registry.

use prometheus::{Encoder, TextEncoder};

/// Encode all registered metrics in Prometheus text format.
///
/// This is intentionally minimal for the first pass; we will wire
/// HTTP-layer counters/histograms in a follow-up.
pub fn encode_prometheus() -> String {
    let metric_families = prometheus::gather();
    let encoder = TextEncoder::new();
    let mut buf = Vec::new();
    if let Err(err) = encoder.encode(&metric_families, &mut buf) {
        eprintln!("[macronode-metrics] encode error: {err}");
        return String::new();
    }

    String::from_utf8(buf).unwrap_or_default()
}

```

### crates/macronode/src/observability/mod.rs
<a id="crates-macronode-src-observability-mod-rs"></a>

```rust
//! RO:WHAT — Observability surfaces for Macronode.
//! RO:WHY  — Keep main/bootstrap clean; centralize logging/metrics wiring.
//! RO:INVARIANTS —
//!   - Logging is initialized exactly once per process.
//!   - Metrics module is present (even if initially a stub) so `/metrics` works.

pub mod logging;
pub mod metrics;

```

### crates/macronode/src/pq/hybrid.rs
<a id="crates-macronode-src-pq-hybrid-rs"></a>

```rust

```

### crates/macronode/src/pq/mod.rs
<a id="crates-macronode-src-pq-mod-rs"></a>

```rust

```

### crates/macronode/src/readiness/deps.rs
<a id="crates-macronode-src-readiness-deps-rs"></a>

```rust

```

### crates/macronode/src/readiness/mod.rs
<a id="crates-macronode-src-readiness-mod-rs"></a>

```rust
//! RO:WHAT — Readiness probes and `/readyz` handler for Macronode.
//! RO:WHY  — Truthful readiness for orchestration (K8s/systemd/CI).
//! RO:INVARIANTS —
//!   - Required gates: listeners_bound && cfg_loaded && gateway_bound && deps_ok.
//!   - Optional probes: metrics_bound.
//!   - Dev override: MACRONODE_DEV_READY=1 forces ready=true.

use axum::{
    http::{HeaderMap, HeaderValue, StatusCode},
    response::IntoResponse,
    Json,
};
use serde::Serialize;
use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};

#[derive(Debug)]
pub struct ReadyProbes {
    listeners_bound: AtomicBool,
    cfg_loaded: AtomicBool,
    metrics_bound: AtomicBool,
    deps_ok: AtomicBool,
    gateway_bound: AtomicBool,
}

impl ReadyProbes {
    pub fn new() -> Self {
        Self {
            listeners_bound: AtomicBool::new(false),
            cfg_loaded: AtomicBool::new(false),
            metrics_bound: AtomicBool::new(false),
            deps_ok: AtomicBool::new(false),
            gateway_bound: AtomicBool::new(false),
        }
    }

    pub fn set_listeners_bound(&self, v: bool) {
        self.listeners_bound.store(v, Ordering::Release);
    }

    pub fn set_cfg_loaded(&self, v: bool) {
        self.cfg_loaded.store(v, Ordering::Release);
    }

    pub fn set_metrics_bound(&self, v: bool) {
        self.metrics_bound.store(v, Ordering::Release);
    }

    pub fn set_deps_ok(&self, v: bool) {
        self.deps_ok.store(v, Ordering::Release);
    }

    pub fn set_gateway_bound(&self, v: bool) {
        self.gateway_bound.store(v, Ordering::Release);
    }

    pub fn snapshot(&self) -> ReadySnapshot {
        ReadySnapshot {
            listeners_bound: self.listeners_bound.load(Ordering::Acquire),
            cfg_loaded: self.cfg_loaded.load(Ordering::Acquire),
            metrics_bound: self.metrics_bound.load(Ordering::Acquire),
            deps_ok: self.deps_ok.load(Ordering::Acquire),
            gateway_bound: self.gateway_bound.load(Ordering::Acquire),
        }
    }
}

impl Default for ReadyProbes {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct ReadySnapshot {
    pub listeners_bound: bool,
    pub cfg_loaded: bool,
    pub metrics_bound: bool,
    pub deps_ok: bool,
    pub gateway_bound: bool,
}

impl ReadySnapshot {
    pub fn required_ready(&self) -> bool {
        self.listeners_bound && self.cfg_loaded && self.deps_ok && self.gateway_bound
    }
}

#[derive(Serialize)]
struct ReadyDeps<'a> {
    config: &'a str,
    network: &'a str,
    gateway: &'a str,
    storage: &'a str,
}

#[derive(Serialize)]
struct ReadyBody<'a> {
    ready: bool,
    deps: ReadyDeps<'a>,
    mode: &'a str,
}

pub async fn handler(probes: Arc<ReadyProbes>) -> impl IntoResponse {
    // dev override
    if matches!(
        std::env::var("MACRONODE_DEV_READY").as_deref(),
        Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
    ) {
        let snap = probes.snapshot();

        let deps = ReadyDeps {
            config: if snap.cfg_loaded { "loaded" } else { "pending" },
            network: if snap.listeners_bound {
                "ok"
            } else {
                "pending"
            },
            gateway: if snap.gateway_bound { "ok" } else { "pending" },
            storage: if snap.deps_ok { "ok" } else { "pending" },
        };

        let body = ReadyBody {
            ready: true,
            deps,
            mode: "dev-forced",
        };

        return (StatusCode::OK, Json(body)).into_response();
    }

    let snap = probes.snapshot();
    let ok = snap.required_ready();

    let deps = ReadyDeps {
        config: if snap.cfg_loaded { "loaded" } else { "pending" },
        network: if snap.listeners_bound {
            "ok"
        } else {
            "pending"
        },
        gateway: if snap.gateway_bound { "ok" } else { "pending" },
        storage: if snap.deps_ok { "ok" } else { "pending" },
    };

    let mut headers = HeaderMap::new();
    if !ok {
        headers.insert("Retry-After", HeaderValue::from_static("5"));
    }

    let body = ReadyBody {
        ready: ok,
        deps,
        mode: "truthful",
    };

    let status = if ok {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };

    (status, headers, Json(body)).into_response()
}

```

### crates/macronode/src/security/amnesia.rs
<a id="crates-macronode-src-security-amnesia-rs"></a>

```rust
//! RO:WHAT — Amnesia posture helpers for Macronode.
//! RO:WHY  — Provide a single source of truth for how "amnesia mode" is
//!           interpreted so config / CLI / services stay consistent.
//! RO:INVARIANTS —
//!   - `Persistent` is the default for Macronode (unlike Micronode).
//!   - `Amnesic` is a best-effort "RAM-first, no durable residue" posture.

#![allow(dead_code)]

/// High-level amnesia posture for this process.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AmnesiaMode {
    /// Normal mode: services are allowed to persist state to disk.
    Persistent,
    /// Best-effort amnesia: avoid durable state, prefer RAM-only caches.
    Amnesic,
}

impl AmnesiaMode {
    /// Returns true if the node should avoid writing persistent state.
    #[must_use]
    pub const fn is_amnesic(self) -> bool {
        matches!(self, AmnesiaMode::Amnesic)
    }
}

/// Classify the mode from a simple boolean flag (e.g. config/CLI/env).
///
/// This keeps the rest of the code from re-encoding the boolean semantics
/// in multiple places.
#[must_use]
pub fn classify_amnesia(enabled: bool) -> AmnesiaMode {
    if enabled {
        AmnesiaMode::Amnesic
    } else {
        AmnesiaMode::Persistent
    }
}

```

### crates/macronode/src/security/macaroon.rs
<a id="crates-macronode-src-security-macaroon-rs"></a>

```rust
//! RO:WHAT — Opaque capability-token wrapper for Macronode.
//! RO:WHY  — Macronode itself does not parse or verify macaroons/JWTs;
//!           it just treats them as opaque bearer tokens that downstream
//!           services (KMS/auth) can validate.
//! RO:INVARIANTS —
//!   - This module never logs token contents.
//!   - Parsing is intentionally minimal: higher layers decide semantics.

#![allow(dead_code)]

/// Opaque capability or macaroon-style token.
///
/// In this crate we treat the token as an opaque string. Verification and
/// interpretation belong to dedicated auth/KMS services.
#[derive(Debug, Clone)]
pub struct CapabilityToken {
    raw: String,
}

impl CapabilityToken {
    /// Construct a token from a raw bearer string (without the "Bearer " prefix).
    #[must_use]
    pub fn new<S: Into<String>>(raw: S) -> Self {
        Self { raw: raw.into() }
    }

    /// View the underlying token bytes.
    #[must_use]
    pub fn as_str(&self) -> &str {
        &self.raw
    }
}

/// Parse a `Authorization` header value into a bearer token, if present.
///
/// This is intentionally tiny and does not validate the token format.
#[must_use]
pub fn parse_bearer_header(header: &str) -> Option<CapabilityToken> {
    // Common forms:
    //   "Bearer abc123"
    //   "bearer abc123"
    let trimmed = header.trim();
    let prefix_lower = "bearer ";

    if trimmed.len() <= prefix_lower.len() {
        return None;
    }

    if trimmed.to_ascii_lowercase().starts_with(prefix_lower) {
        let token = &trimmed[prefix_lower.len()..];
        if token.is_empty() {
            None
        } else {
            Some(CapabilityToken::new(token))
        }
    } else {
        None
    }
}

```

### crates/macronode/src/security/mod.rs
<a id="crates-macronode-src-security-mod-rs"></a>

```rust
//! RO:WHAT — Security utilities for Macronode.
//! RO:WHY  — Central home for amnesia posture, TLS options, and capability
//!           token helpers. This keeps security-related logic coherent and
//!           discoverable without bloating `main` or HTTP modules.
//! RO:INVARIANTS —
//!   - This module is pure helper surface; it does not perform I/O by itself.
//!   - Higher layers remain responsible for actually enforcing policies.

#![allow(dead_code)]

pub(crate) mod amnesia;
pub(crate) mod macaroon;
pub(crate) mod tls;

pub(crate) use amnesia::{classify_amnesia, AmnesiaMode};
pub(crate) use tls::{TlsConfig, TlsMode};

```

### crates/macronode/src/security/tls.rs
<a id="crates-macronode-src-security-tls-rs"></a>

```rust
//! RO:WHAT — TLS configuration helpers for Macronode.
//! RO:WHY  — Provide a small, self-contained representation of TLS posture
//!           so admin/gateway planes can be upgraded to TLS without each
//!           caller reinventing config parsing logic.
//! RO:INVARIANTS —
//!   - This module does **not** perform any I/O by itself.
//!   - The actual listener binding and rustls integration live elsewhere.

#![allow(dead_code)]

use std::path::{Path, PathBuf};

/// TLS mode for a given listener.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TlsMode {
    /// TLS is disabled; listener uses plain TCP.
    Disabled,
    /// TLS is enabled with a certificate/key pair.
    Enabled,
}

/// High-level TLS configuration for a listener.
#[derive(Debug, Clone)]
pub struct TlsConfig {
    mode: TlsMode,
    cert_path: Option<PathBuf>,
    key_path: Option<PathBuf>,
}

impl TlsConfig {
    /// Construct a disabled TLS configuration.
    #[must_use]
    pub const fn disabled() -> Self {
        Self {
            mode: TlsMode::Disabled,
            cert_path: None,
            key_path: None,
        }
    }

    /// Construct an enabled TLS configuration with the given paths.
    #[must_use]
    pub fn enabled(cert_path: PathBuf, key_path: PathBuf) -> Self {
        Self {
            mode: TlsMode::Enabled,
            cert_path: Some(cert_path),
            key_path: Some(key_path),
        }
    }

    /// Returns true if TLS is enabled.
    #[must_use]
    pub const fn is_enabled(&self) -> bool {
        matches!(self.mode, TlsMode::Enabled)
    }

    /// Accessor for the certificate path, if any.
    #[must_use]
    pub fn cert_path(&self) -> Option<&Path> {
        self.cert_path.as_deref()
    }

    /// Accessor for the private key path, if any.
    #[must_use]
    pub fn key_path(&self) -> Option<&Path> {
        self.key_path.as_deref()
    }
}

```

### crates/macronode/src/services/mod.rs
<a id="crates-macronode-src-services-mod-rs"></a>

```rust
//! RO:WHAT — Macronode managed services surface.
//! RO:WHY  — Single place to define which internal services (gateway, overlay,
//!           storage, index, mailbox, dht, etc.) this node composes.
//! RO:INVARIANTS —
//!   - Slice 1 only exposes `spawn_all()` and per-service stubs.
//!   - Future slices will add real service wiring and health reporting.

pub mod spawn;
pub mod svc_dht;
pub mod svc_gateway;
pub mod svc_index;
pub mod svc_mailbox;
pub mod svc_overlay;
pub mod svc_storage;

pub use spawn::spawn_all;

```

### crates/macronode/src/services/registry.rs
<a id="crates-macronode-src-services-registry-rs"></a>

```rust
//! RO:WHAT — In-memory registry of Macronode managed services.
//! RO:WHY  — Give `/api/v1/status` and the supervisor a shared place to
//!           track which services exist and their coarse health.
//! RO:INVARIANTS —
//!   - Registry is in-memory only; macronode owns no persistent data.
//!   - Service names are small static strings; no user input here.

#![allow(dead_code)]

use std::collections::BTreeMap;

/// Coarse status for a composed service.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ServiceStatus {
    /// Present but not yet doing real work (today's stubs).
    Stub,
    /// In the process of starting up.
    Starting,
    /// Fully running and healthy.
    Running,
    /// In the process of draining for shutdown.
    Draining,
    /// Failed permanently; requires operator intervention.
    Failed,
}

/// Simple registry mapping service name → status.
#[derive(Debug, Default)]
pub struct ServiceRegistry {
    inner: BTreeMap<&'static str, ServiceStatus>,
}

impl ServiceRegistry {
    /// Update the status for a named service.
    pub fn set_status(&mut self, name: &'static str, status: ServiceStatus) {
        self.inner.insert(name, status);
    }

    /// Fetch the status for a named service, if known.
    #[must_use]
    pub fn get_status(&self, name: &'static str) -> Option<ServiceStatus> {
        self.inner.get(name).copied()
    }

    /// Take a snapshot of all service statuses for serialization or logging.
    #[must_use]
    pub fn snapshot(&self) -> BTreeMap<&'static str, ServiceStatus> {
        self.inner.clone()
    }
}

```

### crates/macronode/src/services/spawn.rs
<a id="crates-macronode-src-services-spawn-rs"></a>

```rust
//! RO:WHAT — Service startup wiring for Macronode.
//! RO:WHY  — Centralized place to start all internal services.

use std::sync::Arc;

use tracing::info;

use crate::{errors::Result, readiness::ReadyProbes, supervisor::ShutdownToken};

pub async fn spawn_all(probes: Arc<ReadyProbes>, shutdown: ShutdownToken) -> Result<()> {
    info!("macronode supervisor: spawn_all (starting service workers)");

    // Now takes probes so it can mark gateway_bound = true.
    crate::services::svc_gateway::spawn(probes.clone());

    crate::services::svc_overlay::spawn(shutdown.clone());
    crate::services::svc_index::spawn(shutdown.clone());
    crate::services::svc_storage::spawn(shutdown.clone());
    crate::services::svc_mailbox::spawn(shutdown.clone());
    crate::services::svc_dht::spawn(shutdown);

    probes.set_deps_ok(true);

    Ok(())
}

```

### crates/macronode/src/services/svc_dht.rs
<a id="crates-macronode-src-services-svcdht-rs"></a>

```rust
//! RO:WHAT — Macronode stub for svc-dht.
//! RO:WHY  — Reserve a home for DHT / routing table workers.
//! RO:INVARIANTS —
//!   - Worker runs until shutdown is requested via `ShutdownToken`.

use std::time::Duration;

use tokio::time::sleep;
use tracing::info;

use crate::supervisor::ShutdownToken;

pub fn spawn(shutdown: ShutdownToken) {
    tokio::spawn(async move {
        info!("svc-dht: started (stub worker)");
        while !shutdown.is_triggered() {
            sleep(Duration::from_secs(5)).await;
        }
        info!("svc-dht: shutdown requested, exiting worker");
    });
}

```

### crates/macronode/src/services/svc_gateway.rs
<a id="crates-macronode-src-services-svcgateway-rs"></a>

```rust
//! RO:WHAT — Macronode HTTP ingress (svc-gateway MVP).
//! RO:WHY  — Stand up actual ingress listener + mark readiness correctly.

use std::{net::SocketAddr, str::FromStr};

use axum::{response::IntoResponse, routing::get, Json, Router};
use serde::Serialize;
use tokio::net::TcpListener;
use tracing::{error, info};

use crate::readiness::ReadyProbes;
use std::sync::Arc;

#[derive(Debug, Serialize)]
struct PingBody {
    ok: bool,
    service: &'static str,
    profile: &'static str,
}

async fn ping_handler() -> impl IntoResponse {
    Json(PingBody {
        ok: true,
        service: "svc-gateway",
        profile: "macronode",
    })
}

fn resolve_bind_addr() -> SocketAddr {
    const DEFAULT_ADDR: &str = "127.0.0.1:8090";

    if let Ok(raw) = std::env::var("RON_GATEWAY_ADDR") {
        match SocketAddr::from_str(raw.trim()) {
            Ok(addr) => {
                info!("svc-gateway: using RON_GATEWAY_ADDR={addr}");
                return addr;
            }
            Err(err) => {
                error!(
                    "svc-gateway: invalid RON_GATEWAY_ADDR={raw:?}, \
                     falling back to {DEFAULT_ADDR}: {err}"
                );
            }
        }
    }

    SocketAddr::from_str(DEFAULT_ADDR).expect("DEFAULT_ADDR must be a valid SocketAddr")
}

pub fn spawn(probes: Arc<ReadyProbes>) {
    tokio::spawn(async move {
        let addr = resolve_bind_addr();

        let listener = match TcpListener::bind(addr).await {
            Ok(listener) => {
                info!("svc-gateway: listening on {addr}");
                probes.set_gateway_bound(true);
                listener
            }
            Err(err) => {
                error!("svc-gateway: failed to bind to {addr}: {err}");
                return;
            }
        };

        let app = Router::new().route("/ingress/ping", get(ping_handler));

        if let Err(err) = axum::serve(listener, app).await {
            error!("svc-gateway: server error: {err}");
        } else {
            info!("svc-gateway: server exited cleanly");
        }
    });
}

```

### crates/macronode/src/services/svc_index.rs
<a id="crates-macronode-src-services-svcindex-rs"></a>

```rust
//! RO:WHAT — Macronode stub for svc-index.
//! RO:WHY  — Reserve a home for index / naming / lookup services.
//! RO:INVARIANTS —
//!   - Worker runs until shutdown is requested via `ShutdownToken`.

use std::time::Duration;

use tokio::time::sleep;
use tracing::info;

use crate::supervisor::ShutdownToken;

pub fn spawn(shutdown: ShutdownToken) {
    tokio::spawn(async move {
        info!("svc-index: started (stub worker)");
        while !shutdown.is_triggered() {
            sleep(Duration::from_secs(5)).await;
        }
        info!("svc-index: shutdown requested, exiting worker");
    });
}

```

### crates/macronode/src/services/svc_mailbox.rs
<a id="crates-macronode-src-services-svcmailbox-rs"></a>

```rust
//! RO:WHAT — Macronode stub for svc-mailbox.
//! RO:WHY  — Reserve a home for queued message delivery / mailbox semantics.
//! RO:INVARIANTS —
//!   - Worker runs until shutdown is requested via `ShutdownToken`.

use std::time::Duration;

use tokio::time::sleep;
use tracing::info;

use crate::supervisor::ShutdownToken;

pub fn spawn(shutdown: ShutdownToken) {
    tokio::spawn(async move {
        info!("svc-mailbox: started (stub worker)");
        while !shutdown.is_triggered() {
            sleep(Duration::from_secs(5)).await;
        }
        info!("svc-mailbox: shutdown requested, exiting worker");
    });
}

```

### crates/macronode/src/services/svc_overlay.rs
<a id="crates-macronode-src-services-svcoverlay-rs"></a>

```rust
//! RO:WHAT — Macronode stub for svc-overlay.
//! RO:WHY  — Reserve a home for overlay / gossip / connection management.
//! RO:INVARIANTS —
//!   - Worker runs until shutdown is requested via `ShutdownToken`.

use std::time::Duration;

use tokio::time::sleep;
use tracing::info;

use crate::supervisor::ShutdownToken;

pub fn spawn(shutdown: ShutdownToken) {
    tokio::spawn(async move {
        info!("svc-overlay: started (stub worker)");
        while !shutdown.is_triggered() {
            sleep(Duration::from_secs(5)).await;
        }
        info!("svc-overlay: shutdown requested, exiting worker");
    });
}

```

### crates/macronode/src/services/svc_storage.rs
<a id="crates-macronode-src-services-svcstorage-rs"></a>

```rust
//! RO:WHAT — Macronode stub for svc-storage.
//! RO:WHY  — Reserve a home for content-addressed blob storage workers.
//! RO:INVARIANTS —
//!   - Worker runs until shutdown is requested via `ShutdownToken`.

use std::time::Duration;

use tokio::time::sleep;
use tracing::info;

use crate::supervisor::ShutdownToken;

pub fn spawn(shutdown: ShutdownToken) {
    tokio::spawn(async move {
        info!("svc-storage: started (stub worker)");
        while !shutdown.is_triggered() {
            sleep(Duration::from_secs(5)).await;
        }
        info!("svc-storage: shutdown requested, exiting worker");
    });
}

```

### crates/macronode/src/supervisor/backoff.rs
<a id="crates-macronode-src-supervisor-backoff-rs"></a>

```rust
//! RO:WHAT — Exponential backoff helper for service restarts.
//! RO:WHY  — Give the supervisor a small, testable primitive to decide how
//!           long to wait before restarting a crashed worker.
//! RO:INVARIANTS —
//!   - Backoff never panics; it clamps at `max_delay`.

#![allow(dead_code)]

use std::time::Duration;

/// Simple exponential backoff policy.
///
/// This is intentionally small; more elaborate jitter/strategy can be added
/// later without changing call sites.
#[derive(Debug, Clone)]
pub struct Backoff {
    base_delay: Duration,
    max_delay: Duration,
    attempt: u32,
}

impl Backoff {
    /// Construct a new backoff policy with the given base and max delay.
    #[must_use]
    pub fn new(base_delay: Duration, max_delay: Duration) -> Self {
        Self {
            base_delay,
            max_delay,
            attempt: 0,
        }
    }

    /// Reset the attempt counter back to zero.
    pub fn reset(&mut self) {
        self.attempt = 0;
    }

    /// Compute the next delay and increment the attempt counter.
    #[must_use]
    pub fn next_delay(&mut self) -> Duration {
        // 2^attempt * base_delay, clamped at max_delay.
        let factor = 1u64.saturating_shl(self.attempt.min(31) as u32);
        let candidate = self.base_delay.saturating_mul(factor);
        self.attempt = self.attempt.saturating_add(1);
        if candidate > self.max_delay {
            self.max_delay
        } else {
            candidate
        }
    }
}

```

### crates/macronode/src/supervisor/crash_policy.rs
<a id="crates-macronode-src-supervisor-crashpolicy-rs"></a>

```rust
//! RO:WHAT — Crash policy helper for Macronode supervisor.
//! RO:WHY  — Provide a single place to decide whether a given crash history
//!           should result in another restart or giving up on a worker.
//! RO:INVARIANTS —
//!   - Decisions are pure and deterministic.
//!   - The policy never panics on empty or small histories.

#![allow(dead_code)]

use std::time::{Duration, Instant};

/// Result of asking the policy what to do about recent crashes.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CrashDecision {
    /// Supervisor should attempt another restart after the given delay.
    RestartAfter(Duration),
    /// Supervisor should stop restarting this worker.
    GiveUp,
}

/// Crash policy based on "max restarts in a rolling window".
#[derive(Debug, Clone, Copy)]
pub struct CrashPolicy {
    /// Maximum number of restarts allowed within `window` before giving up.
    pub max_restarts: usize,
    /// Rolling time window to consider.
    pub window: Duration,
}

impl CrashPolicy {
    /// Construct a policy with the given limits.
    #[must_use]
    pub const fn new(max_restarts: usize, window: Duration) -> Self {
        Self {
            max_restarts,
            window,
        }
    }

    /// Decide what to do given the timestamps of recent crashes, ordered
    /// from oldest to newest.
    ///
    /// The caller is responsible for trimming the history occasionally;
    /// this function just consumes the slice it is given.
    #[must_use]
    pub fn decide(
        &self,
        now: Instant,
        crash_times: &[Instant],
        backoff_delay: Duration,
    ) -> CrashDecision {
        if crash_times.is_empty() {
            return CrashDecision::RestartAfter(backoff_delay);
        }

        // Count how many crashes are within the rolling window.
        let window_start = now.saturating_duration_since(self.window);
        let recent = crash_times
            .iter()
            .filter(|&&t| t >= window_start)
            .count();

        if recent > self.max_restarts {
            CrashDecision::GiveUp
        } else {
            CrashDecision::RestartAfter(backoff_delay)
        }
    }
}

```

### crates/macronode/src/supervisor/health_reporter.rs
<a id="crates-macronode-src-supervisor-healthreporter-rs"></a>

```rust
//! RO:WHAT — Health reporting helper for Macronode supervisor.
//! RO:WHY  — Provide a small adapter object that can fan supervisor state
//!           into readiness probes or structured status maps.
//! RO:INVARIANTS —
//!   - This module is pure; it does not spawn tasks or own timers.

#![allow(dead_code)]

use std::collections::BTreeMap;

/// High-level status of a logical service.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ServiceHealth {
    Stub,
    Starting,
    Running,
    Draining,
    Failed,
}

impl ServiceHealth {
    #[must_use]
    pub const fn is_healthy(self) -> bool {
        matches!(self, ServiceHealth::Running | ServiceHealth::Draining)
    }
}

/// Aggregated view of service health used for `/api/v1/status`.
#[derive(Debug, Default)]
pub struct HealthSnapshot {
    services: BTreeMap<&'static str, ServiceHealth>,
}

impl HealthSnapshot {
    /// Record or update the health for a named service.
    pub fn set_service(&mut self, name: &'static str, health: ServiceHealth) {
        self.services.insert(name, health);
    }

    /// Immutable view of the underlying map for serialization or logging.
    #[must_use]
    pub fn services(&self) -> &BTreeMap<&'static str, ServiceHealth> {
        &self.services
    }
}

```

### crates/macronode/src/supervisor/lifecycle.rs
<a id="crates-macronode-src-supervisor-lifecycle-rs"></a>

```rust
//! RO:WHAT — Macronode lifecycle states.
//! RO:WHY  — Give supervisor and admin plane a shared vocabulary for the
//!           node's coarse-grained lifecycle (starting, running, draining, stopped).
//! RO:INVARIANTS —
//!   - States form a simple DAG; we do not model every possible edge case.

#![allow(dead_code)]

/// Coarse-grained lifecycle state of the Macronode process.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LifecycleState {
    /// Process is booting, reading config, and binding listeners.
    Starting,
    /// Listeners are up and services are running.
    Running,
    /// Node is draining: rejecting new work and attempting graceful shutdown.
    Draining,
    /// Node has completed shutdown. In practice we usually exit before
    /// exposing this state, but it is useful for tests.
    Stopped,
}

impl LifecycleState {
    /// Returns true if the node should be considered "ready" to serve.
    #[must_use]
    pub const fn is_ready(self) -> bool {
        matches!(self, LifecycleState::Running)
    }

    /// Returns true if the node is in a shutdown path.
    #[must_use]
    pub const fn is_draining(self) -> bool {
        matches!(self, LifecycleState::Draining | LifecycleState::Stopped)
    }
}

```

### crates/macronode/src/supervisor/mod.rs
<a id="crates-macronode-src-supervisor-mod-rs"></a>

```rust
//! RO:WHAT — Process supervisor scaffold for Macronode.
//! RO:WHY  — Central place to coordinate service startup/shutdown.
//! RO:INVARIANTS —
//!   - crash policy + backoff (future slice)
//!   - graceful shutdown orchestration (future slice)
//!   - health reporting to readiness/admin planes (future slice)

mod shutdown;

use std::sync::Arc;

use crate::{errors::Result, readiness::ReadyProbes, services};

pub use shutdown::ShutdownToken;

/// Macronode process supervisor (MVP).
///
/// For now this is a thin wrapper that kicks off service startup. Future
/// revisions will give it:
///   - crash policy + backoff
///   - graceful shutdown orchestration
///   - health reporting to readiness/admin planes.
#[derive(Debug)]
pub struct Supervisor {
    probes: Arc<ReadyProbes>,
    shutdown: ShutdownToken,
}

impl Supervisor {
    /// Construct a new supervisor handle.
    pub fn new(probes: Arc<ReadyProbes>, shutdown: ShutdownToken) -> Self {
        Supervisor { probes, shutdown }
    }

    /// Start all managed services.
    ///
    /// Today this just delegates to `services::spawn_all()`; as we add more
    /// moving parts we will keep this as the single entrypoint for runtime
    /// service wiring.
    pub async fn start(&self) -> Result<()> {
        services::spawn_all(self.probes.clone(), self.shutdown.clone()).await
    }
}

impl Default for Supervisor {
    fn default() -> Self {
        Supervisor {
            probes: Arc::new(ReadyProbes::new()),
            shutdown: ShutdownToken::new(),
        }
    }
}

```

### crates/macronode/src/supervisor/shutdown.rs
<a id="crates-macronode-src-supervisor-shutdown-rs"></a>

```rust
//! RO:WHAT — Simple cooperative shutdown token for Macronode.
//! RO:WHY  — Give the supervisor and services a shared, cheap way to
//!           coordinate graceful shutdown without pulling in extra deps.
//! RO:INVARIANTS —
//!   - `trigger()` is idempotent.
//!   - `is_triggered()` is lock-free and wait-free.

use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};

/// Cheap, cloneable shutdown token.
///
/// This does not provide async notification; workers are expected to
/// periodically call `is_triggered()` inside their own loops.
#[derive(Clone, Debug)]
pub struct ShutdownToken {
    inner: Arc<AtomicBool>,
}

impl ShutdownToken {
    /// Construct a new token in the "not triggered" state.
    pub fn new() -> Self {
        Self {
            inner: Arc::new(AtomicBool::new(false)),
        }
    }

    /// Signal shutdown to all holders of this token.
    pub fn trigger(&self) {
        self.inner.store(true, Ordering::Release);
    }

    /// Check whether shutdown has been requested.
    pub fn is_triggered(&self) -> bool {
        self.inner.load(Ordering::Acquire)
    }
}

impl Default for ShutdownToken {
    fn default() -> Self {
        Self::new()
    }
}

```

### crates/macronode/src/types.rs
<a id="crates-macronode-src-types-rs"></a>

```rust
//! RO:WHAT — Shared runtime types for Macronode.
//! RO:WHY  — Keep main/http modules thin by centralizing state and build info.

use std::{sync::Arc, time::Instant};

use crate::{config::Config, readiness::ReadyProbes};

#[derive(Clone)]
pub struct AppState {
    pub cfg: Arc<Config>,
    pub probes: Arc<ReadyProbes>,
    pub started_at: Instant,
}

/// Build-time info used by `/version`.
///
/// We keep this minimal for now; once a build script is in place
/// we can plumb git SHA, build timestamp, and rustc/msrv versions.
pub struct BuildInfo {
    pub service: &'static str,
    pub version: &'static str,
    pub git_sha: &'static str,
    pub build_ts: &'static str,
    pub rustc: &'static str,
    pub msrv: &'static str,
}

impl BuildInfo {
    pub fn current() -> Self {
        Self {
            service: "macronode",
            version: env!("CARGO_PKG_VERSION"),
            git_sha: "unknown",
            build_ts: "unknown",
            rustc: "unknown",
            msrv: "1.80.0",
        }
    }
}

```

### crates/macronode/src/util/dur.rs
<a id="crates-macronode-src-util-dur-rs"></a>

```rust
//! RO:WHAT — Duration helpers for Macronode.
//! RO:WHY  — Avoid sprinkling raw `Duration::from_secs` calls and magic
//!           numbers (like 1000) throughout the codebase.
//! RO:INVARIANTS —
//!   - Helpers are thin wrappers over `std::time::Duration`.
//!   - Parsing helpers never panic; they return `Result`.

#![allow(dead_code)]

use std::num::ParseIntError;
use std::time::Duration;

/// Construct a duration from whole milliseconds.
#[must_use]
pub const fn millis(ms: u64) -> Duration {
    Duration::from_millis(ms)
}

/// Construct a duration from whole seconds.
#[must_use]
pub const fn seconds(secs: u64) -> Duration {
    Duration::from_secs(secs)
}

/// Construct a duration from whole minutes.
#[must_use]
pub const fn minutes(mins: u64) -> Duration {
    Duration::from_secs(mins * 60)
}

/// Parse a duration expressed as whole seconds (e.g. from an env var).
///
/// Whitespace is trimmed; invalid inputs yield a `ParseIntError`.
pub fn parse_seconds(input: &str) -> Result<Duration, ParseIntError> {
    let secs: u64 = input.trim().parse()?;
    Ok(Duration::from_secs(secs))
}

```

### crates/macronode/src/util/sizes.rs
<a id="crates-macronode-src-util-sizes-rs"></a>

```rust
//! RO:WHAT — Byte-size helpers for Macronode.
//! RO:WHY  — Make size-related config and limits more readable (MiB/GiB)
//!           and avoid repeating 1024 * 1024 everywhere.
//! RO:INVARIANTS —
//!   - Helpers are simple arithmetic and never panic on normal inputs.

#![allow(dead_code)]

/// 1 KiB in bytes.
pub const KIB: u64 = 1024;
/// 1 MiB in bytes.
pub const MIB: u64 = 1024 * 1024;
/// 1 GiB in bytes.
pub const GIB: u64 = 1024 * 1024 * 1024;

/// Return `n` kibibytes in bytes.
#[must_use]
pub const fn kib(n: u64) -> u64 {
    n * KIB
}

/// Return `n` mebibytes in bytes.
#[must_use]
pub const fn mib(n: u64) -> u64 {
    n * MIB
}

/// Return `n` gibibytes in bytes.
#[must_use]
pub const fn gib(n: u64) -> u64 {
    n * GIB
}

```

### crates/macronode/tests/admin_smoke.rs
<a id="crates-macronode-tests-adminsmoke-rs"></a>

```rust
//! RO:WHAT — End-to-end smoke test for the Macronode admin plane.
//! RO:WHY  — Prove that `/version`, `/healthz`, `/readyz`, `/metrics`,
//!           `/api/v1/status`, and `/api/v1/shutdown` all behave sanely.
//!
//! This test boots the real `macronode` binary via `CARGO_BIN_EXE_macronode`,
//! waits for it to come up, hits the core admin endpoints, and then shuts the
//! node down via the HTTP control surface.

use std::process::{Child, Command, Stdio};
use std::time::Duration;

use anyhow::{anyhow, Context, Result};
use reqwest::Client;
use serde_json::Value;
use tokio::time::sleep;

const ADMIN_PORT: u16 = 18080;
const GATEWAY_PORT: u16 = 18090;

/// Spawn the macronode binary and wait until the **full admin HTTP stack** is
/// available by polling `/version`, not just `/healthz`.
///
/// `/healthz` only proves that the event loop is alive; `/version` requires
/// the admin listener, router, and middleware stack to be bound and serving.
async fn spawn_macronode() -> Result<(Child, Client, String)> {
    let bin = env!("CARGO_BIN_EXE_macronode");

    let mut cmd = Command::new(bin);
    cmd.arg("run")
        .env("RUST_LOG", "info,macronode=debug")
        // Per-test ports to avoid collisions when tests run in parallel.
        .env("RON_HTTP_ADDR", format!("127.0.0.1:{ADMIN_PORT}"))
        .env("RON_GATEWAY_ADDR", format!("127.0.0.1:{GATEWAY_PORT}"))
        // Keep test output quiet by default.
        .stdout(Stdio::null())
        .stderr(Stdio::null());

    let child = cmd.spawn().context("failed to spawn macronode binary")?;

    let client = Client::builder()
        .timeout(Duration::from_secs(5))
        .build()
        .context("failed to build reqwest client")?;

    let base = format!("http://127.0.0.1:{ADMIN_PORT}");

    // Wait for `/version` to go green, which implies the full HTTP stack is up.
    for _ in 0..50 {
        match client.get(format!("{base}/version")).send().await {
            Ok(resp) if resp.status().is_success() => return Ok((child, client, base)),
            _ => sleep(Duration::from_millis(200)).await,
        }
    }

    Err(anyhow!("macronode did not expose /version in time"))
}

async fn shutdown_macronode(mut child: Child, client: &Client, base: &str) -> Result<()> {
    let resp = client
        .post(format!("{base}/api/v1/shutdown"))
        .send()
        .await
        .context("failed to call /api/v1/shutdown")?;

    // Log status/body when tests are run with --nocapture or RUST_LOG on.
    let status = resp.status();
    let body_text = resp.text().await.unwrap_or_default();
    eprintln!("[admin_smoke] /shutdown status={status} body={body_text}");

    // Give the process a few seconds to exit cleanly.
    for _ in 0..50 {
        if let Ok(Some(_status)) = child.try_wait() {
            return Ok(());
        }
        sleep(Duration::from_millis(200)).await;
    }

    // If it is still running, kill it to avoid hanging tests.
    let _ = child.kill();
    Err(anyhow!("macronode did not exit cleanly after /shutdown"))
}

#[tokio::test(flavor = "multi_thread")]
async fn admin_plane_smoke() -> Result<()> {
    let (child, client, base) = spawn_macronode().await?;

    // /version
    let resp = client
        .get(format!("{base}/version"))
        .send()
        .await
        .context("GET /version failed")?;
    assert!(resp.status().is_success());
    let body: Value = resp.json().await.context("decode /version body")?;
    // /version contract: includes `service: "macronode"` plus build info.
    assert_eq!(body["service"], "macronode");
    assert!(body["version"].is_string());
    assert!(body["git_sha"].is_string());
    assert!(body["api"]["http"].is_string());

    // /healthz
    let resp = client
        .get(format!("{base}/healthz"))
        .send()
        .await
        .context("GET /healthz failed")?;
    assert!(resp.status().is_success());
    let body: Value = resp.json().await.context("decode /healthz body")?;
    assert_eq!(body["ok"], true);

    // /readyz
    let resp = client
        .get(format!("{base}/readyz"))
        .send()
        .await
        .context("GET /readyz failed")?;
    assert!(
        resp.status().is_success(),
        "expected /readyz 200 when node is up"
    );
    let body: Value = resp.json().await.context("decode /readyz body")?;
    assert_eq!(body["ready"], true);
    // Basic sanity on deps.
    assert_eq!(body["deps"]["config"], "loaded");
    assert_eq!(body["deps"]["network"], "ok");
    assert_eq!(body["deps"]["gateway"], "ok");

    // /metrics
    let resp = client
        .get(format!("{base}/metrics"))
        .send()
        .await
        .context("GET /metrics failed")?;
    assert!(resp.status().is_success(), "/metrics must return 200 OK");

    let headers = resp.headers().clone();
    let text = resp.text().await.context("decode /metrics body")?;

    // Content-type should be text/plain; charset=utf-8 (Axum default for String).
    if let Some(ct) = headers.get(reqwest::header::CONTENT_TYPE) {
        let ct = ct.to_str().unwrap_or_default();
        assert!(
            ct.starts_with("text/plain"),
            "expected text/plain content-type for /metrics, got {ct}"
        );
    }

    // We don't yet enforce that the metrics body is non-empty, only that it is
    // reasonably small and successfully returned as text.
    assert!(
        text.len() < 1024 * 1024,
        "/metrics body should not exceed 1 MiB in tests"
    );

    // /api/v1/status
    let resp = client
        .get(format!("{base}/api/v1/status"))
        .send()
        .await
        .context("GET /api/v1/status failed")?;
    assert!(resp.status().is_success());
    let body: Value = resp.json().await.context("decode /api/v1/status body")?;
    // Status contract: uses `profile: "macronode"` (not `service`).
    assert_eq!(body["profile"], "macronode");
    assert!(body["uptime_seconds"].as_f64().unwrap_or(0.0) >= 0.0);
    // We expect a services map with at least gateway present.
    let services = body["services"].as_object().expect("services map present");
    assert!(
        services.contains_key("svc-gateway"),
        "status.services should contain svc-gateway"
    );

    // Drive shutdown through the HTTP surface.
    shutdown_macronode(child, &client, &base).await?;

    Ok(())
}

```

### crates/macronode/tests/metrics_contract.rs
<a id="crates-macronode-tests-metricscontract-rs"></a>

```rust

//! RO:WHAT — Contract test for the `/metrics` surface.
//! RO:WHY  — Ensure Macronode always exposes a Prometheus text endpoint,
//!           even before we add richer metric series.

use std::process::{Child, Command, Stdio};
use std::time::Duration;

use anyhow::{anyhow, Context, Result};
use reqwest::Client;
use tokio::time::sleep;

const ADMIN_PORT: u16 = 18081;
const GATEWAY_PORT: u16 = 18091;

async fn spawn_macronode() -> Result<(Child, Client, String)> {
    let bin = env!("CARGO_BIN_EXE_macronode");

    let mut cmd = Command::new(bin);
    cmd.arg("run")
        .env("RUST_LOG", "info,macronode=debug")
        .env("RON_HTTP_ADDR", format!("127.0.0.1:{ADMIN_PORT}"))
        .env("RON_GATEWAY_ADDR", format!("127.0.0.1:{GATEWAY_PORT}"))
        .stdout(Stdio::null())
        .stderr(Stdio::null());

    let child = cmd.spawn().context("failed to spawn macronode binary")?;

    let client = Client::builder()
        .timeout(Duration::from_secs(5))
        .build()
        .context("failed to build reqwest client")?;

    let base = format!("http://127.0.0.1:{ADMIN_PORT}");

    // Wait for `/healthz` to be OK.
    for _ in 0..50 {
        match client.get(format!("{base}/healthz")).send().await {
            Ok(resp) if resp.status().is_success() => return Ok((child, client, base)),
            _ => sleep(Duration::from_millis(200)).await,
        }
    }

    Err(anyhow!("macronode did not become healthy in time"))
}

async fn shutdown_macronode(mut child: Child) {
    // Best-effort kill; this test is only concerned that /metrics is present.
    for _ in 0..10 {
        if let Ok(Some(_)) = child.try_wait() {
            return;
        }
        sleep(Duration::from_millis(100)).await;
    }
    let _ = child.kill();
}

#[tokio::test(flavor = "multi_thread")]
async fn metrics_endpoint_exists_and_is_text() -> Result<()> {
    let (child, client, base) = spawn_macronode().await?;

    let resp = client
        .get(format!("{base}/metrics"))
        .send()
        .await
        .context("GET /metrics failed")?;
    assert!(resp.status().is_success(), "/metrics must return 200 OK");

    let headers = resp.headers().clone();
    let body = resp.text().await.context("decode /metrics body")?;

    // Content-type should be text/plain; charset=utf-8 (Axum default for String).
    if let Some(ct) = headers.get(reqwest::header::CONTENT_TYPE) {
        let ct = ct.to_str().unwrap_or_default();
        assert!(
            ct.starts_with("text/plain"),
            "expected text/plain content-type for /metrics, got {ct}"
        );
    }

    // Even if we have no custom metrics yet, the body should not be enormous
    // and should be valid UTF-8 text.
    assert!(
        body.len() < 1024 * 1024,
        "metrics body should not exceed 1 MiB in tests"
    );

    shutdown_macronode(child).await;
    Ok(())
}

```

### crates/macronode/tests/readiness_drain.rs
<a id="crates-macronode-tests-readinessdrain-rs"></a>

```rust
//! RO:WHAT  — Contract tests for `/readyz` truthfulness vs dev-forced mode.
//! RO:WHY   — Ensure orchestrators (K8s/systemd/CI) can trust readiness, and
//!            that the dev override flag behaves exactly as documented.
//!
//! RO:INVARIANTS —
//!   - Truthful mode: `MACRONODE_DEV_READY` is *not* set in the child env.
//!       * `/readyz` eventually returns HTTP 200 with `"mode":"truthful"` and
//!         `"ready":true` once the node has finished booting.
//!   - Dev-forced mode: `MACRONODE_DEV_READY=1` in the child env.
//!       * `/readyz` quickly returns HTTP 200 with `"ready":true` even if some
//!         deps are still pending; `mode` should be either `"dev-forced"` or
//!         `"truthful"` depending on how far the node has progressed.
//!
//! These tests never rely on a config file path. All config comes from
//! environment variables passed to the spawned child, just like the
//! `admin_smoke` and `metrics_contract` tests.

use std::process::{Child, Command, Stdio};
use std::time::{Duration, Instant};

use reqwest::{Client, StatusCode};
use serde_json::Value;
use tokio::time::sleep;

// Use dedicated ports so we don't collide with other tests.
const ADMIN_PORT: u16 = 18082;
const GATEWAY_PORT: u16 = 18092;

/// Spawn a macronode child process with a controlled environment.
///
/// If `dev_ready` is:
///   - `None`        => ensure `MACRONODE_DEV_READY` is *removed* from the child env.
///   - `Some(true)`  => set `MACRONODE_DEV_READY=1`.
///   - `Some(false)` => set `MACRONODE_DEV_READY=0` (does NOT trigger dev mode).
fn spawn_macronode(dev_ready: Option<bool>) -> Child {
    let bin = env!("CARGO_BIN_EXE_macronode");

    let mut cmd = Command::new(bin);
    cmd.arg("run")
        // Keep logs visible enough for debugging without being spammy.
        .env("RUST_LOG", "info,macronode=debug")
        // Configure admin + gateway addresses via env (no config file).
        .env("RON_HTTP_ADDR", format!("127.0.0.1:{ADMIN_PORT}"))
        .env("RON_GATEWAY_ADDR", format!("127.0.0.1:{GATEWAY_PORT}"))
        // Silence child stdout/stderr by default (tests can use --nocapture if desired).
        .stdout(Stdio::null())
        .stderr(Stdio::null());

    match dev_ready {
        None => {
            cmd.env_remove("MACRONODE_DEV_READY");
        }
        Some(true) => {
            cmd.env("MACRONODE_DEV_READY", "1");
        }
        Some(false) => {
            cmd.env("MACRONODE_DEV_READY", "0");
        }
    }

    cmd.spawn().expect("failed to spawn macronode child")
}

/// Poll `/readyz` until it reports the expected mode + ready flag, or time out.
///
/// This function is tolerant of early connection failures (e.g. TCP
/// connection refused while the admin listener is still binding) and treats
/// them as "not ready yet".
async fn wait_for_readyz_mode(
    client: &Client,
    admin_base: &str,
    expected_mode: &str,
    expected_ready: bool,
    overall_timeout: Duration,
) {
    let deadline = Instant::now() + overall_timeout;

    loop {
        match client
            .get(&format!("{admin_base}/readyz"))
            .send()
            .await
        {
            Ok(resp) => {
                let status = resp.status();
                let body: Value = resp
                    .json()
                    .await
                    .expect("failed to parse /readyz JSON body");

                let mode = body
                    .get("mode")
                    .and_then(Value::as_str)
                    .unwrap_or_default()
                    .to_string();
                let ready = body
                    .get("ready")
                    .and_then(Value::as_bool)
                    .unwrap_or(false);

                if mode == expected_mode
                    && ready == expected_ready
                    && status == StatusCode::OK
                {
                    // Reached desired state.
                    return;
                }
            }
            Err(_e) => {
                // Connection refused / timeout: admin plane not up yet.
                // Treat as "not ready yet" and keep polling until deadline.
            }
        }

        if Instant::now() >= deadline {
            panic!(
                "/readyz never reached mode={expected_mode:?}, ready={expected_ready} \
                 within {:?}",
                overall_timeout
            );
        }

        sleep(Duration::from_millis(100)).await;
    }
}

/// POST `/api/v1/shutdown` and wait for the child process to exit.
///
/// For these tests we only require that the node terminates in a bounded
/// amount of time. We do *not* enforce that the exit code is zero, since
/// dev/test profiles may choose to exit with non-zero codes for various
/// reasons (e.g. simulated faults).
async fn shutdown_and_wait(client: &Client, admin_base: &str, child: &mut Child) {
    let resp = client
        .post(&format!("{admin_base}/api/v1/shutdown"))
        .send()
        .await
        .expect("failed to send /shutdown");

    assert!(
        resp.status().is_success(),
        "/shutdown did not return success, got {}",
        resp.status()
    );

    let deadline = Instant::now() + Duration::from_secs(10);

    loop {
        if let Some(status) = child.try_wait().expect("failed to poll child status") {
            eprintln!("[readiness_drain] macronode exited after /shutdown: {status}");
            // Do not assert on success; for readiness tests we only care that
            // the process actually terminates within the timeout.
            return;
        }

        if Instant::now() >= deadline {
            panic!("macronode did not exit within timeout after /shutdown");
        }

        sleep(Duration::from_millis(100)).await;
    }
}

#[tokio::test(flavor = "multi_thread")]
async fn readyz_truthful_mode_eventually_ready() {
    // Spawn WITHOUT dev override; explicitly remove MACRONODE_DEV_READY from
    // the child env so we are not affected by whatever the parent shell has.
    let mut child = spawn_macronode(None);
    let client = Client::new();
    let admin_base = format!("http://127.0.0.1:{ADMIN_PORT}");

    // In truthful mode we expect:
    //   { "mode": "truthful", "ready": true }
    // within a reasonable timeout.
    wait_for_readyz_mode(
        &client,
        &admin_base,
        "truthful",
        true,
        Duration::from_secs(20),
    )
    .await;

    shutdown_and_wait(&client, &admin_base, &mut child).await;
}

#[tokio::test(flavor = "multi_thread")]
async fn readyz_dev_forced_mode() {
    // Spawn WITH dev override enabled only in the child env.
    let mut child = spawn_macronode(Some(true));
    let client = Client::new();
    let admin_base = format!("http://127.0.0.1:{ADMIN_PORT}");

    // In dev-forced mode we care primarily that readiness flips to true quickly.
    // The mode string may be "dev-forced" early, then "truthful" once all deps
    // are genuinely ready; either is acceptable as long as ready=true.
    let overall_timeout = Duration::from_secs(10);
    let deadline = Instant::now() + overall_timeout;

    loop {
        match client
            .get(&format!("{admin_base}/readyz"))
            .send()
            .await
        {
            Ok(resp) => {
                if resp.status() == StatusCode::OK {
                    let body: Value =
                        resp.json().await.expect("failed to parse /readyz JSON body");

                    let ready = body
                        .get("ready")
                        .and_then(Value::as_bool)
                        .unwrap_or(false);

                    if ready {
                        let mode = body
                            .get("mode")
                            .and_then(Value::as_str)
                            .unwrap_or_default()
                            .to_string();

                        // Sanity: mode should be one of the known variants.
                        assert!(
                            mode == "dev-forced" || mode == "truthful",
                            "unexpected /readyz mode in dev-forced test: {mode}"
                        );

                        shutdown_and_wait(&client, &admin_base, &mut child).await;
                        return;
                    }
                }
            }
            Err(_e) => {
                // Listener not up yet; keep trying until deadline.
            }
        }

        if Instant::now() >= deadline {
            panic!(
                "/readyz never reached ready=true within {:?} (dev-forced test)",
                overall_timeout
            );
        }

        sleep(Duration::from_millis(100)).await;
    }
}

```

