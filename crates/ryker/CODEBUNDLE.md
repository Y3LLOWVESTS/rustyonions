<!-- Generated by scripts/make_crate_codex.sh on 2025-10-25T19:12:23Z -->
# Code Bundle — `ryker`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ryker/.clippy.toml](#crates-ryker--clippy-toml)
- [crates/ryker/Cargo.toml](#crates-ryker-Cargo-toml)
- [crates/ryker/benches/batch.rs](#crates-ryker-benches-batch-rs)
- [crates/ryker/benches/dequeue.rs](#crates-ryker-benches-dequeue-rs)
- [crates/ryker/benches/enqueue.rs](#crates-ryker-benches-enqueue-rs)
- [crates/ryker/criterion.toml](#crates-ryker-criterion-toml)
- [crates/ryker/examples/actor_loop.rs](#crates-ryker-examples-actorloop-rs)
- [crates/ryker/examples/config_dump.rs](#crates-ryker-examples-configdump-rs)
- [crates/ryker/fuzz/fuzz_targets/fuzz_mailbox_ops.rs](#crates-ryker-fuzz-fuzztargets-fuzzmailboxops-rs)
- [crates/ryker/fuzz/fuzz_targets/fuzz_parse_config_json.rs](#crates-ryker-fuzz-fuzztargets-fuzzparseconfigjson-rs)
- [crates/ryker/fuzz/fuzz_targets/fuzz_parse_config_toml.rs](#crates-ryker-fuzz-fuzztargets-fuzzparseconfigtoml-rs)
- [crates/ryker/rust-toolchain.toml](#crates-ryker-rust-toolchain-toml)
- [crates/ryker/ryker.example.toml](#crates-ryker-ryker-example-toml)
- [crates/ryker/scripts/public_api_snapshot.sh](#crates-ryker-scripts-publicapisnapshot-sh)
- [crates/ryker/scripts/render-mermaid.sh](#crates-ryker-scripts-render-mermaid-sh)
- [crates/ryker/src/config/loader.rs](#crates-ryker-src-config-loader-rs)
- [crates/ryker/src/config/mod.rs](#crates-ryker-src-config-mod-rs)
- [crates/ryker/src/config/model.rs](#crates-ryker-src-config-model-rs)
- [crates/ryker/src/config/reload.rs](#crates-ryker-src-config-reload-rs)
- [crates/ryker/src/errors.rs](#crates-ryker-src-errors-rs)
- [crates/ryker/src/lib.rs](#crates-ryker-src-lib-rs)
- [crates/ryker/src/mailbox/builder.rs](#crates-ryker-src-mailbox-builder-rs)
- [crates/ryker/src/mailbox/error.rs](#crates-ryker-src-mailbox-error-rs)
- [crates/ryker/src/mailbox/mod.rs](#crates-ryker-src-mailbox-mod-rs)
- [crates/ryker/src/mailbox/observer.rs](#crates-ryker-src-mailbox-observer-rs)
- [crates/ryker/src/mailbox/queue.rs](#crates-ryker-src-mailbox-queue-rs)
- [crates/ryker/src/observe/metrics.rs](#crates-ryker-src-observe-metrics-rs)
- [crates/ryker/src/observe/mod.rs](#crates-ryker-src-observe-mod-rs)
- [crates/ryker/src/observe/trace.rs](#crates-ryker-src-observe-trace-rs)
- [crates/ryker/src/prelude.rs](#crates-ryker-src-prelude-rs)
- [crates/ryker/src/runtime/mod.rs](#crates-ryker-src-runtime-mod-rs)
- [crates/ryker/src/runtime/runtime.rs](#crates-ryker-src-runtime-runtime-rs)
- [crates/ryker/src/supervisor/backoff.rs](#crates-ryker-src-supervisor-backoff-rs)
- [crates/ryker/src/supervisor/mod.rs](#crates-ryker-src-supervisor-mod-rs)
- [crates/ryker/src/supervisor/supervisor.rs](#crates-ryker-src-supervisor-supervisor-rs)
- [crates/ryker/tests/feature_matrix.rs](#crates-ryker-tests-featurematrix-rs)
- [crates/ryker/tests/integration/amnesia.rs](#crates-ryker-tests-integration-amnesia-rs)
- [crates/ryker/tests/integration/backpressure.rs](#crates-ryker-tests-integration-backpressure-rs)
- [crates/ryker/tests/integration/config_env_snapshot.rs](#crates-ryker-tests-integration-configenvsnapshot-rs)
- [crates/ryker/tests/integration/deadline.rs](#crates-ryker-tests-integration-deadline-rs)
- [crates/ryker/tests/integration/metrics_contract.rs](#crates-ryker-tests-integration-metricscontract-rs)
- [crates/ryker/tests/integration/reload_hot_cold.rs](#crates-ryker-tests-integration-reloadhotcold-rs)
- [crates/ryker/tests/integration/supervisor_backoff.rs](#crates-ryker-tests-integration-supervisorbackoff-rs)
- [crates/ryker/tests/loom/loom_backpressure.rs](#crates-ryker-tests-loom-loombackpressure-rs)
- [crates/ryker/tests/loom/loom_mailbox_basic.rs](#crates-ryker-tests-loom-loommailboxbasic-rs)
- [crates/ryker/tests/loom/loom_shutdown.rs](#crates-ryker-tests-loom-loomshutdown-rs)
- [crates/ryker/tests/vectors/snapshots/config_snapshot.json](#crates-ryker-tests-vectors-snapshots-configsnapshot-json)
- [crates/ryker/tests/vectors/snapshots/config_snapshot.toml](#crates-ryker-tests-vectors-snapshots-configsnapshot-toml)

### crates/ryker/.clippy.toml
<a id="crates-ryker--clippy-toml"></a>

```toml
# Minimal, stable-friendly Clippy config for ryker
msrv = "1.80"

```

### crates/ryker/Cargo.toml
<a id="crates-ryker-Cargo-toml"></a>

```toml
[package]
name = "ryker"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Embedded actor & bounded mailbox runtime for RustyOnions"
readme = "README.MD"
rust-version = "1.80"

[features]
default = ["metrics", "tracing", "amnesia"]
metrics = []
tracing = ["dep:tracing"]
amnesia = []
loom = []
dev-cli = []
# Enables a non-intrusive "tap" for benches to clone a receiver; off in prod.
bench_support = []

[dependencies]
tokio = { version = "1.47", features = ["macros", "rt", "time", "sync"] }
parking_lot = "0.12"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
serde_with = "3.9"
humantime = "2.1"
humantime-serde = "1.1"
once_cell = "1.19"
rand = "0.9"
anyhow = "1.0"
serde_json = "1.0"

# Optional tracing; enabled via feature above
tracing = { version = "0.1", optional = true, default-features = false, features = ["std"] }

[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports", "async_tokio"] }
serde_json = "1.0"
anyhow = "1.0"

[[bench]]
name = "enqueue"
harness = false

[[bench]]
name = "dequeue"
harness = false

[[bench]]
name = "batch"
harness = false

[lib]
doctest = false
```

### crates/ryker/benches/batch.rs
<a id="crates-ryker-benches-batch-rs"></a>

```rust
//! RO:WHAT — Criterion bench: batched dequeue throughput.
//! RO:INVAR — Prefill with send(); drop TX; drain RX in batches until N or Closed.

use criterion::{criterion_group, criterion_main, Criterion};
use ryker::prelude::*;
use std::time::Duration;
use tokio::runtime::{Builder as TokioBuilder, Runtime as TokioRt};

const CAP: usize = 2048;
const N_MSGS: usize = CAP;
const BATCH: usize = 64;

fn tokio_rt() -> TokioRt {
    TokioBuilder::new_current_thread()
        .enable_time()
        .build()
        .expect("tokio rt")
}

fn bench_batch(c: &mut Criterion) {
    let rt = tokio_rt();
    c.bench_function("ryker_batch_pull", |b| {
        b.to_async(&rt).iter(|| async {
            let cfg = ryker::config::from_env_validated().unwrap();
            let ry = Runtime::new(cfg);

            let mb = ry
                .mailbox::<u64>("bench.batch")
                .capacity(CAP)
                .deadline(Duration::from_millis(10))
                .build();

            let (tx, mut rx) = mb.split();

            for i in 0..N_MSGS as u64 {
                tx.send(i).await.expect("prefill");
            }
            drop(tx);

            let mut n = 0usize;
            while n < N_MSGS {
                let mut got = 0usize;
                while got < BATCH {
                    match rx.pull().await {
                        Ok(_m) => {
                            got += 1;
                            n += 1;
                            if n >= N_MSGS {
                                break;
                            }
                        }
                        Err(ryker::mailbox::MailboxError::Closed) => break,
                        Err(ryker::mailbox::MailboxError::Timeout) => break,
                        Err(e) => panic!("unexpected: {e}"),
                    }
                }
                tokio::task::yield_now().await;
            }
        });
    });
}

criterion_group!(benches, bench_batch);
criterion_main!(benches);

```

### crates/ryker/benches/dequeue.rs
<a id="crates-ryker-benches-dequeue-rs"></a>

```rust
//! RO:WHAT — Criterion bench: dequeue throughput.
//! RO:INVAR — Prefill with send(); drop TX; drain RX until N or Closed.

use criterion::{criterion_group, criterion_main, Criterion};
use ryker::prelude::*;
use std::time::Duration;
use tokio::runtime::{Builder as TokioBuilder, Runtime as TokioRt};

const CAP: usize = 1024;
const N_MSGS: usize = CAP;

fn tokio_rt() -> TokioRt {
    TokioBuilder::new_current_thread()
        .enable_time()
        .build()
        .expect("tokio rt")
}

fn bench_dequeue(c: &mut Criterion) {
    let rt = tokio_rt();
    c.bench_function("ryker_dequeue_pull", |b| {
        b.to_async(&rt).iter(|| async {
            let cfg = ryker::config::from_env_validated().unwrap();
            let ry = Runtime::new(cfg);

            let mb = ry
                .mailbox::<u64>("bench.dequeue")
                .capacity(CAP)
                .deadline(Duration::from_millis(10))
                .build();

            let (tx, mut rx) = mb.split();

            for i in 0..N_MSGS as u64 {
                tx.send(i).await.expect("prefill");
            }
            drop(tx); // important: close the channel

            let mut n = 0usize;
            loop {
                match rx.pull().await {
                    Ok(_m) => {
                        n += 1;
                        if n >= N_MSGS {
                            break;
                        }
                    }
                    Err(ryker::mailbox::MailboxError::Closed) => break,
                    Err(ryker::mailbox::MailboxError::Timeout) => break,
                    Err(e) => panic!("unexpected: {e}"),
                }
                tokio::task::yield_now().await;
            }
        });
    });
}

criterion_group!(benches, bench_dequeue);
criterion_main!(benches);

```

### crates/ryker/benches/enqueue.rs
<a id="crates-ryker-benches-enqueue-rs"></a>

```rust
//! RO:WHAT — Criterion bench: enqueue throughput (producer side).
//! RO:INVAR — try_send burst, ignore Busy (we measure producer cost, not success rate).

use criterion::{criterion_group, criterion_main, Criterion};
use ryker::prelude::*;
use std::time::Duration;
use tokio::runtime::{Builder as TokioBuilder, Runtime as TokioRt};

const CAP: usize = 2048;
const N_TRIES: usize = CAP * 2; // intentionally over capacity

fn tokio_rt() -> TokioRt {
    TokioBuilder::new_current_thread()
        .enable_time()
        .build()
        .expect("tokio rt")
}

fn bench_enqueue(c: &mut Criterion) {
    let rt = tokio_rt();
    c.bench_function("ryker_enqueue_try_send", |b| {
        b.to_async(&rt).iter(|| async {
            let cfg = ryker::config::from_env_validated().unwrap();
            let ry = Runtime::new(cfg);

            let mb = ry
                .mailbox::<u64>("bench.enqueue")
                .capacity(CAP)
                .deadline(Duration::from_millis(5))
                .build();

            let (tx, _rx) = mb.split();

            for i in 0..N_TRIES as u64 {
                let _ = tx.try_send(i);
            }
        });
    });
}

criterion_group!(benches, bench_enqueue);
criterion_main!(benches);

```

### crates/ryker/criterion.toml
<a id="crates-ryker-criterion-toml"></a>

```toml
warm_up_time = "0.5 s"
measurement_time = "2.0 s"
sample_size = 30
confidence_level = 0.90
noise_threshold = 0.02
nresamples = 10_000
plotting_backend = "disabled"

```

### crates/ryker/examples/actor_loop.rs
<a id="crates-ryker-examples-actorloop-rs"></a>

```rust
// RO:WHAT  — Minimal actor loop using Runtime + Mailbox + Supervisor.
// RO:HOW   — cargo run -p ryker --example actor_loop

use ryker::prelude::*;
use std::time::Duration;

#[derive(Debug, Clone)]
struct Msg(&'static str);

#[tokio::main(flavor = "current_thread")]
async fn main() -> anyhow::Result<()> {
    let cfg = ryker::config::from_env_validated()?;
    let rt = Runtime::new(cfg);

    // Build a small mailbox to demo Busy behavior.
    let mb: ryker::mailbox::Mailbox<Msg> = rt
        .mailbox("demo-actor")
        .capacity(4)
        .deadline(Duration::from_millis(250))
        .build();

    // Enqueue a few messages; you should see Busy when capacity is exceeded.
    for i in 0..8 {
        match mb.try_send(Msg("hello")) {
            Ok(_) => println!("[main] enqueued i={i}"),
            Err(ryker::mailbox::MailboxError::Busy) => {
                println!("[main] queue Busy at i={i} (reject-new)")
            }
            Err(e) => println!("[main] enqueue error at i={i}: {e}"),
        }
    }

    // Hand-off ownership of the mailbox to the supervised actor exactly once.
    // The FnMut factory can be called multiple times by Supervisor after failures;
    // we use Option.take() so only the first call consumes the mailbox.
    let mut rx_opt = Some(mb);
    let sup = Supervisor::new(rt.config());
    let _handle = sup.spawn(move || {
        // Take the mailbox on the first invocation; None thereafter (no restart).
        let rx_taken = rx_opt.take();
        async move {
            if let Some(mut rx) = rx_taken {
                loop {
                    match rx.pull().await {
                        Ok(Msg(s)) => println!("[actor] handled: {s}"),
                        Err(ryker::mailbox::MailboxError::Timeout) => {
                            println!("[actor] idle timeout");
                        }
                        Err(ryker::mailbox::MailboxError::Closed) => break,
                        Err(e) => eprintln!("[actor] error: {e}"),
                    }
                }
            }
            Ok::<(), anyhow::Error>(())
        }
    });

    tokio::time::sleep(Duration::from_secs(1)).await;
    Ok(())
}

```

### crates/ryker/examples/config_dump.rs
<a id="crates-ryker-examples-configdump-rs"></a>

```rust
// RO:WHAT — Print the effective RykerConfig as JSON.
// RO:HOW  — cargo run -p ryker --example config_dump

use serde_json::json;

fn main() -> anyhow::Result<()> {
    let cfg = ryker::config::from_env_validated()?;
    let d = &cfg.defaults;
    let f = &cfg.fairness;
    let s = &cfg.supervisor;

    let out = json!({
        "defaults": {
            "mailbox_capacity": d.mailbox_capacity,
            "max_msg_bytes": d.max_msg_bytes,
            "deadline_ms": d.deadline.as_millis(),
        },
        "fairness": {
            "batch_messages": f.batch_messages,
            "yield_every_n_msgs": f.yield_every_n_msgs,
        },
        "supervisor": {
            "backoff_base_ms": s.backoff_base_ms,
            "backoff_cap_ms": s.backoff_cap_ms,
            "decorrelated_jitter": s.decorrelated_jitter,
        },
        "amnesia": cfg.amnesia,
        "observe": {
            "queue_depth_sampling": cfg.observe.queue_depth_sampling,
        }
    });

    println!("{}", serde_json::to_string_pretty(&out)?);
    Ok(())
}

```

### crates/ryker/fuzz/fuzz_targets/fuzz_mailbox_ops.rs
<a id="crates-ryker-fuzz-fuzztargets-fuzzmailboxops-rs"></a>

```rust
#![no_main]
// cargo-fuzz target (stub): randomized mailbox ops.

```

### crates/ryker/fuzz/fuzz_targets/fuzz_parse_config_json.rs
<a id="crates-ryker-fuzz-fuzztargets-fuzzparseconfigjson-rs"></a>

```rust
#![no_main]
// cargo-fuzz target (stub): parse JSON config.

```

### crates/ryker/fuzz/fuzz_targets/fuzz_parse_config_toml.rs
<a id="crates-ryker-fuzz-fuzztargets-fuzzparseconfigtoml-rs"></a>

```rust
#![no_main]
// cargo-fuzz target (stub): parse TOML config.

```

### crates/ryker/rust-toolchain.toml
<a id="crates-ryker-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/ryker/ryker.example.toml
<a id="crates-ryker-ryker-example-toml"></a>

```toml
# Example config — validated via RykerConfig::from_env_validated()
[mailbox]
capacity = 256
max_msg_bytes = "64KiB"
default_deadline_ms = 1000

[fairness]
batch_messages = 32
yield_every_n = 64

[supervisor]
backoff_base_ms = 100
backoff_cap_ms  = 5000

[observe]
metrics = true
queue_depth_sampling = true

[amnesia]
enabled = false


```

### crates/ryker/scripts/public_api_snapshot.sh
<a id="crates-ryker-scripts-publicapisnapshot-sh"></a>

```bash
#!/usr/bin/env bash
# Takes a public API snapshot for the `ryker` crate and optionally diffs it.
# Requirements:
#   - cargo-public-api  (install: cargo install cargo-public-api)
# Usage:
#   scripts/public_api_snapshot.sh save <name>        # save snapshot to target/public-api/<name>.txt
#   scripts/public_api_snapshot.sh diff <old> <new>   # show diff between two saved snapshots
#   scripts/public_api_snapshot.sh now                # print current API (no file)
# Env:
#   CARGO_FEATURES="..."   # e.g. "--features bench_support"

set -euo pipefail

# Find workspace root by walking upward until Cargo.toml is found.
find_workspace_root() {
  local d="$1"
  for _ in {1..6}; do
    if [[ -f "$d/Cargo.toml" ]]; then
      echo "$d"
      return 0
    fi
    d="$(dirname "$d")"
  done
  return 1
}

here="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
start_dir="$here"
repo="$(find_workspace_root "$start_dir" || true)"
if [[ -z "${repo:-}" ]]; then
  echo "Could not find workspace Cargo.toml by walking up from: $start_dir"
  echo "Hint: run this script from within the workspace, or set REPO_ROOT env var."
  exit 1
fi
cd "$repo"

if ! command -v cargo-public-api >/dev/null 2>&1; then
  echo "cargo-public-api not found. install it first:"
  echo "cargo install cargo-public-api"
  exit 1
fi

outdir="target/public-api"
mkdir -p "$outdir"

features="${CARGO_FEATURES:-}"

case "${1:-}" in
  save)
    name="${2:-ryker-$(date +%Y%m%d-%H%M%S)}"
    out="$outdir/$name.txt"
    cargo public-api -p ryker $features --simplified \
      --omit blanket-impls --omit auto-trait-impls > "$out"
    echo "Saved: $out"
    ;;
  diff)
    old="$outdir/${2:?old snapshot name}.txt"
    new="$outdir/${3:?new snapshot name}.txt"
    if [[ ! -f "$old" || ! -f "$new" ]]; then
      echo "Missing files: $old or $new"
      exit 2
    fi
    diff -u "$old" "$new" || true
    ;;
  now)
    cargo public-api -p ryker $features --simplified \
      --omit blanket-impls --omit auto-trait-impls
    ;;
  *)
    echo "Usage:"
    echo "  $0 save <name>"
    echo "  $0 diff <old> <new>"
    echo "  $0 now"
    exit 64
    ;;
esac

```

### crates/ryker/scripts/render-mermaid.sh
<a id="crates-ryker-scripts-render-mermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Renders docs/*.mmd to SVG using mermaid-cli if available.
ROOT=${1:-"./crates"}
cd "./crates/ryker"
if ! command -v mmdc >/dev/null 2>&1; then
  echo "mmdc not found. Install: npm i -g @mermaid-js/mermaid-cli"
  exit 1
fi
for f in docs/*.mmd; do
  [ -e "$f" ] || continue
  out=${f%.mmd}.svg
  mmdc -i "$f" -o "$out"
  echo "rendered: $out"
done


```

### crates/ryker/src/config/loader.rs
<a id="crates-ryker-src-config-loader-rs"></a>

```rust
//! RO:WHAT — Builder + environment merge for `RykerConfig` (file optional).
//! RO:WHY  — Enforce builder > env > file > defaults; prod guards.
//! RO:INTERACTS — model (schema), reload (hooks), runtime creates snapshot.
//! RO:INVARIANTS — `RYKER_CONFIG_PATH` ignored in prod unless explicitly allowed.

use super::model::RykerConfig;
use crate::errors::{ConfigError, Result};
use once_cell::sync::Lazy;
use std::env;

static IS_PROD: Lazy<bool> = Lazy::new(|| {
    let app = env::var("APP_ENV").ok();
    let rust = env::var("RUST_ENV").ok();
    matches!(app.or(rust), Some(s) if s == "production")
});

#[derive(Default)]
pub struct RykerConfigBuilder {
    inner: RykerConfig,
}

impl RykerConfigBuilder {
    pub fn new() -> Self {
        Self {
            inner: RykerConfig::default(),
        }
    }
    pub fn build(mut self) -> Result<RykerConfig> {
        merge_env(&mut self.inner)?;
        self.inner.validate()?;
        Ok(self.inner)
    }
}

pub fn from_env_validated() -> Result<RykerConfig> {
    let mut cfg = RykerConfig::default();

    if let Ok(path) = env::var("RYKER_CONFIG_PATH") {
        if *IS_PROD && env::var("RYKER_ALLOW_CONFIG_PATH").as_deref() != Ok("1") {
            return Err(
                ConfigError::ProdGuard("RYKER_CONFIG_PATH rejected in production".into()).into(),
            );
        }
        tracing_log!("dev-cli path provided (host should load file): {}", path);
    }

    merge_env(&mut cfg)?;
    cfg.validate()?;
    Ok(cfg)
}

fn merge_env(cfg: &mut RykerConfig) -> Result<()> {
    let get = |k: &str| env::var(k).ok();

    if let Some(v) = get("RYKER_DEFAULT_MAILBOX_CAPACITY") {
        cfg.defaults.mailbox_capacity = v.parse().map_err(|_| {
            ConfigError::Invalid("RYKER_DEFAULT_MAILBOX_CAPACITY must be int".into())
        })?;
    }
    if let Some(v) = get("RYKER_DEFAULT_MAX_MSG_BYTES") {
        cfg.defaults.max_msg_bytes = parse_size(&v)?;
    }
    if let Some(v) = get("RYKER_DEFAULT_DEADLINE") {
        cfg.defaults.deadline = humantime::parse_duration(&v)
            .map_err(|_| ConfigError::Invalid("bad deadline".into()))?;
    }
    if let Some(v) = get("RYKER_BACKOFF_BASE_MS") {
        cfg.supervisor.backoff_base_ms = v
            .parse()
            .map_err(|_| ConfigError::Invalid("bad backoff_base_ms".into()))?;
    }
    if let Some(v) = get("RYKER_BACKOFF_CAP_MS") {
        cfg.supervisor.backoff_cap_ms = v
            .parse()
            .map_err(|_| ConfigError::Invalid("bad backoff_cap_ms".into()))?;
    }
    if let Some(v) = get("RYKER_BATCH_MESSAGES") {
        cfg.fairness.batch_messages = v
            .parse()
            .map_err(|_| ConfigError::Invalid("bad batch_messages".into()))?;
    }
    if let Some(v) = get("RYKER_YIELD_EVERY_N") {
        cfg.fairness.yield_every_n_msgs = v
            .parse()
            .map_err(|_| ConfigError::Invalid("bad yield_every_n".into()))?;
    }
    if let Some(v) = get("RYKER_ENABLE_METRICS") {
        cfg.observe.queue_depth_sampling = matches!(v.as_str(), "1" | "true" | "TRUE");
    }
    if let Some(v) = get("RYKER_AMNESIA") {
        cfg.amnesia = matches!(v.as_str(), "1" | "true" | "TRUE");
    }
    Ok(())
}

fn parse_size(s: &str) -> Result<usize> {
    let s = s.trim();
    if let Some(n) = s.strip_suffix("KiB") {
        let v: usize = n
            .trim()
            .parse()
            .map_err(|_| ConfigError::Invalid("size".into()))?;
        return Ok(v * 1024);
    }
    if let Some(n) = s.strip_suffix("MiB") {
        let v: usize = n
            .trim()
            .parse()
            .map_err(|_| ConfigError::Invalid("size".into()))?;
        return Ok(v * 1024 * 1024);
    }
    let v: usize = s.parse().map_err(|_| ConfigError::Invalid("size".into()))?;
    Ok(v)
}

// Tiny local macro to avoid requiring tracing at call site when feature disabled
#[inline]
fn tracing_log_(lvl: &str, msg: &str) {
    #[cfg(feature = "tracing")]
    match lvl {
        "info" => tracing::info!("{}", msg),
        _ => tracing::debug!("{}", msg),
    }
}

macro_rules! tracing_log {
    ($($tt:tt)*) => {
        #[allow(unused)]
        {
            let s = format!($($tt)*);
            super::loader::tracing_log_("debug", &s);
        }
    };
}
pub(crate) use tracing_log;

```

### crates/ryker/src/config/mod.rs
<a id="crates-ryker-src-config-mod-rs"></a>

```rust
//! RO:WHAT — Public entry for configuration types and loader.
//! RO:WHY  — Keep builder/env/file precedence & validation together.
//! RO:INTERACTS — model (schema), loader (env/file), reload (hooks).
//! RO:INVARIANTS — builder > env > file > defaults; deny invalid combos; amnesia honored.

mod loader;
mod model;
mod reload;

pub use loader::{from_env_validated, RykerConfigBuilder};
pub use model::{FairnessCfg, RykerConfig, SupervisionCfg};
pub use reload::{ReloadCounters, RykerReloadHook};

```

### crates/ryker/src/config/model.rs
<a id="crates-ryker-src-config-model-rs"></a>

```rust
//! RO:WHAT — Typed configuration schema for ryker.
//! RO:WHY  — Deterministic defaults + strict validation (docs-aligned).
//! RO:INTERACTS — loader merges sources; runtime/mailbox read snapshots.
//! RO:INVARIANTS — capacity>0; 0 < deadline ≤ 60s; max_msg_bytes ≤ 1MiB; yield_every_n ≥ batch.

use crate::errors::{ConfigError, Result};
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RykerConfig {
    pub defaults: Defaults,
    pub fairness: FairnessCfg,
    pub supervisor: SupervisionCfg,
    pub amnesia: bool,
    pub observe: ObserveCfg,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Defaults {
    pub mailbox_capacity: usize,
    pub max_msg_bytes: usize,
    #[serde(with = "humantime_serde")]
    pub deadline: Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FairnessCfg {
    pub batch_messages: usize,
    pub yield_every_n_msgs: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupervisionCfg {
    pub backoff_base_ms: u64,
    pub backoff_cap_ms: u64,
    pub decorrelated_jitter: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ObserveCfg {
    /// If true, ryker may sample queue depths via observer hooks.
    pub queue_depth_sampling: bool,
}

impl Default for RykerConfig {
    fn default() -> Self {
        Self {
            defaults: Defaults {
                mailbox_capacity: 256,
                max_msg_bytes: 64 * 1024,
                deadline: Duration::from_secs(1),
            },
            fairness: FairnessCfg {
                batch_messages: 32,
                yield_every_n_msgs: 64,
            },
            supervisor: SupervisionCfg {
                backoff_base_ms: 100,
                backoff_cap_ms: 5_000,
                decorrelated_jitter: true,
            },
            amnesia: false,
            observe: ObserveCfg {
                queue_depth_sampling: true,
            },
        }
    }
}

impl RykerConfig {
    pub fn validate(&self) -> Result<()> {
        // mailbox must have capacity
        if self.defaults.mailbox_capacity == 0 {
            return Err(ConfigError::Invalid("mailbox_capacity=0".into()).into());
        }

        // Upper bound aligns with crate docs (≤ 1 MiB)
        const MIB: usize = 1024 * 1024;
        if self.defaults.max_msg_bytes > MIB {
            return Err(ConfigError::Invalid("max_msg_bytes > 1MiB".into()).into());
        }

        // 1 ms ..= 60 s recommended bounds
        if self.defaults.deadline < Duration::from_millis(1)
            || self.defaults.deadline > Duration::from_secs(60)
        {
            return Err(ConfigError::Invalid("deadline out of [1ms, 60s]".into()).into());
        }

        // yield_every_n must be ≥ batch size
        if self.fairness.yield_every_n_msgs < self.fairness.batch_messages {
            return Err(ConfigError::Invalid("yield_every_n_msgs < batch_messages".into()).into());
        }

        // backoff base/cap relationship must be coherent and non-zero
        if self.supervisor.backoff_base_ms == 0
            || self.supervisor.backoff_cap_ms == 0
            || self.supervisor.backoff_base_ms > self.supervisor.backoff_cap_ms
        {
            return Err(
                ConfigError::Invalid("invalid backoff base/cap relationship".into()).into(),
            );
        }
        Ok(())
    }

    /// Apply in-process overrides (builder-like) then revalidate.
    pub fn with_overrides<F: FnOnce(&mut RykerConfig)>(mut self, f: F) -> Result<RykerConfig> {
        f(&mut self);
        self.validate()?;
        Ok(self)
    }
}

```

### crates/ryker/src/config/reload.rs
<a id="crates-ryker-src-config-reload-rs"></a>

```rust
//! RO:WHAT — Config reload hook trait and counters.
//! RO:WHY  — Hosts may hot-apply fairness/deadline; capacity is cold-only.
//! RO:INTERACTS — runtime applies hooks; observe increments counters.
//! RO:INVARIANTS — reloads are atomic snapshot swaps; diffs are redacted.

use std::sync::atomic::AtomicU64;

#[derive(Default)]
pub struct ReloadCounters {
    pub total: AtomicU64,
    pub errors: AtomicU64,
}

pub trait RykerReloadHook: Send + Sync + 'static {
    /// Apply a new effective snapshot. Implementations must be fast and panic-free.
    fn apply(&self);
}

```

### crates/ryker/src/errors.rs
<a id="crates-ryker-src-errors-rs"></a>

```rust
//! RO:WHAT — Typed error taxonomy for ryker (mailbox/runtime/config).
//! RO:WHY  — Deterministic mapping for hosts; Concerns: RES/DX.
//! RO:INTERACTS — mailbox (Busy/TooLarge/Closed/Timeout), config loader.
//! RO:INVARIANTS — errors stable across minors; strings are non-sensitive.

use thiserror::Error;

pub type Result<T, E = Error> = std::result::Result<T, E>;

#[derive(Debug, Error)]
pub enum Error {
    #[error("mailbox at capacity (Busy)")]
    Busy,
    #[error("message too large (max {max} bytes)")]
    TooLarge { max: usize },
    #[error("mailbox closed")]
    Closed,
    #[error("deadline exceeded")]
    Timeout,
    #[error("configuration error: {0}")]
    Config(ConfigError),
}

#[derive(Debug, Error)]
pub enum ConfigError {
    #[error("invalid value: {0}")]
    Invalid(String),
    #[error("unsupported in production: {0}")]
    ProdGuard(String),
}

// Allow `?` on ConfigError to bubble as Error::Config
impl From<ConfigError> for Error {
    fn from(e: ConfigError) -> Self {
        Error::Config(e)
    }
}

```

### crates/ryker/src/lib.rs
<a id="crates-ryker-src-lib-rs"></a>

```rust
//! RO:WHAT — Crate facade for ryker (actor & bounded mailbox runtime).
//! RO:WHY  — Pillar 1 (Kernel & Orchestration); Concerns: RES/PERF.
//! RO:INTERACTS — modules: config, runtime, mailbox, supervisor, observe, errors.
//! RO:INVARIANTS — bounded mailboxes (reject-new Busy); deadlines enforced; no locks across .await.
//! RO:METRICS — via observe::MailboxObserver callbacks (host integrates Prometheus).
//! RO:CONFIG — env `RYKER_*` honored; builder > env > file > defaults precedence.
//! RO:SECURITY — library-only; no sockets/TLS/PII; amnesia feature zeroizes on drop (host-verified).
//! RO:TEST — unit/integration/loom per docs; property tests optional (proptest).

#![forbid(unsafe_code)]
#![doc = include_str!("../README.md")]

pub mod config;
pub mod errors;
pub mod mailbox;
pub mod observe;
pub mod runtime;
pub mod supervisor;

pub mod prelude;

```

### crates/ryker/src/mailbox/builder.rs
<a id="crates-ryker-src-mailbox-builder-rs"></a>

```rust
//! RO:WHAT — Per-actor mailbox builder with overrides.
//! RO:WHY  — Ergonomics; mirrors README examples; preserves snapshot defaults.
//! RO:INTERACTS — queue::Mailbox, observer hooks, config snapshot.
//! RO:INVARIANTS — capacity>0; max_msg_bytes≤1MiB; deadline bounds; reject-new policy.

#![forbid(unsafe_code)]

use super::observer::{NoopObserver, Observer};
use super::queue::Mailbox;
use crate::config::RykerConfig;
use std::sync::Arc;
use std::time::Duration;

pub struct MailboxBuilder<T> {
    actor_name: String,
    cfg: Arc<RykerConfig>,
    capacity: Option<usize>,
    max_msg_bytes: Option<usize>,
    deadline: Option<Duration>,
    observer: Option<Observer>,
    _phantom: std::marker::PhantomData<T>,
}

impl<T> MailboxBuilder<T> {
    pub(crate) fn new(actor_name: String, cfg: Arc<RykerConfig>) -> Self {
        Self {
            actor_name,
            cfg,
            capacity: None,
            max_msg_bytes: None,
            deadline: None,
            observer: None,
            _phantom: std::marker::PhantomData,
        }
    }

    pub fn capacity(mut self, cap: usize) -> Self {
        self.capacity = Some(cap);
        self
    }

    pub fn max_msg_bytes(mut self, max: usize) -> Self {
        self.max_msg_bytes = Some(max);
        self
    }

    pub fn deadline(mut self, d: Duration) -> Self {
        self.deadline = Some(d);
        self
    }

    /// Convenience for ms-based examples/doc parity.
    pub fn deadline_ms(mut self, ms: u64) -> Self {
        self.deadline = Some(Duration::from_millis(ms));
        self
    }

    pub fn observer(mut self, obs: Observer) -> Self {
        self.observer = Some(obs);
        self
    }

    pub fn build(self) -> Mailbox<T> {
        let cap = self.capacity.unwrap_or(self.cfg.defaults.mailbox_capacity);
        let max = self
            .max_msg_bytes
            .unwrap_or(self.cfg.defaults.max_msg_bytes);
        let dl = self.deadline.unwrap_or(self.cfg.defaults.deadline);
        let obs = self.observer.unwrap_or_else(|| Arc::new(NoopObserver));

        Mailbox::new(self.actor_name, cap, max, dl, obs)
    }
}

```

### crates/ryker/src/mailbox/error.rs
<a id="crates-ryker-src-mailbox-error-rs"></a>

```rust
//! RO:WHAT — Mailbox-local error facade and Result alias.
//! RO:WHY  — Keep mailbox concerns self-contained while mapping 1:1 to crate errors.
//! RO:INTERACTS — Used by `queue.rs` and `builder.rs`; re-exports for callers via `mailbox::`.
//! RO:INVARIANTS — Mirrors `crate::errors::Error`; stable across minor versions.

#![forbid(unsafe_code)]

pub type MailboxResult<T, E = MailboxError> = std::result::Result<T, E>;

/// Thin alias to the crate-wide error so users can import `mailbox::MailboxError`
/// without reaching into `crate::errors`.
#[derive(Debug, thiserror::Error)]
pub enum MailboxError {
    #[error("mailbox at capacity (Busy)")]
    Busy,
    #[error("message too large (max {max} bytes)")]
    TooLarge { max: usize },
    #[error("mailbox closed")]
    Closed,
    #[error("deadline exceeded")]
    Timeout,
}

impl From<crate::errors::Error> for MailboxError {
    fn from(e: crate::errors::Error) -> Self {
        match e {
            crate::errors::Error::Busy => MailboxError::Busy,
            crate::errors::Error::TooLarge { max } => MailboxError::TooLarge { max },
            crate::errors::Error::Closed => MailboxError::Closed,
            crate::errors::Error::Timeout => MailboxError::Timeout,
            crate::errors::Error::Config(_) => {
                // Mailbox never bubbles config errors; map conservatively.
                MailboxError::Closed
            }
        }
    }
}

impl From<MailboxError> for crate::errors::Error {
    fn from(e: MailboxError) -> Self {
        match e {
            MailboxError::Busy => crate::errors::Error::Busy,
            MailboxError::TooLarge { max } => crate::errors::Error::TooLarge { max },
            MailboxError::Closed => crate::errors::Error::Closed,
            MailboxError::Timeout => crate::errors::Error::Timeout,
        }
    }
}

```

### crates/ryker/src/mailbox/mod.rs
<a id="crates-ryker-src-mailbox-mod-rs"></a>

```rust
//! RO:WHAT — Public mailbox types: builder and queue facade.
//! RO:WHY  — Bounded single-consumer mailbox; Busy on overflow.
//! RO:INTERACTS — queue (tokio mpsc), observer hooks, errors.
//! RO:INVARIANTS — FIFO per-mailbox; reject-new; deadlines enforced via timeout.

mod builder;
mod error;
pub mod observer;
mod queue;

pub use builder::MailboxBuilder;
pub use error::{MailboxError, MailboxResult};
pub use queue::Mailbox;

// Convenience re-exports so users can `use ryker::mailbox::*;`
pub use observer::{DropReason, MailboxObserver, NoopObserver, Observer};

```

### crates/ryker/src/mailbox/observer.rs
<a id="crates-ryker-src-mailbox-observer-rs"></a>

```rust
/*! MailboxObserver hooks (stub). Forward to metrics facade without exporter lock-in. */

//! RO:WHAT — Mailbox-local observer trait re-exports and helpers.
//! RO:WHY  — Give callers a single `mailbox::observer` import surface.
//! RO:INTERACTS — Wraps `observe::metrics` to avoid leaking crate internals.
//! RO:INVARIANTS — Non-blocking hooks only; never hold locks across `.await`.

#![forbid(unsafe_code)]

pub use crate::observe::metrics::{DropReason, MailboxObserver, NoopObserver, Observer};

```

### crates/ryker/src/mailbox/queue.rs
<a id="crates-ryker-src-mailbox-queue-rs"></a>

```rust
//! RO:WHAT — Mailbox<T>: bounded queue facade around tokio mpsc, with split().
//! RO:WHY  — Single-consumer FIFO; Busy on overflow; per-message deadlines; explicit close via drop.
//! RO:INTERACTS — mailbox::observer hooks, errors.
//! RO:INVARIANTS — try_send rejects when full; pull uses timeout(deadline). No PII logged.

#![forbid(unsafe_code)]

use super::error::{MailboxError, MailboxResult};
use super::observer::{DropReason, Observer};
use crate::observe::trace;
use std::time::Duration;
use tokio::sync::mpsc;
use tokio::sync::mpsc::error::{SendError, TrySendError};

/// Factory wrapper that owns both ends until you call split().
pub struct Mailbox<T> {
    actor: String,
    tx: mpsc::Sender<T>,
    rx: mpsc::Receiver<T>,
    capacity: usize,
    max_msg_bytes: usize,
    deadline: Duration,
    observer: Observer,
}

impl<T> Mailbox<T> {
    pub(crate) fn new(
        actor: String,
        capacity: usize,
        max_msg_bytes: usize,
        deadline: Duration,
        observer: Observer,
    ) -> Self {
        let (tx, rx) = mpsc::channel(capacity);
        Self {
            actor,
            tx,
            rx,
            capacity,
            max_msg_bytes,
            deadline,
            observer,
        }
    }

    /// Non-blocking enqueue; returns Busy when full.
    pub fn try_send(&self, msg: T) -> MailboxResult<()> {
        match self.tx.try_send(msg) {
            Ok(()) => {
                // Depth is not exposed by tokio mpsc; still notify enqueue for hooks.
                self.observer.on_enqueue(&self.actor, 0);
                trace::span_enqueue(&self.actor, 0);
                Ok(())
            }
            Err(TrySendError::Full(_msg)) => {
                self.observer.on_drop(&self.actor, DropReason::Capacity);
                Err(MailboxError::Busy)
            }
            Err(TrySendError::Closed(_msg)) => Err(MailboxError::Closed),
        }
    }

    /// Blocking send with the mailbox’s per-message deadline (timeout).
    pub async fn send(&self, msg: T) -> MailboxResult<()> {
        tokio::select! {
            biased;
            _ = tokio::time::sleep(self.deadline) => {
                self.observer.on_timeout(&self.actor);
                trace::span_handle(&self.actor, "timeout", self.deadline.as_millis() as u64);
                Err(MailboxError::Timeout)
            }
            res = self.tx.send(msg) => {
                match res {
                    Ok(()) => Ok(()),
                    Err(SendError(_msg)) => Err(MailboxError::Closed),
                }
            }
        }
    }

    /// Pull one message, honoring the deadline as a receive timeout.
    pub async fn pull(&mut self) -> MailboxResult<T> {
        match tokio::time::timeout(self.deadline, self.rx.recv()).await {
            Ok(Some(m)) => Ok(m),
            Ok(None) => Err(MailboxError::Closed),
            Err(_) => {
                self.observer.on_timeout(&self.actor);
                trace::span_handle(&self.actor, "timeout", self.deadline.as_millis() as u64);
                Err(MailboxError::Timeout)
            }
        }
    }

    /// Configured bounded capacity.
    pub fn capacity(&self) -> usize {
        self.capacity
    }

    /// Deadline getter.
    pub fn deadline(&self) -> Duration {
        self.deadline
    }

    /// Split into a producer (tx) and consumer (rx). Dropping tx will *close*
    /// the channel, ensuring drains can terminate (recv => None).
    pub fn split(self) -> (MailboxTx<T>, MailboxRx<T>) {
        let Mailbox {
            actor,
            tx,
            rx,
            capacity: _,
            max_msg_bytes: _,
            deadline,
            observer,
        } = self;
        (
            MailboxTx {
                actor: actor.clone(),
                tx,
                observer: observer.clone(),
            },
            MailboxRx {
                actor,
                rx,
                deadline,
                observer,
            },
        )
    }
}

/// Send half of a mailbox.
pub struct MailboxTx<T> {
    actor: String,
    tx: mpsc::Sender<T>,
    observer: Observer,
}

impl<T> MailboxTx<T> {
    pub fn try_send(&self, msg: T) -> MailboxResult<()> {
        match self.tx.try_send(msg) {
            Ok(()) => {
                self.observer.on_enqueue(&self.actor, 0);
                trace::span_enqueue(&self.actor, 0);
                Ok(())
            }
            Err(TrySendError::Full(_msg)) => {
                self.observer.on_drop(&self.actor, DropReason::Capacity);
                Err(MailboxError::Busy)
            }
            Err(TrySendError::Closed(_msg)) => Err(MailboxError::Closed),
        }
    }

    pub async fn send(&self, msg: T) -> MailboxResult<()> {
        match self.tx.send(msg).await {
            Ok(()) => Ok(()),
            Err(SendError(_msg)) => Err(MailboxError::Closed),
        }
    }
}

/// Receive half of a mailbox.
pub struct MailboxRx<T> {
    actor: String,
    rx: mpsc::Receiver<T>,
    deadline: Duration,
    observer: Observer,
}

impl<T> MailboxRx<T> {
    pub async fn pull(&mut self) -> MailboxResult<T> {
        match tokio::time::timeout(self.deadline, self.rx.recv()).await {
            Ok(Some(m)) => Ok(m),
            Ok(None) => Err(MailboxError::Closed),
            Err(_) => {
                self.observer.on_timeout(&self.actor);
                trace::span_handle(&self.actor, "timeout", self.deadline.as_millis() as u64);
                Err(MailboxError::Timeout)
            }
        }
    }

    pub fn deadline(&self) -> Duration {
        self.deadline
    }
}

```

### crates/ryker/src/observe/metrics.rs
<a id="crates-ryker-src-observe-metrics-rs"></a>

```rust
//! RO:WHAT — Observer trait for mailbox lifecycle signals.
//! RO:WHY  — Allow hosts to increment counters/gauges without pulling prometheus here.
//! RO:INTERACTS — mailbox queue calls hooks on enqueue/drop/timeout/drain.
//! RO:INVARIANTS — must be non-blocking; cheap; thread-safe.

use std::sync::Arc;

#[derive(Clone)]
pub struct NoopObserver;

impl MailboxObserver for NoopObserver {
    fn on_enqueue(&self, _actor: &str, _depth: usize) {}
    fn on_drop(&self, _actor: &str, _reason: DropReason) {}
    fn on_timeout(&self, _actor: &str) {}
    fn on_restart(&self, _actor: &str) {}
}

#[derive(Clone, Copy, Debug)]
pub enum DropReason {
    Capacity,
    Closed,
}

pub trait MailboxObserver: Send + Sync + 'static {
    fn on_enqueue(&self, actor: &str, depth: usize);
    fn on_drop(&self, actor: &str, reason: DropReason);
    fn on_timeout(&self, actor: &str);
    fn on_restart(&self, actor: &str);
}

pub type Observer = Arc<dyn MailboxObserver>;

```

### crates/ryker/src/observe/mod.rs
<a id="crates-ryker-src-observe-mod-rs"></a>

```rust
//! RO:WHAT — Lightweight observability hooks (metrics/tracing integration points).
//! RO:WHY  — Keep ryker decoupled from metrics exporters; host wires Prometheus/OTEL.
//! RO:INTERACTS — mailbox builder/queue calls observer methods; tracing spans are optional.
//! RO:INVARIANTS — no heavy work in hooks; sampling controlled by config.

pub mod metrics;
pub mod trace;

pub use metrics::{MailboxObserver, NoopObserver};

```

### crates/ryker/src/observe/trace.rs
<a id="crates-ryker-src-observe-trace-rs"></a>

```rust
//! RO:WHAT — Optional tracing helpers (no-op without `tracing` feature).
//! RO:WHY  — Keep span names stable per docs; host chooses exporter.
//! RO:INVARIANTS — never log message bodies/PII.

#[inline]
pub fn span_enqueue(actor: &str, depth: usize) {
    #[cfg(feature = "tracing")]
    tracing::trace!(target="ryker", actor=%actor, queue_depth=%depth, "ryker.mailbox.enqueue");
}

#[inline]
pub fn span_handle(actor: &str, outcome: &str, deadline_ms: u64) {
    #[cfg(feature = "tracing")]
    tracing::trace!(target="ryker", actor=%actor, outcome=%outcome, deadline_ms=%deadline_ms, "ryker.actor.handle");
}

#[inline]
pub fn span_config_reload() {
    #[cfg(feature = "tracing")]
    tracing::info!(target = "ryker", "ryker.config.reload");
}

```

### crates/ryker/src/prelude.rs
<a id="crates-ryker-src-prelude-rs"></a>

```rust
//! RO:WHAT — Ergonomic re-exports for common ryker types.
//! RO:WHY  — DX; fewer deep module paths for apps embedding ryker.
//! RO:INTERACTS — re-exports from config, runtime, mailbox, supervisor.
//! RO:INVARIANTS — re-export only stable, documented surface.

pub use crate::config::RykerConfig;
pub use crate::errors::{Error, Result};
pub use crate::mailbox::{Mailbox, MailboxBuilder};
pub use crate::runtime::Runtime;
pub use crate::supervisor::Supervisor;

```

### crates/ryker/src/runtime/mod.rs
<a id="crates-ryker-src-runtime-mod-rs"></a>

```rust
//! RO:WHAT — Runtime facade holding the effective config snapshot.
//! RO:WHY  — Central factory for MailboxBuilder; no global executors.
//! RO:INTERACTS — mailbox builder/queue, observe hooks, config snapshot.
//! RO:INVARIANTS — snapshot immutable via Arc; hosts own task lifetimes.
#![allow(clippy::module_inception)]

mod runtime;

pub use runtime::Runtime;

```

### crates/ryker/src/runtime/runtime.rs
<a id="crates-ryker-src-runtime-runtime-rs"></a>

```rust
//! RO:WHAT — Runtime implementation and mailbox factory methods.
//! RO:WHY  — Host-owned container to spawn mailboxes with per-actor overrides.
//! RO:INTERACTS — config::RykerConfig, mailbox::{Mailbox, MailboxBuilder}.
//! RO:INVARIANTS — never allocates unbounded queues; respects defaults & overrides.

use crate::config::RykerConfig;
use crate::mailbox::{Mailbox, MailboxBuilder};
use std::sync::Arc;

#[derive(Clone)]
pub struct Runtime {
    cfg: Arc<RykerConfig>,
}

impl Runtime {
    pub fn new(cfg: RykerConfig) -> Self {
        Self { cfg: Arc::new(cfg) }
    }

    pub fn mailbox<T>(&self, actor_name: impl Into<String>) -> MailboxBuilder<T> {
        MailboxBuilder::new(actor_name.into(), self.cfg.clone())
    }

    /// Build a mailbox immediately with defaults (no overrides).
    pub fn mailbox_default<T>(&self, actor_name: impl Into<String>) -> Mailbox<T> {
        self.mailbox(actor_name).build()
    }

    /// Access the effective config snapshot.
    pub fn config(&self) -> Arc<RykerConfig> {
        self.cfg.clone()
    }
}

```

### crates/ryker/src/supervisor/backoff.rs
<a id="crates-ryker-src-supervisor-backoff-rs"></a>

```rust
//! RO:WHAT — Decorrelated jitter backoff calculator.
//! RO:WHY  — Avoid lockstep thundering herds; Concerns: RES.
//! RO:INVARIANTS — cap respected; base>0; deterministic bounds.

use rand::{rngs::StdRng, Rng, SeedableRng};

pub fn decorrelated_jitter(base_ms: u64, cap_ms: u64, prev_ms: u64, seed: u64) -> u64 {
    let mut rng = StdRng::seed_from_u64(seed ^ prev_ms);
    let next = (base_ms as f64).max((prev_ms as f64 * 3.0).min(cap_ms as f64));
    let jitter = rng.random_range(base_ms..=next as u64);
    jitter.min(cap_ms)
}

```

### crates/ryker/src/supervisor/mod.rs
<a id="crates-ryker-src-supervisor-mod-rs"></a>

```rust
//! RO:WHAT — Crash-only supervision with jittered backoff.
//! RO:WHY  — Resilience; restarts counted by host metrics via observe hooks.
//! RO:INTERACTS — backoff calc; host spawns async tasks; no global runtime.
//! RO:INVARIANTS — decorrelated jitter; bounded backoff; cancel-safe.
#![allow(clippy::module_inception)]

mod backoff;
mod supervisor;

pub use backoff::decorrelated_jitter;
pub use supervisor::Supervisor;

```

### crates/ryker/src/supervisor/supervisor.rs
<a id="crates-ryker-src-supervisor-supervisor-rs"></a>

```rust
//! RO:WHAT — Supervisor wrapper that restarts an async actor on failure.
//! RO:WHY  — Crash-only philosophy; Concerns: RES; host observes restarts.
//! RO:INTERACTS — config::SupervisionCfg (base/cap/jitter); tracing (optional).
//! RO:INVARIANTS — backoff grows to cap; cancellation cooperative.

use crate::config::RykerConfig;
use crate::supervisor::decorrelated_jitter;
use std::future::Future;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::task::JoinHandle;

pub struct Supervisor {
    cfg: Arc<RykerConfig>,
}

impl Supervisor {
    pub fn new(cfg: Arc<RykerConfig>) -> Self {
        Self { cfg }
    }

    /// Spawn an actor future; if it returns Err or panics, it will be restarted
    /// with decorrelated jitter until cancel() is observed by the actor.
    pub fn spawn<F, Fut>(&self, mut make_actor: F) -> JoinHandle<()>
    where
        F: FnMut() -> Fut + Send + 'static,
        Fut: Future<Output = anyhow::Result<()>> + Send + 'static,
    {
        let cfg = self.cfg.clone();
        tokio::spawn(async move {
            let mut backoff = cfg.supervisor.backoff_base_ms;
            let mut last_fail = Instant::now();
            loop {
                let res = make_actor().await;
                if res.is_ok() {
                    // Normal exit—do not restart.
                    break;
                }
                #[cfg(feature = "tracing")]
                tracing::warn!(target = "ryker", "actor failed; restarting");

                // Compute next delay with decorrelated jitter.
                let seed = last_fail.elapsed().as_millis() as u64;
                backoff = decorrelated_jitter(
                    cfg.supervisor.backoff_base_ms,
                    cfg.supervisor.backoff_cap_ms,
                    backoff,
                    seed,
                );
                tokio::time::sleep(Duration::from_millis(backoff)).await;
                last_fail = Instant::now();
            }
        })
    }
}

```

### crates/ryker/tests/feature_matrix.rs
<a id="crates-ryker-tests-featurematrix-rs"></a>

```rust
/*! Compile-only feature matrix checks (stub). Ensures public surface builds across combos. */

```

### crates/ryker/tests/integration/amnesia.rs
<a id="crates-ryker-tests-integration-amnesia-rs"></a>

```rust
/*! Gate: amnesia zeroize behavior on/off (stub test). */

```

### crates/ryker/tests/integration/backpressure.rs
<a id="crates-ryker-tests-integration-backpressure-rs"></a>

```rust
/*! Gate: full queue -> Busy + dropped_total{reason=capacity} (stub test). */

```

### crates/ryker/tests/integration/config_env_snapshot.rs
<a id="crates-ryker-tests-integration-configenvsnapshot-rs"></a>

```rust
/*! Gate: config precedence & validation (stub test). */

```

### crates/ryker/tests/integration/deadline.rs
<a id="crates-ryker-tests-integration-deadline-rs"></a>

```rust
/*! Gate: deadline -> outcome=timeout in histogram (stub test). */

```

### crates/ryker/tests/integration/metrics_contract.rs
<a id="crates-ryker-tests-integration-metricscontract-rs"></a>

```rust
/*! Gate: metrics contract golden test (stub). Compare to vectors/snapshots/metrics_contract.txt. */

```

### crates/ryker/tests/integration/reload_hot_cold.rs
<a id="crates-ryker-tests-integration-reloadhotcold-rs"></a>

```rust
/*! Gate: hot(deadline/fairness) vs cold(capacity/size) reload semantics (stub test). */

```

### crates/ryker/tests/integration/supervisor_backoff.rs
<a id="crates-ryker-tests-integration-supervisorbackoff-rs"></a>

```rust
/*! Gate: decorrelated jitter bounds + rapid-fail ceiling (stub test). */

```

### crates/ryker/tests/loom/loom_backpressure.rs
<a id="crates-ryker-tests-loom-loombackpressure-rs"></a>

```rust
/*! Loom: deterministic Busy under contention (stub). */

```

### crates/ryker/tests/loom/loom_mailbox_basic.rs
<a id="crates-ryker-tests-loom-loommailboxbasic-rs"></a>

```rust
/*! Loom: N producers -> 1 consumer; no deadlocks; FIFO per mailbox (stub). */

```

### crates/ryker/tests/loom/loom_shutdown.rs
<a id="crates-ryker-tests-loom-loomshutdown-rs"></a>

```rust
/*! Loom: graceful shutdown; cancel-safe; no double-drop (stub). */

```

### crates/ryker/tests/vectors/snapshots/config_snapshot.json
<a id="crates-ryker-tests-vectors-snapshots-configsnapshot-json"></a>

```json
{ "snapshot": true }

```

### crates/ryker/tests/vectors/snapshots/config_snapshot.toml
<a id="crates-ryker-tests-vectors-snapshots-configsnapshot-toml"></a>

```toml
# snapshot placeholder

```

