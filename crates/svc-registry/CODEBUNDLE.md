<!-- Generated by scripts/make_crate_codex.sh on 2025-11-10T22:41:06Z -->
# Code Bundle — `svc-registry`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-registry/.github/workflows/ci.yml](#crates-svc-registry--github-workflows-ci-yml)
- [crates/svc-registry/.github/workflows/perf.yml](#crates-svc-registry--github-workflows-perf-yml)
- [crates/svc-registry/.github/workflows/render-mermaid.yml](#crates-svc-registry--github-workflows-render-mermaid-yml)
- [crates/svc-registry/Cargo.toml](#crates-svc-registry-Cargo-toml)
- [crates/svc-registry/benches/blake3_payload.rs](#crates-svc-registry-benches-blake3payload-rs)
- [crates/svc-registry/benches/verify_approvals.rs](#crates-svc-registry-benches-verifyapprovals-rs)
- [crates/svc-registry/build.rs](#crates-svc-registry-build-rs)
- [crates/svc-registry/fuzz/fuzz_targets/approval_payload.rs](#crates-svc-registry-fuzz-fuzztargets-approvalpayload-rs)
- [crates/svc-registry/fuzz/fuzz_targets/dto_decode.rs](#crates-svc-registry-fuzz-fuzztargets-dtodecode-rs)
- [crates/svc-registry/scripts/perf_sweep.sh](#crates-svc-registry-scripts-perfsweep-sh)
- [crates/svc-registry/scripts/render_mermaid.sh](#crates-svc-registry-scripts-rendermermaid-sh)
- [crates/svc-registry/scripts/run_local.sh](#crates-svc-registry-scripts-runlocal-sh)
- [crates/svc-registry/scripts/smoke_registry.sh](#crates-svc-registry-scripts-smokeregistry-sh)
- [crates/svc-registry/src/auth/macaroon.rs](#crates-svc-registry-src-auth-macaroon-rs)
- [crates/svc-registry/src/auth/uds.rs](#crates-svc-registry-src-auth-uds-rs)
- [crates/svc-registry/src/build_info.rs](#crates-svc-registry-src-buildinfo-rs)
- [crates/svc-registry/src/bus/events.rs](#crates-svc-registry-src-bus-events-rs)
- [crates/svc-registry/src/bus/mod.rs](#crates-svc-registry-src-bus-mod-rs)
- [crates/svc-registry/src/config/default.toml](#crates-svc-registry-src-config-default-toml)
- [crates/svc-registry/src/config/load.rs](#crates-svc-registry-src-config-load-rs)
- [crates/svc-registry/src/config/mod.rs](#crates-svc-registry-src-config-mod-rs)
- [crates/svc-registry/src/config/model.rs](#crates-svc-registry-src-config-model-rs)
- [crates/svc-registry/src/config/reload.rs](#crates-svc-registry-src-config-reload-rs)
- [crates/svc-registry/src/config/validate.rs](#crates-svc-registry-src-config-validate-rs)
- [crates/svc-registry/src/error.rs](#crates-svc-registry-src-error-rs)
- [crates/svc-registry/src/governance/approvals.rs](#crates-svc-registry-src-governance-approvals-rs)
- [crates/svc-registry/src/governance/mod.rs](#crates-svc-registry-src-governance-mod-rs)
- [crates/svc-registry/src/governance/quorum.rs](#crates-svc-registry-src-governance-quorum-rs)
- [crates/svc-registry/src/governance/signer_set.rs](#crates-svc-registry-src-governance-signerset-rs)
- [crates/svc-registry/src/governance/supersede.rs](#crates-svc-registry-src-governance-supersede-rs)
- [crates/svc-registry/src/http/middleware/auth.rs](#crates-svc-registry-src-http-middleware-auth-rs)
- [crates/svc-registry/src/http/middleware/corr_id.rs](#crates-svc-registry-src-http-middleware-corrid-rs)
- [crates/svc-registry/src/http/middleware/limits.rs](#crates-svc-registry-src-http-middleware-limits-rs)
- [crates/svc-registry/src/http/middleware/metrics.rs](#crates-svc-registry-src-http-middleware-metrics-rs)
- [crates/svc-registry/src/http/middleware/timeouts.rs](#crates-svc-registry-src-http-middleware-timeouts-rs)
- [crates/svc-registry/src/http/mod.rs](#crates-svc-registry-src-http-mod-rs)
- [crates/svc-registry/src/http/responses.rs](#crates-svc-registry-src-http-responses-rs)
- [crates/svc-registry/src/http/routes.rs](#crates-svc-registry-src-http-routes-rs)
- [crates/svc-registry/src/http/sse.rs](#crates-svc-registry-src-http-sse-rs)
- [crates/svc-registry/src/interop/dto.rs](#crates-svc-registry-src-interop-dto-rs)
- [crates/svc-registry/src/interop/event_shapes.rs](#crates-svc-registry-src-interop-eventshapes-rs)
- [crates/svc-registry/src/interop/openapi_stub.rs](#crates-svc-registry-src-interop-openapistub-rs)
- [crates/svc-registry/src/lib.rs](#crates-svc-registry-src-lib-rs)
- [crates/svc-registry/src/main.rs](#crates-svc-registry-src-main-rs)
- [crates/svc-registry/src/observability/endpoints.rs](#crates-svc-registry-src-observability-endpoints-rs)
- [crates/svc-registry/src/observability/logging.rs](#crates-svc-registry-src-observability-logging-rs)
- [crates/svc-registry/src/observability/metrics.rs](#crates-svc-registry-src-observability-metrics-rs)
- [crates/svc-registry/src/observability/mod.rs](#crates-svc-registry-src-observability-mod-rs)
- [crates/svc-registry/src/observability/tracing.rs](#crates-svc-registry-src-observability-tracing-rs)
- [crates/svc-registry/src/pipeline/approve.rs](#crates-svc-registry-src-pipeline-approve-rs)
- [crates/svc-registry/src/pipeline/bus_publish.rs](#crates-svc-registry-src-pipeline-buspublish-rs)
- [crates/svc-registry/src/pipeline/checkpoint.rs](#crates-svc-registry-src-pipeline-checkpoint-rs)
- [crates/svc-registry/src/pipeline/commit.rs](#crates-svc-registry-src-pipeline-commit-rs)
- [crates/svc-registry/src/pipeline/deep_verify.rs](#crates-svc-registry-src-pipeline-deepverify-rs)
- [crates/svc-registry/src/pipeline/mod.rs](#crates-svc-registry-src-pipeline-mod-rs)
- [crates/svc-registry/src/pipeline/propose.rs](#crates-svc-registry-src-pipeline-propose-rs)
- [crates/svc-registry/src/pipeline/retention.rs](#crates-svc-registry-src-pipeline-retention-rs)
- [crates/svc-registry/src/pq/mod.rs](#crates-svc-registry-src-pq-mod-rs)
- [crates/svc-registry/src/pq/policy.rs](#crates-svc-registry-src-pq-policy-rs)
- [crates/svc-registry/src/pq/verify_dilithium.rs](#crates-svc-registry-src-pq-verifydilithium-rs)
- [crates/svc-registry/src/pq/verify_falcon.rs](#crates-svc-registry-src-pq-verifyfalcon-rs)
- [crates/svc-registry/src/readiness/gate.rs](#crates-svc-registry-src-readiness-gate-rs)
- [crates/svc-registry/src/result.rs](#crates-svc-registry-src-result-rs)
- [crates/svc-registry/src/shutdown.rs](#crates-svc-registry-src-shutdown-rs)
- [crates/svc-registry/src/storage/checkpoint.rs](#crates-svc-registry-src-storage-checkpoint-rs)
- [crates/svc-registry/src/storage/head.rs](#crates-svc-registry-src-storage-head-rs)
- [crates/svc-registry/src/storage/inmem.rs](#crates-svc-registry-src-storage-inmem-rs)
- [crates/svc-registry/src/storage/log.rs](#crates-svc-registry-src-storage-log-rs)
- [crates/svc-registry/src/storage/mod.rs](#crates-svc-registry-src-storage-mod-rs)
- [crates/svc-registry/src/storage/sled_store.rs](#crates-svc-registry-src-storage-sledstore-rs)
- [crates/svc-registry/src/storage/sqlite_store.rs](#crates-svc-registry-src-storage-sqlitestore-rs)
- [crates/svc-registry/src/storage/types.rs](#crates-svc-registry-src-storage-types-rs)
- [crates/svc-registry/tests/api_commit.rs](#crates-svc-registry-tests-apicommit-rs)
- [crates/svc-registry/tests/chaos_ready.rs](#crates-svc-registry-tests-chaosready-rs)
- [crates/svc-registry/tests/concurrency_loom.rs](#crates-svc-registry-tests-concurrencyloom-rs)
- [crates/svc-registry/tests/http_contract.rs](#crates-svc-registry-tests-httpcontract-rs)
- [crates/svc-registry/tests/invariants.rs](#crates-svc-registry-tests-invariants-rs)
- [crates/svc-registry/tests/metrics_text.rs](#crates-svc-registry-tests-metricstext-rs)
- [crates/svc-registry/tests/storage_monotonic.rs](#crates-svc-registry-tests-storagemonotonic-rs)
- [crates/svc-registry/tests/vectors/approvals_ed25519.json](#crates-svc-registry-tests-vectors-approvalsed25519-json)
- [crates/svc-registry/tests/vectors/approvals_pq_mixed.json](#crates-svc-registry-tests-vectors-approvalspqmixed-json)
- [crates/svc-registry/tests/vectors/descriptor_set_v1.json](#crates-svc-registry-tests-vectors-descriptorsetv1-json)
- [crates/svc-registry/tests/vectors/proposal.json](#crates-svc-registry-tests-vectors-proposal-json)

### crates/svc-registry/.github/workflows/ci.yml
<a id="crates-svc-registry--github-workflows-ci-yml"></a>

```yaml
name: ci (scaffold)
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "CI scaffold (no build steps yet)."

```

### crates/svc-registry/.github/workflows/perf.yml
<a id="crates-svc-registry--github-workflows-perf-yml"></a>

```yaml
name: perf (scaffold)
on:
  schedule:
    - cron: "0 3 * * *"
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "Nightly perf scaffold."

```

### crates/svc-registry/.github/workflows/render-mermaid.yml
<a id="crates-svc-registry--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid (scaffold)
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          for f in $(git ls-files 'crates/svc-registry2/docs/*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out"
          done

```

### crates/svc-registry/Cargo.toml
<a id="crates-svc-registry-Cargo-toml"></a>

```toml
[package]
name = "svc-registry"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[dependencies]
# Workspace pins (exact versions come from the root)
tokio = { workspace = true, features = ["rt-multi-thread", "macros", "signal", "io-util", "time"] }
axum           = { workspace = true, features = ["tokio", "http1", "http2", "json", "matched-path"] }
tower          = { workspace = true, features = ["util", "timeout"] }
tower-http     = { workspace = true, features = ["cors", "limit", "timeout"] }
http           = { workspace = true }
tokio-util     = { workspace = true }
tokio-rustls   = { workspace = true }

tracing            = { workspace = true }
tracing-subscriber = { workspace = true, features = ["env-filter", "fmt", "std", "json"] }
prometheus         = { workspace = true }

serde           = { workspace = true }
serde_json      = { workspace = true }
toml            = { workspace = true }
humantime-serde = { workspace = true }

thiserror    = { workspace = true }
anyhow       = { workspace = true }
bytes        = { workspace = true }
parking_lot  = { workspace = true }
futures      = { workspace = true }
futures-util = { workspace = true }
rand         = { workspace = true }
fastrand     = { workspace = true }

# Needed by corr_id middleware
ulid = "1"

# --- storage + SSE needs (explicit to avoid workspace inherit issues) ---
async-trait  = "0.1.83"
# IMPORTANT: enable 'sync' for BroadcastStream
tokio-stream = { version = "0.1.17", features = ["sync"] }
chrono       = { version = "0.4.38", features = ["serde", "clock"] }

# Intra-workspace crates
ron-kernel   = { path = "../ron-kernel" }
ron-bus      = { path = "../ron-bus" }
ron-metrics  = { path = "../ron-metrics" }
ron-proto    = { path = "../ron-proto" }
ron-policy   = { path = "../ron-policy" }

[build-dependencies]
time = { version = "0.3", features = ["formatting"] }

[dev-dependencies]
# (add test-only deps here when we flesh out benches/tests further)

```

### crates/svc-registry/benches/blake3_payload.rs
<a id="crates-svc-registry-benches-blake3payload-rs"></a>

```rust
// Criterion bench placeholder (scaffold)
fn main() {}

```

### crates/svc-registry/benches/verify_approvals.rs
<a id="crates-svc-registry-benches-verifyapprovals-rs"></a>

```rust
// Criterion bench placeholder (scaffold)
fn main() {}

```

### crates/svc-registry/build.rs
<a id="crates-svc-registry-build-rs"></a>

```rust
// crates/svc-registry/build.rs
use std::process::Command;

fn main() {
    // Re-run if we change this file or git state changes
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs/heads");
    println!("cargo:rerun-if-changed=.git/index");

    // RFC3339 build time (UTC)
    let now = time::OffsetDateTime::now_utc()
        .format(&time::format_description::well_known::Rfc3339)
        .unwrap_or_else(|_| "unknown".to_string());
    println!("cargo:rustc-env=BUILD_TIME_RFC3339={}", now);

    // Full + short commit (best-effort)
    let full = run_git(&["rev-parse", "--verify", "HEAD"]).unwrap_or_else(|| "unknown".into());
    let short = run_git(&["rev-parse", "--short", "HEAD"]).unwrap_or_else(|| "unknown".into());

    // Dirty flag (any uncommitted changes?)
    let dirty = run_git(&["status", "--porcelain"])
        .map(|s| !s.trim().is_empty())
        .unwrap_or(false);
    if dirty {
        println!("cargo:rustc-env=VERGEN_GIT_DIRTY=1");
    }

    // New envs expected by build_info.rs
    println!("cargo:rustc-env=VERGEN_GIT_SHA={}", full);
    println!("cargo:rustc-env=VERGEN_GIT_SHA_SHORT={}", short);

    // Legacy compatibility (you had these before)
    println!("cargo:rustc-env=GIT_COMMIT_HASH={}", full);
    println!("cargo:rustc-env=GIT_COMMIT_SHORT={}", short);
}

fn run_git(args: &[&str]) -> Option<String> {
    let out = Command::new("git").args(args).output().ok()?;
    if !out.status.success() {
        return None;
    }
    let s = String::from_utf8(out.stdout).ok()?;
    Some(s.trim().to_string())
}

```

### crates/svc-registry/fuzz/fuzz_targets/approval_payload.rs
<a id="crates-svc-registry-fuzz-fuzztargets-approvalpayload-rs"></a>

```rust
// cargo-fuzz target placeholder (scaffold)
fn main() {}

```

### crates/svc-registry/fuzz/fuzz_targets/dto_decode.rs
<a id="crates-svc-registry-fuzz-fuzztargets-dtodecode-rs"></a>

```rust
// cargo-fuzz target placeholder (scaffold)
fn main() {}

```

### crates/svc-registry/scripts/perf_sweep.sh
<a id="crates-svc-registry-scripts-perfsweep-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "Perf sweep scaffold — no benches wired yet."

```

### crates/svc-registry/scripts/render_mermaid.sh
<a id="crates-svc-registry-scripts-rendermermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "Rendering mermaid (requires mmdc) ..."
for f in "$(dirname "$0")"/../docs/*.mmd; do
  [ -f "$f" ] || continue
  out="${f%.mmd}.svg"
  mmdc -i "$f" -o "$out"
  echo "Rendered: $out"
done

```

### crates/svc-registry/scripts/run_local.sh
<a id="crates-svc-registry-scripts-runlocal-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "Run-local scaffold for svc-registry2. (No binary logic yet.)"

```

### crates/svc-registry/scripts/smoke_registry.sh
<a id="crates-svc-registry-scripts-smokeregistry-sh"></a>

```bash
#!/usr/bin/env bash
# smoke_registry.sh — one-shot smoke test for svc-registry
# Modes:
#   (default)   — assumes service already running (two-terminal workflow)
#   --spawn     — kills port holders, spawns svc-registry in background, runs checks, then cleans up

set -euo pipefail

ADMIN_ADDR="${ADMIN_ADDR:-127.0.0.1:9909}"
API_ADDR="${API_ADDR:-127.0.0.1:9444}"
RUST_LOG="${RUST_LOG:-info}"
SPAWN=0
if [[ "${1:-}" == "--spawn" ]]; then
  SPAWN=1
fi

# Utilities (macOS-friendly)
die() { echo "[ERR] $*" >&2; exit 1; }
info() { echo "[INFO] $*"; }
ok() { echo "[OK] $*"; }
step() { echo "[STEP] $*"; }

kill_port_holders() {
  local port="$1"
  local pids
  if pids=$(lsof -ti tcp:"$port" 2>/dev/null); then
    if [[ -n "$pids" ]]; then
      info "Port $port busy. Killing holder(s)…"
      # shellcheck disable=SC2086
      kill -9 $pids || true
      sleep 0.2
    fi
  fi
}

wait_for_healthz() {
  local url="$1"
  local retries="${2:-60}" # ~60s max
  local i=0
  info "Waiting for $url ..."
  until curl -sSf -o /dev/null "$url"; do
    ((i++)) || true
    if (( i >= retries )); then
      return 1
    fi
    sleep 1
  done
  ok "$url"
  return 0
}

# ── Metric helpers ──────────────────────────────────────────────────────────────
sum_head_requests() {
  # Sum requests_total counter values for route="/registry/head" across all methods/statuses
  curl -s "http://${ADMIN_ADDR}/metrics" \
  | awk -F' ' '/^requests_total\{.*route="\/registry\/head"/ { v=$NF; gsub(/\r/,"",v); s+=v } END { if (s=="") s=0; print s+0 }'
}

# Globals for --spawn
LOG_FILE="/tmp/svc-registry.log"
SVC_PID=""

spawn_service() {
  kill_port_holders "${ADMIN_ADDR##*:}"
  kill_port_holders "${API_ADDR##*:}"

  info "Spawning svc-registry (cargo run -p svc-registry)"
  : > "$LOG_FILE"
  if command -v setsid >/dev/null 2>&1; then
    RUST_LOG="$RUST_LOG" setsid bash -c 'cargo run -p svc-registry' > "$LOG_FILE" 2>&1 &
  else
    RUST_LOG="$RUST_LOG" bash -c 'cargo run -p svc-registry' > "$LOG_FILE" 2>&1 &
  fi
  SVC_PID="$!"
  info "svc-registry spawned (pid=${SVC_PID}); logs at $LOG_FILE"

  # Robust wait: “listening” log or /healthz 200
  local waited=0
  local max_wait=90
  while (( waited < max_wait )); do
    if grep -q '"message":"listening"' "$LOG_FILE" || grep -q 'listening' "$LOG_FILE"; then
      break
    fi
    if curl -sSf -o /dev/null "http://${ADMIN_ADDR}/healthz"; then
      break
    fi
    sleep 1
    ((waited++)) || true
  done

  if ! curl -sSf -o /dev/null "http://${ADMIN_ADDR}/healthz"; then
    if ! wait_for_healthz "http://${ADMIN_ADDR}/healthz" 10; then
      echo "----- last 120 log lines -----"
      tail -n 120 "$LOG_FILE" || true
      die "svc-registry failed to come up"
    fi
  fi
}

cleanup_spawn() {
  if [[ -n "${SVC_PID:-}" ]]; then
    info "Stopping svc-registry (pid=${SVC_PID})"
    kill -TERM "${SVC_PID}" 2>/dev/null || true
    sleep 0.5
    kill -9 "${SVC_PID}" 2>/dev/null || true
  fi
}

trap '[[ $SPAWN -eq 1 ]] && cleanup_spawn' EXIT

# If requested, spawn the service
if [[ $SPAWN -eq 1 ]]; then
  spawn_service
fi

# ────────────────────────────────────────────────────────────────────────────────
# Admin plane checks
# ────────────────────────────────────────────────────────────────────────────────
step "Admin plane checks"
wait_for_healthz "http://${ADMIN_ADDR}/healthz" 60

# Ready (truthful)
curl -is "http://${ADMIN_ADDR}/readyz" | sed -n '1,5p'
curl -s "http://${ADMIN_ADDR}/readyz" | jq -c . || die "jq required"

# Version
curl -s "http://${ADMIN_ADDR}/version" | jq -c . || die "jq required"

# Metrics (peek)
step "Metrics head (first 25 lines)"
curl -s "http://${ADMIN_ADDR}/metrics" | head -n 25

# ────────────────────────────────────────────────────────────────────────────────
# API: read head, drive some requests to move metrics, then commit
# ────────────────────────────────────────────────────────────────────────────────
step "API: /registry/head (capture current head)"
HEAD_JSON="$(curl -s "http://${API_ADDR}/registry/head")"
echo "HEAD: ${HEAD_JSON}"
HEAD_VER="$(echo "$HEAD_JSON" | jq -r '.version')"

step "Drive a few requests, then assert metrics moved"
before_val="$(sum_head_requests)"
# Hit /registry/head 5x
for _ in 1 2 3 4 5; do curl -s "http://${API_ADDR}/registry/head" >/dev/null; done
sleep 0.2
after_val="$(sum_head_requests)"
echo "[INFO] requests_total value before=${before_val} after=${after_val}"
delta=$(( ${after_val%.*} - ${before_val%.*} ))
if (( delta >= 5 )); then
  echo "✅ metrics advanced by >= 5 (delta=${delta})"
else
  die "requests_total did not advance as expected (delta=${delta})"
fi

# ────────────────────────────────────────────────────────────────────────────────
# SSE: start stream reader, commit, verify bump and event
# ────────────────────────────────────────────────────────────────────────────────
step "SSE smoke: start stream reader (capture a few lines incl. commits)"
SSE_LOG="$(mktemp -t svc-registry-sse.XXXXXX)"
curl -sN "http://${API_ADDR}/registry/stream" > "${SSE_LOG}" 2>&1 &
SSE_PID="$!"
sleep 0.3

step "POST /registry/commit and verify version bump"
RAND="$(LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 16 || echo XxXxXxXxXxXxXxXx)"
RESP="$(curl -s -X POST "http://${API_ADDR}/registry/commit" \
  -H 'content-type: application/json' \
  --data "{\"payload_b3\":\"b3:${RAND}\"}")"
echo "COMMIT RESP: ${RESP}"
NEW_VER="$(echo "$RESP" | jq -r '.version')"
if [[ "$NEW_VER" != "null" ]] && (( NEW_VER == HEAD_VER + 1 )); then
  echo "✅ head.version bumped by +1"
else
  die "commit did not bump version (+1)"
fi

step "Verify /registry/head reflects the new version"
HEAD2="$(curl -s "http://${API_ADDR}/registry/head")"
echo "HEAD NOW: ${HEAD2}"
NEW_HEAD_VER="$(echo "$HEAD2" | jq -r '.version')"
if (( NEW_HEAD_VER == NEW_VER )); then
  echo "✅ /registry/head matches committed version"
else
  die "/registry/head mismatch"
fi

step "Wait briefly and check SSE log for a commit event"
sleep 0.5
kill -TERM "${SSE_PID}" 2>/dev/null || true
sleep 0.2
kill -KILL "${SSE_PID}" 2>/dev/null || true

if grep -q '^event: commit' "${SSE_LOG}"; then
  ok "SSE commit event observed"
else
  echo "----- SSE LOG (tail) -----"
  tail -n 120 "${SSE_LOG}" || true
  die "SSE commit event not observed"
fi

step "SSE heartbeat (optional quick check)"
grep -m1 '^event: heartbeat' "${SSE_LOG}" >/dev/null 2>&1 && echo "event: heartbeat" || true

echo "✅ svc-registry smoke OK"

```

### crates/svc-registry/src/auth/macaroon.rs
<a id="crates-svc-registry-src-auth-macaroon-rs"></a>

```rust
/*! Macaroon verifier (scaffold) */

```

### crates/svc-registry/src/auth/uds.rs
<a id="crates-svc-registry-src-auth-uds-rs"></a>

```rust
/*! UDS peer credential checks (scaffold) */

```

### crates/svc-registry/src/build_info.rs
<a id="crates-svc-registry-src-buildinfo-rs"></a>

```rust
//! RO:WHAT — Canonical build metadata struct and constructor.
//! RO:WHY  — Shared across admin/version and anywhere else needing service build info.
//! RO:INTERACTS — Used by `observability::endpoints::AdminState` and `/version` handler.

use serde::Serialize;

/// Service build metadata returned by `/version`.
#[derive(Clone, Debug, Serialize)]
pub struct BuildInfo {
    pub service: &'static str,
    pub version: &'static str,
    /// Build fingerprint (prefer git SHA; fall back to BLAKE3 or "unknown").
    pub commit: &'static str,
    pub schema: serde_json::Value,
    pub deprecations: Vec<String>,
}

/// Construct the current build info.
/// Priority: VERGEN_GIT_SHA (or GIT_COMMIT_SHA) → RON_BUILD_B3 → "unknown".
pub fn build_info() -> BuildInfo {
    // Prefer standard git SHA if present (via `vergen`, CI export, or custom build.rs).
    let commit = option_env!("VERGEN_GIT_SHA")
        .or(option_env!("GIT_COMMIT_SHA"))
        // Optional: your BLAKE3 fallback from CI/build.rs
        .or(option_env!("RON_BUILD_B3"))
        .unwrap_or("unknown");

    BuildInfo {
        service: "svc-registry",
        version: env!("CARGO_PKG_VERSION"),
        commit,
        schema: serde_json::json!({
            "registry": "1.0.0"
        }),
        deprecations: Vec::new(),
    }
}

```

### crates/svc-registry/src/bus/events.rs
<a id="crates-svc-registry-src-bus-events-rs"></a>

```rust
/*! Event constructors (scaffold) */

```

### crates/svc-registry/src/bus/mod.rs
<a id="crates-svc-registry-src-bus-mod-rs"></a>

```rust
/*! Bus facade (scaffold) */

```

### crates/svc-registry/src/config/default.toml
<a id="crates-svc-registry-src-config-default-toml"></a>

```toml
# svc-registry default configuration (dev-friendly)
bind_addr    = "127.0.0.1:9444"
metrics_addr = "127.0.0.1:9909"
max_conns    = 1024
read_timeout  = "5s"
write_timeout = "5s"
idle_timeout  = "60s"

[storage]
kind     = "sled"
data_dir = "./target/dev-registry"
fsync    = true

[limits]
max_request_bytes = 65536

[timeouts]
request_ms = 5000

[sse]
heartbeat_ms = 5000
max_clients  = 8192
drop_policy  = "lag-drop"

[cors]
# For dev you can keep "*" or replace with exact origins, e.g.:
# allowed_origins = ["http://localhost:5173", "http://127.0.0.1:8080"]
allowed_origins = ["*"]

```

### crates/svc-registry/src/config/load.rs
<a id="crates-svc-registry-src-config-load-rs"></a>

```rust
//! Config loading from env + optional file (TOML). Precedence aligns to docs.
//! Order of precedence (highest → lowest):
//!   1) Explicit function arg `explicit_path`
//!   2) Env var `SVCR_CONFIG_FILE`
//!   3) Workspace default: `crates/svc-registry/config/default.toml` (if exists)
//!   4) Built-in defaults (see `model.rs`)
use super::{model::Config, validate::validate_config};
use std::{env, fs, path::Path};

/// Load config following the documented precedence and apply `SVCR_*` env overrides.
pub fn load_config(explicit_path: Option<&str>) -> anyhow::Result<Config> {
    // 1) explicit path
    let mut cfg = if let Some(path) = explicit_path {
        load_if_exists(path)?.unwrap_or_default()
    } else {
        // 2) env var
        if let Ok(path) = env::var("SVCR_CONFIG_FILE") {
            load_if_exists(&path)?.unwrap_or_default()
        } else {
            // 3) workspace default file (best-effort)
            let default_path = "crates/svc-registry/config/default.toml";
            load_if_exists(default_path)?.unwrap_or_default()
        }
    };

    // 4) apply env overrides (scoped, explicit & bounded)
    apply_env_overrides(&mut cfg);

    validate_config(&cfg)?;
    Ok(cfg)
}

fn load_if_exists(path: &str) -> anyhow::Result<Option<Config>> {
    if Path::new(path).exists() {
        let s = fs::read_to_string(path)?;
        let cfg: Config = toml::from_str(&s)?;
        Ok(Some(cfg))
    } else {
        Ok(None)
    }
}

fn apply_env_overrides(cfg: &mut Config) {
    // Flat keys
    if let Ok(v) = std::env::var("SVCR_BIND_ADDR") {
        cfg.bind_addr = v;
    }
    if let Ok(v) = std::env::var("SVCR_METRICS_ADDR") {
        cfg.metrics_addr = v;
    }
    if let Ok(v) = std::env::var("SVCR_MAX_CONNS") {
        if let Ok(n) = v.parse::<u32>() {
            cfg.max_conns = n;
        }
    }
    if let Ok(v) = std::env::var("SVCR_READ_TIMEOUT") {
        cfg.read_timeout = v;
    }
    if let Ok(v) = std::env::var("SVCR_WRITE_TIMEOUT") {
        cfg.write_timeout = v;
    }
    if let Ok(v) = std::env::var("SVCR_IDLE_TIMEOUT") {
        cfg.idle_timeout = v;
    }

    // Storage
    if let Ok(v) = std::env::var("SVCR_STORAGE__KIND") {
        cfg.storage.kind = v;
    }
    if let Ok(v) = std::env::var("SVCR_STORAGE__DATA_DIR") {
        cfg.storage.data_dir = v;
    }
    if let Ok(v) = std::env::var("SVCR_STORAGE__FSYNC") {
        match v.to_ascii_lowercase().as_str() {
            "1" | "true" | "yes" | "on" => cfg.storage.fsync = true,
            "0" | "false" | "no" | "off" => cfg.storage.fsync = false,
            _ => {}
        }
    }

    // Limits
    if let Ok(v) = std::env::var("SVCR_LIMITS__MAX_REQUEST_BYTES") {
        if let Ok(n) = v.parse::<usize>() {
            cfg.limits.max_request_bytes = n;
        }
    }

    // Timeouts (structured)
    if let Ok(v) = std::env::var("SVCR_TIMEOUTS__REQUEST_MS") {
        if let Ok(n) = v.parse::<u64>() {
            cfg.timeouts.request_ms = n;
        }
    }

    // SSE
    if let Ok(v) = std::env::var("SVCR_SSE__HEARTBEAT_MS") {
        if let Ok(n) = v.parse::<u64>() {
            cfg.sse.heartbeat_ms = n;
        }
    }
    if let Ok(v) = std::env::var("SVCR_SSE__MAX_CLIENTS") {
        if let Ok(n) = v.parse::<usize>() {
            cfg.sse.max_clients = n;
        }
    }
    if let Ok(v) = std::env::var("SVCR_SSE__DROP_POLICY") {
        cfg.sse.drop_policy = v;
    }

    // CORS
    if let Ok(v) = std::env::var("SVCR_CORS__ALLOWED_ORIGINS") {
        // Comma-separated list.
        let list = v
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect::<Vec<_>>();
        if !list.is_empty() {
            cfg.cors.allowed_origins = list;
        }
    }
}

```

### crates/svc-registry/src/config/mod.rs
<a id="crates-svc-registry-src-config-mod-rs"></a>

```rust
//! Config: model + load + validate (+ hot-reload later).
pub mod load;
pub mod model;
pub mod reload;
pub mod validate;

```

### crates/svc-registry/src/config/model.rs
<a id="crates-svc-registry-src-config-model-rs"></a>

```rust
//! Config model and defaults. Env prefix SVCR_.
use serde::{Deserialize, Serialize};

/// Service configuration (beta scope).
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Config {
    // Existing flat fields (kept for compatibility with current bootstrap)
    pub bind_addr: String,
    pub metrics_addr: String,
    pub max_conns: u32,
    pub read_timeout: String,
    pub write_timeout: String,
    pub idle_timeout: String,
    pub storage: Storage,

    // New structured sections (used by HTTP layers, SSE, and CORS).
    #[serde(default)]
    pub limits: Limits,
    #[serde(default)]
    pub timeouts: Timeouts,
    #[serde(default)]
    pub sse: Sse,
    #[serde(default)]
    pub cors: Cors,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Storage {
    pub kind: String, // "sled" | "sqlite" (foundation uses stub)
    pub data_dir: String,
    pub fsync: bool,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(deny_unknown_fields, default)]
pub struct Limits {
    /// Max inbound request body size (bytes)
    pub max_request_bytes: usize,
}

impl Default for Limits {
    fn default() -> Self {
        Self {
            max_request_bytes: 64 * 1024,
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(deny_unknown_fields, default)]
pub struct Timeouts {
    /// Per-request timeout in milliseconds (applied at HTTP layer).
    pub request_ms: u64,
}

impl Default for Timeouts {
    fn default() -> Self {
        Self { request_ms: 5_000 }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(deny_unknown_fields, default)]
pub struct Sse {
    /// Heartbeat interval in milliseconds.
    pub heartbeat_ms: u64,
    /// Max clients (informational; enforcement may be best-effort).
    pub max_clients: usize,
    /// Informational drop policy label (e.g., "lag-drop").
    pub drop_policy: String,
}

impl Default for Sse {
    fn default() -> Self {
        Self {
            heartbeat_ms: 5_000,
            max_clients: 8_192,
            drop_policy: "lag-drop".to_string(),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(deny_unknown_fields, default)]
pub struct Cors {
    /// Exact origins like "http://localhost:5173". Use "*" for permissive dev.
    pub allowed_origins: Vec<String>,
}

impl Default for Cors {
    fn default() -> Self {
        Self {
            allowed_origins: vec!["*".to_string()],
        }
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            bind_addr: "127.0.0.1:9444".into(),
            metrics_addr: "127.0.0.1:9909".into(),
            max_conns: 1024,
            read_timeout: "5s".into(),
            write_timeout: "5s".into(),
            idle_timeout: "60s".into(),
            storage: Storage {
                kind: "sled".into(),
                data_dir: "./target/dev-registry".into(),
                fsync: true,
            },
            limits: Limits::default(),
            timeouts: Timeouts::default(),
            sse: Sse::default(),
            cors: Cors::default(),
        }
    }
}

```

### crates/svc-registry/src/config/reload.rs
<a id="crates-svc-registry-src-config-reload-rs"></a>

```rust
//! Hot-reload stub (wired later to kernel watcher).
pub fn spawn_reloader() {
    // no-op foundation; real file/env watcher lands later
}

```

### crates/svc-registry/src/config/validate.rs
<a id="crates-svc-registry-src-config-validate-rs"></a>

```rust
//! Config validation + normalization.
use super::model::Config;

pub fn validate_config(c: &Config) -> anyhow::Result<()> {
    // existing checks
    if c.max_conns == 0 {
        anyhow::bail!("max_conns must be > 0");
    }
    if !c.bind_addr.contains(':') {
        anyhow::bail!("bind_addr must be host:port");
    }
    if !c.metrics_addr.contains(':') {
        anyhow::bail!("metrics_addr must be host:port");
    }

    // new structured guards (simple sanity; we avoid parsing times here)
    if c.limits.max_request_bytes == 0 {
        anyhow::bail!("limits.max_request_bytes must be > 0");
    }
    if c.timeouts.request_ms == 0 {
        anyhow::bail!("timeouts.request_ms must be > 0");
    }
    if c.sse.heartbeat_ms == 0 {
        anyhow::bail!("sse.heartbeat_ms must be > 0");
    }
    if c.sse.max_clients == 0 {
        anyhow::bail!("sse.max_clients must be > 0");
    }

    Ok(())
}

```

### crates/svc-registry/src/error.rs
<a id="crates-svc-registry-src-error-rs"></a>

```rust
//! Error types (intentionally small public surface). :contentReference[oaicite:10]{index=10}
use thiserror::Error;

/// Service-level error (non-exhaustive to allow additions without SemVer break). :contentReference[oaicite:11]{index=11}
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum Error {
    #[error("configuration: {0}")]
    Config(String),
    #[error("storage: {0}")]
    Storage(String),
    #[error("busy")]
    Busy,
    #[error("unauthorized")]
    Unauthorized,
}

```

### crates/svc-registry/src/governance/approvals.rs
<a id="crates-svc-registry-src-governance-approvals-rs"></a>

```rust
/*! Approval verification (scaffold) */

```

### crates/svc-registry/src/governance/mod.rs
<a id="crates-svc-registry-src-governance-mod-rs"></a>

```rust
/*! Governance facade (scaffold) */

```

### crates/svc-registry/src/governance/quorum.rs
<a id="crates-svc-registry-src-governance-quorum-rs"></a>

```rust
/*! M-of-N quorum evaluation (scaffold) */

```

### crates/svc-registry/src/governance/signer_set.rs
<a id="crates-svc-registry-src-governance-signerset-rs"></a>

```rust
/*! Signer set lifecycle (scaffold) */

```

### crates/svc-registry/src/governance/supersede.rs
<a id="crates-svc-registry-src-governance-supersede-rs"></a>

```rust
/*! Supersede mechanics (scaffold) */

```

### crates/svc-registry/src/http/middleware/auth.rs
<a id="crates-svc-registry-src-http-middleware-auth-rs"></a>

```rust
//! Auth stub (foundation keeps public GETs unauthenticated).
#[derive(Clone, Default)]
pub struct AuthCfg {
    pub enabled: bool,
}

// Placeholder for future macaroon / UDS gating.

```

### crates/svc-registry/src/http/middleware/corr_id.rs
<a id="crates-svc-registry-src-http-middleware-corrid-rs"></a>

```rust
//! Correlation ID middleware (generates if missing).
use axum::{http::Request, response::Response};
use std::task::{Context, Poll};
use tower::{Layer, Service};
use ulid::Ulid;

#[derive(Clone, Default)]
pub struct CorrLayer;

impl CorrLayer {
    pub fn new() -> Self {
        Self
    }
}

impl<S> Layer<S> for CorrLayer {
    type Service = CorrSvc<S>;
    fn layer(&self, inner: S) -> Self::Service {
        CorrSvc { inner }
    }
}

#[derive(Clone)]
pub struct CorrSvc<S> {
    inner: S,
}

impl<S, B> Service<Request<B>> for CorrSvc<S>
where
    S: Service<Request<B>, Response = Response> + Clone,
{
    type Response = Response;
    type Error = S::Error;
    type Future = S::Future;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        // delegate readiness directly; no pinning needed
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, mut req: Request<B>) -> Self::Future {
        const HDR: &str = "X-Corr-ID";
        if !req.headers().contains_key(HDR) {
            let id = Ulid::new().to_string();
            if let Ok(val) = http::HeaderValue::from_str(&id) {
                req.headers_mut().insert(HDR, val);
            }
        }
        self.inner.call(req)
    }
}

```

### crates/svc-registry/src/http/middleware/limits.rs
<a id="crates-svc-registry-src-http-middleware-limits-rs"></a>

```rust
//! Request size limits using Axum's built-in limiter (preserves Response<Body>).

use axum::extract::DefaultBodyLimit;

/// Config for request body size limits.
#[derive(Clone, Copy, Debug)]
pub struct LimitCfg {
    /// Maximum allowed request body in bytes.
    pub max_body_bytes: usize,
}

impl Default for LimitCfg {
    fn default() -> Self {
        // Foundation: small cap; bump later per route if needed.
        Self {
            max_body_bytes: 64 * 1024,
        }
    }
}

/// Build the body-limit layer. Safe to apply at Router::layer with axum 0.7.9.
pub fn limits_layer(cfg: &LimitCfg) -> DefaultBodyLimit {
    DefaultBodyLimit::max(cfg.max_body_bytes)
}

```

### crates/svc-registry/src/http/middleware/metrics.rs
<a id="crates-svc-registry-src-http-middleware-metrics-rs"></a>

```rust
//! Per-route Prometheus metrics middleware.
//! Labels: method, route, status. Also records a per-route latency histogram.

use std::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
    time::Instant,
};

use axum::{http::Request, response::Response};
use tower::{Layer, Service};

use crate::observability::metrics::RegistryMetrics;

#[derive(Clone)]
pub struct MetricsLayer {
    metrics: RegistryMetrics,
}

impl MetricsLayer {
    pub fn new(metrics: RegistryMetrics) -> Self {
        Self { metrics }
    }
}

#[derive(Clone)]
pub struct MetricsSvc<S> {
    inner: S,
    metrics: RegistryMetrics,
}

impl<S> Layer<S> for MetricsLayer {
    type Service = MetricsSvc<S>;
    fn layer(&self, inner: S) -> Self::Service {
        MetricsSvc {
            inner,
            metrics: self.metrics.clone(),
        }
    }
}

impl<S, B> Service<Request<B>> for MetricsSvc<S>
where
    S: Service<Request<B>, Response = Response> + Clone + Send + 'static,
    S::Future: Send + 'static,
    B: Send + 'static,
{
    type Response = Response;
    type Error = S::Error;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        // Capture route and method now; status is read from the response.
        let method = req.method().as_str().to_string();
        // Axum puts the matched path in an extension; fall back to "unmatched".
        let route = req
            .extensions()
            .get::<axum::extract::MatchedPath>()
            .map(|p| p.as_str().to_string())
            .unwrap_or_else(|| "unmatched".to_string());

        let metrics = self.metrics.clone();
        let start = Instant::now();

        let fut = self.inner.call(req);
        Box::pin(async move {
            let resp = fut.await?;
            let status_s = resp.status().as_u16().to_string();

            // Counter (labels: method, route, status) — matches NOTES and RegistryMetrics
            metrics
                .requests_total
                .with_label_values(&[&method, &route, &status_s])
                .inc();

            // Histogram (per route)
            metrics
                .request_latency_seconds
                .with_label_values(&[&route])
                .observe(start.elapsed().as_secs_f64());

            Ok(resp)
        })
    }
}

```

### crates/svc-registry/src/http/middleware/timeouts.rs
<a id="crates-svc-registry-src-http-middleware-timeouts-rs"></a>

```rust
//! Simple overall request timeout (foundation default).
use std::time::Duration;
// CHANGE: use tower_http's TimeoutLayer, not tower::timeout
use tower_http::timeout::TimeoutLayer;

#[derive(Clone)]
pub struct TimeoutCfg {
    pub overall_ms: u64,
}

impl Default for TimeoutCfg {
    fn default() -> Self {
        // Read-mostly service; 5s overall is generous for foundation.
        Self { overall_ms: 5_000 }
    }
}

pub fn timeouts_layer(cfg: &TimeoutCfg) -> TimeoutLayer {
    TimeoutLayer::new(Duration::from_millis(cfg.overall_ms))
}

```

### crates/svc-registry/src/http/mod.rs
<a id="crates-svc-registry-src-http-mod-rs"></a>

```rust
//! HTTP surface (routers, middleware, helpers).
pub mod routes;
pub mod sse;

pub mod middleware {
    pub mod auth;
    pub mod corr_id;
    pub mod limits;
    pub mod metrics;
    pub mod timeouts;
}

pub mod responses;

```

### crates/svc-registry/src/http/responses.rs
<a id="crates-svc-registry-src-http-responses-rs"></a>

```rust
//! Response helpers & error mapping (to be extended as write plane lands).
use axum::{response::IntoResponse, Json};
use http::StatusCode;

pub fn err(status: StatusCode, code: &str, message: &str, corr_id: &str) -> impl IntoResponse {
    let body = serde_json::json!({
        "error": { "code": code, "message": message, "corr_id": corr_id }
    });
    (status, Json(body))
}

```

### crates/svc-registry/src/http/routes.rs
<a id="crates-svc-registry-src-http-routes-rs"></a>

```rust
//! RO:WHAT — API routes: read plane + SSE + commit write path.
//! RO:INVARIANTS — POST /registry/commit monotonic bump; idempotency-by-value left to client.

use std::sync::Arc;

use axum::{
    extract::State,
    response::IntoResponse,
    routing::{get, post},
    Json, Router,
};
use http::StatusCode;
use tower::ServiceBuilder;
use tower_http::cors::{Any, CorsLayer};

use super::middleware::{
    auth::AuthCfg,
    corr_id::CorrLayer,
    limits::{limits_layer, LimitCfg},
    metrics::MetricsLayer,
    timeouts::{timeouts_layer, TimeoutCfg},
};
use super::sse::sse_stream;
use crate::config::model::Config;
use crate::http::responses;
use crate::observability::metrics::RegistryMetrics;
use crate::storage::RegistryStore;

/// Shared application state for HTTP handlers.
#[derive(Clone)]
pub struct AppState {
    pub metrics: RegistryMetrics,
    pub store: Arc<dyn RegistryStore>,

    // Config bits handlers need fast access to:
    pub sse_heartbeat_ms: u64,
}

pub fn registry_routes_with_cfg(
    metrics: RegistryMetrics,
    store: Arc<dyn RegistryStore>,
    cfg: &Config,
) -> Router {
    // Construct auth cfg and *read* a field so it’s not dead code until real auth wired.
    let auth = AuthCfg::default();
    let _auth_enabled = auth.enabled;

    let state = AppState {
        metrics: metrics.clone(),
        store,
        sse_heartbeat_ms: cfg.sse.heartbeat_ms,
    };

    // Build middleware stack in the intended order.
    let limit_cfg = LimitCfg {
        max_body_bytes: cfg.limits.max_request_bytes,
    };
    let timeout_cfg = TimeoutCfg {
        overall_ms: cfg.timeouts.request_ms,
    };

    let cors_layer = build_cors(&cfg.cors.allowed_origins);

    let stack = ServiceBuilder::new()
        .layer(MetricsLayer::new(metrics.clone()))
        .layer(limits_layer(&limit_cfg))
        .layer(timeouts_layer(&timeout_cfg))
        .layer(cors_layer)
        .layer(CorrLayer::new());

    Router::new()
        .route("/registry/head", get(get_head))
        .route("/registry/commit", post(post_commit))
        .route("/registry/stream", get(sse_stream))
        .fallback(|| async { (StatusCode::NOT_FOUND, "not found") })
        .with_state(state)
        .layer(stack)
}

fn build_cors(allowed_origins: &[String]) -> CorsLayer {
    // If "*" present, be permissive (dev)
    if allowed_origins.iter().any(|o| o == "*") {
        return CorsLayer::permissive();
    }
    // Otherwise allow the exact origins provided; if parsing fails, fall back to permissive.
    let mut layer = CorsLayer::new().allow_methods(Any).allow_headers(Any);
    for origin in allowed_origins {
        if let Ok(hv) = http::HeaderValue::from_str(origin) {
            layer = layer.allow_origin(hv);
        }
    }
    layer
}

/// GET /registry/head
async fn get_head(State(st): State<AppState>) -> impl IntoResponse {
    let head = st.store.head().await;
    st.metrics.set_head_version(head.version);
    Json(head)
}

/// POST /registry/commit
#[derive(Debug, serde::Deserialize)]
struct CommitReq {
    /// b3:<base64> payload; validated minimally here.
    payload_b3: String,
}

async fn post_commit(State(st): State<AppState>, Json(req): Json<CommitReq>) -> impl IntoResponse {
    if !req.payload_b3.starts_with("b3:") {
        return responses::err(
            StatusCode::BAD_REQUEST,
            "invalid_payload",
            "payload_b3 must start with 'b3:'",
            "",
        )
        .into_response();
    }

    match st.store.commit(req.payload_b3).await {
        Ok(head) => {
            st.metrics.inc_commit_ok();
            st.metrics.set_head_version(head.version);
            (StatusCode::OK, Json(head)).into_response()
        }
        Err(e) => {
            st.metrics.inc_commit_err();
            responses::err(
                StatusCode::INTERNAL_SERVER_ERROR,
                "commit_failed",
                &e.to_string(),
                "",
            )
            .into_response()
        }
    }
}

```

### crates/svc-registry/src/http/sse.rs
<a id="crates-svc-registry-src-http-sse-rs"></a>

```rust
//! RO:WHAT — Server-Sent Events for registry stream (heartbeat + commit events).
//! RO:INVARIANTS — Heartbeats at configured interval; slow clients are dropped by broadcast.

use std::{convert::Infallible, time::Duration};

use axum::response::sse::{Event, KeepAlive, Sse};
use axum::{extract::State, response::IntoResponse};
use futures_util::stream::Stream;
use tokio_stream::{
    wrappers::IntervalStream,
    StreamExt, // .filter, .map, .merge
};

use crate::http::routes::AppState;

pub async fn sse_stream(State(st): State<AppState>) -> impl IntoResponse {
    st.metrics.sse_client_connected();

    // subscribe() returns BroadcastStream<Result<Head, RecvError>>
    // 1) Synchronous filter keeps only Ok(..)
    // 2) Map Ok(head) -> SSE "commit" Event
    let commits = st.store.subscribe().filter(|res| res.is_ok()).map(|res| {
        // Safe due to the filter above.
        let head = match res {
            Ok(h) => h,
            Err(_) => unreachable!("filtered out Err by .filter(|r| r.is_ok())"),
        };
        let data = serde_json::to_string(&head).unwrap_or_else(|_| "{}".to_string());
        Ok::<Event, Infallible>(Event::default().event("commit").data(data))
    });

    // Heartbeat keepalive (SSE control frame)
    let keepalive = KeepAlive::new()
        .interval(Duration::from_millis(st.sse_heartbeat_ms))
        .text("heartbeat");

    Sse::new(merge_with_heartbeat(commits, st.sse_heartbeat_ms)).keep_alive(keepalive)
}

// Merge commit stream with periodic heartbeat events.
fn merge_with_heartbeat<S>(
    commits: S,
    heartbeat_ms: u64,
) -> impl Stream<Item = Result<Event, Infallible>> + Send
where
    S: Stream<Item = Result<Event, Infallible>> + Send + 'static,
{
    let heartbeats = {
        let interval =
            IntervalStream::new(tokio::time::interval(Duration::from_millis(heartbeat_ms)));
        interval.map(|_| Ok(Event::default().event("heartbeat").data("1")))
    };

    // `.merge` comes from `tokio_stream::StreamExt`
    commits.merge(heartbeats)
}

```

### crates/svc-registry/src/interop/dto.rs
<a id="crates-svc-registry-src-interop-dto-rs"></a>

```rust
/*! ron-proto DTO glue (scaffold) */

```

### crates/svc-registry/src/interop/event_shapes.rs
<a id="crates-svc-registry-src-interop-eventshapes-rs"></a>

```rust
/*! Bus event JSON shapes (scaffold) */

```

### crates/svc-registry/src/interop/openapi_stub.rs
<a id="crates-svc-registry-src-interop-openapistub-rs"></a>

```rust
/*! OpenAPI sync check (scaffold) */

```

### crates/svc-registry/src/lib.rs
<a id="crates-svc-registry-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]
#![deny(clippy::unwrap_used, clippy::expect_used, clippy::await_holding_lock)]
#![allow(missing_docs)]

//! svc-registry — authoritative, append-only registry service (foundation build)

pub mod build_info;
pub mod config;
pub mod error;
pub mod http;
pub mod observability;
pub mod shutdown;
pub mod storage; // <-- new

pub use build_info::BuildInfo;
pub use config::model::Config;
pub use error::Error;
pub use observability::metrics::RegistryMetrics as Metrics;

```

### crates/svc-registry/src/main.rs
<a id="crates-svc-registry-src-main-rs"></a>

```rust
#![deny(clippy::unwrap_used, clippy::expect_used, clippy::await_holding_lock)]

mod build_info;
mod config;
mod http;
mod observability;
mod storage;

use std::{net::SocketAddr, sync::Arc};

use axum::Router;
use ron_kernel::{wait_for_ctrl_c, HealthState};
use tokio::net::TcpListener;
use tracing::info;

use crate::config::load::load_config;
use crate::http::routes::registry_routes_with_cfg;
use crate::observability::endpoints::{admin_router, set_queues_ok, set_services_ok, AdminState};
use crate::observability::tracing::SERVICE_NAME;
use crate::storage::inmem::InMemoryStore;
use crate::storage::RegistryStore; // bring trait into scope for .subscribe()

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Use the shared logger in observability::logging to avoid dead-code.
    crate::observability::logging::init_tracing();

    // Load config (env/file precedence handled in load_config)
    let cfg = load_config(None)?;
    let metrics = crate::observability::metrics::RegistryMetrics::new();
    let health = Arc::new(HealthState::default());

    // Spawn (stub) config reloader so the function isn't dead code.
    crate::config::reload::spawn_reloader();

    // Storage (in-memory for beta); after created, flip services_ok.
    let store = Arc::new(InMemoryStore::new());
    set_services_ok(&health, true);

    // Probe queues by trying a subscribe; on success flip queues_ok.
    {
        let _rx = store.subscribe();
        set_queues_ok(&health, true);
    }

    // Build routers
    let admin = admin_router(AdminState {
        health: health.clone(),
        build: build_info::build_info(),
        metrics: metrics.clone(),
    });
    let api: Router = registry_routes_with_cfg(metrics.clone(), store.clone(), &cfg);

    // Bind (cfg.metrics_addr == admin plane; cfg.bind_addr == public API)
    let admin_addr: SocketAddr = cfg.metrics_addr.parse()?;
    let api_addr: SocketAddr = cfg.bind_addr.parse()?;

    info!(
        service = SERVICE_NAME,
        admin_addr = %admin_addr,
        api_addr = %api_addr,
        "listening"
    );

    let admin_listener = TcpListener::bind(admin_addr).await?;
    let api_listener = TcpListener::bind(api_addr).await?;

    let admin_task = tokio::spawn(async move {
        axum::serve(admin_listener, admin.into_make_service())
            .with_graceful_shutdown(wait_for_ctrl_c())
            .await
            .ok();
    });

    let api_task = tokio::spawn(async move {
        axum::serve(api_listener, api.into_make_service())
            .with_graceful_shutdown(wait_for_ctrl_c())
            .await
            .ok();
    });

    // Wait for either to finish (Ctrl-C triggers graceful shutdown)
    let _ = tokio::join!(admin_task, api_task);

    Ok(())
}

```

### crates/svc-registry/src/observability/endpoints.rs
<a id="crates-svc-registry-src-observability-endpoints-rs"></a>

```rust
//! RO:WHAT — Admin plane endpoints (/metrics, /healthz, /readyz, /version) + readiness gates.
//! RO:WHY  — Truthful SLO surfaces and a simple flip-to-ready mechanism.

use std::sync::Arc;

use axum::{routing::get, Router};
use http::StatusCode;
use ron_kernel::HealthState;

use crate::build_info::BuildInfo;
use crate::observability::metrics::RegistryMetrics;

/// Shared admin-plane state.
#[derive(Clone)]
pub struct AdminState {
    pub health: Arc<HealthState>,
    pub build: BuildInfo,
    pub metrics: RegistryMetrics,
}

// Helpers to flip gates — call from main after init.
pub fn set_services_ok(health: &Arc<HealthState>, ok: bool) {
    health.set("services_ok", ok);
}
pub fn set_queues_ok(health: &Arc<HealthState>, ok: bool) {
    health.set("queues_ok", ok);
}

pub fn admin_router(state: AdminState) -> Router {
    Router::new()
        .route("/healthz", get(healthz))
        .route("/readyz", get(readyz))
        .route("/version", get(version))
        .route("/metrics", get(metrics))
        .with_state(state)
}

async fn healthz() -> impl axum::response::IntoResponse {
    (StatusCode::OK, "")
}

async fn readyz(
    axum::extract::State(st): axum::extract::State<AdminState>,
) -> impl axum::response::IntoResponse {
    let snap = st.health.snapshot();
    let services_ok = snap.get("services_ok").copied().unwrap_or(false);
    let queues_ok = snap.get("queues_ok").copied().unwrap_or(false);
    let ready = services_ok && queues_ok;
    let degraded = !(services_ok && queues_ok);

    let body = serde_json::json!({
        "ready": ready,
        "degraded": degraded,
        "services_ok": services_ok,
        "queues_ok": queues_ok
    });

    if ready {
        (StatusCode::OK, axum::Json(body))
    } else {
        (StatusCode::SERVICE_UNAVAILABLE, axum::Json(body))
    }
}

async fn version(
    axum::extract::State(st): axum::extract::State<AdminState>,
) -> impl axum::response::IntoResponse {
    // Return an owned clone to avoid borrowing state across the response.
    axum::Json(st.build.clone())
}

async fn metrics(
    axum::extract::State(st): axum::extract::State<AdminState>,
) -> impl axum::response::IntoResponse {
    // Use the instance method (fixes E0061 after making gather_text non-static).
    let body = st.metrics.gather_text();
    (StatusCode::OK, body)
}

```

### crates/svc-registry/src/observability/logging.rs
<a id="crates-svc-registry-src-observability-logging-rs"></a>

```rust
//! Tracing/logging init (JSON by default).
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

pub fn init_tracing() {
    let env = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,axum=warn,tower_http=warn,svc_registry=info"));
    let fmt = fmt::layer().json().flatten_event(true).with_target(true);
    tracing_subscriber::registry().with(env).with(fmt).init();
}

```

### crates/svc-registry/src/observability/metrics.rs
<a id="crates-svc-registry-src-observability-metrics-rs"></a>

```rust
//! RO:WHAT — Prometheus metrics for svc-registry.
//! RO:WHY  — Standardized counters/gauges/histograms with bounded label cardinality.
//! RO:INVARIANTS — label keys fixed; route labels reflect templates, not raw paths.
//!
//! Note: registration is made idempotent with a process-global OnceLock so tests
//! can construct multiple RegistryMetrics without "AlreadyReg" panics.

use prometheus::{
    opts, register_gauge, register_histogram_vec, register_int_counter, register_int_counter_vec,
    Encoder, Gauge, HistogramVec, IntCounter, IntCounterVec, TextEncoder,
};
use std::sync::OnceLock;

#[derive(Clone)]
pub struct RegistryMetrics {
    /// HTTP request totals by method/route/status.
    pub requests_total: IntCounterVec,
    /// HTTP request latency histogram by route.
    pub request_latency_seconds: HistogramVec,

    /// Write-path outcomes: {outcome="ok|error"}.
    pub registry_commits_total: IntCounterVec,
    /// Current head version (gauge).
    pub registry_head_version: Gauge,

    /// SSE lifecycle counters.
    pub registry_sse_clients_connected_total: IntCounter,
    pub registry_sse_clients_disconnected_total: IntCounter,
}

static METRICS_ONCE: OnceLock<RegistryMetrics> = OnceLock::new();

impl Default for RegistryMetrics {
    fn default() -> Self {
        Self::new()
    }
}

impl RegistryMetrics {
    /// Return a clone of the singleton metrics set; first caller registers.
    pub fn new() -> Self {
        METRICS_ONCE
            .get_or_init(|| Self::register_all())
            .clone()
    }

    /// Increment commit-success counter.
    pub fn inc_commit_ok(&self) {
        self.registry_commits_total
            .with_label_values(&["ok"])
            .inc();
    }

    /// Increment commit-error counter.
    pub fn inc_commit_err(&self) {
        self.registry_commits_total
            .with_label_values(&["error"])
            .inc();
    }

    /// Update the head-version gauge.
    pub fn set_head_version(&self, v: u64) {
        self.registry_head_version.set(v as f64);
    }

    /// Record an SSE **connect** event.
    pub fn sse_client_connected(&self) {
        self.registry_sse_clients_connected_total.inc();
    }

    /// Record an SSE **disconnect** (hooked post-beta when we have an on-close signal).
    #[allow(dead_code)]
    pub fn sse_client_disconnected(&self) {
        self.registry_sse_clients_disconnected_total.inc();
    }

    /// Gather current metrics into Prometheus text exposition format.
    pub fn gather_text(&self) -> String {
        let mf = prometheus::gather();
        let mut buf = Vec::with_capacity(64 * 1024);
        let encoder = TextEncoder::new();
        let _ = encoder.encode(&mf, &mut buf);
        String::from_utf8_lossy(&buf).into_owned()
    }

    // ---- internals ----

    /// Construct and register all collectors on the default registry once.
    #[allow(clippy::expect_used)]
    fn register_all() -> Self {
        // HTTP
        let requests_total = register_int_counter_vec!(
            opts!(
                "requests_total",
                "HTTP request totals by method/route/status"
            ),
            &["method", "route", "status"]
        )
        .expect("register requests_total");

        let request_latency_seconds = register_histogram_vec!(
            "request_latency_seconds",
            "HTTP request latency (seconds) by route",
            &["route"]
        )
        .expect("register request_latency_seconds");

        // Registry
        let registry_commits_total = register_int_counter_vec!(
            opts!(
                "registry_commits_total",
                "Registry commit outcomes (ok|error)"
            ),
            &["outcome"]
        )
        .expect("register registry_commits_total");

        let registry_head_version =
            register_gauge!("registry_head_version", "Current registry head version")
                .expect("register registry_head_version");

        // SSE lifecycle
        let registry_sse_clients_connected_total = register_int_counter!(
            "registry_sse_clients_connected_total",
            "SSE clients connected (lifetime)"
        )
        .expect("register registry_sse_clients_connected_total");

        let registry_sse_clients_disconnected_total = register_int_counter!(
            "registry_sse_clients_disconnected_total",
            "SSE clients disconnected (lifetime)"
        )
        .expect("register registry_sse_clients_disconnected_total");

        Self {
            requests_total,
            request_latency_seconds,
            registry_commits_total,
            registry_head_version,
            registry_sse_clients_connected_total,
            registry_sse_clients_disconnected_total,
        }
    }
}

```

### crates/svc-registry/src/observability/mod.rs
<a id="crates-svc-registry-src-observability-mod-rs"></a>

```rust
//! Observability: metrics, tracing/logging, and admin endpoints. :contentReference[oaicite:16]{index=16}
pub mod endpoints;
pub mod logging;
pub mod metrics;
pub mod tracing;

```

### crates/svc-registry/src/observability/tracing.rs
<a id="crates-svc-registry-src-observability-tracing-rs"></a>

```rust
//! Extra trace helpers (placeholders for spans/fields).
pub const SERVICE_NAME: &str = "svc-registry";

```

### crates/svc-registry/src/pipeline/approve.rs
<a id="crates-svc-registry-src-pipeline-approve-rs"></a>

```rust
/*! Add approval (scaffold) */

```

### crates/svc-registry/src/pipeline/bus_publish.rs
<a id="crates-svc-registry-src-pipeline-buspublish-rs"></a>

```rust
/*! Publish events non-blocking (scaffold) */

```

### crates/svc-registry/src/pipeline/checkpoint.rs
<a id="crates-svc-registry-src-pipeline-checkpoint-rs"></a>

```rust
/*! Periodic checkpoints (scaffold) */

```

### crates/svc-registry/src/pipeline/commit.rs
<a id="crates-svc-registry-src-pipeline-commit-rs"></a>

```rust
/*! Single-writer commit path (scaffold) */

```

### crates/svc-registry/src/pipeline/deep_verify.rs
<a id="crates-svc-registry-src-pipeline-deepverify-rs"></a>

```rust
/*! Background integrity verification (scaffold) */

```

### crates/svc-registry/src/pipeline/mod.rs
<a id="crates-svc-registry-src-pipeline-mod-rs"></a>

```rust
/*! Pipeline wiring (scaffold) */

```

### crates/svc-registry/src/pipeline/propose.rs
<a id="crates-svc-registry-src-pipeline-propose-rs"></a>

```rust
/*! Accept proposal, enqueue (scaffold) */

```

### crates/svc-registry/src/pipeline/retention.rs
<a id="crates-svc-registry-src-pipeline-retention-rs"></a>

```rust
/*! Retention/pruning (scaffold) */

```

### crates/svc-registry/src/pq/mod.rs
<a id="crates-svc-registry-src-pq-mod-rs"></a>

```rust
/*! PQ posture facade (scaffold) */

```

### crates/svc-registry/src/pq/policy.rs
<a id="crates-svc-registry-src-pq-policy-rs"></a>

```rust
/*! Mixed-quorum policy (scaffold) */

```

### crates/svc-registry/src/pq/verify_dilithium.rs
<a id="crates-svc-registry-src-pq-verifydilithium-rs"></a>

```rust
/*! Dilithium verify adapter (scaffold) */

```

### crates/svc-registry/src/pq/verify_falcon.rs
<a id="crates-svc-registry-src-pq-verifyfalcon-rs"></a>

```rust
/*! Falcon verify adapter (scaffold) */

```

### crates/svc-registry/src/readiness/gate.rs
<a id="crates-svc-registry-src-readiness-gate-rs"></a>

```rust
/*! Readiness aggregator (scaffold) */

```

### crates/svc-registry/src/result.rs
<a id="crates-svc-registry-src-result-rs"></a>

```rust
//! Local Result alias.
pub type Result<T, E = crate::error::Error> = core::result::Result<T, E>;

```

### crates/svc-registry/src/shutdown.rs
<a id="crates-svc-registry-src-shutdown-rs"></a>

```rust
//! Graceful shutdown helpers.
pub async fn graceful_shutdown() {
    tracing::info!("svc-registry shutdown complete");
}

```

### crates/svc-registry/src/storage/checkpoint.rs
<a id="crates-svc-registry-src-storage-checkpoint-rs"></a>

```rust
/*! Durable checkpoints (scaffold) */

```

### crates/svc-registry/src/storage/head.rs
<a id="crates-svc-registry-src-storage-head-rs"></a>

```rust
/*! HEAD snapshot & CAS (scaffold) */

```

### crates/svc-registry/src/storage/inmem.rs
<a id="crates-svc-registry-src-storage-inmem-rs"></a>

```rust
//! RO:WHAT — In-memory RegistryStore implementation with broadcasted commit events.
//! RO:WHY  — Fast foundation path; persistence can plug in later behind feature flags.
//! RO:INTERACTS — storage::RegistryStore trait; http::{routes,sse}.
//! RO:INVARIANTS — Single-writer discipline by &mut on commit path via Mutex gate.

use super::{Head, RegistryEvent, RegistryStore};
use chrono::Utc;
use std::sync::Arc;
use tokio::sync::{broadcast, Mutex, RwLock};
use tokio_stream::wrappers::BroadcastStream;

const BROADCAST_CAPACITY: usize = 1024; // bounded, drops oldest when overrun

#[derive(Clone)]
pub struct InMemoryStore {
    head: Arc<RwLock<Head>>,
    tx: broadcast::Sender<RegistryEvent>,
    // Single-writer commit gate; cheap because commit is tiny.
    writer: Arc<Mutex<()>>,
}

impl InMemoryStore {
    pub fn new() -> Self {
        let (tx, _rx) = broadcast::channel(BROADCAST_CAPACITY);
        let head = Head {
            version: 0,
            payload_b3: "b3:0".to_string(),
            committed_at: None,
        };
        Self {
            head: Arc::new(RwLock::new(head)),
            tx,
            writer: Arc::new(Mutex::new(())),
        }
    }
}

#[async_trait::async_trait]
impl RegistryStore for InMemoryStore {
    async fn head(&self) -> Head {
        self.head.read().await.clone()
    }

    async fn commit(&self, payload_b3: String) -> anyhow::Result<Head> {
        anyhow::ensure!(
            payload_b3.starts_with("b3:"),
            "payload must be base64-with-prefix (b3:..)"
        );

        // Single writer section
        let _guard = self.writer.lock().await;

        // Bump version/commit time
        let mut w = self.head.write().await;
        let new_head = Head {
            version: w.version.saturating_add(1),
            payload_b3,
            committed_at: Some(Utc::now()),
        };
        *w = new_head.clone();

        // Broadcast (best-effort; drop if no one is listening)
        let _ = self.tx.send(RegistryEvent::Commit {
            head: new_head.clone(),
        });

        Ok(new_head)
    }

    fn subscribe(&self) -> BroadcastStream<RegistryEvent> {
        BroadcastStream::new(self.tx.subscribe())
    }
}

impl Default for InMemoryStore {
    fn default() -> Self {
        Self::new()
    }
}

```

### crates/svc-registry/src/storage/log.rs
<a id="crates-svc-registry-src-storage-log-rs"></a>

```rust
/*! Append-only log (scaffold) */

```

### crates/svc-registry/src/storage/mod.rs
<a id="crates-svc-registry-src-storage-mod-rs"></a>

```rust
//! RO:WHAT — Storage facade for svc-registry (trait + in-memory backend).
//! RO:WHY  — Abstracts the read/write plane and the SSE event source.
//! RO:INTERACTS — http::{routes,sse}, observability::metrics, readiness gate.
//! RO:INVARIANTS — Monotonic head.version; subscribe is non-blocking.

pub mod inmem;

use chrono::{DateTime, Utc};
use tokio_stream::wrappers::BroadcastStream;

/// Public head shape returned to clients.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Head {
    pub version: u64,
    pub payload_b3: String,
    pub committed_at: Option<DateTime<Utc>>,
}

/// Internal SSE events exposed by the store.
#[derive(Debug, Clone, serde::Serialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum RegistryEvent {
    // Sent on successful commit with the resulting Head.
    Commit { head: Head },
}

#[async_trait::async_trait]
pub trait RegistryStore: Send + Sync {
    /// RO:WHAT — Fast read of the current head.
    async fn head(&self) -> Head;

    /// RO:WHAT — Commit a new payload; monotonically bumps version and returns new head.
    /// RO:INVARIANTS — version strictly increases; committed_at set to now.
    async fn commit(&self, payload_b3: String) -> anyhow::Result<Head>;

    /// RO:WHAT — Subscribe to store events (commit stream).
    /// RO:WHY  — Feeds SSE; non-blocking broadcast with bounded buffers.
    fn subscribe(&self) -> BroadcastStream<RegistryEvent>;
}

```

### crates/svc-registry/src/storage/sled_store.rs
<a id="crates-svc-registry-src-storage-sledstore-rs"></a>

```rust
/*! Sled backend adapter (scaffold) */

```

### crates/svc-registry/src/storage/sqlite_store.rs
<a id="crates-svc-registry-src-storage-sqlitestore-rs"></a>

```rust
/*! SQLite backend adapter (scaffold) */

```

### crates/svc-registry/src/storage/types.rs
<a id="crates-svc-registry-src-storage-types-rs"></a>

```rust
//! Storage-facing types (DTO-lite).
use serde::{Deserialize, Serialize};

/// The current head of the registry log.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Head {
    /// Monotonic version (0 if empty).
    pub version: u64,
    /// Blake3 of the payload at head (dev: synthesized).
    pub payload_b3: String,
    /// RFC3339 timestamp if committed; null when empty.
    pub committed_at: Option<String>,
}

```

### crates/svc-registry/tests/api_commit.rs
<a id="crates-svc-registry-tests-apicommit-rs"></a>

```rust
use std::sync::Arc;

use axum::{body, http::Request, Router};
use svc_registry::{
    config::model::Config,
    http::routes::registry_routes_with_cfg,
    observability::metrics::RegistryMetrics,
    storage::inmem::InMemoryStore,
};
use tower::util::ServiceExt; // for .oneshot

#[tokio::test]
async fn commit_endpoint_roundtrip_and_body_shape() {
    let metrics = RegistryMetrics::default();
    let store = Arc::new(InMemoryStore::new());
    let cfg = Config::default();
    let api: Router = registry_routes_with_cfg(metrics, store.clone(), &cfg);

    // Commit once
    let req = Request::post("/registry/commit")
        .header("content-type", "application/json")
        .body(axum::body::Body::from(r#"{"payload_b3":"b3:roundtrip"}"#))
        .unwrap();

    let res = api.clone().oneshot(req).await.unwrap();
    assert!(res.status().is_success());
    let body = body::to_bytes(res.into_body(), 1 << 20).await.unwrap();
    let s = String::from_utf8(body.to_vec()).unwrap();
    assert!(s.contains(r#""version":1"#));
    assert!(s.contains(r#""payload_b3":"b3:roundtrip""#));

    // GET head via router to ensure JSON shape is stable
    let res = api
        .oneshot(
            Request::get("/registry/head")
                .body(axum::body::Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    assert!(res.status().is_success());
    let body = body::to_bytes(res.into_body(), 1 << 20).await.unwrap();
    let s = String::from_utf8(body.to_vec()).unwrap();
    assert!(s.contains(r#""version":1"#));
}

```

### crates/svc-registry/tests/chaos_ready.rs
<a id="crates-svc-registry-tests-chaosready-rs"></a>

```rust
// Chaos readiness test placeholder (scaffold)
#[test]
fn chaos_ready_scaffold() {
    assert!(true);
}

```

### crates/svc-registry/tests/concurrency_loom.rs
<a id="crates-svc-registry-tests-concurrencyloom-rs"></a>

```rust
// Loom model placeholder (scaffold)
#[test]
fn loom_scaffold() {
    assert!(true);
}

```

### crates/svc-registry/tests/http_contract.rs
<a id="crates-svc-registry-tests-httpcontract-rs"></a>

```rust
use std::sync::Arc;

use axum::{body, http::Request, Router};
use ron_kernel::HealthState;
use svc_registry::{
    build_info,
    config::model::Config,
    http::routes::registry_routes_with_cfg,
    observability::{
        endpoints::{admin_router, AdminState},
        metrics::RegistryMetrics,
    },
    storage::{inmem::InMemoryStore, RegistryStore},
};
use tower::util::ServiceExt; // for .oneshot

#[tokio::test]
async fn readiness_flips_200_when_gates_true() {
    // Build admin plane and flip gates like main.rs does.
    let metrics = RegistryMetrics::default();
    let health = Arc::new(HealthState::default());
    health.set("services_ok", true);
    health.set("queues_ok", true);

    let admin: Router = admin_router(AdminState {
        health,
        build: build_info::build_info(),
        metrics,
    });

    // GET /readyz -> 200 with our flips
    let res = admin
        .clone()
        .oneshot(Request::get("/readyz").body(axum::body::Body::empty()).unwrap())
        .await
        .unwrap();

    assert!(res.status().is_success());

    // (Optional) also sanity-check /version and /healthz are reachable.
    let v = admin
        .clone()
        .oneshot(Request::get("/version").body(axum::body::Body::empty()).unwrap())
        .await
        .unwrap();
    assert!(v.status().is_success());

    let h = admin
        .oneshot(Request::get("/healthz").body(axum::body::Body::empty()).unwrap())
        .await
        .unwrap();
    assert!(h.status().is_success());
}

#[tokio::test]
async fn commit_bumps_head_and_returns_200() {
    let metrics = RegistryMetrics::default();
    let store = Arc::new(InMemoryStore::new());

    // Minimal config (routes only read the pieces they need)
    let cfg = Config::default();

    // Build API router
    let api: Router = registry_routes_with_cfg(metrics, store.clone(), &cfg);

    // Capture initial head
    let h0 = store.head().await;
    assert_eq!(h0.version, 0);

    // POST /registry/commit
    let req = Request::post("/registry/commit")
        .header("content-type", "application/json")
        .body(axum::body::Body::from(r#"{"payload_b3":"b3:test"}"#))
        .unwrap();

    let res = api.clone().oneshot(req).await.unwrap();
    assert!(res.status().is_success());

    // Head should bump to 1
    let h1 = store.head().await;
    assert_eq!(h1.version, 1);

    // And /registry/head returns the bumped version if we call through the router:
    let res = api
        .oneshot(Request::get("/registry/head").body(axum::body::Body::empty()).unwrap())
        .await
        .unwrap();
    assert!(res.status().is_success());
    let body = body::to_bytes(res.into_body(), 1 << 20).await.unwrap();
    let s = String::from_utf8(body.to_vec()).unwrap();
    assert!(s.contains(r#""version":1"#));
}

```

### crates/svc-registry/tests/invariants.rs
<a id="crates-svc-registry-tests-invariants-rs"></a>

```rust
// Property test placeholder (scaffold)
#[test]
fn invariants_scaffold() {
    assert!(true);
}

```

### crates/svc-registry/tests/metrics_text.rs
<a id="crates-svc-registry-tests-metricstext-rs"></a>

```rust
use std::sync::Arc;

use axum::{body, http::Request, Router};
use ron_kernel::HealthState;
use svc_registry::{
    build_info,
    observability::{
        endpoints::{admin_router, AdminState},
        metrics::RegistryMetrics,
    },
};
use tower::util::ServiceExt; // for .oneshot

#[tokio::test]
async fn metrics_text_includes_registry_counters() {
    // Build admin router with current state.
    let metrics = RegistryMetrics::default();
    let health = Arc::new(HealthState::default());
    let admin: Router = admin_router(AdminState {
        health,
        build: build_info::build_info(),
        metrics: metrics.clone(),
    });

    // GET /metrics
    let res = admin
        .clone()
        .oneshot(Request::get("/metrics").body(axum::body::Body::empty()).unwrap())
        .await
        .unwrap();

    assert!(res.status().is_success());

    // axum::body::to_bytes requires a limit param (bytes cap).
    let bytes = body::to_bytes(res.into_body(), 1 << 20).await.unwrap();
    let s = String::from_utf8(bytes.to_vec()).unwrap();

    // “Must-have” metric names:
    assert!(s.contains("registry_head_version"));
    assert!(s.contains("registry_sse_clients_connected_total"));
    assert!(s.contains("registry_sse_clients_disconnected_total"));
}

```

### crates/svc-registry/tests/storage_monotonic.rs
<a id="crates-svc-registry-tests-storagemonotonic-rs"></a>

```rust
// crates/svc-registry/tests/storage_monotonic.rs
use std::sync::Arc;
use std::time::Duration;

use svc_registry::storage::{inmem::InMemoryStore, RegistryStore};
use tokio::time::timeout;
use tokio_stream::StreamExt; // for .next()

#[tokio::test]
async fn head_is_monotonic_and_events_fire() {
    // Fresh in-memory store
    let store = Arc::new(InMemoryStore::new());

    // Head starts at version 0
    let h0 = store.head().await;
    assert_eq!(h0.version, 0);

    // Subscribe to events as a BroadcastStream
    let mut rx = store.subscribe();

    // Commit #1
    let h1 = store
        .commit("b3:abc".to_string())
        .await
        .expect("commit #1 ok");
    assert_eq!(h1.version, 1);

    // Expect an event within 500 ms
    let evt1 = timeout(Duration::from_millis(500), rx.next())
        .await
        .expect("event delivery timed out");
    assert!(evt1.is_some(), "stream ended unexpectedly");
    // If you want to assert it wasn't an error from channel:
    assert!(evt1.unwrap().is_ok(), "recv error on broadcast stream");

    // Head should now be 1
    let head_now = store.head().await;
    assert_eq!(head_now.version, 1);

    // Commit #2
    let h2 = store
        .commit("b3:def".to_string())
        .await
        .expect("commit #2 ok");
    assert_eq!(h2.version, 2);

    // Another event should arrive
    let evt2 = timeout(Duration::from_millis(500), rx.next())
        .await
        .expect("event delivery timed out (second)");
    assert!(evt2.is_some(), "stream ended unexpectedly (second)");
    assert!(evt2.unwrap().is_ok(), "recv error on broadcast stream (second)");
}

```

### crates/svc-registry/tests/vectors/approvals_ed25519.json
<a id="crates-svc-registry-tests-vectors-approvalsed25519-json"></a>

```json
{ "scaffold": "ed25519 approvals vector placeholder" }

```

### crates/svc-registry/tests/vectors/approvals_pq_mixed.json
<a id="crates-svc-registry-tests-vectors-approvalspqmixed-json"></a>

```json
{ "scaffold": "pq mixed approvals vector placeholder" }

```

### crates/svc-registry/tests/vectors/descriptor_set_v1.json
<a id="crates-svc-registry-tests-vectors-descriptorsetv1-json"></a>

```json
{ "scaffold": "descriptor set v1 placeholder" }

```

### crates/svc-registry/tests/vectors/proposal.json
<a id="crates-svc-registry-tests-vectors-proposal-json"></a>

```json
{ "scaffold": "proposal vector placeholder" }

```

