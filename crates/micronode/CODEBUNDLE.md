<!-- Generated by scripts/make_crate_codex.sh on 2025-11-05T21:24:09Z -->
# Code Bundle — `micronode`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/micronode/.clippy.toml](#crates-micronode--clippy-toml)
- [crates/micronode/.rustfmt.toml](#crates-micronode--rustfmt-toml)
- [crates/micronode/Cargo.toml](#crates-micronode-Cargo-toml)
- [crates/micronode/benches/oap_frame_perf.rs](#crates-micronode-benches-oapframeperf-rs)
- [crates/micronode/benches/pq_overhead.rs](#crates-micronode-benches-pqoverhead-rs)
- [crates/micronode/benches/readiness_walk.rs](#crates-micronode-benches-readinesswalk-rs)
- [crates/micronode/build.rs](#crates-micronode-build-rs)
- [crates/micronode/configs/micronode.amnesia.off.toml](#crates-micronode-configs-micronode-amnesia-off-toml)
- [crates/micronode/configs/micronode.dev.toml](#crates-micronode-configs-micronode-dev-toml)
- [crates/micronode/configs/micronode.pq.required.toml](#crates-micronode-configs-micronode-pq-required-toml)
- [crates/micronode/configs/micronode.pq.toml](#crates-micronode-configs-micronode-pq-toml)
- [crates/micronode/configs/micronode.toml](#crates-micronode-configs-micronode-toml)
- [crates/micronode/deny.toml](#crates-micronode-deny-toml)
- [crates/micronode/examples/quickstart.rs](#crates-micronode-examples-quickstart-rs)
- [crates/micronode/fuzz/config_from_env_fuzz.rs](#crates-micronode-fuzz-configfromenvfuzz-rs)
- [crates/micronode/fuzz/pq_kex_fuzz.rs](#crates-micronode-fuzz-pqkexfuzz-rs)
- [crates/micronode/scripts/chaos_degrade_shed.sh](#crates-micronode-scripts-chaosdegradeshed-sh)
- [crates/micronode/scripts/fs_spy_amnesia.sh](#crates-micronode-scripts-fsspyamnesia-sh)
- [crates/micronode/scripts/gen_diagrams.sh](#crates-micronode-scripts-gendiagrams-sh)
- [crates/micronode/scripts/pq_matrix_ci.sh](#crates-micronode-scripts-pqmatrixci-sh)
- [crates/micronode/scripts/run_dev.sh](#crates-micronode-scripts-rundev-sh)
- [crates/micronode/scripts/smoke_oap_limits.sh](#crates-micronode-scripts-smokeoaplimits-sh)
- [crates/micronode/specs/oap_vectors.json](#crates-micronode-specs-oapvectors-json)
- [crates/micronode/specs/pq_handshake_cases.json](#crates-micronode-specs-pqhandshakecases-json)
- [crates/micronode/src/adapters/index_client.rs](#crates-micronode-src-adapters-indexclient-rs)
- [crates/micronode/src/adapters/mailbox_client.rs](#crates-micronode-src-adapters-mailboxclient-rs)
- [crates/micronode/src/adapters/mod.rs](#crates-micronode-src-adapters-mod-rs)
- [crates/micronode/src/adapters/overlay_client.rs](#crates-micronode-src-adapters-overlayclient-rs)
- [crates/micronode/src/adapters/policy_client.rs](#crates-micronode-src-adapters-policyclient-rs)
- [crates/micronode/src/adapters/storage_client.rs](#crates-micronode-src-adapters-storageclient-rs)
- [crates/micronode/src/app.rs](#crates-micronode-src-app-rs)
- [crates/micronode/src/cli/args.rs](#crates-micronode-src-cli-args-rs)
- [crates/micronode/src/cli/mod.rs](#crates-micronode-src-cli-mod-rs)
- [crates/micronode/src/cli/run.rs](#crates-micronode-src-cli-run-rs)
- [crates/micronode/src/concurrency/backpressure.rs](#crates-micronode-src-concurrency-backpressure-rs)
- [crates/micronode/src/concurrency/mod.rs](#crates-micronode-src-concurrency-mod-rs)
- [crates/micronode/src/concurrency/registry.rs](#crates-micronode-src-concurrency-registry-rs)
- [crates/micronode/src/concurrency/shutdown.rs](#crates-micronode-src-concurrency-shutdown-rs)
- [crates/micronode/src/config/cli_overlay.rs](#crates-micronode-src-config-clioverlay-rs)
- [crates/micronode/src/config/env_overlay.rs](#crates-micronode-src-config-envoverlay-rs)
- [crates/micronode/src/config/hot_reload.rs](#crates-micronode-src-config-hotreload-rs)
- [crates/micronode/src/config/load.rs](#crates-micronode-src-config-load-rs)
- [crates/micronode/src/config/mod.rs](#crates-micronode-src-config-mod-rs)
- [crates/micronode/src/config/schema.rs](#crates-micronode-src-config-schema-rs)
- [crates/micronode/src/config/validate.rs](#crates-micronode-src-config-validate-rs)
- [crates/micronode/src/errors.rs](#crates-micronode-src-errors-rs)
- [crates/micronode/src/facets/feed.rs](#crates-micronode-src-facets-feed-rs)
- [crates/micronode/src/facets/graph.rs](#crates-micronode-src-facets-graph-rs)
- [crates/micronode/src/facets/media.rs](#crates-micronode-src-facets-media-rs)
- [crates/micronode/src/facets/mod.rs](#crates-micronode-src-facets-mod-rs)
- [crates/micronode/src/facets/search.rs](#crates-micronode-src-facets-search-rs)
- [crates/micronode/src/http/admin.rs](#crates-micronode-src-http-admin-rs)
- [crates/micronode/src/http/mod.rs](#crates-micronode-src-http-mod-rs)
- [crates/micronode/src/http/routes.rs](#crates-micronode-src-http-routes-rs)
- [crates/micronode/src/layers/body_cap.rs](#crates-micronode-src-layers-bodycap-rs)
- [crates/micronode/src/layers/concurrency.rs](#crates-micronode-src-layers-concurrency-rs)
- [crates/micronode/src/layers/decode_guard.rs](#crates-micronode-src-layers-decodeguard-rs)
- [crates/micronode/src/layers/mod.rs](#crates-micronode-src-layers-mod-rs)
- [crates/micronode/src/lib.rs](#crates-micronode-src-lib-rs)
- [crates/micronode/src/limits.rs](#crates-micronode-src-limits-rs)
- [crates/micronode/src/main.rs](#crates-micronode-src-main-rs)
- [crates/micronode/src/observability/health.rs](#crates-micronode-src-observability-health-rs)
- [crates/micronode/src/observability/http_metrics.rs](#crates-micronode-src-observability-httpmetrics-rs)
- [crates/micronode/src/observability/logging.rs](#crates-micronode-src-observability-logging-rs)
- [crates/micronode/src/observability/metrics.rs](#crates-micronode-src-observability-metrics-rs)
- [crates/micronode/src/observability/mod.rs](#crates-micronode-src-observability-mod-rs)
- [crates/micronode/src/observability/ready.rs](#crates-micronode-src-observability-ready-rs)
- [crates/micronode/src/observability/version.rs](#crates-micronode-src-observability-version-rs)
- [crates/micronode/src/security/amnesia.rs](#crates-micronode-src-security-amnesia-rs)
- [crates/micronode/src/security/auth_macaroon.rs](#crates-micronode-src-security-authmacaroon-rs)
- [crates/micronode/src/security/mod.rs](#crates-micronode-src-security-mod-rs)
- [crates/micronode/src/security/pq_config.rs](#crates-micronode-src-security-pqconfig-rs)
- [crates/micronode/src/security/pq_observe.rs](#crates-micronode-src-security-pqobserve-rs)
- [crates/micronode/src/security/pq_toggle.rs](#crates-micronode-src-security-pqtoggle-rs)
- [crates/micronode/src/security/tls_rustls.rs](#crates-micronode-src-security-tlsrustls-rs)
- [crates/micronode/src/state.rs](#crates-micronode-src-state-rs)
- [crates/micronode/src/types.rs](#crates-micronode-src-types-rs)
- [crates/micronode/tests/admin_parity.rs](#crates-micronode-tests-adminparity-rs)
- [crates/micronode/tests/amnesia_proof.rs](#crates-micronode-tests-amnesiaproof-rs)
- [crates/micronode/tests/backpressure.rs](#crates-micronode-tests-backpressure-rs)
- [crates/micronode/tests/facets_proxy.rs](#crates-micronode-tests-facetsproxy-rs)
- [crates/micronode/tests/oap_limits.rs](#crates-micronode-tests-oaplimits-rs)
- [crates/micronode/tests/pq_fallback.rs](#crates-micronode-tests-pqfallback-rs)
- [crates/micronode/tests/pq_modes.rs](#crates-micronode-tests-pqmodes-rs)
- [crates/micronode/tests_chaos/degrade_shed.rs](#crates-micronode-testschaos-degradeshed-rs)
- [crates/micronode/tests_loom/shutdown_interleavings.rs](#crates-micronode-testsloom-shutdowninterleavings-rs)
- [crates/micronode/tests_property/oap_fuzz.rs](#crates-micronode-testsproperty-oapfuzz-rs)
- [crates/micronode/tests_property/pq_handshake_props.rs](#crates-micronode-testsproperty-pqhandshakeprops-rs)

### crates/micronode/.clippy.toml
<a id="crates-micronode--clippy-toml"></a>

```toml
# Minimal, valid Clippy config (use only supported keys)
cognitive-complexity-threshold = 35
too-many-lines-threshold = 400

```

### crates/micronode/.rustfmt.toml
<a id="crates-micronode--rustfmt-toml"></a>

```toml
max_width = 100
use_small_heuristics = "Max"
# Keep stable-only options here; nightly-only options (like format_code_in_doc_comments) are removed.

```

### crates/micronode/Cargo.toml
<a id="crates-micronode-Cargo-toml"></a>

```toml
[package]
name = "micronode"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false
build = "build.rs"

[lib]
name = "micronode"
path = "src/lib.rs"

[[bin]]
name = "micronode"
path = "src/main.rs"

[features]
default = []

[dependencies]
# RON workspace crates
ron-kernel = { path = "../ron-kernel" }
ron-proto  = { path = "../ron-proto" }
oap        = { path = "../oap" }

# Async/HTTP stack (workspace-standard pins)
tokio       = { version = "1", features = ["macros", "rt-multi-thread", "signal", "time", "io-util", "sync", "net", "fs"] }
axum        = { version = "0.7", default-features = false, features = ["tokio", "http1", "http2", "json"] }
tower       = "0.5"
tower-http  = { version = "0.6.6", features = ["trace"] }
http        = "1"

# Obs & logging
tracing            = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus         = "0.14"

# Config & serde
serde       = { version = "1.0", features = ["derive"] }
serde_json  = "1"
toml        = "0.8"
humantime-serde = "1"
anyhow      = "1.0"
thiserror   = "1.0"

# Utilities
parking_lot = "0.12"

[dev-dependencies]
reqwest = { version = "0.12", features = ["rustls-tls-native-roots", "json"] }

```

### crates/micronode/benches/oap_frame_perf.rs
<a id="crates-micronode-benches-oapframeperf-rs"></a>

```rust


```

### crates/micronode/benches/pq_overhead.rs
<a id="crates-micronode-benches-pqoverhead-rs"></a>

```rust


```

### crates/micronode/benches/readiness_walk.rs
<a id="crates-micronode-benches-readinesswalk-rs"></a>

```rust


```

### crates/micronode/build.rs
<a id="crates-micronode-build-rs"></a>

```rust
// RO:WHAT — build script that stamps a UNIX build time for /version.
// RO:WHY  — Observability/versioning; helps triage running binaries.
// RO:INVARIANTS — Emits MICRONODE_BUILD_UNIX env var always.
fn main() {
    println!("cargo:rustc-env=MICRONODE_BUILD_UNIX={}", chrono_unix());
}

fn chrono_unix() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_secs().to_string())
        .unwrap_or_else(|_| "0".to_string())
}

```

### crates/micronode/configs/micronode.amnesia.off.toml
<a id="crates-micronode-configs-micronode-amnesia-off-toml"></a>

```toml

```

### crates/micronode/configs/micronode.dev.toml
<a id="crates-micronode-configs-micronode-dev-toml"></a>

```toml

```

### crates/micronode/configs/micronode.pq.required.toml
<a id="crates-micronode-configs-micronode-pq-required-toml"></a>

```toml

```

### crates/micronode/configs/micronode.pq.toml
<a id="crates-micronode-configs-micronode-pq-toml"></a>

```toml

```

### crates/micronode/configs/micronode.toml
<a id="crates-micronode-configs-micronode-toml"></a>

```toml
# RO:WHAT — Default dev config for Micronode
# RO:WHY  — Makes `cargo run -p micronode` work out-of-the-box.

[server]
bind = "127.0.0.1:5310"
dev_routes = true

```

### crates/micronode/deny.toml
<a id="crates-micronode-deny-toml"></a>

```toml
[advisories]
yanked = "deny"
unmaintained = "deny"
vulnerability = "deny"

[licenses]
allow = ["MIT", "Apache-2.0"]

```

### crates/micronode/examples/quickstart.rs
<a id="crates-micronode-examples-quickstart-rs"></a>

```rust


```

### crates/micronode/fuzz/config_from_env_fuzz.rs
<a id="crates-micronode-fuzz-configfromenvfuzz-rs"></a>

```rust

```

### crates/micronode/fuzz/pq_kex_fuzz.rs
<a id="crates-micronode-fuzz-pqkexfuzz-rs"></a>

```rust

```

### crates/micronode/scripts/chaos_degrade_shed.sh
<a id="crates-micronode-scripts-chaosdegradeshed-sh"></a>

```bash

```

### crates/micronode/scripts/fs_spy_amnesia.sh
<a id="crates-micronode-scripts-fsspyamnesia-sh"></a>

```bash

```

### crates/micronode/scripts/gen_diagrams.sh
<a id="crates-micronode-scripts-gendiagrams-sh"></a>

```bash

```

### crates/micronode/scripts/pq_matrix_ci.sh
<a id="crates-micronode-scripts-pqmatrixci-sh"></a>

```bash

```

### crates/micronode/scripts/run_dev.sh
<a id="crates-micronode-scripts-rundev-sh"></a>

```bash

```

### crates/micronode/scripts/smoke_oap_limits.sh
<a id="crates-micronode-scripts-smokeoaplimits-sh"></a>

```bash

```

### crates/micronode/specs/oap_vectors.json
<a id="crates-micronode-specs-oapvectors-json"></a>

```json

```

### crates/micronode/specs/pq_handshake_cases.json
<a id="crates-micronode-specs-pqhandshakecases-json"></a>

```json

```

### crates/micronode/src/adapters/index_client.rs
<a id="crates-micronode-src-adapters-indexclient-rs"></a>

```rust

```

### crates/micronode/src/adapters/mailbox_client.rs
<a id="crates-micronode-src-adapters-mailboxclient-rs"></a>

```rust

```

### crates/micronode/src/adapters/mod.rs
<a id="crates-micronode-src-adapters-mod-rs"></a>

```rust

```

### crates/micronode/src/adapters/overlay_client.rs
<a id="crates-micronode-src-adapters-overlayclient-rs"></a>

```rust

```

### crates/micronode/src/adapters/policy_client.rs
<a id="crates-micronode-src-adapters-policyclient-rs"></a>

```rust

```

### crates/micronode/src/adapters/storage_client.rs
<a id="crates-micronode-src-adapters-storageclient-rs"></a>

```rust

```

### crates/micronode/src/app.rs
<a id="crates-micronode-src-app-rs"></a>

```rust
//! RO:WHAT — Router assembly for Micronode.
//! RO:WHY  — Central composition point for routes and layers.
//! RO:INVARIANTS — outer: tracing; per-route caps first. No ambient authority.

use crate::{
    config::schema::Config,
    http::{admin, routes},
    layers::{self, body_cap::BodyCapLayer, concurrency::ConcurrencyLayer},
    limits::HTTP_BODY_CAP_BYTES,
    state::AppState,
};
use axum::{middleware, routing::get, Router};
use std::sync::Arc;
use tokio::sync::Semaphore;
use tower_http::trace::TraceLayer;

pub fn build_router(cfg: Config) -> (Router, AppState) {
    let st = AppState::new(cfg.clone());

    // --- Admin plane ---
    let admin_routes = Router::new()
        .route("/healthz", get(admin::healthz))
        .route("/readyz", get(admin::readyz))
        .route("/version", get(admin::version))
        .route("/metrics", get(admin::metrics));

    // --- Dev plane (guarded route) ---
    let dev = if st.cfg.server.dev_routes {
        let echo_conc = Arc::new(Semaphore::new(256)); // default per-route cap

        Router::new().route(
            "/dev/echo",
            axum::routing::post(routes::dev::echo)
                // Order matters: decode policy -> body cap -> concurrency
                .layer(middleware::from_fn(layers::decode_guard::guard))
                .layer(BodyCapLayer::new(HTTP_BODY_CAP_BYTES))
                .layer(ConcurrencyLayer::new(echo_conc)),
        )
    } else {
        Router::new()
    };

    // --- Feature routes (expand later) ---
    let api_v1 = Router::new().route("/ping", get(routes::ping));

    let router = Router::new()
        .merge(admin_routes)
        .nest("/v1", api_v1)
        .merge(dev)
        .with_state(st.clone())
        .layer(TraceLayer::new_for_http());

    (router, st)
}

```

### crates/micronode/src/cli/args.rs
<a id="crates-micronode-src-cli-args-rs"></a>

```rust

```

### crates/micronode/src/cli/mod.rs
<a id="crates-micronode-src-cli-mod-rs"></a>

```rust

```

### crates/micronode/src/cli/run.rs
<a id="crates-micronode-src-cli-run-rs"></a>

```rust

```

### crates/micronode/src/concurrency/backpressure.rs
<a id="crates-micronode-src-concurrency-backpressure-rs"></a>

```rust

```

### crates/micronode/src/concurrency/mod.rs
<a id="crates-micronode-src-concurrency-mod-rs"></a>

```rust

```

### crates/micronode/src/concurrency/registry.rs
<a id="crates-micronode-src-concurrency-registry-rs"></a>

```rust

```

### crates/micronode/src/concurrency/shutdown.rs
<a id="crates-micronode-src-concurrency-shutdown-rs"></a>

```rust

```

### crates/micronode/src/config/cli_overlay.rs
<a id="crates-micronode-src-config-clioverlay-rs"></a>

```rust
//! RO:WHAT — Placeholder for CLI-overlay support (kept for tree parity).
//! RO:WHY  — Future: clap/argp integration without bloating foundation.

pub fn _apply_cli_overlays() {
    // Intentionally empty for foundation cut.
}

```

### crates/micronode/src/config/env_overlay.rs
<a id="crates-micronode-src-config-envoverlay-rs"></a>

```rust
//! RO:WHAT — Placeholder for richer env overlays (kept for tree parity).
//! RO:WHY  — Your TODO tree references this module explicitly.

pub fn _apply_env_overlays() {
    // Intentionally empty for foundation cut.
}

```

### crates/micronode/src/config/hot_reload.rs
<a id="crates-micronode-src-config-hotreload-rs"></a>

```rust
//! RO:WHAT — Placeholder for config hot-reload (notify-based).
//! RO:WHY  — Wire later; keep module present so imports won't break.

pub fn _spawn_config_watcher() {
    // Intentionally empty for foundation cut.
}

```

### crates/micronode/src/config/load.rs
<a id="crates-micronode-src-config-load-rs"></a>

```rust
//! RO:WHAT — Load config from file and env overlays (foundation).
//! RO:WHY  — Keep main.rs tiny; centralized error handling.
//! RO:INVARIANTS — File is optional; env can fully drive defaults.

use super::{schema::Config, validate::validate};
use crate::errors::{Error, Result};
use std::{env, fs, path::PathBuf};

pub fn load_config() -> Result<Config> {
    let mut cfg = Config::default();

    // Optional file: MICRONODE_CONFIG or ./configs/micronode.toml
    if let Some(path) = env::var_os("MICRONODE_CONFIG") {
        overlay_file(&mut cfg, PathBuf::from(path))?;
    } else {
        let p = PathBuf::from("crates/micronode/configs/micronode.toml");
        if p.exists() {
            overlay_file(&mut cfg, p)?;
        }
    }

    // Env overlays
    overlay_env(&mut cfg)?;

    validate(&cfg)?;
    Ok(cfg)
}

fn overlay_file(cfg: &mut Config, path: PathBuf) -> Result<()> {
    let s =
        fs::read_to_string(&path).map_err(|e| Error::Config(format!("read {:?}: {e}", path)))?;
    let from: Config =
        toml::from_str(&s).map_err(|e| Error::Config(format!("parse {:?}: {e}", path)))?;
    *cfg = merge(cfg.clone(), from);
    Ok(())
}

fn overlay_env(cfg: &mut Config) -> Result<()> {
    if let Ok(addr) = std::env::var("BIND_ADDR") {
        cfg.server.bind =
            addr.parse().map_err(|e| Error::Config(format!("BIND_ADDR parse: {e}")))?;
    }
    if let Ok(v) = std::env::var("MICRONODE_DEV_ROUTES") {
        cfg.server.dev_routes = matches!(v.as_str(), "1" | "true" | "TRUE" | "on" | "ON");
    }
    Ok(())
}

fn merge(mut base: Config, from: Config) -> Config {
    base.server.bind = from.server.bind;
    base.server.dev_routes = from.server.dev_routes;
    base
}

```

### crates/micronode/src/config/mod.rs
<a id="crates-micronode-src-config-mod-rs"></a>

```rust
//! RO:WHAT — Config module root.
//! RO:WHY  — Schema + loaders + validation + overlays (env/CLI).
pub mod cli_overlay;
pub mod env_overlay;
pub mod hot_reload;
pub mod load;
pub mod schema;
pub mod validate;

```

### crates/micronode/src/config/schema.rs
<a id="crates-micronode-src-config-schema-rs"></a>

```rust
//! RO:WHAT — Micronode config schema and defaults.
//! RO:WHY  — Deterministic config with sane hardening defaults.
//! RO:INVARIANTS — Defaults truthful; amnesia honored at higher layers later.

use serde::Deserialize;
use std::net::SocketAddr;

#[derive(Debug, Clone, Deserialize)]
pub struct Config {
    pub server: Server,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Server {
    pub bind: SocketAddr,
    pub dev_routes: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            server: Server {
                bind: "127.0.0.1:5310".parse().expect("default bind"),
                dev_routes: false,
            },
        }
    }
}

```

### crates/micronode/src/config/validate.rs
<a id="crates-micronode-src-config-validate-rs"></a>

```rust
//! RO:WHAT — Config validation.
//! RO:WHY  — Ship fast fail messages before boot.
//! RO:INVARIANTS — Deterministic; no IO.

use super::schema::Config;
use crate::errors::{Error, Result};

pub fn validate(cfg: &Config) -> Result<()> {
    // Minimal baseline; expand with limits/policies later.
    if cfg.server.bind.port() == 0 {
        return Err(Error::Config("bind port must be non-zero".into()));
    }
    Ok(())
}

```

### crates/micronode/src/errors.rs
<a id="crates-micronode-src-errors-rs"></a>

```rust
//! RO:WHAT — Error types for Micronode (foundation).
//! RO:WHY  — Stable envelopes and anyhow interop.
//! RO:INVARIANTS — Avoid leaking secrets; messages deterministic for SDKs.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("config: {0}")]
    Config(String),
    #[error("internal error")]
    Internal,
}

pub type Result<T> = std::result::Result<T, Error>;

```

### crates/micronode/src/facets/feed.rs
<a id="crates-micronode-src-facets-feed-rs"></a>

```rust

```

### crates/micronode/src/facets/graph.rs
<a id="crates-micronode-src-facets-graph-rs"></a>

```rust

```

### crates/micronode/src/facets/media.rs
<a id="crates-micronode-src-facets-media-rs"></a>

```rust

```

### crates/micronode/src/facets/mod.rs
<a id="crates-micronode-src-facets-mod-rs"></a>

```rust

```

### crates/micronode/src/facets/search.rs
<a id="crates-micronode-src-facets-search-rs"></a>

```rust

```

### crates/micronode/src/http/admin.rs
<a id="crates-micronode-src-http-admin-rs"></a>

```rust
//! RO:WHAT — Admin plane: /metrics, /healthz, /readyz, /version.
//! RO:WHY  — Golden surfaces; shared by all RON services.
//! RO:INVARIANTS — Truthful readyz; explicit dev override in handler.

use crate::{observability, state::AppState};
use axum::{extract::State, http::StatusCode, response::IntoResponse};
use prometheus::{Encoder, TextEncoder};

pub async fn metrics(_: State<AppState>) -> impl IntoResponse {
    let families = prometheus::gather();
    let mut buf = Vec::new();
    let _ = TextEncoder::new().encode(&families, &mut buf);
    (StatusCode::OK, buf)
}

pub async fn healthz() -> impl IntoResponse {
    observability::health::handler().await
}

pub async fn readyz(State(st): State<AppState>) -> impl IntoResponse {
    observability::ready::handler(st.probes.clone()).await
}

pub async fn version() -> impl IntoResponse {
    observability::version::handler().await
}

```

### crates/micronode/src/http/mod.rs
<a id="crates-micronode-src-http-mod-rs"></a>

```rust
//! RO:WHAT — HTTP handlers (admin + basic routes + dev).
//! RO:WHY  — Keep app.rs readable.

pub mod admin;
pub mod routes;

pub mod dev {
    pub use super::routes::dev::echo;
}

```

### crates/micronode/src/http/routes.rs
<a id="crates-micronode-src-http-routes-rs"></a>

```rust
//! RO:WHAT — Public and dev routes for Micronode.

use axum::{http::StatusCode, Json};
use serde_json::{json, Value};

// --- /v1/ping ---
pub async fn ping() -> Json<Value> {
    Json(json!({ "pong": true }))
}

// --- /dev/echo ---
// Echoes JSON payload deterministically. Requires Content-Type: application/json
// and (by policy) Content-Length (enforced by BodyCap layer).
pub mod dev {
    use super::*;
    use axum::response::IntoResponse;

    /// Echo JSON back; reject non-JSON early.
    pub async fn echo(Json(body): Json<Value>) -> impl IntoResponse {
        (StatusCode::OK, Json(body))
    }
}

```

### crates/micronode/src/layers/body_cap.rs
<a id="crates-micronode-src-layers-bodycap-rs"></a>

```rust
//! RO:WHAT — Body cap guard as a Tower Layer (early 413/411).
//! RO:WHY  — Avoid buffering/unbounded decode; deterministic hot rejects.
//! RO:AXUM — Implemented as `Layer + Service<Request<Body>>` to satisfy Axum 0.7 bounds.

use axum::{
    body::Body,
    http::{header, Request, StatusCode},
    response::{IntoResponse, Response},
};
use std::{
    convert::Infallible,
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};
use tower::{Layer, Service};

type BoxFut = Pin<Box<dyn Future<Output = Result<Response, Infallible>> + Send + 'static>>;

#[derive(Clone, Copy)]
pub struct BodyCapLayer {
    cap_bytes: usize,
}

impl BodyCapLayer {
    pub fn new(cap_bytes: usize) -> Self {
        Self { cap_bytes }
    }
}

impl<S> Layer<S> for BodyCapLayer {
    type Service = BodyCapService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        BodyCapService { inner, cap_bytes: self.cap_bytes }
    }
}

#[derive(Clone)]
pub struct BodyCapService<S> {
    inner: S,
    cap_bytes: usize,
}

impl<S> Service<Request<Body>> for BodyCapService<S>
where
    S: Service<Request<Body>, Response = Response, Error = Infallible> + Clone + Send + 'static,
    S::Future: Send + 'static,
{
    type Response = Response;
    type Error = Infallible;
    type Future = BoxFut;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        // Delegate readiness to inner (propagates backpressure correctly).
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
            // Inner error type is Infallible by Axum design for route services.
            Poll::Ready(Err(_)) => Poll::Ready(Ok(())),
        }
    }

    fn call(&mut self, req: Request<Body>) -> Self::Future {
        let cap = self.cap_bytes;
        let mut inner = self.inner.clone();

        // Methods that *could* carry a body we want to gate; others pass through.
        let may_have_body =
            matches!(req.method().as_str(), "POST" | "PUT" | "PATCH" | "DELETE" | "PROPPATCH");

        if !may_have_body {
            return Box::pin(async move { inner.call(req).await });
        }

        // Require explicit Content-Length and cap it via header (cheap hot path).
        let decide = req
            .headers()
            .get(header::CONTENT_LENGTH)
            .and_then(|hv| hv.to_str().ok())
            .and_then(|s| s.parse::<u64>().ok())
            .map(|n| n as usize);

        match decide {
            Some(n) if n <= cap => Box::pin(async move { inner.call(req).await }),
            Some(_) => Box::pin(async move {
                Ok((StatusCode::PAYLOAD_TOO_LARGE, format!("body exceeds cap of {} bytes", cap))
                    .into_response())
            }),
            None => Box::pin(async move {
                Ok((
                    StatusCode::LENGTH_REQUIRED,
                    "missing Content-Length (policy requires explicit length)".to_string(),
                )
                    .into_response())
            }),
        }
    }
}

```

### crates/micronode/src/layers/concurrency.rs
<a id="crates-micronode-src-layers-concurrency-rs"></a>

```rust
//! RO:WHAT — Per-route non-blocking concurrency cap (429 when saturated).
//! RO:WHY  — Shed load early without stalling worker threads.
//! RO:AXUM — Tower Layer to satisfy Axum 0.7 trait bounds.

use axum::{
    body::Body,
    http::Request,
    response::{IntoResponse, Response},
};
use http::StatusCode;
use std::{
    convert::Infallible,
    future::Future,
    pin::Pin,
    sync::Arc,
    task::{Context, Poll},
};
use tokio::sync::Semaphore;
use tower::{Layer, Service};

type BoxFut = Pin<Box<dyn Future<Output = Result<Response, Infallible>> + Send + 'static>>;

#[derive(Clone)]
pub struct ConcurrencyLayer {
    sema: Arc<Semaphore>,
}

impl ConcurrencyLayer {
    pub fn new(sema: Arc<Semaphore>) -> Self {
        Self { sema }
    }
}

impl<S> Layer<S> for ConcurrencyLayer {
    type Service = ConcurrencyService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        ConcurrencyService { inner, sema: self.sema.clone() }
    }
}

#[derive(Clone)]
pub struct ConcurrencyService<S> {
    inner: S,
    sema: Arc<Semaphore>,
}

impl<S> Service<Request<Body>> for ConcurrencyService<S>
where
    S: Service<Request<Body>, Response = Response, Error = Infallible> + Clone + Send + 'static,
    S::Future: Send + 'static,
{
    type Response = Response;
    type Error = Infallible;
    type Future = BoxFut;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
            Poll::Ready(Err(_)) => Poll::Ready(Ok(())),
        }
    }

    fn call(&mut self, req: Request<Body>) -> Self::Future {
        let mut inner = self.inner.clone();

        // Use OWNED permit so it is 'static-safe inside the async block.
        match self.sema.clone().try_acquire_owned() {
            Ok(permit) => Box::pin(async move {
                let resp = inner.call(req).await?;
                drop(permit); // explicit for clarity
                Ok(resp)
            }),
            Err(_) => Box::pin(async move {
                Ok((StatusCode::TOO_MANY_REQUESTS, "concurrency limit exceeded").into_response())
            }),
        }
    }
}

```

### crates/micronode/src/layers/decode_guard.rs
<a id="crates-micronode-src-layers-decodeguard-rs"></a>

```rust
// crates/micronode/src/layers/decode_guard.rs
//! RO:WHAT — Simple decode policy guard: reject any Content-Encoding and stacked encodings.
//! RO:WHY  — We don't transparently decompress; callers must send identity bodies.

use axum::{
    body::Body,
    http::{header, Request, StatusCode},
    middleware::Next,
    response::{IntoResponse, Response},
};

/// Stateless decode guard: 415 on any Content-Encoding; 415 on stacked encodings ("," in header).
pub async fn guard(req: Request<Body>, next: Next) -> Response {
    match req.headers().get(header::CONTENT_ENCODING) {
        None => next.run(req).await,
        Some(hv) => {
            let enc = match hv.to_str() {
                Ok(s) => s,
                Err(_) => {
                    return (StatusCode::UNSUPPORTED_MEDIA_TYPE, "invalid Content-Encoding header")
                        .into_response();
                }
            };

            if enc.contains(',') {
                return (
                    StatusCode::UNSUPPORTED_MEDIA_TYPE,
                    "stacked content encodings are not supported",
                )
                    .into_response();
            }

            (StatusCode::UNSUPPORTED_MEDIA_TYPE, "compressed request bodies are not supported")
                .into_response()
        }
    }
}

```

### crates/micronode/src/layers/mod.rs
<a id="crates-micronode-src-layers-mod-rs"></a>

```rust
//! RO:WHAT — Ingress guard layers (body cap, decode guard, concurrency).
//! RO:WHY  — Enforce limits *before* heavy work; deterministic early rejects.

pub mod body_cap;
pub mod concurrency;
pub mod decode_guard;

```

### crates/micronode/src/lib.rs
<a id="crates-micronode-src-lib-rs"></a>

```rust
//! RO:WHAT — Micronode library surface (router assembly, config, observability).
#![forbid(unsafe_code)]

pub mod app;
pub mod config;
pub mod errors;
pub mod http;
pub mod layers;
pub mod limits;
pub mod observability;
pub mod state;
pub mod types;

pub use app::build_router;

```

### crates/micronode/src/limits.rs
<a id="crates-micronode-src-limits-rs"></a>

```rust
//! RO:WHAT — Central HTTP/OAP limit constants (foundation only).
//! RO:WHY  — Hardening blueprint: size/time/concurrency must be explicit.
//! RO:INVARIANTS — OAP max_frame=1MiB; decoded body cap defaults to 1MiB.

pub const OAP_MAX_FRAME_BYTES: usize = 1_048_576; // 1 MiB
pub const HTTP_BODY_CAP_BYTES: usize = 1_048_576; // 1 MiB

```

### crates/micronode/src/main.rs
<a id="crates-micronode-src-main-rs"></a>

```rust
//! RO:WHAT — Micronode binary entry: load config, init logs, wire readiness, run HTTP.
//! RO:WHY  — Single-binary Micronode with truthful /readyz and dev override.
//! RO:INVARIANTS — No locks across .await; flip readiness probes at the right moments.

#![forbid(unsafe_code)]

use micronode::{app::build_router, config::load::load_config, observability::logging};
use ron_kernel::wait_for_ctrl_c;
use std::net::SocketAddr;
use tracing::{error, info};

#[tokio::main(flavor = "multi_thread")]
async fn main() {
    logging::init();

    // Load config
    let cfg = match load_config() {
        Ok(c) => c,
        Err(e) => {
            error!("config load failed: {e:#}");
            std::process::exit(2);
        }
    };

    // Build router and capture state
    let (router, st) = build_router(cfg.clone());

    // Probe: config successfully loaded
    st.probes.set_cfg_loaded(true);

    let bind: SocketAddr = cfg.server.bind;
    info!("micronode starting on http://{bind}");

    // Bind listener (readiness depends on this)
    let listener = match tokio::net::TcpListener::bind(bind).await {
        Ok(l) => {
            st.probes.set_listeners_bound(true);
            l
        }
        Err(e) => {
            error!("bind failed on {bind}: {e:#}");
            std::process::exit(98);
        }
    };

    // We've registered /metrics; treat exporter as "bound" (process-exposed).
    st.probes.set_metrics_bound(true);

    // Run server with graceful shutdown
    let server = axum::serve(listener, router).with_graceful_shutdown(async {
        wait_for_ctrl_c().await;
        info!("shutdown signal received");
    });

    if let Err(e) = server.await {
        error!("server error: {e:#}");
    }
}

```

### crates/micronode/src/observability/health.rs
<a id="crates-micronode-src-observability-health-rs"></a>

```rust
//! RO:WHAT — /healthz handler adapter (thin wrapper if we need custom shape later).
//! RO:WHY  — Keep admin.rs simple.
//! RO:INVARIANTS — Truthful.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct Health {
    ok: bool,
}

pub async fn handler() -> impl IntoResponse {
    Json(Health { ok: true })
}

```

### crates/micronode/src/observability/http_metrics.rs
<a id="crates-micronode-src-observability-httpmetrics-rs"></a>

```rust
//! RO:WHAT — Minimal HTTP metrics middleware (request count + latency).
//! RO:WHY  — Golden metrics parity across services.
//! RO:INVARIANTS — Prewarm labels later; stable names: micronode_http_*.

use axum::{body::Body, http::Request};
use once_cell::sync::Lazy;
use prometheus::{Histogram, HistogramOpts, IntCounterVec, Opts, Registry};
use std::time::Instant;
use tower::Layer;
use tower::{BoxError, Service};
use tracing::error;

static REGISTRY: Lazy<Registry> = Lazy::new(prometheus::default_registry);
static REQS: Lazy<IntCounterVec> = Lazy::new(|| {
    let o = Opts::new("micronode_http_requests_total", "HTTP requests");
    let v = IntCounterVec::new(o, &["method", "route", "status"]).unwrap();
    REGISTRY.register(Box::new(v.clone())).ok();
    v
});
static LAT: Lazy<Histogram> = Lazy::new(|| {
    let o = HistogramOpts::new("micronode_request_latency_seconds", "Request latency");
    let h = Histogram::with_opts(o).unwrap();
    REGISTRY.register(Box::new(h.clone())).ok();
    h
});

#[derive(Clone)]
pub struct HttpMetricsLayer;

impl<S> Layer<S> for HttpMetricsLayer {
    type Service = HttpMetrics<S>;
    fn layer(&self, inner: S) -> Self::Service {
        HttpMetrics { inner }
    }
}

#[derive(Clone)]
pub struct HttpMetrics<S> {
    inner: S,
}

impl<S> Service<Request<Body>> for HttpMetrics<S>
where
    S: Service<Request<Body>, Response = axum::response::Response> + Clone + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<BoxError>,
{
    type Response = axum::response::Response;
    type Error = BoxError;
    type Future = tokio::task::JoinHandle<Result<Self::Response, Self::Error>>;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        futures::ready!(tokio::task::block_in_place(|| std::task::Poll::Ready(Ok(()))));
        // Delegate readiness directly if inner has it:
        // But to avoid trait bounds complexity here, we assume OK (foundation).
        std::task::Poll::Ready(Ok(()))
    }

    fn call(&mut self, req: Request<Body>) -> Self::Future {
        let method = req.method().as_str().to_owned();
        // Route label best-effort: use URI path; real router labels later.
        let route = req.uri().path().to_owned();
        let start = Instant::now();

        let mut inner = self.inner.clone();
        tokio::spawn(async move {
            let resp = inner.call(req).await.map_err(|e| e.into()).map_err(|e: BoxError| {
                error!("handler error: {e}");
                e
            })?;
            let status = resp.status().as_u16().to_string();
            REQS.with_label_values(&[&method, &route, &status]).inc();
            LAT.observe(start.elapsed().as_secs_f64());
            Ok(resp)
        })
    }
}

pub fn layer() -> HttpMetricsLayer {
    HttpMetricsLayer
}

```

### crates/micronode/src/observability/logging.rs
<a id="crates-micronode-src-observability-logging-rs"></a>

```rust
//! RO:WHAT — Tracing subscriber initialization.
//! RO:WHY  — Deterministic logs with env filter.

use tracing_subscriber::{fmt, EnvFilter};

pub fn init() {
    let filter = std::env::var("RUST_LOG").unwrap_or_else(|_| "info,micronode=debug".to_string());
    let _ = fmt().with_env_filter(EnvFilter::new(filter)).try_init();
}

```

### crates/micronode/src/observability/metrics.rs
<a id="crates-micronode-src-observability-metrics-rs"></a>

```rust

```

### crates/micronode/src/observability/mod.rs
<a id="crates-micronode-src-observability-mod-rs"></a>

```rust
//! RO:WHAT — Observability surfaces: logging and version/health/ready adapters.
//! RO:WHY  — Keep app.rs lean; centralize obs stack.

pub mod health;
pub mod logging;
pub mod ready;
pub mod version;

```

### crates/micronode/src/observability/ready.rs
<a id="crates-micronode-src-observability-ready-rs"></a>

```rust
//! RO:WHAT — Readiness probes and `/readyz` handler (truthful by default).
//! RO:WHY  — Operators need a machine-readable snapshot of liveness gates.
//! RO:INVARIANTS
//!   - Required probes: listeners_bound && cfg_loaded.
//!   - Optional probes: metrics_bound, deps_ok (storage/index/etc).
//!   - Dev override via MICRONODE_DEV_READY=1 returns 200 immediately.

use axum::{http::StatusCode, response::IntoResponse, Json};
use serde::Serialize;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

#[derive(Debug)]
pub struct ReadyProbes {
    listeners_bound: AtomicBool,
    cfg_loaded: AtomicBool,
    metrics_bound: AtomicBool,
    deps_ok: AtomicBool, // placeholder: storage/index/queue/etc
}

impl ReadyProbes {
    pub fn new() -> Self {
        Self {
            listeners_bound: AtomicBool::new(false),
            cfg_loaded: AtomicBool::new(false),
            metrics_bound: AtomicBool::new(false),
            deps_ok: AtomicBool::new(false),
        }
    }

    // --- Setters (flip true when satisfied) ---
    pub fn set_listeners_bound(&self, v: bool) {
        self.listeners_bound.store(v, Ordering::Release);
    }
    pub fn set_cfg_loaded(&self, v: bool) {
        self.cfg_loaded.store(v, Ordering::Release);
    }
    pub fn set_metrics_bound(&self, v: bool) {
        self.metrics_bound.store(v, Ordering::Release);
    }
    pub fn set_deps_ok(&self, v: bool) {
        self.deps_ok.store(v, Ordering::Release);
    }

    // --- Snapshot & decision ---
    pub fn snapshot(&self) -> ReadySnapshot {
        ReadySnapshot {
            listeners_bound: self.listeners_bound.load(Ordering::Acquire),
            cfg_loaded: self.cfg_loaded.load(Ordering::Acquire),
            metrics_bound: self.metrics_bound.load(Ordering::Acquire),
            deps_ok: self.deps_ok.load(Ordering::Acquire),
        }
    }
}

// Clippy: new_without_default — provide a Default that delegates to new().
impl Default for ReadyProbes {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReadySnapshot {
    pub listeners_bound: bool,
    pub cfg_loaded: bool,
    pub metrics_bound: bool,
    pub deps_ok: bool,
}

impl ReadySnapshot {
    /// REQUIRED probes for 200 OK. Adjust here if you want stricter gates.
    pub fn required_ready(&self) -> bool {
        self.listeners_bound && self.cfg_loaded
    }
}

#[derive(Serialize)]
#[serde(deny_unknown_fields)]
struct ReadyReport {
    ready: bool,
    probes: ReadySnapshot,
    mode: &'static str, // "dev-forced" or "truthful"
}

pub async fn handler(probes: Arc<ReadyProbes>) -> impl IntoResponse {
    // Dev override: force ready for local benches/smokes.
    if matches!(
        std::env::var("MICRONODE_DEV_READY").as_deref(),
        Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
    ) {
        let snap = probes.snapshot();
        let report = ReadyReport { ready: true, probes: snap, mode: "dev-forced" };
        return (StatusCode::OK, Json(report)).into_response();
    }

    let snap = probes.snapshot();
    let ok = snap.required_ready();
    let status = if ok { StatusCode::OK } else { StatusCode::SERVICE_UNAVAILABLE };
    let report = ReadyReport { ready: ok, probes: snap, mode: "truthful" };
    (status, Json(report)).into_response()
}

```

### crates/micronode/src/observability/version.rs
<a id="crates-micronode-src-observability-version-rs"></a>

```rust
//! RO:WHAT — /version payload.
//! RO:WHY  — Build provenance for ops.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct VersionResp<'a> {
    name: &'a str,
    version: &'a str,
    built_at_unix: u64,
}

pub async fn handler() -> impl IntoResponse {
    let built =
        option_env!("MICRONODE_BUILD_UNIX").and_then(|s| s.parse::<u64>().ok()).unwrap_or(0);
    Json(VersionResp {
        name: "micronode",
        version: env!("CARGO_PKG_VERSION"),
        built_at_unix: built,
    })
}

```

### crates/micronode/src/security/amnesia.rs
<a id="crates-micronode-src-security-amnesia-rs"></a>

```rust

```

### crates/micronode/src/security/auth_macaroon.rs
<a id="crates-micronode-src-security-authmacaroon-rs"></a>

```rust

```

### crates/micronode/src/security/mod.rs
<a id="crates-micronode-src-security-mod-rs"></a>

```rust

```

### crates/micronode/src/security/pq_config.rs
<a id="crates-micronode-src-security-pqconfig-rs"></a>

```rust

```

### crates/micronode/src/security/pq_observe.rs
<a id="crates-micronode-src-security-pqobserve-rs"></a>

```rust

```

### crates/micronode/src/security/pq_toggle.rs
<a id="crates-micronode-src-security-pqtoggle-rs"></a>

```rust

```

### crates/micronode/src/security/tls_rustls.rs
<a id="crates-micronode-src-security-tlsrustls-rs"></a>

```rust

```

### crates/micronode/src/state.rs
<a id="crates-micronode-src-state-rs"></a>

```rust
//! RO:WHAT — Process state container: config, metrics, health, readiness probes.
//! RO:WHY  — Keep shared handles in one place for Axum State.
//! RO:INVARIANTS — No locks across `.await`; clone-friendly handles.

use crate::config::schema::Config;
use crate::observability::ready::ReadyProbes;
use ron_kernel::metrics::health::HealthState;
use ron_kernel::Metrics;
use std::sync::Arc;

#[derive(Clone)]
pub struct AppState {
    pub cfg: Config,
    pub metrics: Arc<Metrics>,    // exported via /metrics
    pub health: Arc<HealthState>, // liveness
    pub probes: Arc<ReadyProbes>, // readiness (truthful)
}

impl AppState {
    pub fn new(cfg: Config) -> Self {
        // false = we don't auto-serve exporter here (we expose /metrics via axum)
        let metrics: Arc<Metrics> = Metrics::new(false);
        let health = Arc::new(HealthState::new());
        let probes = Arc::new(ReadyProbes::new());

        // baseline liveness true; readiness remains truthful via probes
        health.set("micronode", true);

        Self { cfg, metrics, health, probes }
    }
}

```

### crates/micronode/src/types.rs
<a id="crates-micronode-src-types-rs"></a>

```rust
//! RO:WHAT — Shared DTOs for tiny endpoints (/version, dev echo).
//! RO:WHY  — Keep handler files small and composable.
//! RO:INVARIANTS — DTO hygiene: #[serde(deny_unknown_fields)].

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Version {
    pub name: &'static str,
    pub version: &'static str,
    pub built_at_unix: u64,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Echo {
    pub message: String,
}

```

### crates/micronode/tests/admin_parity.rs
<a id="crates-micronode-tests-adminparity-rs"></a>

```rust


```

### crates/micronode/tests/amnesia_proof.rs
<a id="crates-micronode-tests-amnesiaproof-rs"></a>

```rust


```

### crates/micronode/tests/backpressure.rs
<a id="crates-micronode-tests-backpressure-rs"></a>

```rust


```

### crates/micronode/tests/facets_proxy.rs
<a id="crates-micronode-tests-facetsproxy-rs"></a>

```rust


```

### crates/micronode/tests/oap_limits.rs
<a id="crates-micronode-tests-oaplimits-rs"></a>

```rust


```

### crates/micronode/tests/pq_fallback.rs
<a id="crates-micronode-tests-pqfallback-rs"></a>

```rust


```

### crates/micronode/tests/pq_modes.rs
<a id="crates-micronode-tests-pqmodes-rs"></a>

```rust


```

### crates/micronode/tests_chaos/degrade_shed.rs
<a id="crates-micronode-testschaos-degradeshed-rs"></a>

```rust

```

### crates/micronode/tests_loom/shutdown_interleavings.rs
<a id="crates-micronode-testsloom-shutdowninterleavings-rs"></a>

```rust

```

### crates/micronode/tests_property/oap_fuzz.rs
<a id="crates-micronode-testsproperty-oapfuzz-rs"></a>

```rust

```

### crates/micronode/tests_property/pq_handshake_props.rs
<a id="crates-micronode-testsproperty-pqhandshakeprops-rs"></a>

```rust

```

