<!-- Generated by scripts/make_crate_codex.sh on 2025-11-17T02:23:51Z -->
# Code Bundle — `micronode`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/micronode/.clippy.toml](#crates-micronode--clippy-toml)
- [crates/micronode/.rustfmt.toml](#crates-micronode--rustfmt-toml)
- [crates/micronode/Cargo.toml](#crates-micronode-Cargo-toml)
- [crates/micronode/benches/http_kv.rs](#crates-micronode-benches-httpkv-rs)
- [crates/micronode/benches/oap_frame_perf.rs](#crates-micronode-benches-oapframeperf-rs)
- [crates/micronode/benches/pq_overhead.rs](#crates-micronode-benches-pqoverhead-rs)
- [crates/micronode/benches/readiness_walk.rs](#crates-micronode-benches-readinesswalk-rs)
- [crates/micronode/build.rs](#crates-micronode-build-rs)
- [crates/micronode/configs/micronode.amnesia.off.toml](#crates-micronode-configs-micronode-amnesia-off-toml)
- [crates/micronode/configs/micronode.dev.toml](#crates-micronode-configs-micronode-dev-toml)
- [crates/micronode/configs/micronode.pq.required.toml](#crates-micronode-configs-micronode-pq-required-toml)
- [crates/micronode/configs/micronode.pq.toml](#crates-micronode-configs-micronode-pq-toml)
- [crates/micronode/configs/micronode.toml](#crates-micronode-configs-micronode-toml)
- [crates/micronode/deny.toml](#crates-micronode-deny-toml)
- [crates/micronode/examples/quickstart.rs](#crates-micronode-examples-quickstart-rs)
- [crates/micronode/fuzz/config_from_env_fuzz.rs](#crates-micronode-fuzz-configfromenvfuzz-rs)
- [crates/micronode/fuzz/pq_kex_fuzz.rs](#crates-micronode-fuzz-pqkexfuzz-rs)
- [crates/micronode/scripts/beta_check.sh](#crates-micronode-scripts-betacheck-sh)
- [crates/micronode/scripts/chaos_degrade_shed.sh](#crates-micronode-scripts-chaosdegradeshed-sh)
- [crates/micronode/scripts/fs_spy_amnesia.sh](#crates-micronode-scripts-fsspyamnesia-sh)
- [crates/micronode/scripts/gen_diagrams.sh](#crates-micronode-scripts-gendiagrams-sh)
- [crates/micronode/scripts/pq_matrix_ci.sh](#crates-micronode-scripts-pqmatrixci-sh)
- [crates/micronode/scripts/run_dev.sh](#crates-micronode-scripts-rundev-sh)
- [crates/micronode/scripts/smoke_micronode.sh](#crates-micronode-scripts-smokemicronode-sh)
- [crates/micronode/scripts/smoke_oap_limits.sh](#crates-micronode-scripts-smokeoaplimits-sh)
- [crates/micronode/specs/oap_vectors.json](#crates-micronode-specs-oapvectors-json)
- [crates/micronode/specs/pq_handshake_cases.json](#crates-micronode-specs-pqhandshakecases-json)
- [crates/micronode/src/adapters/index_client.rs](#crates-micronode-src-adapters-indexclient-rs)
- [crates/micronode/src/adapters/mailbox_client.rs](#crates-micronode-src-adapters-mailboxclient-rs)
- [crates/micronode/src/adapters/mod.rs](#crates-micronode-src-adapters-mod-rs)
- [crates/micronode/src/adapters/overlay_client.rs](#crates-micronode-src-adapters-overlayclient-rs)
- [crates/micronode/src/adapters/policy_client.rs](#crates-micronode-src-adapters-policyclient-rs)
- [crates/micronode/src/adapters/storage_client.rs](#crates-micronode-src-adapters-storageclient-rs)
- [crates/micronode/src/app.rs](#crates-micronode-src-app-rs)
- [crates/micronode/src/cli/args.rs](#crates-micronode-src-cli-args-rs)
- [crates/micronode/src/cli/mod.rs](#crates-micronode-src-cli-mod-rs)
- [crates/micronode/src/cli/run.rs](#crates-micronode-src-cli-run-rs)
- [crates/micronode/src/concurrency/backpressure.rs](#crates-micronode-src-concurrency-backpressure-rs)
- [crates/micronode/src/concurrency/mod.rs](#crates-micronode-src-concurrency-mod-rs)
- [crates/micronode/src/concurrency/registry.rs](#crates-micronode-src-concurrency-registry-rs)
- [crates/micronode/src/concurrency/shutdown.rs](#crates-micronode-src-concurrency-shutdown-rs)
- [crates/micronode/src/config/cli_overlay.rs](#crates-micronode-src-config-clioverlay-rs)
- [crates/micronode/src/config/env_overlay.rs](#crates-micronode-src-config-envoverlay-rs)
- [crates/micronode/src/config/hot_reload.rs](#crates-micronode-src-config-hotreload-rs)
- [crates/micronode/src/config/load.rs](#crates-micronode-src-config-load-rs)
- [crates/micronode/src/config/mod.rs](#crates-micronode-src-config-mod-rs)
- [crates/micronode/src/config/schema.rs](#crates-micronode-src-config-schema-rs)
- [crates/micronode/src/config/validate.rs](#crates-micronode-src-config-validate-rs)
- [crates/micronode/src/errors.rs](#crates-micronode-src-errors-rs)
- [crates/micronode/src/facets/feed.rs](#crates-micronode-src-facets-feed-rs)
- [crates/micronode/src/facets/graph.rs](#crates-micronode-src-facets-graph-rs)
- [crates/micronode/src/facets/media.rs](#crates-micronode-src-facets-media-rs)
- [crates/micronode/src/facets/mod.rs](#crates-micronode-src-facets-mod-rs)
- [crates/micronode/src/facets/search.rs](#crates-micronode-src-facets-search-rs)
- [crates/micronode/src/http/admin.rs](#crates-micronode-src-http-admin-rs)
- [crates/micronode/src/http/kv.rs](#crates-micronode-src-http-kv-rs)
- [crates/micronode/src/http/mod.rs](#crates-micronode-src-http-mod-rs)
- [crates/micronode/src/http/routes.rs](#crates-micronode-src-http-routes-rs)
- [crates/micronode/src/layers/body_cap.rs](#crates-micronode-src-layers-bodycap-rs)
- [crates/micronode/src/layers/concurrency.rs](#crates-micronode-src-layers-concurrency-rs)
- [crates/micronode/src/layers/decode_guard.rs](#crates-micronode-src-layers-decodeguard-rs)
- [crates/micronode/src/layers/mod.rs](#crates-micronode-src-layers-mod-rs)
- [crates/micronode/src/lib.rs](#crates-micronode-src-lib-rs)
- [crates/micronode/src/limits.rs](#crates-micronode-src-limits-rs)
- [crates/micronode/src/main.rs](#crates-micronode-src-main-rs)
- [crates/micronode/src/observability/health.rs](#crates-micronode-src-observability-health-rs)
- [crates/micronode/src/observability/http_metrics.rs](#crates-micronode-src-observability-httpmetrics-rs)
- [crates/micronode/src/observability/logging.rs](#crates-micronode-src-observability-logging-rs)
- [crates/micronode/src/observability/metrics.rs](#crates-micronode-src-observability-metrics-rs)
- [crates/micronode/src/observability/mod.rs](#crates-micronode-src-observability-mod-rs)
- [crates/micronode/src/observability/ready.rs](#crates-micronode-src-observability-ready-rs)
- [crates/micronode/src/observability/version.rs](#crates-micronode-src-observability-version-rs)
- [crates/micronode/src/security/amnesia.rs](#crates-micronode-src-security-amnesia-rs)
- [crates/micronode/src/security/auth_macaroon.rs](#crates-micronode-src-security-authmacaroon-rs)
- [crates/micronode/src/security/mod.rs](#crates-micronode-src-security-mod-rs)
- [crates/micronode/src/security/pq_config.rs](#crates-micronode-src-security-pqconfig-rs)
- [crates/micronode/src/security/pq_observe.rs](#crates-micronode-src-security-pqobserve-rs)
- [crates/micronode/src/security/pq_toggle.rs](#crates-micronode-src-security-pqtoggle-rs)
- [crates/micronode/src/security/tls_rustls.rs](#crates-micronode-src-security-tlsrustls-rs)
- [crates/micronode/src/state.rs](#crates-micronode-src-state-rs)
- [crates/micronode/src/storage/mod.rs](#crates-micronode-src-storage-mod-rs)
- [crates/micronode/src/storage/sled_store.rs](#crates-micronode-src-storage-sledstore-rs)
- [crates/micronode/src/types.rs](#crates-micronode-src-types-rs)
- [crates/micronode/tests/admin_parity.rs](#crates-micronode-tests-adminparity-rs)
- [crates/micronode/tests/amnesia_proof.rs](#crates-micronode-tests-amnesiaproof-rs)
- [crates/micronode/tests/backpressure.rs](#crates-micronode-tests-backpressure-rs)
- [crates/micronode/tests/facets_proxy.rs](#crates-micronode-tests-facetsproxy-rs)
- [crates/micronode/tests/guard_behavior.rs](#crates-micronode-tests-guardbehavior-rs)
- [crates/micronode/tests/kv_roundtrip.rs](#crates-micronode-tests-kvroundtrip-rs)
- [crates/micronode/tests/oap_limits.rs](#crates-micronode-tests-oaplimits-rs)
- [crates/micronode/tests/pq_fallback.rs](#crates-micronode-tests-pqfallback-rs)
- [crates/micronode/tests/pq_modes.rs](#crates-micronode-tests-pqmodes-rs)
- [crates/micronode/tests_chaos/degrade_shed.rs](#crates-micronode-testschaos-degradeshed-rs)
- [crates/micronode/tests_loom/shutdown_interleavings.rs](#crates-micronode-testsloom-shutdowninterleavings-rs)
- [crates/micronode/tests_property/oap_fuzz.rs](#crates-micronode-testsproperty-oapfuzz-rs)
- [crates/micronode/tests_property/pq_handshake_props.rs](#crates-micronode-testsproperty-pqhandshakeprops-rs)

### crates/micronode/.clippy.toml
<a id="crates-micronode--clippy-toml"></a>

```toml
# Minimal, valid Clippy config (use only supported keys)
cognitive-complexity-threshold = 35
too-many-lines-threshold = 400

```

### crates/micronode/.rustfmt.toml
<a id="crates-micronode--rustfmt-toml"></a>

```toml
max_width = 100
use_small_heuristics = "Max"
# Keep stable-only options here; nightly-only options (like format_code_in_doc_comments) are removed.

```

### crates/micronode/Cargo.toml
<a id="crates-micronode-Cargo-toml"></a>

```toml
[package]
name = "micronode"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false
build = "build.rs"

[lib]
name = "micronode"
path = "src/lib.rs"

[[bin]]
name = "micronode"
path = "src/main.rs"

[features]
# RO:WHAT  — Feature flags for Micronode.
# RO:WHY   — Let us pick storage engines (mem vs sled) and later gate facets.
# RO:NOTE  — For now we only gate storage; graph/search/feed/media remain stubs.
default = ["mem-store"]

# In-memory storage engine (hashmap/RwLock). Always available.
mem-store = []

# Sled-backed storage engine (optional, may be used by KV v1 later).
sled-store = ["sled"]

[dependencies]
# RON workspace crates
ron-kernel = { path = "../ron-kernel" }
ron-proto  = { path = "../ron-proto" }
oap        = { path = "../oap" }

# Async/HTTP stack (workspace-standard pins)
tokio       = { version = "1", features = ["macros", "rt-multi-thread", "signal", "time", "io-util", "sync", "net", "fs"] }
axum        = { version = "0.7", default-features = false, features = ["tokio", "http1", "http2", "json"] }
tower       = "0.5"
tower-http  = { version = "0.6.6", features = ["trace"] }
http        = "1"

# Obs & logging
tracing            = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus         = "0.14"

# Config & serde
serde           = { version = "1.0", features = ["derive"] }
serde_json      = "1"
toml            = "0.8"
humantime-serde = "1"
anyhow          = "1.0"
thiserror       = "1.0"

# Utilities
parking_lot = "0.12"

# Storage engine (optional; gated by 'sled-store' feature)
sled = { version = "0.34", optional = true }

[dev-dependencies]
# HTTP client for admin/guard/KV tests
reqwest = { version = "0.12", features = ["rustls-tls-native-roots", "json"] }

# Criterion for micro-benchmarks (in-process HTTP router benches)
criterion = { version = "0.5", features = ["html_reports", "async"] }

[[bench]]
name = "http_kv"
harness = false

```

### crates/micronode/benches/http_kv.rs
<a id="crates-micronode-benches-httpkv-rs"></a>

```rust
// crates/micronode/benches/http_kv.rs
//! Simple HTTP-level benchmarks for micronode.
//!
//! RO:WHAT — Benchmark the in-process Axum router for:
//!   - `/healthz` fast-path.
//!   - `/v1/kv/{bucket}/{key}` small PUT/GET/DELETE roundtrip.
//!   - `/v1/kv/{bucket}/{key}` hot reject via DecodeGuard (Content-Encoding).
//!
//! RO:WHY  — Give us a quick sanity check on HTTP latencies for the Micronode
//!           profile without binding a real TCP port.
//!
//! RO:HOW  — Build the Router via `build_router(Config::default())` and drive
//!           requests with a Tokio runtime + `Router::oneshot(req)` inside a
//!           Criterion `b.iter(...)` loop.

use axum::body::Body;
use axum::Router;
use criterion::{criterion_group, criterion_main, Criterion};
use http::{Method, Request, StatusCode};
use micronode::app::build_router;
use micronode::config::schema::Config;
use tower::ServiceExt as _; // for `oneshot`

fn build_app() -> Router {
    // For benches we can rely on Config::default(): it should give us
    // localhost bind + in-memory storage engine.
    let cfg = Config::default();
    let (router, _state) = build_router(cfg);
    router
}

fn bench_healthz(c: &mut Criterion) {
    let router = build_app();

    // Shared runtime for this benchmark.
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .expect("failed to build tokio runtime for benches");

    c.bench_function("http_healthz_fast_path", |b| {
        b.iter(|| {
            // Clone the Router so `oneshot(self, req)` can take ownership.
            let router = router.clone();

            rt.block_on(async move {
                let req = Request::builder()
                    .method(Method::GET)
                    .uri("/healthz")
                    .body(Body::empty())
                    .expect("healthz request build failed");

                let resp = router.oneshot(req).await.expect("healthz handler failed");

                // Sanity: ensure we stayed on the happy path.
                assert_eq!(resp.status(), StatusCode::OK);
            });
        });
    });
}

fn bench_kv_small_roundtrip(c: &mut Criterion) {
    let router = build_app();

    // Shared runtime for this benchmark.
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .expect("failed to build tokio runtime for benches");

    c.bench_function("http_kv_small_put_get_delete", |b| {
        b.iter(|| {
            // Clone the Router so `oneshot(self, req)` can take ownership.
            let router = router.clone();

            rt.block_on(async move {
                let bucket = "bench";
                let key = "k";

                // Payload for PUT — we must set an accurate Content-Length
                // because BodyCapLayer enforces it for POST/PUT/PATCH.
                let payload = "hello-micronode";
                let payload_len = payload.len().to_string();

                // PUT small value
                let put_req = Request::builder()
                    .method(Method::PUT)
                    .uri(format!("/v1/kv/{}/{}", bucket, key))
                    .header("content-type", "application/octet-stream")
                    .header("content-length", payload_len)
                    .body(Body::from(payload.to_owned()))
                    .expect("PUT request build failed");

                let put_resp = router.clone().oneshot(put_req).await.expect("PUT handler failed");
                assert!(
                    put_resp.status().is_success(),
                    "expected PUT success, got {}",
                    put_resp.status()
                );

                // GET the value
                let get_req = Request::builder()
                    .method(Method::GET)
                    .uri(format!("/v1/kv/{}/{}", bucket, key))
                    .body(Body::empty())
                    .expect("GET request build failed");

                let get_resp = router.clone().oneshot(get_req).await.expect("GET handler failed");
                assert_eq!(get_resp.status(), StatusCode::OK);

                // DELETE it
                let del_req = Request::builder()
                    .method(Method::DELETE)
                    .uri(format!("/v1/kv/{}/{}", bucket, key))
                    .body(Body::empty())
                    .expect("DELETE request build failed");

                let del_resp = router.oneshot(del_req).await.expect("DELETE handler failed");
                assert!(
                    del_resp.status().is_success(),
                    "expected DELETE success, got {}",
                    del_resp.status()
                );
            });
        });
    });
}

fn bench_kv_decode_guard_hot_reject(c: &mut Criterion) {
    let router = build_app();

    // Shared runtime for this benchmark.
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .expect("failed to build tokio runtime for benches");

    c.bench_function("http_kv_decode_guard_hot_reject", |b| {
        b.iter(|| {
            // Clone the Router so `oneshot(self, req)` can take ownership.
            let router = router.clone();

            rt.block_on(async move {
                let bucket = "bench";
                let key = "guard";

                // Tiny payload with accurate length so BodyCapLayer is satisfied
                // and we actually exercise DecodeGuard.
                let payload = "x";
                let payload_len = payload.len().to_string();

                let req = Request::builder()
                    .method(Method::PUT)
                    .uri(format!("/v1/kv/{}/{}", bucket, key))
                    .header("content-type", "application/octet-stream")
                    .header("content-length", payload_len)
                    .header("content-encoding", "gzip")
                    .body(Body::from(payload.to_owned()))
                    .expect("decode-guard PUT request build failed");

                let resp = router.oneshot(req).await.expect("decode-guard handler failed");

                // Sanity: ensure we’re measuring the hot reject, not a 411 from BodyCap.
                assert_eq!(
                    resp.status(),
                    StatusCode::UNSUPPORTED_MEDIA_TYPE,
                    "expected 415 from DecodeGuard, got {}",
                    resp.status()
                );
            });
        });
    });
}

criterion_group!(
    micronode_http,
    bench_healthz,
    bench_kv_small_roundtrip,
    bench_kv_decode_guard_hot_reject
);
criterion_main!(micronode_http);

```

### crates/micronode/benches/oap_frame_perf.rs
<a id="crates-micronode-benches-oapframeperf-rs"></a>

```rust


```

### crates/micronode/benches/pq_overhead.rs
<a id="crates-micronode-benches-pqoverhead-rs"></a>

```rust


```

### crates/micronode/benches/readiness_walk.rs
<a id="crates-micronode-benches-readinesswalk-rs"></a>

```rust


```

### crates/micronode/build.rs
<a id="crates-micronode-build-rs"></a>

```rust
// RO:WHAT — build script that stamps a UNIX build time for /version.
// RO:WHY  — Observability/versioning; helps triage running binaries.
// RO:INVARIANTS — Emits MICRONODE_BUILD_UNIX env var always.
fn main() {
    println!("cargo:rustc-env=MICRONODE_BUILD_UNIX={}", chrono_unix());
}

fn chrono_unix() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_secs().to_string())
        .unwrap_or_else(|_| "0".to_string())
}

```

### crates/micronode/configs/micronode.amnesia.off.toml
<a id="crates-micronode-configs-micronode-amnesia-off-toml"></a>

```toml

```

### crates/micronode/configs/micronode.dev.toml
<a id="crates-micronode-configs-micronode-dev-toml"></a>

```toml

```

### crates/micronode/configs/micronode.pq.required.toml
<a id="crates-micronode-configs-micronode-pq-required-toml"></a>

```toml

```

### crates/micronode/configs/micronode.pq.toml
<a id="crates-micronode-configs-micronode-pq-toml"></a>

```toml

```

### crates/micronode/configs/micronode.toml
<a id="crates-micronode-configs-micronode-toml"></a>

```toml
# RO:WHAT — Default Micronode config (beta profile).
# RO:WHY  — Workspace-local defaults for dev and smoke tests.
#           This file is safe to check in: it binds to localhost and
#           uses in-memory storage (amnesia-first).
# RO:INVARIANTS —
#   - Localhost-only bind.
#   - Dev routes enabled for quick smokes.
#   - Storage is in-memory (`engine = "mem"`) by default.

[server]
bind = "127.0.0.1:5310"
dev_routes = true

[storage]
# Amnesia-first: keep everything in memory unless explicitly changed.
engine = "mem"

# Optional: uncomment and switch engine to "sled" when you want
# persistence for this Micronode instance.
#
# engine = "sled"
# path = "micronode-data"

```

### crates/micronode/deny.toml
<a id="crates-micronode-deny-toml"></a>

```toml
[advisories]
yanked = "deny"
unmaintained = "deny"
vulnerability = "deny"

[licenses]
allow = ["MIT", "Apache-2.0"]

```

### crates/micronode/examples/quickstart.rs
<a id="crates-micronode-examples-quickstart-rs"></a>

```rust
// crates/micronode/examples/quickstart.rs
//! RO:WHAT — Minimal example entrypoint so `cargo build` succeeds.
//! RO:HOW  — Prints a hint to use the primary binary (`cargo run -p micronode`).
//! RO:FUTURE — Can be replaced later with a runnable SDK demo.

fn main() {
    println!("Micronode quickstart example.");
    println!("Run the server with:");
    println!("  MICRONODE_DEV_ROUTES=1 cargo run -p micronode");
}

```

### crates/micronode/fuzz/config_from_env_fuzz.rs
<a id="crates-micronode-fuzz-configfromenvfuzz-rs"></a>

```rust

```

### crates/micronode/fuzz/pq_kex_fuzz.rs
<a id="crates-micronode-fuzz-pqkexfuzz-rs"></a>

```rust

```

### crates/micronode/scripts/beta_check.sh
<a id="crates-micronode-scripts-betacheck-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Simple beta gate for `micronode`.
#
# Runs (from repo root):
#   1) fmt + clippy (warnings = errors)
#   2) unit + integration tests
#   3) HTTP+KV benchmarks (http_kv)
#   4) Smoke test via scripts/smoke_micronode.sh with dev routes enabled
#
# Usage:
#   bash crates/micronode/scripts/beta_check.sh
#
# Env toggles:
#   SKIP_BENCH=1  → skip Criterion benches (useful on battery / CI)

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../.." && pwd)"
CRATE="micronode"

echo "[beta-check] crate=${CRATE} root=${ROOT_DIR}"

cd "${ROOT_DIR}"

###############################################################################
# 1) fmt + clippy
###############################################################################
echo "[beta-check] 1) fmt + clippy"
cargo fmt -p "${CRATE}"
cargo clippy -p "${CRATE}" --no-deps -- -D warnings

###############################################################################
# 2) Tests (unit + integration + doc tests)
###############################################################################
echo "[beta-check] 2) cargo test -p ${CRATE}"
cargo test -p "${CRATE}"

###############################################################################
# 3) HTTP+KV benchmarks (optional)
###############################################################################
if [[ "${SKIP_BENCH:-0}" != "1" ]]; then
  echo "[beta-check] 3) cargo bench -p ${CRATE} --bench http_kv"
  cargo bench -p "${CRATE}" --bench http_kv
else
  echo "[beta-check] 3) benches skipped (SKIP_BENCH=1)"
fi

###############################################################################
# 4) Smoke test (admin plane + KV roundtrip)
###############################################################################
echo "[beta-check] 4) smoke_micronode.sh (with MICRONODE_DEV_ROUTES=1)"

MICRONODE_DEV_ROUTES=1 cargo run -p "${CRATE}" &
APP_PID=$!

# Give the server a moment to bind.
sleep 2

# Run the smoke script (expects 127.0.0.1:5310 by default).
bash "crates/${CRATE}/scripts/smoke_micronode.sh"

echo "[beta-check] smoke_micronode.sh OK, shutting down micronode (pid=${APP_PID})"
kill "${APP_PID}" >/dev/null 2>&1 || true
wait "${APP_PID}" 2>/dev/null || true

echo "[beta-check] ✅ ${CRATE} beta gate PASSED"

```

### crates/micronode/scripts/chaos_degrade_shed.sh
<a id="crates-micronode-scripts-chaosdegradeshed-sh"></a>

```bash

```

### crates/micronode/scripts/fs_spy_amnesia.sh
<a id="crates-micronode-scripts-fsspyamnesia-sh"></a>

```bash

```

### crates/micronode/scripts/gen_diagrams.sh
<a id="crates-micronode-scripts-gendiagrams-sh"></a>

```bash

```

### crates/micronode/scripts/pq_matrix_ci.sh
<a id="crates-micronode-scripts-pqmatrixci-sh"></a>

```bash

```

### crates/micronode/scripts/run_dev.sh
<a id="crates-micronode-scripts-rundev-sh"></a>

```bash

```

### crates/micronode/scripts/smoke_micronode.sh
<a id="crates-micronode-scripts-smokemicronode-sh"></a>

```bash
#!/usr/bin/env bash
# smoke_micronode.sh — one-shot smoke test for Micronode
# Modes:
#   (default)   — assumes micronode already running on ADDR (two-terminal workflow)
#   --spawn     — kills port holder on 5310, spawns micronode in background, runs checks, then cleans up
#
# Env knobs:
#   ADDR                 — admin/API addr (default 127.0.0.1:5310)
#   RUST_LOG             — log level when spawning (default info,micronode=debug)
#   MICRONODE_DEV_ROUTES — when spawning, enable dev routes (default 1)

set -euo pipefail

ADDR="${ADDR:-127.0.0.1:5310}"
RUST_LOG="${RUST_LOG:-info,micronode=debug}"

SPAWN=0
if [[ "${1:-}" == "--spawn" ]]; then
  SPAWN=1
fi

# Utilities (macOS-friendly)
die() { echo "[ERR] $*" >&2; exit 1; }
info() { echo "[INFO] $*"; }
ok() { echo "[OK] $*"; }
step() { echo "[STEP] $*"; }

kill_port_holders() {
  local port="$1"
  local pids
  if pids=$(lsof -ti tcp:"$port" 2>/dev/null); then
    if [[ -n "$pids" ]]; then
      info "Port $port busy. Killing holder(s)…"
      # shellcheck disable=SC2086
      kill -9 $pids || true
      sleep 0.2
    fi
  fi
}

wait_for_healthz() {
  local url="$1"
  local retries="${2:-60}" # ~60s max
  local i=0
  info "Waiting for $url ..."
  until curl -sSf -o /dev/null "$url"; do
    i=$((i+1)) || true
    if [[ "$i" -ge "$retries" ]]; then
      die "Timed out waiting for $url"
    fi
    sleep 1
  done
  ok "Healthy: $url"
}

MICRO_PID=""
LOG_FILE=""

cleanup() {
  if [[ -n "$MICRO_PID" ]]; then
    info "Killing micronode (pid=$MICRO_PID)…"
    kill "$MICRO_PID" 2>/dev/null || true
  fi
  if [[ -n "$LOG_FILE" && -f "$LOG_FILE" ]]; then
    info "Micronode logs were captured in: $LOG_FILE"
  fi
}
trap cleanup EXIT

if [[ "$SPAWN" -eq 1 ]]; then
  info "Spawn mode: will start micronode on ${ADDR}"
  # Assume ADDR is host:port; we only care about the port for kill_port_holders
  PORT="${ADDR##*:}"
  kill_port_holders "$PORT"

  LOG_FILE="$(mktemp -t micronode-smoke-XXXX.log)"
  info "Spawning micronode (logs -> $LOG_FILE)…"

  MICRONODE_DEV_ROUTES="${MICRONODE_DEV_ROUTES:-1}" \
  RUST_LOG="$RUST_LOG" \
    cargo run -p micronode >"$LOG_FILE" 2>&1 &

  MICRO_PID=$!
  sleep 0.5
fi

BASE_URL="http://${ADDR}"

step "Admin plane checks"
wait_for_healthz "${BASE_URL}/healthz"

info "GET /metrics (head)"
curl -sSf "${BASE_URL}/metrics" | head -n 20 >/tmp/micronode_metrics_head.$$ || die "/metrics not reachable"
ok "/metrics reachable"

# Optional: assert our http metrics family is present
if curl -sSf "${BASE_URL}/metrics" | grep -q "micronode_http_requests_total"; then
  ok "micronode_http_requests_total present in /metrics"
else
  info "micronode_http_requests_total not seen yet (may appear after more traffic)"
fi

step "Readiness (/readyz)"
curl -sSf "${BASE_URL}/readyz" | jq . || die "/readyz failed"
ok "/readyz returned JSON"

step "Version (/version)"
curl -sSf "${BASE_URL}/version" | jq . || die "/version failed"
ok "/version returned JSON"

step "KV roundtrip via /v1/kv/{bucket}/{key}"
BUCKET="${BUCKET:-smoke}"
KEY="${KEY:-k}"
VALUE="${VALUE:-hello-micronode}"

PUT_CODE=$(curl -sS -o /dev/null -w "%{http_code}" \
  -X PUT "${BASE_URL}/v1/kv/${BUCKET}/${KEY}" \
  -H 'content-type: application/octet-stream' \
  --data-binary "${VALUE}" || true)

echo "[INFO] PUT status: ${PUT_CODE}"
if [[ "${PUT_CODE}" != "201" && "${PUT_CODE}" != "204" ]]; then
  die "Expected 201/204 from PUT, got ${PUT_CODE}"
fi
ok "PUT /v1/kv/${BUCKET}/${KEY} → ${PUT_CODE}"

GET_BODY=$(curl -sS "${BASE_URL}/v1/kv/${BUCKET}/${KEY}" || true)
echo "[INFO] GET body: ${GET_BODY}"
if [[ "${GET_BODY}" != "${VALUE}" ]]; then
  die "Expected GET body '${VALUE}', got '${GET_BODY}'"
fi
ok "GET /v1/kv/${BUCKET}/${KEY} roundtrip OK"

DEL_CODE=$(curl -sS -o /dev/null -w "%{http_code}" \
  -X DELETE "${BASE_URL}/v1/kv/${BUCKET}/${KEY}" || true)

echo "[INFO] DELETE status: ${DEL_CODE}"
if [[ "${DEL_CODE}" != "204" ]]; then
  die "Expected 204 from DELETE, got ${DEL_CODE}"
fi
ok "DELETE /v1/kv/${BUCKET}/${KEY} → ${DEL_CODE}"

echo "✅ micronode smoke OK"

```

### crates/micronode/scripts/smoke_oap_limits.sh
<a id="crates-micronode-scripts-smokeoaplimits-sh"></a>

```bash

```

### crates/micronode/specs/oap_vectors.json
<a id="crates-micronode-specs-oapvectors-json"></a>

```json

```

### crates/micronode/specs/pq_handshake_cases.json
<a id="crates-micronode-specs-pqhandshakecases-json"></a>

```json

```

### crates/micronode/src/adapters/index_client.rs
<a id="crates-micronode-src-adapters-indexclient-rs"></a>

```rust

```

### crates/micronode/src/adapters/mailbox_client.rs
<a id="crates-micronode-src-adapters-mailboxclient-rs"></a>

```rust

```

### crates/micronode/src/adapters/mod.rs
<a id="crates-micronode-src-adapters-mod-rs"></a>

```rust

```

### crates/micronode/src/adapters/overlay_client.rs
<a id="crates-micronode-src-adapters-overlayclient-rs"></a>

```rust

```

### crates/micronode/src/adapters/policy_client.rs
<a id="crates-micronode-src-adapters-policyclient-rs"></a>

```rust

```

### crates/micronode/src/adapters/storage_client.rs
<a id="crates-micronode-src-adapters-storageclient-rs"></a>

```rust

```

### crates/micronode/src/app.rs
<a id="crates-micronode-src-app-rs"></a>

```rust
//! RO:WHAT — Router assembly for Micronode.
//! RO:WHY  — Central composition point for routes and layers.
//! RO:INTERACTS — config::schema::Config, http::{admin,routes,kv}, layers, limits, state::AppState.
//! RO:INVARIANTS — Outer trace layer; HTTP metrics just inside; per-route caps first.
//! RO:METRICS — HTTP metrics/trace via http_metrics + tower-http TraceLayer.
//! RO:CONFIG — Reads cfg.server.bind + cfg.server.dev_routes; storage engine later.
//! RO:SECURITY — No auth at router level; capability/policy live in layers/handlers.
//! RO:TEST — Covered by integration tests hitting /healthz,/readyz,/version,/metrics,/v1/kv.

use crate::{
    config::schema::Config,
    http::{admin, kv, routes},
    layers::{self, body_cap::BodyCapLayer, concurrency::ConcurrencyLayer},
    limits::HTTP_BODY_CAP_BYTES,
    observability::http_metrics,
    state::AppState,
};
use axum::{middleware, routing::get, Router};
use std::{convert::Infallible, sync::Arc};
use tokio::sync::Semaphore;
use tower_http::trace::TraceLayer;

pub fn build_router(cfg: Config) -> (Router, AppState) {
    let st = AppState::new(cfg.clone());

    // Prewarm HTTP metrics so /metrics exposes micronode_http_* families immediately.
    http_metrics::prewarm();

    // --- Admin plane ---
    let admin_routes = Router::new()
        .route("/healthz", get(admin::healthz))
        .route("/readyz", get(admin::readyz))
        .route("/version", get(admin::version))
        .route("/metrics", get(admin::metrics));

    // --- Dev plane (guarded route) ---
    let dev = if st.cfg.server.dev_routes {
        let echo_conc = Arc::new(Semaphore::new(256)); // default per-route cap

        Router::new().route(
            "/dev/echo",
            axum::routing::post(routes::dev::echo)
                // Order matters: decode policy -> body cap -> concurrency
                .layer::<_, Infallible>(middleware::from_fn(layers::decode_guard::guard))
                .layer(BodyCapLayer::new(HTTP_BODY_CAP_BYTES))
                .layer(ConcurrencyLayer::new(echo_conc)),
        )
    } else {
        Router::new()
    };

    // --- Feature routes (v1 API) ---

    // Concurrency cap for KV operations; sized for small-node defaults.
    let kv_conc = Arc::new(Semaphore::new(256));

    let api_v1 = Router::new().route("/ping", get(routes::ping)).route(
        "/kv/:bucket/:key",
        axum::routing::get(kv::get_kv)
            .put(kv::put_kv)
            .delete(kv::delete_kv)
            // Same guard stack as dev echo: decode + body cap + concurrency.
            .layer::<_, Infallible>(middleware::from_fn(layers::decode_guard::guard))
            .layer(BodyCapLayer::new(HTTP_BODY_CAP_BYTES))
            .layer(ConcurrencyLayer::new(kv_conc)),
    );

    let router = Router::new()
        .merge(admin_routes)
        .nest("/v1", api_v1)
        .merge(dev)
        .with_state(st.clone())
        // Observability stack: metrics inner, tracing outer (so spans wrap metrics).
        .layer(http_metrics::layer())
        .layer(TraceLayer::new_for_http());

    (router, st)
}

```

### crates/micronode/src/cli/args.rs
<a id="crates-micronode-src-cli-args-rs"></a>

```rust

```

### crates/micronode/src/cli/mod.rs
<a id="crates-micronode-src-cli-mod-rs"></a>

```rust

```

### crates/micronode/src/cli/run.rs
<a id="crates-micronode-src-cli-run-rs"></a>

```rust

```

### crates/micronode/src/concurrency/backpressure.rs
<a id="crates-micronode-src-concurrency-backpressure-rs"></a>

```rust

```

### crates/micronode/src/concurrency/mod.rs
<a id="crates-micronode-src-concurrency-mod-rs"></a>

```rust

```

### crates/micronode/src/concurrency/registry.rs
<a id="crates-micronode-src-concurrency-registry-rs"></a>

```rust

```

### crates/micronode/src/concurrency/shutdown.rs
<a id="crates-micronode-src-concurrency-shutdown-rs"></a>

```rust

```

### crates/micronode/src/config/cli_overlay.rs
<a id="crates-micronode-src-config-clioverlay-rs"></a>

```rust
//! RO:WHAT — Placeholder for CLI-overlay support (kept for tree parity).
//! RO:WHY  — Future: clap/argp integration without bloating foundation.

pub fn _apply_cli_overlays() {
    // Intentionally empty for foundation cut.
}

```

### crates/micronode/src/config/env_overlay.rs
<a id="crates-micronode-src-config-envoverlay-rs"></a>

```rust
//! RO:WHAT — Placeholder for richer env overlays (kept for tree parity).
//! RO:WHY  — Your TODO tree references this module explicitly.

pub fn _apply_env_overlays() {
    // Intentionally empty for foundation cut.
}

```

### crates/micronode/src/config/hot_reload.rs
<a id="crates-micronode-src-config-hotreload-rs"></a>

```rust
//! RO:WHAT — Placeholder for config hot-reload (notify-based).
//! RO:WHY  — Wire later; keep module present so imports won't break.

pub fn _spawn_config_watcher() {
    // Intentionally empty for foundation cut.
}

```

### crates/micronode/src/config/load.rs
<a id="crates-micronode-src-config-load-rs"></a>

```rust
//! RO:WHAT — Load config from file and env overlays (foundation).
//! RO:WHY  — Keep `main.rs` tiny; centralize TOML + env behavior and
//!           provide a single `load_config()` entrypoint.
//! RO:INTERACTS —
//!   - Reads TOML from `MICRONODE_CONFIG` or well-known paths.
//!   - Applies env overrides for bind/dev-routes (storage is TOML-only
//!     for now; env wiring can be added later).
//!     RO:INVARIANTS —
//!   - Always returns a validated `Config` or a typed `Error::Config`.
//!   - Defaults are safe (amnesia-first, local bind).
//!   - File overlays are applied in a deterministic order.

use std::{env, fs, path::PathBuf};

use crate::errors::{Error, Result};

use super::schema::Config;
use super::validate::validate;

/// Entry point used by `main.rs` to construct the runtime config.
///
/// Order of precedence:
///
/// 1. Start from `Config::default()` (safe defaults).
/// 2. If `MICRONODE_CONFIG` is set, load that TOML and merge.
/// 3. Else, try `./configs/micronode.toml`.
/// 4. Else, try `./crates/micronode/configs/micronode.toml`.
/// 5. Apply env overrides (bind address, dev routes).
/// 6. Run `validate` to enforce invariants.
///
/// Any failure in file IO, TOML parse, or validation is surfaced as
/// `Error::Config` and causes startup to fail-fast.
pub fn load_config() -> Result<Config> {
    let mut cfg = Config::default();

    if let Some(path) = discover_config_path() {
        overlay_file(&mut cfg, path)?;
    }

    overlay_env(&mut cfg)?;
    validate(&cfg)?;
    Ok(cfg)
}

/// Try to locate a config file on disk.
///
/// This intentionally accepts multiple fallbacks to allow:
/// - `MICRONODE_CONFIG` when run under systemd/k8s.
/// - `./configs/micronode.toml` for workspace-local dev.
/// - `./crates/micronode/configs/micronode.toml` for crate-local dev.
fn discover_config_path() -> Option<PathBuf> {
    if let Ok(path) = env::var("MICRONODE_CONFIG") {
        return Some(PathBuf::from(path));
    }

    let workspace_local = PathBuf::from("configs/micronode.toml");
    if workspace_local.exists() {
        return Some(workspace_local);
    }

    let crate_local = PathBuf::from("crates/micronode/configs/micronode.toml");
    if crate_local.exists() {
        return Some(crate_local);
    }

    None
}

/// Overlay TOML config from the given path onto the existing `cfg`.
fn overlay_file(cfg: &mut Config, path: PathBuf) -> Result<()> {
    let s =
        fs::read_to_string(&path).map_err(|e| Error::Config(format!("read {:?}: {e}", path)))?;
    let from: Config =
        toml::from_str(&s).map_err(|e| Error::Config(format!("parse {:?}: {e}", path)))?;

    // Take the current cfg by value, merge, then write back.
    let base = std::mem::take(cfg);
    *cfg = merge(base, from);

    Ok(())
}

/// Apply env-var overrides on top of the parsed config.
///
/// Current surface:
/// - `BIND_ADDR` — override `server.bind`
/// - `MICRONODE_DEV_ROUTES=1` — enable dev routes
///
/// Storage is intentionally configured via TOML only in beta; env-based
/// overrides can be added later when the surface stabilizes.
fn overlay_env(cfg: &mut Config) -> Result<()> {
    if let Ok(addr) = env::var("BIND_ADDR") {
        let parsed = addr
            .parse()
            .map_err(|e| Error::Config(format!("BIND_ADDR parse error ({addr}): {e}")))?;
        cfg.server.bind = parsed;
    }

    if let Ok(flag) = env::var("MICRONODE_DEV_ROUTES") {
        let enabled = flag == "1" || flag.eq_ignore_ascii_case("true");
        cfg.server.dev_routes = enabled;
    }

    Ok(())
}

/// Merge two config instances, with `from` overriding `base`.
///
/// For now this is a simple "last writer wins" overlay; if/when we add
/// partial inheritance we can make this more granular.
fn merge(mut base: Config, from: Config) -> Config {
    // Server section: file/env wins completely.
    base.server = from.server;

    // Storage section: file/env wins completely.
    //
    // This keeps the default (amnesia-first) profile unless the TOML
    // explicitly opts into a different engine or path.
    base.storage = from.storage;

    base
}

```

### crates/micronode/src/config/mod.rs
<a id="crates-micronode-src-config-mod-rs"></a>

```rust
//! RO:WHAT — Config module root.
//! RO:WHY  — Schema + loaders + validation + overlays (env/CLI).
pub mod cli_overlay;
pub mod env_overlay;
pub mod hot_reload;
pub mod load;
pub mod schema;
pub mod validate;

```

### crates/micronode/src/config/schema.rs
<a id="crates-micronode-src-config-schema-rs"></a>

```rust
//! RO:WHAT — Config schema for Micronode.
//! RO:WHY  — Define a typed configuration model (TOML + env overlays)
//!           including server bind options and storage posture.
//! RO:INTERACTS — Parsed from TOML in `config::load`, validated in
//!                `config::validate`, stored in `AppState`.
//! RO:INVARIANTS —
//!   - Defaults are safe and amnesia-first (in-memory storage).
//!   - `StorageEngine::Sled` requires a non-empty `storage.path`
//!     (enforced in `validate`).
//!   - Config is cloneable and sendable across tasks.

use serde::Deserialize;
use std::net::SocketAddr;

/// Top-level Micronode configuration.
///
/// Maps 1:1 to the `micronode.toml` structure:
///
/// ```toml
/// [server]
/// bind = "127.0.0.1:5310"
/// dev_routes = true
///
/// [storage]
/// engine = "mem"
/// # path = "micronode-data"
/// ```
#[derive(Debug, Clone, Deserialize, Default)]
pub struct Config {
    pub server: Server,
    #[serde(default)]
    pub storage: StorageCfg,
}

/// HTTP server configuration.
#[derive(Debug, Clone, Deserialize)]
pub struct Server {
    /// Bind address for the Micronode HTTP listener.
    pub bind: SocketAddr,
    /// Whether to expose `/dev/*` routes (echo, etc.).
    #[serde(default)]
    pub dev_routes: bool,
}

/// Storage configuration.
///
/// Beta scope:
/// - `engine = "mem"` — in-memory KV (amnesia-first, no persistence).
/// - `engine = "sled"` — persistent sled-backed KV (requires `path`).
#[derive(Debug, Clone, Deserialize, Default)]
pub struct StorageCfg {
    /// Storage engine selection, defaults to `"mem"`.
    ///
    /// Serialized as lowercase strings: `"mem"`, `"sled"`.
    #[serde(default)]
    pub engine: StorageEngine,
    /// Optional on-disk path for sled.
    ///
    /// Required (non-empty) when `engine = "sled"`.
    #[serde(default)]
    pub path: Option<String>,
}

/// Storage engine kind.
#[derive(Debug, Clone, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "lowercase")]
pub enum StorageEngine {
    /// In-memory store (amnesia-first profile).
    #[default]
    Mem,
    /// Sled-backed KV store (persistent profile).
    Sled,
}

impl Default for Server {
    fn default() -> Self {
        // Same default bind the crate already uses in configs.
        let bind =
            "127.0.0.1:5310".parse().expect("hard-coded default bind must be valid SocketAddr");

        Server { bind, dev_routes: false }
    }
}

```

### crates/micronode/src/config/validate.rs
<a id="crates-micronode-src-config-validate-rs"></a>

```rust
//! RO:WHAT — Validation for Micronode configuration.
//! RO:WHY  — Catch invalid configs early (on startup) with clear
//!           error messages instead of failing deep in runtime code.
//! RO:INTERACTS — Called from `config::load::load_config` once TOML
//!                and env overlays have been applied.
//! RO:INVARIANTS —
//!   - Bind address must be usable (non-zero port).
//!   - `StorageEngine::Sled` requires a non-empty path.
//!   - Validation never mutates the config.

use crate::errors::{Error, Result};

use super::schema::{Config, StorageEngine};

/// Validate a fully assembled configuration.
///
/// Returns `Ok(())` if the config is usable; otherwise returns
/// `Error::Config` with a human-readable description.
pub fn validate(cfg: &Config) -> Result<()> {
    // Basic sanity on server.bind.
    if cfg.server.bind.port() == 0 {
        return Err(Error::Config("server.bind must not use port 0 (ephemeral)".to_string()));
    }

    // Storage posture checks.
    match cfg.storage.engine {
        StorageEngine::Mem => {
            // In-memory is always valid; path is ignored.
        }
        StorageEngine::Sled => {
            // Sled requires a non-empty path so we don't silently spray
            // data into the working directory.
            let path_ok =
                cfg.storage.path.as_deref().map(|s| !s.trim().is_empty()).unwrap_or(false);

            if !path_ok {
                return Err(Error::Config(
                    "storage.engine=\"sled\" requires storage.path to be set and non-empty"
                        .to_string(),
                ));
            }
        }
    }

    Ok(())
}

```

### crates/micronode/src/errors.rs
<a id="crates-micronode-src-errors-rs"></a>

```rust
//! RO:WHAT — Error types for Micronode (foundation).
//! RO:WHY  — Stable envelopes and anyhow interop.
//! RO:INVARIANTS — Avoid leaking secrets; messages deterministic for SDKs.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("config: {0}")]
    Config(String),
    #[error("internal error")]
    Internal,
}

pub type Result<T> = std::result::Result<T, Error>;

```

### crates/micronode/src/facets/feed.rs
<a id="crates-micronode-src-facets-feed-rs"></a>

```rust

```

### crates/micronode/src/facets/graph.rs
<a id="crates-micronode-src-facets-graph-rs"></a>

```rust

```

### crates/micronode/src/facets/media.rs
<a id="crates-micronode-src-facets-media-rs"></a>

```rust

```

### crates/micronode/src/facets/mod.rs
<a id="crates-micronode-src-facets-mod-rs"></a>

```rust

```

### crates/micronode/src/facets/search.rs
<a id="crates-micronode-src-facets-search-rs"></a>

```rust

```

### crates/micronode/src/http/admin.rs
<a id="crates-micronode-src-http-admin-rs"></a>

```rust
//! RO:WHAT — Admin plane: /metrics, /healthz, /readyz, /version.
//! RO:WHY  — Golden surfaces; shared by all RON services.
//! RO:INVARIANTS — Truthful readyz; explicit dev override in handler.

use crate::{observability, state::AppState};
use axum::{extract::State, http::StatusCode, response::IntoResponse};
use prometheus::{Encoder, TextEncoder};

pub async fn metrics(_: State<AppState>) -> impl IntoResponse {
    let families = prometheus::gather();
    let mut buf = Vec::new();
    let _ = TextEncoder::new().encode(&families, &mut buf);
    (StatusCode::OK, buf)
}

pub async fn healthz() -> impl IntoResponse {
    observability::health::handler().await
}

pub async fn readyz(State(st): State<AppState>) -> impl IntoResponse {
    observability::ready::handler(st.probes.clone()).await
}

pub async fn version() -> impl IntoResponse {
    observability::version::handler().await
}

```

### crates/micronode/src/http/kv.rs
<a id="crates-micronode-src-http-kv-rs"></a>

```rust
//! RO:WHAT — KV v1 HTTP handlers: PUT/GET/DELETE /kv/{bucket}/{key}.
//! RO:WHY  — Provide a minimal key/value API for Micronode, backed by Storage.
//! RO:INTERACTS — state::AppState (storage), storage::Storage, layers (body cap, decode guard).
//! RO:INVARIANTS — Binary-safe; no JSON; caps/enforced by layers; no auth yet.
//! RO:METRICS — HTTP metrics handled by global middleware; KV domain metrics later.
//! RO:CONFIG — No per-route config yet; concurrency/body caps are applied in app.rs.
//! RO:SECURITY — No auth/policy here; must be added via middleware in a later step.
//! RO:TEST — To be covered by integration tests (kv_roundtrip, guard_behavior).

use crate::state::AppState;
use axum::{
    body::Bytes,
    extract::{Path, State},
    http::{header, StatusCode},
    response::IntoResponse,
};

/// PUT /kv/{bucket}/{key}
///
/// Body is treated as opaque bytes with `Content-Type: application/octet-stream`.
/// Returns 201 on create, 204 on update, 500 on internal errors.
pub async fn put_kv(
    State(st): State<AppState>,
    Path((bucket, key)): Path<(String, String)>,
    body: Bytes,
) -> impl IntoResponse {
    match st.storage.put(&bucket, &key, &body) {
        Ok(true) => StatusCode::CREATED,
        Ok(false) => StatusCode::NO_CONTENT,
        Err(_e) => StatusCode::INTERNAL_SERVER_ERROR,
    }
}

/// GET /kv/{bucket}/{key}
///
/// Returns 200 with raw bytes and `Content-Type: application/octet-stream`
/// or 404 if the key is absent.
pub async fn get_kv(
    State(st): State<AppState>,
    Path((bucket, key)): Path<(String, String)>,
) -> impl IntoResponse {
    match st.storage.get(&bucket, &key) {
        Ok(Some(bytes)) => {
            (StatusCode::OK, [(header::CONTENT_TYPE, "application/octet-stream")], bytes)
                .into_response()
        }
        Ok(None) => StatusCode::NOT_FOUND.into_response(),
        Err(_e) => StatusCode::INTERNAL_SERVER_ERROR.into_response(),
    }
}

/// DELETE /kv/{bucket}/{key}
///
/// Returns 204 if a value was deleted, 404 if it did not exist.
pub async fn delete_kv(
    State(st): State<AppState>,
    Path((bucket, key)): Path<(String, String)>,
) -> impl IntoResponse {
    match st.storage.delete(&bucket, &key) {
        Ok(true) => StatusCode::NO_CONTENT,
        Ok(false) => StatusCode::NOT_FOUND,
        Err(_e) => StatusCode::INTERNAL_SERVER_ERROR,
    }
}

```

### crates/micronode/src/http/mod.rs
<a id="crates-micronode-src-http-mod-rs"></a>

```rust
//! RO:WHAT — HTTP handlers (admin + basic routes + dev).
//! RO:WHY  — Keep app.rs readable.

pub mod admin;
pub mod kv;
pub mod routes;

pub mod dev {
    pub use super::routes::dev::echo;
}

```

### crates/micronode/src/http/routes.rs
<a id="crates-micronode-src-http-routes-rs"></a>

```rust
//! RO:WHAT — Public and dev routes for Micronode.

use axum::{http::StatusCode, Json};
use serde_json::{json, Value};

// --- /v1/ping ---
pub async fn ping() -> Json<Value> {
    Json(json!({ "pong": true }))
}

// --- /dev/echo ---
// Echoes JSON payload deterministically. Requires Content-Type: application/json
// and (by policy) Content-Length (enforced by BodyCap layer).
pub mod dev {
    use super::*;
    use axum::response::IntoResponse;

    /// Echo JSON back; reject non-JSON early.
    pub async fn echo(Json(body): Json<Value>) -> impl IntoResponse {
        (StatusCode::OK, Json(body))
    }
}

```

### crates/micronode/src/layers/body_cap.rs
<a id="crates-micronode-src-layers-bodycap-rs"></a>

```rust
// crates/micronode/src/layers/body_cap.rs
//! RO:WHAT  — Header-level body cap + content-length policy.
//! RO:WHY   — Enforce explicit Content-Length only on methods that typically
//!            carry bodies (POST/PUT/PATCH). Don't force it for GET/DELETE.
//! RO:NOTE  — Still reject if a Content-Length is present but exceeds the cap.
//! RO:HTTP  — 411 Length Required; 413 Payload Too Large.

use axum::http::{Request, StatusCode};
use axum::response::IntoResponse;
use std::convert::Infallible;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use tower::{Layer, Service};

#[derive(Clone, Copy)]
pub struct BodyCapLayer {
    cap_bytes: usize,
}

impl BodyCapLayer {
    pub fn new(cap_bytes: usize) -> Self {
        Self { cap_bytes }
    }
}

impl<S> Layer<S> for BodyCapLayer {
    type Service = BodyCapService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        BodyCapService { inner, cap_bytes: self.cap_bytes }
    }
}

#[derive(Clone)]
pub struct BodyCapService<S> {
    inner: S,
    cap_bytes: usize,
}

impl<S, B> Service<Request<B>> for BodyCapService<S>
where
    S: Service<Request<B>, Response = axum::response::Response> + Clone + Send + 'static,
    S::Future: Send + 'static,
    B: Send + 'static,
{
    type Response = S::Response;
    type Error = Infallible;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        // Delegate to inner; if inner errors, we still return Ready(Ok(())) and
        // map to 500 in call() to avoid bubbling error types here.
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Ready(Err(_)) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
        }
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        let mut inner = self.inner.clone();
        let cap = self.cap_bytes;

        // Methods that typically *carry* a body and must declare Content-Length explicitly.
        let requires_len = matches!(
            *req.method(),
            axum::http::Method::POST | axum::http::Method::PUT | axum::http::Method::PATCH
        );

        // Inspect Content-Length if present.
        let len_opt = req
            .headers()
            .get(axum::http::header::CONTENT_LENGTH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse::<usize>().ok());

        // If a Content-Length is present on ANY method, enforce the cap.
        if let Some(len) = len_opt {
            if len > cap {
                return Box::pin(async move {
                    Ok((StatusCode::PAYLOAD_TOO_LARGE, "payload too large").into_response())
                });
            }
        }

        // For methods that *require* an explicit Content-Length, enforce presence.
        if requires_len && len_opt.is_none() {
            return Box::pin(async move {
                Ok((StatusCode::LENGTH_REQUIRED, "length required").into_response())
            });
        }

        Box::pin(async move {
            Ok(inner.call(req).await.unwrap_or_else(|_| {
                (StatusCode::INTERNAL_SERVER_ERROR, "internal error").into_response()
            }))
        })
    }
}

```

### crates/micronode/src/layers/concurrency.rs
<a id="crates-micronode-src-layers-concurrency-rs"></a>

```rust
//! RO:WHAT — Per-route non-blocking concurrency cap (429 when saturated).
//! RO:WHY  — Shed load early without stalling worker threads.
//! RO:AXUM — Tower Layer to satisfy Axum 0.7 trait bounds.

use axum::{
    body::Body,
    http::Request,
    response::{IntoResponse, Response},
};
use http::StatusCode;
use std::{
    convert::Infallible,
    future::Future,
    pin::Pin,
    sync::Arc,
    task::{Context, Poll},
};
use tokio::sync::Semaphore;
use tower::{Layer, Service};

type BoxFut = Pin<Box<dyn Future<Output = Result<Response, Infallible>> + Send + 'static>>;

#[derive(Clone)]
pub struct ConcurrencyLayer {
    sema: Arc<Semaphore>,
}

impl ConcurrencyLayer {
    pub fn new(sema: Arc<Semaphore>) -> Self {
        Self { sema }
    }
}

impl<S> Layer<S> for ConcurrencyLayer {
    type Service = ConcurrencyService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        ConcurrencyService { inner, sema: self.sema.clone() }
    }
}

#[derive(Clone)]
pub struct ConcurrencyService<S> {
    inner: S,
    sema: Arc<Semaphore>,
}

impl<S> Service<Request<Body>> for ConcurrencyService<S>
where
    S: Service<Request<Body>, Response = Response, Error = Infallible> + Clone + Send + 'static,
    S::Future: Send + 'static,
{
    type Response = Response;
    type Error = Infallible;
    type Future = BoxFut;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
            Poll::Ready(Err(_)) => Poll::Ready(Ok(())),
        }
    }

    fn call(&mut self, req: Request<Body>) -> Self::Future {
        let mut inner = self.inner.clone();

        // Use OWNED permit so it is 'static-safe inside the async block.
        match self.sema.clone().try_acquire_owned() {
            Ok(permit) => Box::pin(async move {
                let resp = inner.call(req).await?;
                drop(permit); // explicit for clarity
                Ok(resp)
            }),
            Err(_) => Box::pin(async move {
                Ok((StatusCode::TOO_MANY_REQUESTS, "concurrency limit exceeded").into_response())
            }),
        }
    }
}

```

### crates/micronode/src/layers/decode_guard.rs
<a id="crates-micronode-src-layers-decodeguard-rs"></a>

```rust
// crates/micronode/src/layers/decode_guard.rs
//! RO:WHAT — Simple decode policy guard: reject any Content-Encoding and stacked encodings.
//! RO:WHY  — We don't transparently decompress; callers must send identity bodies.

use axum::{
    body::Body,
    http::{header, Request, StatusCode},
    middleware::Next,
    response::{IntoResponse, Response},
};

/// Stateless decode guard: 415 on any Content-Encoding; 415 on stacked encodings ("," in header).
pub async fn guard(req: Request<Body>, next: Next) -> Response {
    match req.headers().get(header::CONTENT_ENCODING) {
        None => next.run(req).await,
        Some(hv) => {
            let enc = match hv.to_str() {
                Ok(s) => s,
                Err(_) => {
                    return (StatusCode::UNSUPPORTED_MEDIA_TYPE, "invalid Content-Encoding header")
                        .into_response();
                }
            };

            if enc.contains(',') {
                return (
                    StatusCode::UNSUPPORTED_MEDIA_TYPE,
                    "stacked content encodings are not supported",
                )
                    .into_response();
            }

            (StatusCode::UNSUPPORTED_MEDIA_TYPE, "compressed request bodies are not supported")
                .into_response()
        }
    }
}

```

### crates/micronode/src/layers/mod.rs
<a id="crates-micronode-src-layers-mod-rs"></a>

```rust
//! RO:WHAT — Ingress guard layers (body cap, decode guard, concurrency).
//! RO:WHY  — Enforce limits *before* heavy work; deterministic early rejects.

pub mod body_cap;
pub mod concurrency;
pub mod decode_guard;

```

### crates/micronode/src/lib.rs
<a id="crates-micronode-src-lib-rs"></a>

```rust
//! RO:WHAT — Micronode library surface (router assembly, config, observability).
#![forbid(unsafe_code)]

pub mod app;
pub mod config;
pub mod errors;
pub mod http;
pub mod layers;
pub mod limits;
pub mod observability;
pub mod state;
pub mod storage;
pub mod types;

pub use app::build_router;

```

### crates/micronode/src/limits.rs
<a id="crates-micronode-src-limits-rs"></a>

```rust
//! RO:WHAT — Central HTTP/OAP limit constants (foundation only).
//! RO:WHY  — Hardening blueprint: size/time/concurrency must be explicit.
//! RO:INVARIANTS — OAP max_frame=1MiB; decoded body cap defaults to 1MiB.

pub const OAP_MAX_FRAME_BYTES: usize = 1_048_576; // 1 MiB
pub const HTTP_BODY_CAP_BYTES: usize = 1_048_576; // 1 MiB

```

### crates/micronode/src/main.rs
<a id="crates-micronode-src-main-rs"></a>

```rust
//! RO:WHAT — Micronode binary entry: load config, init logs, wire readiness, run HTTP.
//! RO:WHY  — Single-binary Micronode with truthful /readyz and dev override.
//! RO:INVARIANTS — No locks across .await; flip readiness probes at the right moments.

#![forbid(unsafe_code)]

use micronode::{app::build_router, config::load::load_config, observability::logging};
use ron_kernel::wait_for_ctrl_c;
use std::net::SocketAddr;
use tracing::{error, info};

#[tokio::main(flavor = "multi_thread")]
async fn main() {
    logging::init();

    // Load config
    let cfg = match load_config() {
        Ok(c) => c,
        Err(e) => {
            error!("config load failed: {e:#}");
            std::process::exit(2);
        }
    };

    // Build router and capture state
    let (router, st) = build_router(cfg.clone());

    // Probe: config successfully loaded
    st.probes.set_cfg_loaded(true);

    let bind: SocketAddr = cfg.server.bind;
    info!("micronode starting on http://{bind}");

    // Bind listener (readiness depends on this)
    let listener = match tokio::net::TcpListener::bind(bind).await {
        Ok(l) => {
            st.probes.set_listeners_bound(true);
            l
        }
        Err(e) => {
            error!("bind failed on {bind}: {e:#}");
            std::process::exit(98);
        }
    };

    // We've registered /metrics; treat exporter as "bound" (process-exposed).
    st.probes.set_metrics_bound(true);

    // Run server with graceful shutdown
    let server = axum::serve(listener, router).with_graceful_shutdown(async {
        wait_for_ctrl_c().await;
        info!("shutdown signal received");
    });

    if let Err(e) = server.await {
        error!("server error: {e:#}");
    }
}

```

### crates/micronode/src/observability/health.rs
<a id="crates-micronode-src-observability-health-rs"></a>

```rust
//! RO:WHAT — /healthz handler adapter (thin wrapper if we need custom shape later).
//! RO:WHY  — Keep admin.rs simple.
//! RO:INVARIANTS — Truthful.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct Health {
    ok: bool,
}

pub async fn handler() -> impl IntoResponse {
    Json(Health { ok: true })
}

```

### crates/micronode/src/observability/http_metrics.rs
<a id="crates-micronode-src-observability-httpmetrics-rs"></a>

```rust
//! RO:WHAT — Minimal HTTP metrics middleware (request count + latency).
//! RO:WHY  — Golden metrics parity across services, with stable metric names:
//!           `micronode_http_requests_total` and `micronode_request_latency_seconds`.
//!
//! RO:INVARIANTS —
//!   - Never propagates errors (Error = Infallible).
//!   - Records a 500 status in metrics if the inner service errors.
//!   - No locks held across `.await`.
//!
//! RO:METRICS —
//!   - micronode_http_requests_total{method,route,status}
//!   - micronode_request_latency_seconds
//!
//! RO:CONFIG — Transparent; router decides which routes are wrapped.

use std::{
    convert::Infallible,
    future::Future,
    pin::Pin,
    sync::OnceLock,
    task::{Context, Poll},
    time::Instant,
};

use axum::{body::Body, http::Request, response::Response};
use prometheus::{Histogram, HistogramOpts, IntCounterVec, Opts};
use tower::{Layer, Service};
use tracing::error;

// --- Static metric families (initialized on first use) ---

static REQS: OnceLock<IntCounterVec> = OnceLock::new();
static LAT: OnceLock<Histogram> = OnceLock::new();

fn reqs() -> &'static IntCounterVec {
    REQS.get_or_init(|| {
        let opts = Opts::new(
            "micronode_http_requests_total",
            "Total HTTP requests processed by Micronode",
        );
        let vec = IntCounterVec::new(opts, &["method", "route", "status"])
            .expect("construct micronode_http_requests_total");

        prometheus::default_registry()
            .register(Box::new(vec.clone()))
            .expect("register micronode_http_requests_total");

        vec
    })
}

fn lat() -> &'static Histogram {
    LAT.get_or_init(|| {
        let opts = HistogramOpts::new(
            "micronode_request_latency_seconds",
            "HTTP request latency observed by Micronode",
        )
        .buckets(prometheus::DEFAULT_BUCKETS.to_vec());

        let hist = Histogram::with_opts(opts).expect("construct micronode_request_latency_seconds");

        prometheus::default_registry()
            .register(Box::new(hist.clone()))
            .expect("register micronode_request_latency_seconds");

        hist
    })
}

// --- Tower Layer implementation ---

#[derive(Clone, Default)]
pub struct HttpMetricsLayer;

impl<S> Layer<S> for HttpMetricsLayer {
    type Service = HttpMetrics<S>;

    fn layer(&self, inner: S) -> Self::Service {
        HttpMetrics { inner }
    }
}

#[derive(Clone)]
pub struct HttpMetrics<S> {
    inner: S,
}

impl<S> Service<Request<Body>> for HttpMetrics<S>
where
    S: Service<Request<Body>, Response = Response> + Clone + Send + 'static,
    S::Error: std::error::Error + Send + Sync + 'static,
    S::Future: Send + 'static,
{
    type Response = S::Response;
    type Error = Infallible;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
            Poll::Ready(Err(e)) => {
                // For foundation cut, we log readiness errors but don't propagate them.
                error!("HttpMetrics inner not ready: {e}");
                Poll::Ready(Ok(()))
            }
        }
    }

    fn call(&mut self, req: Request<Body>) -> Self::Future {
        let method = req.method().as_str().to_owned();
        let route = req.uri().path().to_owned();
        let start = Instant::now();

        let mut inner = self.inner.clone();

        Box::pin(async move {
            let result = inner.call(req).await;
            let elapsed = start.elapsed().as_secs_f64();

            match result {
                Ok(resp) => {
                    let status = resp.status().as_u16().to_string();
                    reqs().with_label_values(&[&method, &route, &status]).inc();
                    lat().observe(elapsed);
                    Ok(resp)
                }
                Err(e) => {
                    error!("handler error in HttpMetrics: {e}");
                    // Record as a 500 in metrics.
                    let status = String::from("500");
                    reqs().with_label_values(&[&method, &route, &status]).inc();
                    lat().observe(elapsed);

                    let resp = Response::builder()
                        .status(500)
                        .body(Body::from("internal error"))
                        .expect("build 500 response in HttpMetrics");

                    Ok(resp)
                }
            }
        })
    }
}

/// Convenience constructor so app.rs can stay clean.
pub fn layer() -> HttpMetricsLayer {
    HttpMetricsLayer
}

/// Prewarm so the metric families are registered and visible at `/metrics`
/// even before the first real request hits.
pub fn prewarm() {
    let _ = reqs();
    let _ = lat();
}

```

### crates/micronode/src/observability/logging.rs
<a id="crates-micronode-src-observability-logging-rs"></a>

```rust
//! RO:WHAT — Tracing subscriber initialization.
//! RO:WHY  — Deterministic logs with env filter.

use tracing_subscriber::{fmt, EnvFilter};

pub fn init() {
    let filter = std::env::var("RUST_LOG").unwrap_or_else(|_| "info,micronode=debug".to_string());
    let _ = fmt().with_env_filter(EnvFilter::new(filter)).try_init();
}

```

### crates/micronode/src/observability/metrics.rs
<a id="crates-micronode-src-observability-metrics-rs"></a>

```rust


```

### crates/micronode/src/observability/mod.rs
<a id="crates-micronode-src-observability-mod-rs"></a>

```rust
//! RO:WHAT — Observability surfaces: logging and version/health/ready adapters.
//! RO:WHY  — Keep app.rs lean; centralize obs stack.

pub mod health;
pub mod http_metrics;
pub mod logging;
pub mod ready;
pub mod version;
// `metrics` module is kept for future richer gauges/counters; currently a stub.
pub mod metrics;

```

### crates/micronode/src/observability/ready.rs
<a id="crates-micronode-src-observability-ready-rs"></a>

```rust
//! RO:WHAT — Readiness probes and `/readyz` handler (truthful by default).
//! RO:WHY  — Operators need a machine-readable snapshot of liveness gates.
//! RO:INVARIANTS
//!   - Required probes: listeners_bound && cfg_loaded.
//!   - Optional probes: metrics_bound, deps_ok (storage/index/etc).
//!   - Dev override via MICRONODE_DEV_READY=1 returns 200 immediately.

use axum::{http::StatusCode, response::IntoResponse, Json};
use serde::Serialize;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

#[derive(Debug)]
pub struct ReadyProbes {
    listeners_bound: AtomicBool,
    cfg_loaded: AtomicBool,
    metrics_bound: AtomicBool,
    deps_ok: AtomicBool, // placeholder: storage/index/queue/etc
}

impl ReadyProbes {
    /// Construct probes with a conservative-but-truthful baseline for the
    /// current Micronode profile.
    ///
    /// For the in-memory storage engine, `deps_ok` is effectively always true
    /// once the process is up: there is no fallible external dependency to
    /// gate on. We initialise `deps_ok` to true so that "truthful" mode
    /// reflects reality today.
    ///
    /// When we add a fallible engine (sled / overlay / remote index), that
    /// engine's open result should drive `set_deps_ok(false|true)` instead.
    pub fn new() -> Self {
        Self {
            listeners_bound: AtomicBool::new(false),
            cfg_loaded: AtomicBool::new(false),
            metrics_bound: AtomicBool::new(false),
            deps_ok: AtomicBool::new(true),
        }
    }

    // --- Setters (flip true when satisfied) ---

    pub fn set_listeners_bound(&self, v: bool) {
        self.listeners_bound.store(v, Ordering::Release);
    }

    pub fn set_cfg_loaded(&self, v: bool) {
        self.cfg_loaded.store(v, Ordering::Release);
    }

    pub fn set_metrics_bound(&self, v: bool) {
        self.metrics_bound.store(v, Ordering::Release);
    }

    pub fn set_deps_ok(&self, v: bool) {
        self.deps_ok.store(v, Ordering::Release);
    }

    // --- Snapshot & decision ---

    pub fn snapshot(&self) -> ReadySnapshot {
        ReadySnapshot {
            listeners_bound: self.listeners_bound.load(Ordering::Acquire),
            cfg_loaded: self.cfg_loaded.load(Ordering::Acquire),
            metrics_bound: self.metrics_bound.load(Ordering::Acquire),
            deps_ok: self.deps_ok.load(Ordering::Acquire),
        }
    }
}

// Clippy: new-without-default — keep `new()` as the semantic ctor and
// delegate `Default` to it.
impl Default for ReadyProbes {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct ReadySnapshot {
    pub listeners_bound: bool,
    pub cfg_loaded: bool,
    pub metrics_bound: bool,
    pub deps_ok: bool,
}

impl ReadySnapshot {
    /// REQUIRED probes for 200 OK. Adjust here if you want stricter gates.
    ///
    /// Today we keep this minimal: Micronode is "ready" once it is listening
    /// and config has been successfully loaded. Optional probes such as
    /// metrics_bound and deps_ok are still included in the JSON payload for
    /// operators and dashboards but do not flip the readiness bit.
    pub fn required_ready(&self) -> bool {
        self.listeners_bound && self.cfg_loaded
    }
}

#[derive(Serialize)]
#[serde(deny_unknown_fields)]
struct ReadyReport {
    ready: bool,
    probes: ReadySnapshot,
    mode: &'static str, // "dev-forced" or "truthful"
}

pub async fn handler(probes: Arc<ReadyProbes>) -> impl IntoResponse {
    // Dev override: force ready for local benches/smokes.
    if matches!(
        std::env::var("MICRONODE_DEV_READY").as_deref(),
        Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
    ) {
        let snap = probes.snapshot();
        let report = ReadyReport { ready: true, probes: snap, mode: "dev-forced" };
        return (StatusCode::OK, Json(report)).into_response();
    }

    let snap = probes.snapshot();
    let ok = snap.required_ready();
    let status = if ok { StatusCode::OK } else { StatusCode::SERVICE_UNAVAILABLE };

    let report = ReadyReport { ready: ok, probes: snap, mode: "truthful" };

    (status, Json(report)).into_response()
}

```

### crates/micronode/src/observability/version.rs
<a id="crates-micronode-src-observability-version-rs"></a>

```rust
//! RO:WHAT — /version payload.
//! RO:WHY  — Build provenance for ops.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct VersionResp<'a> {
    name: &'a str,
    version: &'a str,
    built_at_unix: u64,
}

pub async fn handler() -> impl IntoResponse {
    let built =
        option_env!("MICRONODE_BUILD_UNIX").and_then(|s| s.parse::<u64>().ok()).unwrap_or(0);
    Json(VersionResp {
        name: "micronode",
        version: env!("CARGO_PKG_VERSION"),
        built_at_unix: built,
    })
}

```

### crates/micronode/src/security/amnesia.rs
<a id="crates-micronode-src-security-amnesia-rs"></a>

```rust

```

### crates/micronode/src/security/auth_macaroon.rs
<a id="crates-micronode-src-security-authmacaroon-rs"></a>

```rust

```

### crates/micronode/src/security/mod.rs
<a id="crates-micronode-src-security-mod-rs"></a>

```rust

```

### crates/micronode/src/security/pq_config.rs
<a id="crates-micronode-src-security-pqconfig-rs"></a>

```rust

```

### crates/micronode/src/security/pq_observe.rs
<a id="crates-micronode-src-security-pqobserve-rs"></a>

```rust

```

### crates/micronode/src/security/pq_toggle.rs
<a id="crates-micronode-src-security-pqtoggle-rs"></a>

```rust

```

### crates/micronode/src/security/tls_rustls.rs
<a id="crates-micronode-src-security-tlsrustls-rs"></a>

```rust

```

### crates/micronode/src/state.rs
<a id="crates-micronode-src-state-rs"></a>

```rust
//! RO:WHAT — Process state container: config, metrics, health, readiness probes, storage.
//! RO:WHY  — Keep shared handles in one place for Axum State.
//! RO:INTERACTS — config::schema::Config, observability::ready::ReadyProbes, ron_kernel::Metrics, storage::MemStore.
//! RO:INVARIANTS — No locks across `.await`; handles are clone-friendly; storage is behind a trait.
//! RO:METRICS — Metrics handle exported via /metrics (Prometheus).
//! RO:CONFIG — Config drives server bind/dev routes (storage engine later).
//! RO:SECURITY — No capabilities enforced here (auth/policy lives at handlers).
//! RO:TEST — Covered by HTTP integration tests that exercise AppState via routes.

use crate::config::schema::Config;
use crate::observability::ready::ReadyProbes;
use crate::storage::{DynStorage, MemStore};
use ron_kernel::metrics::health::HealthState;
use ron_kernel::Metrics;
use std::sync::Arc;

#[derive(Clone)]
pub struct AppState {
    pub cfg: Config,
    pub metrics: Arc<Metrics>,    // exported via /metrics
    pub health: Arc<HealthState>, // liveness
    pub probes: Arc<ReadyProbes>, // readiness (truthful)
    pub storage: DynStorage,      // key/value engine (mem today, pluggable later)
}

impl AppState {
    pub fn new(cfg: Config) -> Self {
        // false = we don't auto-serve exporter here (we expose /metrics via axum)
        let metrics: Arc<Metrics> = Metrics::new(false);
        let health = Arc::new(HealthState::new());
        let probes = Arc::new(ReadyProbes::new());

        // For now Micronode always boots with the in-memory store.
        // Later, Config::storage.engine will select sled vs mem.
        let storage: DynStorage = Arc::new(MemStore::new());

        // Baseline liveness true; readiness remains truthful via probes.
        health.set("micronode", true);

        Self { cfg, metrics, health, probes, storage }
    }
}

```

### crates/micronode/src/storage/mod.rs
<a id="crates-micronode-src-storage-mod-rs"></a>

```rust
//! RO:WHAT — Storage abstraction for Micronode (KV engine + in-memory implementation).
//! RO:WHY  — Give Micronode a boring key/value API that can later plug sled/RocksDB/etc.
//! RO:INTERACTS — Used by state::AppState and HTTP KV handlers (http::kv).
//! RO:INVARIANTS — No locks across `.await`; operations are short, bounded, and sync.
//! RO:METRICS — KV ops/bytes metrics can be layered on top later (domain counters).
//! RO:CONFIG — Engine selection will come from Config (engine="mem" | "sled") in a later step.
//! RO:SECURITY — No auth here; capability/policy checks live at HTTP layer.
//! RO:TEST — Unit tests for MemStore + HTTP integration tests for KV routes (future).

use crate::errors::Result;
use parking_lot::RwLock;
use std::collections::HashMap;
use std::sync::Arc;

/// Trait for Micronode KV engines.
///
/// This is intentionally small and synchronous; HTTP handlers stay async and
/// call into this trait without holding locks across `.await`.
pub trait Storage: Send + Sync {
    /// Insert or overwrite a value.
    ///
    /// Returns `Ok(true)` if the key was newly created, `Ok(false)` if it
    /// replaced an existing value.
    fn put(&self, bucket: &str, key: &str, value: &[u8]) -> Result<bool>;

    /// Fetch a value, if present.
    fn get(&self, bucket: &str, key: &str) -> Result<Option<Vec<u8>>>;

    /// Delete a value.
    ///
    /// Returns `Ok(true)` if a value existed and was removed, `Ok(false)` if
    /// the key was absent.
    fn delete(&self, bucket: &str, key: &str) -> Result<bool>;
}

/// Shared trait object type for storage engines.
pub type DynStorage = Arc<dyn Storage + Send + Sync>;

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
struct BucketKey {
    bucket: String,
    key: String,
}

impl BucketKey {
    fn new(bucket: &str, key: &str) -> Self {
        Self { bucket: bucket.to_owned(), key: key.to_owned() }
    }
}

/// Simple in-memory store backed by a `RwLock<HashMap<BucketKey, Vec<u8>>>`.
///
/// Intended for:
///   - dev/prototyping
///   - amnesia-first micronode profiles
///   - tests
#[derive(Debug, Default)]
pub struct MemStore {
    inner: RwLock<HashMap<BucketKey, Vec<u8>>>,
}

impl MemStore {
    pub fn new() -> Self {
        Self::default()
    }
}

impl Storage for MemStore {
    fn put(&self, bucket: &str, key: &str, value: &[u8]) -> Result<bool> {
        let k = BucketKey::new(bucket, key);
        let mut guard = self.inner.write();
        let existed = guard.insert(k, value.to_vec()).is_some();
        Ok(!existed)
    }

    fn get(&self, bucket: &str, key: &str) -> Result<Option<Vec<u8>>> {
        let k = BucketKey::new(bucket, key);
        let guard = self.inner.read();
        Ok(guard.get(&k).cloned())
    }

    fn delete(&self, bucket: &str, key: &str) -> Result<bool> {
        let k = BucketKey::new(bucket, key);
        let mut guard = self.inner.write();
        Ok(guard.remove(&k).is_some())
    }
}

// In the next step we can add:
//
// #[cfg(feature = "sled-store")]
// pub mod sled_store;
//
// and implement `Storage` for a sled-backed engine.

```

### crates/micronode/src/storage/sled_store.rs
<a id="crates-micronode-src-storage-sledstore-rs"></a>

```rust
// crates/micronode/src/storage/sled_store.rs
//! RO:WHAT — Sled-backed Storage adapter (bucket = tree; key = binary value).
//! RO:MODE — Behind `sled-store` feature; not used by default.
//! RO:ERRS — Map sled errors to `Error::Internal` (beta scope).

#[cfg(feature = "sled-store")]
mod sled_adapter {
    use super::super::{Storage};
    use crate::errors::{Error, Result};
    use std::sync::Arc;

    pub struct SledStore {
        db: sled::Db,
    }

    impl SledStore {
        pub fn open(path: &str) -> Result<Arc<Self>> {
            let db = sled::open(path).map_err(|_| Error::Internal)?;
            Ok(Arc::new(Self { db }))
        }

        #[inline]
        fn tree(&self, bucket: &str) -> Result<sled::Tree> {
            self.db.open_tree(bucket).map_err(|_| Error::Internal)
        }
    }

    impl Storage for SledStore {
        fn put(&self, bucket: &str, key: &str, val: &[u8]) -> Result<()> {
            let t = self.tree(bucket)?;
            t.insert(key.as_bytes(), val).map_err(|_| Error::Internal)?;
            Ok(())
        }

        fn get(&self, bucket: &str, key: &str) -> Result<Option<Vec<u8>>> {
            let t = self.tree(bucket)?;
            let v = t.get(key.as_bytes()).map_err(|_| Error::Internal)?;
            Ok(v.map(|ivec| ivec.to_vec()))
        }

        fn del(&self, bucket: &str, key: &str) -> Result<bool> {
            let t = self.tree(bucket)?;
            let removed = t.remove(key.as_bytes()).map_err(|_| Error::Internal)?;
            Ok(removed.is_some())
        }
    }
}

// Public re-export only when feature is enabled.
#[cfg(feature = "sled-store")]
pub use sled_adapter::SledStore;

```

### crates/micronode/src/types.rs
<a id="crates-micronode-src-types-rs"></a>

```rust
//! RO:WHAT — Shared DTOs for tiny endpoints (/version, dev echo).
//! RO:WHY  — Keep handler files small and composable.
//! RO:INVARIANTS — DTO hygiene: #[serde(deny_unknown_fields)].

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Version {
    pub name: &'static str,
    pub version: &'static str,
    pub built_at_unix: u64,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Echo {
    pub message: String,
}

```

### crates/micronode/tests/admin_parity.rs
<a id="crates-micronode-tests-adminparity-rs"></a>

```rust
//! RO:WHAT — Integration tests for Micronode admin plane.
//! RO:WHY  — Ensure `/healthz`, `/readyz`, `/version`, `/metrics` are wired
//!           and behave sanely in-process (no external binaries needed).
//! RO:HOW  — Spin up an ephemeral axum server using `build_router` and
//!           hit it with `reqwest`.
//!
//! These are intentionally high-level smoke tests:
//!   - If they fail, the node is not “basically alive”.
//!   - They double as a template for future KV / guard tests.

use std::{net::SocketAddr, time::Duration};

use micronode::app::build_router;
use micronode::config::schema::{Config, Server};
use reqwest::StatusCode;
use tokio::task::JoinHandle;

/// Spawn an in-process Micronode instance on an ephemeral port.
///
/// This mirrors the main binary’s bootstrap pattern but avoids config
/// files and uses a synthetic `Config` pointing at `127.0.0.1:0`.
async fn spawn_micronode() -> (SocketAddr, JoinHandle<()>) {
    // Bind an ephemeral port first so we know where to hit the server.
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.expect("bind test listener");
    let addr = listener.local_addr().expect("get local address for test listener");

    // Minimal config: bind address + dev routes (handy for future tests).
    let cfg = Config { server: Server { bind: addr, dev_routes: true }, ..Config::default() };

    // Build router + state the same way the binary does.
    let (router, state) = build_router(cfg);

    // Flip readiness probes to a “healthy” state.
    //
    // This matches what the main binary does after binding listeners
    // and wiring metrics. For now we treat deps_ok as true because the
    // in-memory store has no external failure mode.
    state.probes.set_cfg_loaded(true);
    state.probes.set_listeners_bound(true);
    state.probes.set_metrics_bound(true);
    state.probes.set_deps_ok(true);

    // Run the server in the background. Dropping the handle will cancel it.
    let handle = tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, router).await {
            eprintln!("[micronode-test] server error: {err}");
        }
    });

    (addr, handle)
}

#[tokio::test]
async fn admin_endpoints_are_healthy_and_observable() {
    let (addr, _handle) = spawn_micronode().await;
    let base = format!("http://{}", addr);

    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(2))
        .build()
        .expect("build reqwest client");

    // /healthz — must be 200 and JSON { "ok": true }.
    let health = client.get(format!("{base}/healthz")).send().await.expect("GET /healthz");
    assert!(health.status().is_success(), "expected 2xx from /healthz, got {}", health.status());
    let health_body: serde_json::Value = health.json().await.expect("parse /healthz json");
    assert_eq!(
        health_body["ok"],
        serde_json::Value::Bool(true),
        "expected /healthz.ok == true, got {health_body}"
    );

    // /readyz — must be 200 and JSON { "ready": true, ... } in truthful mode.
    let ready = client.get(format!("{base}/readyz")).send().await.expect("GET /readyz");
    assert_eq!(ready.status(), StatusCode::OK, "expected 200 from /readyz, got {}", ready.status());
    let ready_body: serde_json::Value = ready.json().await.expect("parse /readyz json");
    assert_eq!(
        ready_body["ready"],
        serde_json::Value::Bool(true),
        "expected /readyz.ready == true, got {ready_body}"
    );

    // /version — must be 200 and at least contain `name: "micronode"`.
    let version = client.get(format!("{base}/version")).send().await.expect("GET /version");
    assert!(version.status().is_success(), "expected 2xx from /version, got {}", version.status());
    let version_body: serde_json::Value = version.json().await.expect("parse /version json");
    assert_eq!(
        version_body["name"],
        serde_json::Value::String("micronode".to_string()),
        "expected /version.name == \"micronode\", got {version_body}"
    );

    // /metrics — must be 200 and contain at least the micronode HTTP series.
    let metrics = client.get(format!("{base}/metrics")).send().await.expect("GET /metrics");
    assert!(metrics.status().is_success(), "expected 2xx from /metrics, got {}", metrics.status());
    let metrics_text = metrics.text().await.expect("read /metrics text");

    assert!(
        metrics_text.contains("micronode_http_requests_total"),
        "expected /metrics to contain micronode_http_requests_total; got:\n{}",
        metrics_text
    );
    assert!(
        metrics_text.contains("micronode_request_latency_seconds"),
        "expected /metrics to contain micronode_request_latency_seconds; got:\n{}",
        metrics_text
    );
}

```

### crates/micronode/tests/amnesia_proof.rs
<a id="crates-micronode-tests-amnesiaproof-rs"></a>

```rust


```

### crates/micronode/tests/backpressure.rs
<a id="crates-micronode-tests-backpressure-rs"></a>

```rust


```

### crates/micronode/tests/facets_proxy.rs
<a id="crates-micronode-tests-facetsproxy-rs"></a>

```rust


```

### crates/micronode/tests/guard_behavior.rs
<a id="crates-micronode-tests-guardbehavior-rs"></a>

```rust
//! RO:WHAT — Integration tests for Micronode guard behavior (decode + body cap).
//! RO:WHY  — Assert that `DecodeGuard` and `BodyCapLayer` behave as specified
//!           on real HTTP routes (no mock services).
//!
//! RO:INVARIANTS —
//!   - Any `Content-Encoding` on guarded routes yields 415.
//!   - Payloads over `HTTP_BODY_CAP_BYTES` yield 413.
//!
//! These tests exercise `/dev/echo`, which is wired with:
//!   DecodeGuard -> BodyCapLayer -> ConcurrencyLayer -> handler.

use std::{net::SocketAddr, time::Duration};

use micronode::app::build_router;
use micronode::config::schema::{Config, Server};
use micronode::limits::HTTP_BODY_CAP_BYTES;
use reqwest::StatusCode;
use tokio::task::JoinHandle;

/// Spawn an in-process Micronode instance on an ephemeral port, with
/// dev routes enabled and readiness probes flipped to "healthy".
async fn spawn_micronode() -> (SocketAddr, JoinHandle<()>) {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.expect("bind test listener");
    let addr = listener.local_addr().expect("get local address for test listener");

    let cfg = Config { server: Server { bind: addr, dev_routes: true }, ..Config::default() };

    let (router, state) = build_router(cfg);

    state.probes.set_cfg_loaded(true);
    state.probes.set_listeners_bound(true);
    state.probes.set_metrics_bound(true);
    state.probes.set_deps_ok(true);

    let handle = tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, router).await {
            eprintln!("[micronode-guard-test] server error: {err}");
        }
    });

    (addr, handle)
}

#[tokio::test]
async fn decode_guard_rejects_any_content_encoding() {
    let (addr, _handle) = spawn_micronode().await;
    let base = format!("http://{}", addr);
    let url = format!("{base}/dev/echo");

    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(2))
        .build()
        .expect("build reqwest client");

    let resp = client
        .post(&url)
        .header("content-type", "application/json")
        .header("content-encoding", "gzip")
        .body(r#"{"message":"hi"}"#)
        .send()
        .await
        .expect("POST /dev/echo with content-encoding");

    assert_eq!(
        resp.status(),
        StatusCode::UNSUPPORTED_MEDIA_TYPE,
        "expected 415 from DecodeGuard on any Content-Encoding, got {}",
        resp.status()
    );
}

#[tokio::test]
async fn body_cap_enforces_max_payload_size() {
    let (addr, _handle) = spawn_micronode().await;
    let base = format!("http://{}", addr);
    let url = format!("{base}/dev/echo");

    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(5))
        .build()
        .expect("build reqwest client");

    // Construct a payload that is one byte over the configured cap.
    let over_cap_len = (HTTP_BODY_CAP_BYTES as usize).saturating_add(1);
    let payload = vec![b'a'; over_cap_len];

    let resp = client
        .post(&url)
        .header("content-type", "application/json")
        .body(payload)
        .send()
        .await
        .expect("POST /dev/echo with over-cap payload");

    assert_eq!(
        resp.status(),
        StatusCode::PAYLOAD_TOO_LARGE,
        "expected 413 from BodyCapLayer for payload > HTTP_BODY_CAP_BYTES, got {}",
        resp.status()
    );
}

```

### crates/micronode/tests/kv_roundtrip.rs
<a id="crates-micronode-tests-kvroundtrip-rs"></a>

```rust
//! RO:WHAT — Integration tests for Micronode KV v1 HTTP API.
//! RO:WHY  — Assert that PUT/GET/DELETE /v1/kv/{bucket}/{key} behave as
//!           documented, using the same router wiring as the binary.
//! RO:INVARIANTS —
//!   - In-memory storage engine behaves like a simple KV store.
//!   - Readiness probes are flipped to "healthy" for the duration of the test.

use std::{net::SocketAddr, time::Duration};

use micronode::app::build_router;
use micronode::config::schema::{Config, Server};
use reqwest::StatusCode;
use tokio::task::JoinHandle;

/// Spawn an in-process Micronode instance on an ephemeral port.
///
/// Mirrors the binary bootstrap pattern:
///   - Bind 127.0.0.1:0
///   - Build router from Config
///   - Flip readiness probes so /readyz is truthfully "ready"
async fn spawn_micronode() -> (SocketAddr, JoinHandle<()>) {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.expect("bind test listener");
    let addr = listener.local_addr().expect("get local address for test listener");

    // Minimal config: bind address + dev routes enabled (harmless for KV tests).
    let cfg = Config { server: Server { bind: addr, dev_routes: true }, ..Config::default() };

    let (router, state) = build_router(cfg);

    // Make readiness truthful for the in-memory engine.
    state.probes.set_cfg_loaded(true);
    state.probes.set_listeners_bound(true);
    state.probes.set_metrics_bound(true);
    state.probes.set_deps_ok(true);

    let handle = tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, router).await {
            eprintln!("[micronode-kv-test] server error: {err}");
        }
    });

    (addr, handle)
}

#[tokio::test]
async fn kv_put_get_delete_roundtrip() {
    let (addr, _handle) = spawn_micronode().await;
    let base = format!("http://{}", addr);
    let key_url = format!("{base}/v1/kv/a/k");

    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(2))
        .build()
        .expect("build reqwest client");

    // 1) PUT — create key with "hello" payload.
    let put = client
        .put(&key_url)
        .header("content-type", "application/octet-stream")
        .body("hello")
        .send()
        .await
        .expect("PUT /v1/kv/a/k");
    assert_eq!(put.status(), StatusCode::CREATED, "expected 201 from PUT, got {}", put.status());

    // 2) GET — verify payload echoes back verbatim.
    let get = client.get(&key_url).send().await.expect("GET /v1/kv/a/k (after PUT)");
    assert_eq!(
        get.status(),
        StatusCode::OK,
        "expected 200 from GET after PUT, got {}",
        get.status()
    );
    let body = get.bytes().await.expect("read GET body");
    assert_eq!(&body[..], b"hello", "expected GET body == b\"hello\"");

    // 3) DELETE — remove key.
    let del = client.delete(&key_url).send().await.expect("DELETE /v1/kv/a/k");
    assert_eq!(
        del.status(),
        StatusCode::NO_CONTENT,
        "expected 204 from DELETE, got {}",
        del.status()
    );

    // 4) GET again — now we expect 404.
    let get_missing = client.get(&key_url).send().await.expect("GET /v1/kv/a/k (after DELETE)");
    assert_eq!(
        get_missing.status(),
        StatusCode::NOT_FOUND,
        "expected 404 from GET after DELETE, got {}",
        get_missing.status()
    );
}

```

### crates/micronode/tests/oap_limits.rs
<a id="crates-micronode-tests-oaplimits-rs"></a>

```rust


```

### crates/micronode/tests/pq_fallback.rs
<a id="crates-micronode-tests-pqfallback-rs"></a>

```rust


```

### crates/micronode/tests/pq_modes.rs
<a id="crates-micronode-tests-pqmodes-rs"></a>

```rust


```

### crates/micronode/tests_chaos/degrade_shed.rs
<a id="crates-micronode-testschaos-degradeshed-rs"></a>

```rust

```

### crates/micronode/tests_loom/shutdown_interleavings.rs
<a id="crates-micronode-testsloom-shutdowninterleavings-rs"></a>

```rust

```

### crates/micronode/tests_property/oap_fuzz.rs
<a id="crates-micronode-testsproperty-oapfuzz-rs"></a>

```rust

```

### crates/micronode/tests_property/pq_handshake_props.rs
<a id="crates-micronode-testsproperty-pqhandshakeprops-rs"></a>

```rust

```

