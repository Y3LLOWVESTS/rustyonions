<!-- Generated by scripts/make_crate_codex.sh on 2025-11-17T20:12:21Z -->
# Code Bundle — `micronode`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/micronode/.clippy.toml](#crates-micronode--clippy-toml)
- [crates/micronode/.rustfmt.toml](#crates-micronode--rustfmt-toml)
- [crates/micronode/Cargo.toml](#crates-micronode-Cargo-toml)
- [crates/micronode/benches/http_kv.rs](#crates-micronode-benches-httpkv-rs)
- [crates/micronode/benches/oap_frame_perf.rs](#crates-micronode-benches-oapframeperf-rs)
- [crates/micronode/benches/pq_overhead.rs](#crates-micronode-benches-pqoverhead-rs)
- [crates/micronode/benches/readiness_walk.rs](#crates-micronode-benches-readinesswalk-rs)
- [crates/micronode/build.rs](#crates-micronode-build-rs)
- [crates/micronode/configs/micronode.amnesia.off.toml](#crates-micronode-configs-micronode-amnesia-off-toml)
- [crates/micronode/configs/micronode.dev.toml](#crates-micronode-configs-micronode-dev-toml)
- [crates/micronode/configs/micronode.pq.required.toml](#crates-micronode-configs-micronode-pq-required-toml)
- [crates/micronode/configs/micronode.pq.toml](#crates-micronode-configs-micronode-pq-toml)
- [crates/micronode/configs/micronode.toml](#crates-micronode-configs-micronode-toml)
- [crates/micronode/deny.toml](#crates-micronode-deny-toml)
- [crates/micronode/examples/quickstart.rs](#crates-micronode-examples-quickstart-rs)
- [crates/micronode/fuzz/config_from_env_fuzz.rs](#crates-micronode-fuzz-configfromenvfuzz-rs)
- [crates/micronode/fuzz/pq_kex_fuzz.rs](#crates-micronode-fuzz-pqkexfuzz-rs)
- [crates/micronode/scripts/beta_check.sh](#crates-micronode-scripts-betacheck-sh)
- [crates/micronode/scripts/chaos_degrade_shed.sh](#crates-micronode-scripts-chaosdegradeshed-sh)
- [crates/micronode/scripts/fs_spy_amnesia.sh](#crates-micronode-scripts-fsspyamnesia-sh)
- [crates/micronode/scripts/gen_diagrams.sh](#crates-micronode-scripts-gendiagrams-sh)
- [crates/micronode/scripts/pq_matrix_ci.sh](#crates-micronode-scripts-pqmatrixci-sh)
- [crates/micronode/scripts/run_dev.sh](#crates-micronode-scripts-rundev-sh)
- [crates/micronode/scripts/smoke_micronode.sh](#crates-micronode-scripts-smokemicronode-sh)
- [crates/micronode/scripts/smoke_oap_limits.sh](#crates-micronode-scripts-smokeoaplimits-sh)
- [crates/micronode/specs/oap_vectors.json](#crates-micronode-specs-oapvectors-json)
- [crates/micronode/specs/pq_handshake_cases.json](#crates-micronode-specs-pqhandshakecases-json)
- [crates/micronode/src/adapters/index_client.rs](#crates-micronode-src-adapters-indexclient-rs)
- [crates/micronode/src/adapters/mailbox_client.rs](#crates-micronode-src-adapters-mailboxclient-rs)
- [crates/micronode/src/adapters/mod.rs](#crates-micronode-src-adapters-mod-rs)
- [crates/micronode/src/adapters/overlay_client.rs](#crates-micronode-src-adapters-overlayclient-rs)
- [crates/micronode/src/adapters/policy_client.rs](#crates-micronode-src-adapters-policyclient-rs)
- [crates/micronode/src/adapters/storage_client.rs](#crates-micronode-src-adapters-storageclient-rs)
- [crates/micronode/src/app.rs](#crates-micronode-src-app-rs)
- [crates/micronode/src/cli/args.rs](#crates-micronode-src-cli-args-rs)
- [crates/micronode/src/cli/mod.rs](#crates-micronode-src-cli-mod-rs)
- [crates/micronode/src/cli/run.rs](#crates-micronode-src-cli-run-rs)
- [crates/micronode/src/concurrency/backpressure.rs](#crates-micronode-src-concurrency-backpressure-rs)
- [crates/micronode/src/concurrency/mod.rs](#crates-micronode-src-concurrency-mod-rs)
- [crates/micronode/src/concurrency/registry.rs](#crates-micronode-src-concurrency-registry-rs)
- [crates/micronode/src/concurrency/shutdown.rs](#crates-micronode-src-concurrency-shutdown-rs)
- [crates/micronode/src/config/cli_overlay.rs](#crates-micronode-src-config-clioverlay-rs)
- [crates/micronode/src/config/env_overlay.rs](#crates-micronode-src-config-envoverlay-rs)
- [crates/micronode/src/config/hot_reload.rs](#crates-micronode-src-config-hotreload-rs)
- [crates/micronode/src/config/load.rs](#crates-micronode-src-config-load-rs)
- [crates/micronode/src/config/mod.rs](#crates-micronode-src-config-mod-rs)
- [crates/micronode/src/config/schema.rs](#crates-micronode-src-config-schema-rs)
- [crates/micronode/src/config/validate.rs](#crates-micronode-src-config-validate-rs)
- [crates/micronode/src/errors.rs](#crates-micronode-src-errors-rs)
- [crates/micronode/src/facets/feed.rs](#crates-micronode-src-facets-feed-rs)
- [crates/micronode/src/facets/graph.rs](#crates-micronode-src-facets-graph-rs)
- [crates/micronode/src/facets/loader.rs](#crates-micronode-src-facets-loader-rs)
- [crates/micronode/src/facets/manifest.rs](#crates-micronode-src-facets-manifest-rs)
- [crates/micronode/src/facets/media.rs](#crates-micronode-src-facets-media-rs)
- [crates/micronode/src/facets/mod.rs](#crates-micronode-src-facets-mod-rs)
- [crates/micronode/src/facets/search.rs](#crates-micronode-src-facets-search-rs)
- [crates/micronode/src/http/admin.rs](#crates-micronode-src-http-admin-rs)
- [crates/micronode/src/http/kv.rs](#crates-micronode-src-http-kv-rs)
- [crates/micronode/src/http/mod.rs](#crates-micronode-src-http-mod-rs)
- [crates/micronode/src/http/routes.rs](#crates-micronode-src-http-routes-rs)
- [crates/micronode/src/layers/body_cap.rs](#crates-micronode-src-layers-bodycap-rs)
- [crates/micronode/src/layers/concurrency.rs](#crates-micronode-src-layers-concurrency-rs)
- [crates/micronode/src/layers/decode_guard.rs](#crates-micronode-src-layers-decodeguard-rs)
- [crates/micronode/src/layers/mod.rs](#crates-micronode-src-layers-mod-rs)
- [crates/micronode/src/layers/security.rs](#crates-micronode-src-layers-security-rs)
- [crates/micronode/src/lib.rs](#crates-micronode-src-lib-rs)
- [crates/micronode/src/limits.rs](#crates-micronode-src-limits-rs)
- [crates/micronode/src/main.rs](#crates-micronode-src-main-rs)
- [crates/micronode/src/observability/health.rs](#crates-micronode-src-observability-health-rs)
- [crates/micronode/src/observability/http_metrics.rs](#crates-micronode-src-observability-httpmetrics-rs)
- [crates/micronode/src/observability/logging.rs](#crates-micronode-src-observability-logging-rs)
- [crates/micronode/src/observability/metrics.rs](#crates-micronode-src-observability-metrics-rs)
- [crates/micronode/src/observability/mod.rs](#crates-micronode-src-observability-mod-rs)
- [crates/micronode/src/observability/ready.rs](#crates-micronode-src-observability-ready-rs)
- [crates/micronode/src/observability/version.rs](#crates-micronode-src-observability-version-rs)
- [crates/micronode/src/security/amnesia.rs](#crates-micronode-src-security-amnesia-rs)
- [crates/micronode/src/security/auth_macaroon.rs](#crates-micronode-src-security-authmacaroon-rs)
- [crates/micronode/src/security/mod.rs](#crates-micronode-src-security-mod-rs)
- [crates/micronode/src/security/pq_config.rs](#crates-micronode-src-security-pqconfig-rs)
- [crates/micronode/src/security/pq_observe.rs](#crates-micronode-src-security-pqobserve-rs)
- [crates/micronode/src/security/pq_toggle.rs](#crates-micronode-src-security-pqtoggle-rs)
- [crates/micronode/src/security/tls_rustls.rs](#crates-micronode-src-security-tlsrustls-rs)
- [crates/micronode/src/state.rs](#crates-micronode-src-state-rs)
- [crates/micronode/src/storage/mod.rs](#crates-micronode-src-storage-mod-rs)
- [crates/micronode/src/storage/sled_store.rs](#crates-micronode-src-storage-sledstore-rs)
- [crates/micronode/src/types.rs](#crates-micronode-src-types-rs)
- [crates/micronode/tests/admin_parity.rs](#crates-micronode-tests-adminparity-rs)
- [crates/micronode/tests/amnesia_proof.rs](#crates-micronode-tests-amnesiaproof-rs)
- [crates/micronode/tests/auth_gate.rs](#crates-micronode-tests-authgate-rs)
- [crates/micronode/tests/backpressure.rs](#crates-micronode-tests-backpressure-rs)
- [crates/micronode/tests/cli_smoke.rs](#crates-micronode-tests-clismoke-rs)
- [crates/micronode/tests/facets_loader.rs](#crates-micronode-tests-facetsloader-rs)
- [crates/micronode/tests/facets_proxy.rs](#crates-micronode-tests-facetsproxy-rs)
- [crates/micronode/tests/guard_behavior.rs](#crates-micronode-tests-guardbehavior-rs)
- [crates/micronode/tests/kv_roundtrip.rs](#crates-micronode-tests-kvroundtrip-rs)
- [crates/micronode/tests/oap_limits.rs](#crates-micronode-tests-oaplimits-rs)
- [crates/micronode/tests/pq_fallback.rs](#crates-micronode-tests-pqfallback-rs)
- [crates/micronode/tests/pq_modes.rs](#crates-micronode-tests-pqmodes-rs)
- [crates/micronode/tests_chaos/degrade_shed.rs](#crates-micronode-testschaos-degradeshed-rs)
- [crates/micronode/tests_loom/shutdown_interleavings.rs](#crates-micronode-testsloom-shutdowninterleavings-rs)
- [crates/micronode/tests_property/oap_fuzz.rs](#crates-micronode-testsproperty-oapfuzz-rs)
- [crates/micronode/tests_property/pq_handshake_props.rs](#crates-micronode-testsproperty-pqhandshakeprops-rs)

### crates/micronode/.clippy.toml
<a id="crates-micronode--clippy-toml"></a>

```toml
# Minimal, valid Clippy config (use only supported keys)
cognitive-complexity-threshold = 35
too-many-lines-threshold = 400

```

### crates/micronode/.rustfmt.toml
<a id="crates-micronode--rustfmt-toml"></a>

```toml
max_width = 100
use_small_heuristics = "Max"
# Keep stable-only options here; nightly-only options (like format_code_in_doc_comments) are removed.

```

### crates/micronode/Cargo.toml
<a id="crates-micronode-Cargo-toml"></a>

```toml
[package]
name = "micronode"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false
build = "build.rs"

[lib]
name = "micronode"
path = "src/lib.rs"

[[bin]]
name = "micronode"
path = "src/main.rs"

[features]
# RO:WHAT  — Feature flags for Micronode.
# RO:WHY   — Let us pick storage engines (mem vs sled) and later gate facets.
# RO:NOTE  — For now we only gate storage; graph/search/feed/media remain stubs.
default = ["mem-store"]

# In-memory storage engine (hashmap/RwLock). Always available.
mem-store = []

# Sled-backed storage engine (optional, may be used by KV v1 later).
sled-store = ["sled"]

[dependencies]
# RON workspace crates
ron-kernel = { path = "../ron-kernel" }
ron-proto  = { path = "../ron-proto" }
oap        = { path = "../oap" }

# Async/HTTP stack (workspace-standard pins)
tokio       = { version = "1", features = ["macros", "rt-multi-thread", "signal", "time", "io-util", "sync", "net", "fs"] }
axum        = { version = "0.7", default-features = false, features = ["tokio", "http1", "http2", "json"] }
tower       = "0.5"
tower-http  = { version = "0.6.6", features = ["trace"] }
http        = "1"

# Obs & logging
tracing            = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
prometheus         = "0.14"

# Config & serde
serde           = { version = "1.0", features = ["derive"] }
serde_json      = "1"
toml            = "0.8"
humantime-serde = "1"
anyhow          = "1.0"
thiserror       = "1.0"

# Utilities
parking_lot = "0.12"

# Storage engine (optional; gated by 'sled-store' feature)
sled = { version = "0.34", optional = true }

[dev-dependencies]
# HTTP client for admin/guard/KV tests
reqwest = { version = "0.12", features = ["rustls-tls-native-roots", "json"] }
tempfile = "3"

# Criterion for micro-benchmarks (in-process HTTP router benches)
criterion = { version = "0.5", features = ["html_reports", "async"] }

[[bench]]
name = "http_kv"
harness = false

```

### crates/micronode/benches/http_kv.rs
<a id="crates-micronode-benches-httpkv-rs"></a>

```rust
// crates/micronode/benches/http_kv.rs
//! Simple HTTP-level benchmarks for micronode.
//!
//! RO:WHAT — Benchmark the in-process Axum router for:
//!   - `/healthz` fast-path.
//!   - `/v1/kv/{bucket}/{key}` small PUT/GET/DELETE roundtrip.
//!   - `/v1/kv/{bucket}/{key}` hot reject via DecodeGuard (Content-Encoding).
//!
//! RO:WHY  — Give us a quick sanity check on HTTP latencies for the Micronode
//!           profile without binding a real TCP port.
//!
//! RO:HOW  — Build the Router via `build_router(Config::default())` and drive
//!           requests with a Tokio runtime + `Router::oneshot(req)` inside a
//!           Criterion `b.iter(...)` loop.

use axum::body::Body;
use axum::Router;
use criterion::{criterion_group, criterion_main, Criterion};
use http::{Method, Request, StatusCode};
use micronode::app::build_router;
use micronode::config::schema::Config;
use tower::ServiceExt as _; // for `oneshot`

fn build_app() -> Router {
    // For benches we can rely on Config::default(): it should give us
    // localhost bind + in-memory storage engine.
    let cfg = Config::default();
    let (router, _state) = build_router(cfg);
    router
}

fn bench_healthz(c: &mut Criterion) {
    let router = build_app();

    // Shared runtime for this benchmark.
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .expect("failed to build tokio runtime for benches");

    c.bench_function("http_healthz_fast_path", |b| {
        b.iter(|| {
            // Clone the Router so `oneshot(self, req)` can take ownership.
            let router = router.clone();

            rt.block_on(async move {
                let req = Request::builder()
                    .method(Method::GET)
                    .uri("/healthz")
                    .body(Body::empty())
                    .expect("healthz request build failed");

                let resp = router.oneshot(req).await.expect("healthz handler failed");

                // Sanity: ensure we stayed on the happy path.
                assert_eq!(resp.status(), StatusCode::OK);
            });
        });
    });
}

fn bench_kv_small_roundtrip(c: &mut Criterion) {
    let router = build_app();

    // Shared runtime for this benchmark.
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .expect("failed to build tokio runtime for benches");

    c.bench_function("http_kv_small_put_get_delete", |b| {
        b.iter(|| {
            // Clone the Router so `oneshot(self, req)` can take ownership.
            let router = router.clone();

            rt.block_on(async move {
                let bucket = "bench";
                let key = "k";

                // Payload for PUT — we must set an accurate Content-Length
                // because BodyCapLayer enforces it for POST/PUT/PATCH.
                let payload = "hello-micronode";
                let payload_len = payload.len().to_string();

                // PUT small value
                let put_req = Request::builder()
                    .method(Method::PUT)
                    .uri(format!("/v1/kv/{}/{}", bucket, key))
                    .header("content-type", "application/octet-stream")
                    .header("content-length", payload_len)
                    .body(Body::from(payload.to_owned()))
                    .expect("PUT request build failed");

                let put_resp = router.clone().oneshot(put_req).await.expect("PUT handler failed");
                assert!(
                    put_resp.status().is_success(),
                    "expected PUT success, got {}",
                    put_resp.status()
                );

                // GET the value
                let get_req = Request::builder()
                    .method(Method::GET)
                    .uri(format!("/v1/kv/{}/{}", bucket, key))
                    .body(Body::empty())
                    .expect("GET request build failed");

                let get_resp = router.clone().oneshot(get_req).await.expect("GET handler failed");
                assert_eq!(get_resp.status(), StatusCode::OK);

                // DELETE it
                let del_req = Request::builder()
                    .method(Method::DELETE)
                    .uri(format!("/v1/kv/{}/{}", bucket, key))
                    .body(Body::empty())
                    .expect("DELETE request build failed");

                let del_resp = router.oneshot(del_req).await.expect("DELETE handler failed");
                assert!(
                    del_resp.status().is_success(),
                    "expected DELETE success, got {}",
                    del_resp.status()
                );
            });
        });
    });
}

fn bench_kv_decode_guard_hot_reject(c: &mut Criterion) {
    let router = build_app();

    // Shared runtime for this benchmark.
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .expect("failed to build tokio runtime for benches");

    c.bench_function("http_kv_decode_guard_hot_reject", |b| {
        b.iter(|| {
            // Clone the Router so `oneshot(self, req)` can take ownership.
            let router = router.clone();

            rt.block_on(async move {
                let bucket = "bench";
                let key = "guard";

                // Tiny payload with accurate length so BodyCapLayer is satisfied
                // and we actually exercise DecodeGuard.
                let payload = "x";
                let payload_len = payload.len().to_string();

                let req = Request::builder()
                    .method(Method::PUT)
                    .uri(format!("/v1/kv/{}/{}", bucket, key))
                    .header("content-type", "application/octet-stream")
                    .header("content-length", payload_len)
                    .header("content-encoding", "gzip")
                    .body(Body::from(payload.to_owned()))
                    .expect("decode-guard PUT request build failed");

                let resp = router.oneshot(req).await.expect("decode-guard handler failed");

                // Sanity: ensure we’re measuring the hot reject, not a 411 from BodyCap.
                assert_eq!(
                    resp.status(),
                    StatusCode::UNSUPPORTED_MEDIA_TYPE,
                    "expected 415 from DecodeGuard, got {}",
                    resp.status()
                );
            });
        });
    });
}

criterion_group!(
    micronode_http,
    bench_healthz,
    bench_kv_small_roundtrip,
    bench_kv_decode_guard_hot_reject
);
criterion_main!(micronode_http);

```

### crates/micronode/benches/oap_frame_perf.rs
<a id="crates-micronode-benches-oapframeperf-rs"></a>

```rust


```

### crates/micronode/benches/pq_overhead.rs
<a id="crates-micronode-benches-pqoverhead-rs"></a>

```rust


```

### crates/micronode/benches/readiness_walk.rs
<a id="crates-micronode-benches-readinesswalk-rs"></a>

```rust


```

### crates/micronode/build.rs
<a id="crates-micronode-build-rs"></a>

```rust
// RO:WHAT — build script that stamps a UNIX build time for /version.
// RO:WHY  — Observability/versioning; helps triage running binaries.
// RO:INVARIANTS — Emits MICRONODE_BUILD_UNIX env var always.
fn main() {
    println!("cargo:rustc-env=MICRONODE_BUILD_UNIX={}", chrono_unix());
}

fn chrono_unix() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_secs().to_string())
        .unwrap_or_else(|_| "0".to_string())
}

```

### crates/micronode/configs/micronode.amnesia.off.toml
<a id="crates-micronode-configs-micronode-amnesia-off-toml"></a>

```toml

```

### crates/micronode/configs/micronode.dev.toml
<a id="crates-micronode-configs-micronode-dev-toml"></a>

```toml

```

### crates/micronode/configs/micronode.pq.required.toml
<a id="crates-micronode-configs-micronode-pq-required-toml"></a>

```toml

```

### crates/micronode/configs/micronode.pq.toml
<a id="crates-micronode-configs-micronode-pq-toml"></a>

```toml

```

### crates/micronode/configs/micronode.toml
<a id="crates-micronode-configs-micronode-toml"></a>

```toml
# RO:WHAT — Default Micronode config (beta profile).
# RO:WHY  — Workspace-local defaults for dev and smoke tests.
#           This file is safe to check in: it binds to localhost and
#           uses in-memory storage (amnesia-first).
# RO:INVARIANTS —
#   - Localhost-only bind.
#   - Dev routes enabled for quick smokes.
#   - Storage is in-memory (`engine = "mem"`) by default.

[server]
bind = "127.0.0.1:5310"
dev_routes = true

[storage]
# Amnesia-first: keep everything in memory unless explicitly changed.
engine = "mem"

# Optional: uncomment and switch engine to "sled" when you want
# persistence for this Micronode instance.
#
# engine = "sled"
# path = "micronode-data"

```

### crates/micronode/deny.toml
<a id="crates-micronode-deny-toml"></a>

```toml
[advisories]
yanked = "deny"
unmaintained = "deny"
vulnerability = "deny"

[licenses]
allow = ["MIT", "Apache-2.0"]

```

### crates/micronode/examples/quickstart.rs
<a id="crates-micronode-examples-quickstart-rs"></a>

```rust
// crates/micronode/examples/quickstart.rs
//! RO:WHAT — Minimal example entrypoint so `cargo build` succeeds.
//! RO:HOW  — Prints a hint to use the primary binary (`cargo run -p micronode`).
//! RO:FUTURE — Can be replaced later with a runnable SDK demo.

fn main() {
    println!("Micronode quickstart example.");
    println!("Run the server with:");
    println!("  MICRONODE_DEV_ROUTES=1 cargo run -p micronode");
}

```

### crates/micronode/fuzz/config_from_env_fuzz.rs
<a id="crates-micronode-fuzz-configfromenvfuzz-rs"></a>

```rust

```

### crates/micronode/fuzz/pq_kex_fuzz.rs
<a id="crates-micronode-fuzz-pqkexfuzz-rs"></a>

```rust

```

### crates/micronode/scripts/beta_check.sh
<a id="crates-micronode-scripts-betacheck-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Simple beta gate for `micronode`.
#
# Runs (from repo root):
#   1) fmt + clippy (warnings = errors)
#   2) unit + integration tests
#   3) HTTP+KV benchmarks (http_kv)
#   4) Smoke test via scripts/smoke_micronode.sh with dev routes enabled
#
# Usage:
#   bash crates/micronode/scripts/beta_check.sh
#
# Env toggles:
#   SKIP_BENCH=1  → skip Criterion benches (useful on battery / CI)

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../.." && pwd)"
CRATE="micronode"

echo "[beta-check] crate=${CRATE} root=${ROOT_DIR}"

cd "${ROOT_DIR}"

###############################################################################
# 1) fmt + clippy
###############################################################################
echo "[beta-check] 1) fmt + clippy"
cargo fmt -p "${CRATE}"
cargo clippy -p "${CRATE}" --no-deps -- -D warnings

###############################################################################
# 2) Tests (unit + integration + doc tests)
###############################################################################
echo "[beta-check] 2) cargo test -p ${CRATE}"
cargo test -p "${CRATE}"

###############################################################################
# 3) HTTP+KV benchmarks (optional)
###############################################################################
if [[ "${SKIP_BENCH:-0}" != "1" ]]; then
  echo "[beta-check] 3) cargo bench -p ${CRATE} --bench http_kv"
  cargo bench -p "${CRATE}" --bench http_kv
else
  echo "[beta-check] 3) benches skipped (SKIP_BENCH=1)"
fi

###############################################################################
# 4) Smoke test (admin plane + KV roundtrip)
###############################################################################
echo "[beta-check] 4) smoke_micronode.sh (with MICRONODE_DEV_ROUTES=1)"

MICRONODE_DEV_ROUTES=1 cargo run -p "${CRATE}" &
APP_PID=$!

# Give the server a moment to bind.
sleep 2

# Run the smoke script (expects 127.0.0.1:5310 by default).
bash "crates/${CRATE}/scripts/smoke_micronode.sh"

echo "[beta-check] smoke_micronode.sh OK, shutting down micronode (pid=${APP_PID})"
kill "${APP_PID}" >/dev/null 2>&1 || true
wait "${APP_PID}" 2>/dev/null || true

echo "[beta-check] ✅ ${CRATE} beta gate PASSED"

```

### crates/micronode/scripts/chaos_degrade_shed.sh
<a id="crates-micronode-scripts-chaosdegradeshed-sh"></a>

```bash

```

### crates/micronode/scripts/fs_spy_amnesia.sh
<a id="crates-micronode-scripts-fsspyamnesia-sh"></a>

```bash

```

### crates/micronode/scripts/gen_diagrams.sh
<a id="crates-micronode-scripts-gendiagrams-sh"></a>

```bash

```

### crates/micronode/scripts/pq_matrix_ci.sh
<a id="crates-micronode-scripts-pqmatrixci-sh"></a>

```bash

```

### crates/micronode/scripts/run_dev.sh
<a id="crates-micronode-scripts-rundev-sh"></a>

```bash

```

### crates/micronode/scripts/smoke_micronode.sh
<a id="crates-micronode-scripts-smokemicronode-sh"></a>

```bash
#!/usr/bin/env bash
# smoke_micronode.sh — one-shot smoke test for Micronode
# Modes:
#   (default)   — assumes micronode already running on ADDR (two-terminal workflow)
#   --spawn     — kills port holder on 5310, spawns micronode in background, runs checks, then cleans up
#
# Env knobs:
#   ADDR                 — admin/API addr (default 127.0.0.1:5310)
#   RUST_LOG             — log level when spawning (default info,micronode=debug)
#   MICRONODE_DEV_ROUTES — when spawning, enable dev routes (default 1)

set -euo pipefail

ADDR="${ADDR:-127.0.0.1:5310}"
RUST_LOG="${RUST_LOG:-info,micronode=debug}"

SPAWN=0
if [[ "${1:-}" == "--spawn" ]]; then
  SPAWN=1
fi

# Utilities (macOS-friendly)
die() { echo "[ERR] $*" >&2; exit 1; }
info() { echo "[INFO] $*"; }
ok() { echo "[OK] $*"; }
step() { echo "[STEP] $*"; }

kill_port_holders() {
  local port="$1"
  local pids
  if pids=$(lsof -ti tcp:"$port" 2>/dev/null); then
    if [[ -n "$pids" ]]; then
      info "Port $port busy. Killing holder(s)…"
      # shellcheck disable=SC2086
      kill -9 $pids || true
      sleep 0.2
    fi
  fi
}

wait_for_healthz() {
  local url="$1"
  local retries="${2:-60}" # ~60s max
  local i=0
  info "Waiting for $url ..."
  until curl -sSf -o /dev/null "$url"; do
    i=$((i+1)) || true
    if [[ "$i" -ge "$retries" ]]; then
      die "Timed out waiting for $url"
    fi
    sleep 1
  done
  ok "Healthy: $url"
}

MICRO_PID=""
LOG_FILE=""

cleanup() {
  if [[ -n "$MICRO_PID" ]]; then
    info "Killing micronode (pid=$MICRO_PID)…"
    kill "$MICRO_PID" 2>/dev/null || true
  fi
  if [[ -n "$LOG_FILE" && -f "$LOG_FILE" ]]; then
    info "Micronode logs were captured in: $LOG_FILE"
  fi
}
trap cleanup EXIT

if [[ "$SPAWN" -eq 1 ]]; then
  info "Spawn mode: will start micronode on ${ADDR}"
  # Assume ADDR is host:port; we only care about the port for kill_port_holders
  PORT="${ADDR##*:}"
  kill_port_holders "$PORT"

  LOG_FILE="$(mktemp -t micronode-smoke-XXXX.log)"
  info "Spawning micronode (logs -> $LOG_FILE)…"

  MICRONODE_DEV_ROUTES="${MICRONODE_DEV_ROUTES:-1}" \
  RUST_LOG="$RUST_LOG" \
    cargo run -p micronode >"$LOG_FILE" 2>&1 &

  MICRO_PID=$!
  sleep 0.5
fi

BASE_URL="http://${ADDR}"

step "Admin plane checks"
wait_for_healthz "${BASE_URL}/healthz"

info "GET /metrics (head)"
curl -sSf "${BASE_URL}/metrics" | head -n 20 >/tmp/micronode_metrics_head.$$ || die "/metrics not reachable"
ok "/metrics reachable"

# Optional: assert our http metrics family is present
if curl -sSf "${BASE_URL}/metrics" | grep -q "micronode_http_requests_total"; then
  ok "micronode_http_requests_total present in /metrics"
else
  info "micronode_http_requests_total not seen yet (may appear after more traffic)"
fi

step "Readiness (/readyz)"
curl -sSf "${BASE_URL}/readyz" | jq . || die "/readyz failed"
ok "/readyz returned JSON"

step "Version (/version)"
curl -sSf "${BASE_URL}/version" | jq . || die "/version failed"
ok "/version returned JSON"

step "KV roundtrip via /v1/kv/{bucket}/{key}"
BUCKET="${BUCKET:-smoke}"
KEY="${KEY:-k}"
VALUE="${VALUE:-hello-micronode}"

PUT_CODE=$(curl -sS -o /dev/null -w "%{http_code}" \
  -X PUT "${BASE_URL}/v1/kv/${BUCKET}/${KEY}" \
  -H 'content-type: application/octet-stream' \
  --data-binary "${VALUE}" || true)

echo "[INFO] PUT status: ${PUT_CODE}"
if [[ "${PUT_CODE}" != "201" && "${PUT_CODE}" != "204" ]]; then
  die "Expected 201/204 from PUT, got ${PUT_CODE}"
fi
ok "PUT /v1/kv/${BUCKET}/${KEY} → ${PUT_CODE}"

GET_BODY=$(curl -sS "${BASE_URL}/v1/kv/${BUCKET}/${KEY}" || true)
echo "[INFO] GET body: ${GET_BODY}"
if [[ "${GET_BODY}" != "${VALUE}" ]]; then
  die "Expected GET body '${VALUE}', got '${GET_BODY}'"
fi
ok "GET /v1/kv/${BUCKET}/${KEY} roundtrip OK"

DEL_CODE=$(curl -sS -o /dev/null -w "%{http_code}" \
  -X DELETE "${BASE_URL}/v1/kv/${BUCKET}/${KEY}" || true)

echo "[INFO] DELETE status: ${DEL_CODE}"
if [[ "${DEL_CODE}" != "204" ]]; then
  die "Expected 204 from DELETE, got ${DEL_CODE}"
fi
ok "DELETE /v1/kv/${BUCKET}/${KEY} → ${DEL_CODE}"

echo "✅ micronode smoke OK"

```

### crates/micronode/scripts/smoke_oap_limits.sh
<a id="crates-micronode-scripts-smokeoaplimits-sh"></a>

```bash

```

### crates/micronode/specs/oap_vectors.json
<a id="crates-micronode-specs-oapvectors-json"></a>

```json

```

### crates/micronode/specs/pq_handshake_cases.json
<a id="crates-micronode-specs-pqhandshakecases-json"></a>

```json

```

### crates/micronode/src/adapters/index_client.rs
<a id="crates-micronode-src-adapters-indexclient-rs"></a>

```rust
//! RO:WHAT — Lightweight handle for talking to the index service
//!           (svc-index) from Micronode.
//!
//! RO:WHY  — Keep any future index-related flows behind a tiny,
//!           testable wrapper so Micronode core is not sprinkled with
//!           raw URLs.
//!
//! RO:INVARIANTS —
//!   * No network I/O here; this is just a configuration container.
//!   * `base_url` is assumed to point at the svc-index HTTP or OAP
//!     ingress surface depending on how the node is wired.
//!
//! RO:TEST — Trivial type; basic behavior is indirectly tested via
//!           the `adapters` module tests.

#[derive(Clone, Debug)]
pub struct IndexClient {
    base_url: String,
}

impl IndexClient {
    /// Construct a new index client from a base URL.
    ///
    /// The `base_url` should be something like
    /// `http://127.0.0.1:9913` or an internal overlay address once
    /// svc-index is running on the same node.
    pub fn new(base_url: impl Into<String>) -> Self {
        Self { base_url: base_url.into() }
    }

    /// Return the base URL this client is configured for.
    pub fn base_url(&self) -> &str {
        &self.base_url
    }

    /// Short, stable tag suitable for metrics or logging labels.
    pub fn tag(&self) -> &'static str {
        "svc-index"
    }
}

```

### crates/micronode/src/adapters/mailbox_client.rs
<a id="crates-micronode-src-adapters-mailboxclient-rs"></a>

```rust
//! RO:WHAT — Handle for a future mailbox service used by Micronode.
//!
//! RO:WHY  — Some Micronode deployments may want a durable inbox or
//!           outbox for messages, notifications, or scheduled work.
//!           This client provides the configuration hook without
//!           forcing the mailbox concept into the core.
//!
//! RO:INVARIANTS —
//!   * No networking in this module for now.
//!   * The mailbox abstraction is intentionally vague until the
//!     concrete svc-mailbox design settles.

#[derive(Clone, Debug)]
pub struct MailboxClient {
    base_url: String,
}

impl MailboxClient {
    pub fn new(base_url: impl Into<String>) -> Self {
        Self { base_url: base_url.into() }
    }

    pub fn base_url(&self) -> &str {
        &self.base_url
    }

    /// Short, stable tag suitable for metrics or logging labels.
    pub fn tag(&self) -> &'static str {
        "svc-mailbox"
    }
}

```

### crates/micronode/src/adapters/mod.rs
<a id="crates-micronode-src-adapters-mod-rs"></a>

```rust
//! RO:WHAT — Adapter layer for Micronode.
//! RO:WHY  — Provide typed, low-friction handles for talking to other
//!           RON-CORE services (index, mailbox, storage, overlay,
//!           policy) without coupling Micronode core to any specific
//!           HTTP or RPC client.
//!
//! RO:INTERACTS — In future cuts, these clients will wrap a shared
//!                HTTP or OAP/1 client and offer small, well-typed
//!                methods for a few high-value flows. For the
//!                foundation cut they are simple data holders.
//!
//! RO:INVARIANTS —
//!   * No network I/O in this module for now.
//!   * Handles are cheap to clone and can be stored in `AppState`.
//!   * Adapters are optional: Micronode can run without any of them.
//!
//! RO:CONFIG — Construction of each client is driven by higher-layer
//!             config modules or CLI overlays, not from here.
//!
//! RO:SECURITY — Capability handling and macaroon verification are
//!               handled by dedicated security services; these
//!               adapters should carry any required capability tokens
//!               as opaque strings, not parse them.
//!
//! RO:TEST — Light unit tests here ensure the basic ergonomics work;
//!           future integration tests can live in `tests/adapters_*.rs`
//!           once we wire Micronode to real remote services.

mod index_client;
mod mailbox_client;
mod overlay_client;
mod policy_client;
mod storage_client;

pub use index_client::IndexClient;
pub use mailbox_client::MailboxClient;
pub use overlay_client::OverlayClient;
pub use policy_client::PolicyClient;
pub use storage_client::StorageClient;

/// Bag of optional adapters that Micronode may use.
///
/// This is a convenience struct for higher layers that want to pass
/// around a single handle rather than five independent options.
/// Nothing in the core currently depends on this type; it is provided
/// as ready-made glue for future integration with `AppState`.
#[derive(Clone, Debug, Default)]
pub struct Adapters {
    pub index: Option<IndexClient>,
    pub mailbox: Option<MailboxClient>,
    pub storage: Option<StorageClient>,
    pub overlay: Option<OverlayClient>,
    pub policy: Option<PolicyClient>,
}

impl Adapters {
    /// Construct a new, empty adapter bag.
    ///
    /// This is equivalent to `Adapters::default()` but reads more
    /// clearly at call sites.
    pub fn new() -> Self {
        Self::default()
    }

    /// Return `true` if no adapters are configured.
    ///
    /// This is useful for callers that want to short-circuit any
    /// remote flows if Micronode is running in a completely isolated
    /// profile.
    pub fn is_empty(&self) -> bool {
        self.index.is_none()
            && self.mailbox.is_none()
            && self.storage.is_none()
            && self.overlay.is_none()
            && self.policy.is_none()
    }

    /// Convenience builder for setting the index client.
    pub fn with_index(mut self, client: IndexClient) -> Self {
        self.index = Some(client);
        self
    }

    /// Convenience builder for setting the mailbox client.
    pub fn with_mailbox(mut self, client: MailboxClient) -> Self {
        self.mailbox = Some(client);
        self
    }

    /// Convenience builder for setting the storage client.
    pub fn with_storage(mut self, client: StorageClient) -> Self {
        self.storage = Some(client);
        self
    }

    /// Convenience builder for setting the overlay client.
    pub fn with_overlay(mut self, client: OverlayClient) -> Self {
        self.overlay = Some(client);
        self
    }

    /// Convenience builder for setting the policy client.
    pub fn with_policy(mut self, client: PolicyClient) -> Self {
        self.policy = Some(client);
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_adapters_reports_empty() {
        let adapters = Adapters::new();
        assert!(adapters.is_empty());
        assert!(adapters.index.is_none());
        assert!(adapters.mailbox.is_none());
        assert!(adapters.storage.is_none());
        assert!(adapters.overlay.is_none());
        assert!(adapters.policy.is_none());
    }

    #[test]
    fn builder_methods_mark_adapters_present() {
        let idx = IndexClient::new("http://idx");
        let mbx = MailboxClient::new("http://mbx");
        let st = StorageClient::new("http://st");
        let ov = OverlayClient::new("http://ov");
        let pol = PolicyClient::new("http://pol");

        let adapters = Adapters::new()
            .with_index(idx.clone())
            .with_mailbox(mbx.clone())
            .with_storage(st.clone())
            .with_overlay(ov.clone())
            .with_policy(pol.clone());

        assert!(!adapters.is_empty());
        assert_eq!(adapters.index.as_ref().unwrap().base_url(), "http://idx");
        assert_eq!(adapters.mailbox.as_ref().unwrap().base_url(), "http://mbx");
        assert_eq!(adapters.storage.as_ref().unwrap().base_url(), "http://st");
        assert_eq!(adapters.overlay.as_ref().unwrap().base_url(), "http://ov");
        assert_eq!(adapters.policy.as_ref().unwrap().base_url(), "http://pol");
    }
}

```

### crates/micronode/src/adapters/overlay_client.rs
<a id="crates-micronode-src-adapters-overlayclient-rs"></a>

```rust
//! RO:WHAT — Handle for the overlay or discovery service
//!           (svc-overlay / svc-dht).
//!
//! RO:WHY  — Micronode may need to ask the overlay about other nodes,
//!           capabilities, or routes. Keeping that behind an adapter
//!           lets us mock or swap it out cleanly.
//!
//! RO:INVARIANTS —
//!   * Pure configuration container for now.
//!   * Does not assume a particular protocol; `base_url` is just a
//!     locator string that higher layers agree on.

#[derive(Clone, Debug)]
pub struct OverlayClient {
    base_url: String,
}

impl OverlayClient {
    pub fn new(base_url: impl Into<String>) -> Self {
        Self { base_url: base_url.into() }
    }

    pub fn base_url(&self) -> &str {
        &self.base_url
    }

    /// Short, stable tag suitable for metrics or logging labels.
    pub fn tag(&self) -> &'static str {
        "svc-overlay"
    }
}

```

### crates/micronode/src/adapters/policy_client.rs
<a id="crates-micronode-src-adapters-policyclient-rs"></a>

```rust
//! RO:WHAT — Handle for the policy service (ron-policy / svc-policy)
//!           as seen from Micronode.
//!
//! RO:WHY  — Leave policy evaluation and rich authorization to a
//!           dedicated service. Micronode can forward the minimal
//!           context it knows about a request and let policy decide.
//!
//! RO:SECURITY — Capability tokens or macaroons should be treated as
//!               opaque values and passed along as such. Parsing or
//!               verifying them belongs in dedicated security code,
//!               not in this adapter.
//!
//! RO:INVARIANTS —
//!   * No networking in this module.
//!   * The adapter may be absent in some deployments; Micronode
//!     should continue to function with local-only policy.

#[derive(Clone, Debug)]
pub struct PolicyClient {
    base_url: String,
}

impl PolicyClient {
    pub fn new(base_url: impl Into<String>) -> Self {
        Self { base_url: base_url.into() }
    }

    pub fn base_url(&self) -> &str {
        &self.base_url
    }

    /// Short, stable tag suitable for metrics or logging labels.
    pub fn tag(&self) -> &'static str {
        "svc-policy"
    }
}

```

### crates/micronode/src/adapters/storage_client.rs
<a id="crates-micronode-src-adapters-storageclient-rs"></a>

```rust
//! RO:WHAT — Handle for the storage service (svc-storage) as seen
//!           from Micronode.
//!
//! RO:WHY  — Even though Micronode already has an in-process KV
//!           engine, some deployments will prefer to delegate
//!           large-object or CAS responsibilities to svc-storage.
//!           This client provides the configuration hook.
//!
//! RO:INTERACTS — In the future this will likely send OAP/1 requests
//!                over ron-transport rather than raw HTTP. For now it
//!                remains a pure data type.
//!
//! RO:INVARIANTS —
//!   * `base_url` typically points at the svc-storage ingress surface.
//!   * No implicit retries or backoff here; callers should own policy.

#[derive(Clone, Debug)]
pub struct StorageClient {
    base_url: String,
}

impl StorageClient {
    pub fn new(base_url: impl Into<String>) -> Self {
        Self { base_url: base_url.into() }
    }

    pub fn base_url(&self) -> &str {
        &self.base_url
    }

    /// Short, stable tag suitable for metrics or logging labels.
    pub fn tag(&self) -> &'static str {
        "svc-storage"
    }
}

```

### crates/micronode/src/app.rs
<a id="crates-micronode-src-app-rs"></a>

```rust
//! RO:WHAT — Router assembly for Micronode.
//! RO:WHY  — Central composition point for routes and layers.
//! RO:INTERACTS — config::schema::Config, http::{admin,routes,kv}, facets, layers,
//!                limits, state::AppState.
//! RO:INVARIANTS — Compose routers with state=(), then attach AppState once at the end.
//! RO:SECURITY — SecurityLayer (extract) + RequireAuthLayer (enforce) for KV & Facets.
//! RO:TEST — Covered by integration tests (admin parity, kv_roundtrip, guard_behavior, concurrency,
//!           facets, auth_gate).

use crate::{
    config::schema::Config,
    http::{admin, kv, routes},
    layers::{
        body_cap::BodyCapLayer,
        concurrency::ConcurrencyLayer,
        decode_guard,
        security::{RequireAuthLayer, SecurityLayer},
    },
    limits::HTTP_BODY_CAP_BYTES,
    observability::http_metrics,
    state::AppState,
};
use axum::{
    middleware,
    routing::{get, post, put},
    Router,
};
use http::Error as HttpError;
use std::{convert::Infallible, path::PathBuf, sync::Arc};
use tokio::sync::Semaphore;
use tower_http::trace::TraceLayer;

pub fn build_router(cfg: Config) -> (Router, AppState) {
    let st = AppState::new(cfg.clone());

    // Prewarm metrics.
    http_metrics::prewarm();

    // --- Admin plane ---
    let admin_routes = Router::new()
        .route("/healthz", get(admin::healthz))
        .route("/readyz", get(admin::readyz))
        .route("/version", get(admin::version))
        .route("/metrics", get(admin::metrics));

    // --- Dev plane (guarded) ---
    let dev = if st.cfg.server.dev_routes {
        let echo_conc = Arc::new(Semaphore::new(256));
        Router::new().route(
            "/dev/echo",
            post(routes::dev::echo)
                .layer::<_, HttpError>(ConcurrencyLayer::new(echo_conc))
                .layer(BodyCapLayer::new(HTTP_BODY_CAP_BYTES))
                .layer::<_, Infallible>(middleware::from_fn(decode_guard::guard))
                .layer(SecurityLayer::new()),
        )
    } else {
        Router::new()
    };

    // --- API v1 (public) ---
    let kv_conc = Arc::new(Semaphore::new(256));
    let api_v1 = Router::new().route("/ping", get(routes::ping)).route(
        "/kv/:bucket/:key",
        put(kv::put_kv)
            .delete(kv::delete_kv)
            .get(kv::get_kv)
            .layer(RequireAuthLayer::new(st.cfg.security.mode))
            .layer::<_, HttpError>(ConcurrencyLayer::new(kv_conc.clone()))
            .layer(BodyCapLayer::new(HTTP_BODY_CAP_BYTES))
            .layer::<_, Infallible>(middleware::from_fn(decode_guard::guard))
            .layer(SecurityLayer::new()),
    );

    // Compose top-level router core.
    let mut router = Router::new().merge(admin_routes).nest("/v1", api_v1).merge(dev);

    // --- Facets plane (manifest-driven if enabled) ---
    if st.cfg.facets.enabled {
        if let Some(dir) = st.cfg.facets.dir.clone() {
            let p = PathBuf::from(dir);
            match crate::facets::loader::load_facets(&p) {
                Ok(reg) => {
                    router = crate::facets::mount_with_registry(router, reg, st.cfg.security.mode);
                }
                Err(e) => {
                    // Loader error: make readiness reflect truth.
                    tracing::error!("facet loader failed: {e}");
                    st.probes.set_deps_ok(false);
                    router = crate::facets::mount(router); // keep meta + demo ping for visibility
                }
            }
        } else {
            tracing::warn!("facets.enabled=true but facets.dir not set");
            st.probes.set_deps_ok(false);
            router = crate::facets::mount(router);
        }
    } else {
        // Disabled => keep demo + empty meta for operator sanity.
        router = crate::facets::mount(router);
    }

    // Attach state + global observability.
    let router = router
        .with_state(st.clone())
        .layer(http_metrics::layer())
        .layer(TraceLayer::new_for_http());

    (router, st)
}

```

### crates/micronode/src/cli/args.rs
<a id="crates-micronode-src-cli-args-rs"></a>

```rust

```

### crates/micronode/src/cli/mod.rs
<a id="crates-micronode-src-cli-mod-rs"></a>

```rust
//! RO:WHAT — Micronode CLI surface (shape only).
//! RO:WHY  — Give micronode a stable CLI shape (`serve`, `check`) without
//!           committing yet to any particular argument parser crate.
//! RO:INTERACTS — `main.rs` can later call `Cli::from_env()` instead of
//!                hard-coding config/env logic.
//! RO:INVARIANTS —
//!     - All types here are `pub` so `dead_code` does not fire when the CLI
//!       is not yet wired into `main.rs`.
//!     - No external dependencies (no `clap`/`argh` yet); safe to evolve later.
//!     RO:TEST — Exercised by `tests/cli_smoke.rs`.

/// High-level profile for Micronode behavior.
///
/// This is intentionally coarse; config/env can refine details later.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Profile {
    /// Developer profile: dev routes enabled, in-memory storage, verbose logs.
    #[default]
    Dev,
    /// Amnesia-first profile: prefer non-persistent storage where possible.
    Amnesia,
    /// Durable profile: persistent storage (sled or remote CAS) is allowed.
    Durable,
}

/// Options for the `serve` subcommand.
#[derive(Debug, Clone)]
pub struct ServeOpts {
    /// Optional path to a config file; if `None`, Micronode will fall back
    /// to its default config discovery (env vars, default paths, etc.).
    pub config_path: Option<String>,
    /// Optional bind override for the HTTP listener (e.g., "127.0.0.1:5310").
    pub bind_addr: Option<String>,
    /// High-level runtime profile (dev/amnesia/durable).
    pub profile: Profile,
    /// Whether to expose dev-only routes (e.g. `/dev/echo`).
    pub dev_routes: bool,
}

impl Default for ServeOpts {
    fn default() -> Self {
        Self { config_path: None, bind_addr: None, profile: Profile::default(), dev_routes: true }
    }
}

/// Supported Micronode CLI commands.
///
/// More subcommands (e.g., `smoke`, `diag`) can be added without breaking
/// the existing API surface.
#[derive(Debug, Clone)]
pub enum Command {
    /// Run the Micronode HTTP server.
    Serve(ServeOpts),
    /// Validate config and exit (non-zero status on error).
    Check {
        /// Optional path to a config file.
        config_path: Option<String>,
    },
}

/// Top-level CLI representation.
///
/// For now we provide only a very small API:
/// - `Cli::from_env()` to construct a baseline value.
/// - `command()` accessor to drive dispatch in `main.rs` later.
#[derive(Debug, Clone)]
pub struct Cli {
    pub cmd: Command,
}

impl Cli {
    /// Construct a CLI representation from the environment.
    ///
    /// Foundation cut:
    /// - Ignores actual `std::env::args()` for now.
    /// - Always returns `Command::Serve(ServeOpts::default())`.
    ///
    /// This gives us a stable type and test surface; later we can replace
    /// the body with a proper parser (e.g., `clap`) without changing call
    /// sites or tests.
    pub fn from_env() -> Self {
        // Placeholder behavior: default to `serve` with default options.
        Self { cmd: Command::Serve(ServeOpts::default()) }
    }

    /// Borrow the parsed command.
    pub fn command(&self) -> &Command {
        &self.cmd
    }
}

```

### crates/micronode/src/cli/run.rs
<a id="crates-micronode-src-cli-run-rs"></a>

```rust

```

### crates/micronode/src/concurrency/backpressure.rs
<a id="crates-micronode-src-concurrency-backpressure-rs"></a>

```rust
//! RO:WHAT — Shared vocabulary for backpressure queues and metrics labels.
//! RO:WHY  — Avoid stringly-typed queue names scattered across the crate;
//!           keep backpressure docs and code in sync.
//! RO:INVARIANTS —
//!   * Queue names are stable across releases.
//!   * Metrics (e.g. `queue_depth{queue=...}`) use the same labels.

/// Logical name for the primary work queue feeding Micronode handlers.
///
/// This corresponds to the “work” queue discussed in `CONCURRENCY.MD`.
pub const QUEUE_WORK: &str = "work";

/// Logical name for the broadcast bus queue (used when tracking lag/backpressure).
pub const QUEUE_BUS: &str = "bus";

/// Logical name for telemetry/export queues (best-effort, drop-oldest on overflow).
pub const QUEUE_TELEMETRY: &str = "telemetry";

```

### crates/micronode/src/concurrency/mod.rs
<a id="crates-micronode-src-concurrency-mod-rs"></a>

```rust
//! RO:WHAT — Concurrency plane for Micronode (limits, registry, backpressure labels).
//! RO:WHY  — Central home for per-route concurrency caps and work queues.
//! RO:INTERACTS — `layers::concurrency::ConcurrencyLayer`, HTTP router, future worker pools.
//! RO:INVARIANTS — Bounded, non-blocking admission; prefer shed (429) over buffering;
//!                 no locks held across `.await`.
//! RO:TEST — Exercised indirectly by `tests/backpressure.rs`.

pub mod backpressure;
pub mod registry;
pub mod shutdown;

/// Named concurrency limit for a class of operations.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ConcurrencyLimit {
    /// Stable name used for metrics labels and registry keys.
    pub name: &'static str,
    /// Maximum number of inflight operations allowed for this class.
    pub max_inflight: usize,
}

/// Static concurrency configuration for Micronode.
///
/// Today this is **in-code** and sized for a small, single-node Micronode.
/// Later we can source this from `Config` / env once the config plane grows.
#[derive(Debug, Clone)]
pub struct ConcurrencyConfig {
    pub http_admin: ConcurrencyLimit,
    pub http_dev_echo: ConcurrencyLimit,
    pub http_kv: ConcurrencyLimit,
    pub http_facets: ConcurrencyLimit,
}

impl Default for ConcurrencyConfig {
    fn default() -> Self {
        Self {
            // Admin is cheap and should basically never be the bottleneck.
            http_admin: ConcurrencyLimit { name: HTTP_ADMIN_BUDGET, max_inflight: 64 },
            // Dev echo is purely DX; keep it modest so it cannot starve real traffic.
            http_dev_echo: ConcurrencyLimit { name: HTTP_DEV_ECHO_BUDGET, max_inflight: 32 },
            // KV is the main hot-path for Micronode; give it a healthier budget.
            http_kv: ConcurrencyLimit { name: HTTP_KV_BUDGET, max_inflight: 256 },
            // Facets will typically fan back into KV and CAS; sized conservatively for now.
            http_facets: ConcurrencyLimit { name: HTTP_FACETS_BUDGET, max_inflight: 128 },
        }
    }
}

impl ConcurrencyConfig {
    /// Lookup a limit by its logical name.
    ///
    /// This is primarily intended for tests and for any code that wants to
    /// introspect the static configuration.
    pub fn limit_for(&self, name: &str) -> Option<ConcurrencyLimit> {
        match name {
            HTTP_ADMIN_BUDGET => Some(self.http_admin),
            HTTP_DEV_ECHO_BUDGET => Some(self.http_dev_echo),
            HTTP_KV_BUDGET => Some(self.http_kv),
            HTTP_FACETS_BUDGET => Some(self.http_facets),
            _ => None,
        }
    }

    /// Build a `ConcurrencyRegistry` from this configuration.
    pub fn build_registry(&self) -> ConcurrencyRegistry {
        ConcurrencyRegistry::from_config(self)
    }
}

// Stable string constants for concurrency budget names. These are meant to be
// shared between the registry, metrics labels, and any future worker pools.

/// Budget name for admin-plane HTTP endpoints (`/healthz`, `/readyz`, `/metrics`, `/version`).
pub const HTTP_ADMIN_BUDGET: &str = "http_admin";

/// Budget name for dev DX endpoints such as `/dev/echo`.
pub const HTTP_DEV_ECHO_BUDGET: &str = "http_dev_echo";

/// Budget name for KV HTTP endpoints (`/v1/kv/...`).
pub const HTTP_KV_BUDGET: &str = "http_kv";

/// Budget name for facet-exposed HTTP endpoints (`/facets/...`).
pub const HTTP_FACETS_BUDGET: &str = "http_facets";

pub use registry::ConcurrencyRegistry;

```

### crates/micronode/src/concurrency/registry.rs
<a id="crates-micronode-src-concurrency-registry-rs"></a>

```rust
//! RO:WHAT — Registry for named concurrency pools.
//! RO:WHY  — Let HTTP routes and worker pools share semaphores by logical name,
//!           rather than each constructing ad-hoc caps.
//! RO:INTERACTS — `ConcurrencyConfig`, `layers::concurrency::ConcurrencyLayer`.
//! RO:INVARIANTS —
//!   * Each known budget name maps to a bounded `Semaphore`.
//!   * Registry is immutable after construction (no runtime mutation).
//!   * Unknown names fall back to a safe, modest default (no panics).

use std::{collections::HashMap, sync::Arc};

use tokio::sync::Semaphore;

use super::{ConcurrencyConfig, ConcurrencyLimit};

/// Immutable registry of concurrency pools keyed by logical budget name.
#[derive(Debug)]
pub struct ConcurrencyRegistry {
    inner: HashMap<&'static str, Arc<Semaphore>>,
}

impl ConcurrencyRegistry {
    /// Build a registry from the static concurrency configuration.
    ///
    /// Each `ConcurrencyLimit` becomes a distinct semaphore keyed by `limit.name`.
    pub fn from_config(cfg: &ConcurrencyConfig) -> Self {
        let mut inner = HashMap::new();

        for limit in [cfg.http_admin, cfg.http_dev_echo, cfg.http_kv, cfg.http_facets] {
            Self::insert_limit(&mut inner, limit);
        }

        Self { inner }
    }

    fn insert_limit(inner: &mut HashMap<&'static str, Arc<Semaphore>>, limit: ConcurrencyLimit) {
        // If a name is duplicated in the config, last-one-wins. That should not
        // happen in practice, but this keeps behavior deterministic.
        inner.insert(limit.name, Arc::new(Semaphore::new(limit.max_inflight)));
    }

    /// Fetch a semaphore for the given logical budget name.
    ///
    /// If the name is unknown (e.g. future budgets added without updating the
    /// registry construction), we fall back to a modest default (256). This
    /// ensures callers never panic on a missing entry.
    pub fn get(&self, name: &'static str) -> Arc<Semaphore> {
        self.inner.get(name).cloned().unwrap_or_else(|| Arc::new(Semaphore::new(256)))
    }
}

```

### crates/micronode/src/concurrency/shutdown.rs
<a id="crates-micronode-src-concurrency-shutdown-rs"></a>

```rust
//! RO:WHAT — Placeholder module for concurrency-aware shutdown helpers.
//! RO:WHY  — Keep a stable home for future drain orchestration (e.g. draining
//!           work queues before shutdown, coordinating with bus + HTTP).
//! RO:NOTE — Today Micronode reuses the kernel’s shutdown wiring and does not
//!           need additional helpers here. This module exists so the
//!           concurrency blueprint has a concrete code anchor.

// This module is intentionally empty for now. Once Micronode grows its own
// work queues / worker pools, shutdown coordination types can live here.

```

### crates/micronode/src/config/cli_overlay.rs
<a id="crates-micronode-src-config-clioverlay-rs"></a>

```rust
//! RO:WHAT — Placeholder for CLI-overlay support (kept for tree parity).
//! RO:WHY  — Future: clap/argp integration without bloating foundation.

pub fn _apply_cli_overlays() {
    // Intentionally empty for foundation cut.
}

```

### crates/micronode/src/config/env_overlay.rs
<a id="crates-micronode-src-config-envoverlay-rs"></a>

```rust
//! RO:WHAT — Placeholder for richer env overlays (kept for tree parity).
//! RO:WHY  — Your TODO tree references this module explicitly.

pub fn _apply_env_overlays() {
    // Intentionally empty for foundation cut.
}

```

### crates/micronode/src/config/hot_reload.rs
<a id="crates-micronode-src-config-hotreload-rs"></a>

```rust
//! RO:WHAT — Placeholder for config hot-reload (notify-based).
//! RO:WHY  — Wire later; keep module present so imports won't break.

pub fn _spawn_config_watcher() {
    // Intentionally empty for foundation cut.
}

```

### crates/micronode/src/config/load.rs
<a id="crates-micronode-src-config-load-rs"></a>

```rust
//! RO:WHAT — Load config from file + env overlays into a validated `Config`.
//! RO:WHY  — Keep `main.rs` tiny; centralize config precedence and invariants.
//! RO:ORDER —
//!   1) Start from `Config::default()`.
//!   2) If `MICRONODE_CONFIG` set, load that TOML and merge.
//!   3) Else try `./configs/micronode.toml`, then `./crates/micronode/configs/micronode.toml`.
//!   4) Apply env overrides (bind/dev-routes only; storage/security via TOML).
//!   5) Validate invariants; on error return `Error::Config` (fail-fast).
//!
//! RO:INVARIANTS — Safe defaults (amnesia-first, local bind); deterministic overlay order.

use super::schema::Config;
use super::validate::validate;
use crate::errors::{Error, Result};

use std::{env, fs, net::SocketAddr, path::PathBuf};

/// Entry point used by `main.rs`.
pub fn load_config() -> Result<Config> {
    let mut cfg = Config::default();

    if let Some(path) = discover_config_path() {
        overlay_file(&mut cfg, path)?;
    }

    overlay_env(&mut cfg)?;
    validate(&cfg)?;
    Ok(cfg)
}

/// Resolve a config path by env or well-known files.
fn discover_config_path() -> Option<PathBuf> {
    if let Ok(p) = env::var("MICRONODE_CONFIG") {
        let pb = PathBuf::from(p);
        if pb.exists() {
            return Some(pb);
        }
    }

    let workspace_local = PathBuf::from("configs/micronode.toml");
    if workspace_local.exists() {
        return Some(workspace_local);
    }

    let crate_local = PathBuf::from("crates/micronode/configs/micronode.toml");
    if crate_local.exists() {
        return Some(crate_local);
    }

    None
}

/// Overlay TOML at `path` onto `cfg`.
fn overlay_file(cfg: &mut Config, path: PathBuf) -> Result<()> {
    let s =
        fs::read_to_string(&path).map_err(|e| Error::Config(format!("read {:?}: {e}", path)))?;
    let from: Config =
        toml::from_str(&s).map_err(|e| Error::Config(format!("parse {:?}: {e}", path)))?;

    let base = std::mem::take(cfg);
    *cfg = merge(base, from);
    Ok(())
}

/// Apply env-var overrides on top (bind/dev only).
///
/// Supported env:
/// - MICRONODE_BIND = "127.0.0.1:5310"
/// - MICRONODE_DEV_ROUTES = "1" | "true" | "yes"
fn overlay_env(cfg: &mut Config) -> Result<()> {
    if let Ok(bind_s) = env::var("MICRONODE_BIND") {
        let bind: SocketAddr = bind_s.parse().map_err(|e| {
            Error::Config(format!("MICRONODE_BIND parse failed for {:?}: {e}", bind_s))
        })?;
        cfg.server.bind = bind;
    }

    if let Ok(dev_s) = env::var("MICRONODE_DEV_ROUTES") {
        let dev = matches!(dev_s.to_ascii_lowercase().as_str(), "1" | "true" | "yes" | "on");
        cfg.server.dev_routes = dev;
    }

    Ok(())
}

/// Merge `from` onto `base`, field-by-field.
///
/// NOTE: This is where we must carry **security** from TOML, otherwise
/// a file like `[security]\nmode="dev_allow"` won’t take effect.
fn merge(mut base: Config, from: Config) -> Config {
    base.server = from.server;
    base.storage = from.storage;
    base.security = from.security;
    base
}

#[cfg(test)]
mod tests {
    use super::super::schema::{SecurityCfg, SecurityMode};
    use super::*;

    #[test]
    fn merge_applies_security_mode() {
        let base = Config::default(); // DenyAll by default
        let from =
            Config { security: SecurityCfg { mode: SecurityMode::DevAllow }, ..Config::default() };
        let merged = merge(base, from);
        assert_eq!(merged.security.mode, SecurityMode::DevAllow);
    }

    #[test]
    fn overlay_env_parses_bind_and_dev_routes() {
        let _ = env::remove_var("MICRONODE_BIND");
        let _ = env::remove_var("MICRONODE_DEV_ROUTES");
        let mut cfg = Config::default();

        env::set_var("MICRONODE_BIND", "127.0.0.1:5311");
        env::set_var("MICRONODE_DEV_ROUTES", "true");
        overlay_env(&mut cfg).unwrap();

        assert_eq!(cfg.server.bind, "127.0.0.1:5311".parse::<SocketAddr>().unwrap());
        assert!(cfg.server.dev_routes);
    }
}

```

### crates/micronode/src/config/mod.rs
<a id="crates-micronode-src-config-mod-rs"></a>

```rust
//! RO:WHAT — Config module root.
//! RO:WHY  — Schema + loaders + validation + overlays (env/CLI).
pub mod cli_overlay;
pub mod env_overlay;
pub mod hot_reload;
pub mod load;
pub mod schema;
pub mod validate;

```

### crates/micronode/src/config/schema.rs
<a id="crates-micronode-src-config-schema-rs"></a>

```rust
//! RO:WHAT — Config schema for Micronode.
//! RO:WHY  — Define a typed configuration model (TOML + env overlays)
//!           including server bind options, storage posture, security mode, and facets.
//! RO:INTERACTS — Parsed from TOML in `config::load`, validated in
//!                `config::validate`, stored in `AppState`.
//! RO:INVARIANTS —
//!   - Defaults are safe and amnesia-first (in-memory storage).
//!   - `StorageEngine::Sled` requires a non-empty `storage.path` (enforced in `validate`).
//!   - Config is cloneable and sendable across tasks.

use serde::Deserialize;
use std::net::SocketAddr;

#[derive(Debug, Clone, Deserialize, Default)]
pub struct Config {
    /// Server settings; defaults to 127.0.0.1:5310 with dev_routes=false
    #[serde(default)]
    pub server: Server,
    #[serde(default)]
    pub storage: StorageCfg,
    /// Security posture (deny-by-default unless explicitly relaxed).
    #[serde(default)]
    pub security: SecurityCfg,
    /// Facet loading configuration.
    #[serde(default)]
    pub facets: FacetsCfg,
}

/// HTTP server configuration.
#[derive(Debug, Clone, Deserialize)]
pub struct Server {
    /// Bind address for the Micronode HTTP listener.
    pub bind: SocketAddr,
    /// Whether to expose `/dev/*` routes (echo, etc.).
    #[serde(default)]
    pub dev_routes: bool,
}

impl Default for Server {
    fn default() -> Self {
        let bind: SocketAddr =
            "127.0.0.1:5310".parse().expect("hard-coded default bind must be valid SocketAddr");
        Server { bind, dev_routes: false }
    }
}

/// Storage configuration.
///
/// Beta scope:
/// - `engine = "mem"` — in-memory KV (amnesia-first, no persistence).
/// - `engine = "sled"` — persistent sled-backed KV (requires `path`).
#[derive(Debug, Clone, Deserialize, Default)]
pub struct StorageCfg {
    /// Storage engine selection, defaults to `"mem"`.
    ///
    /// Serialized as lowercase strings: `"mem"`, `"sled"`.
    #[serde(default)]
    pub engine: StorageEngine,
    /// Optional on-disk path for sled.
    ///
    /// Required (non-empty) when `engine = "sled"`.
    #[serde(default)]
    pub path: Option<String>,
}

/// Storage engine kind.
#[derive(Debug, Clone, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "lowercase")]
pub enum StorageEngine {
    /// In-memory store (amnesia-first profile).
    #[default]
    Mem,
    /// Sled-backed KV store (persistent profile).
    Sled,
}

/// Security configuration.
#[derive(Debug, Clone, Deserialize)]
pub struct SecurityCfg {
    /// Security policy for Micronode HTTP surfaces.
    #[serde(default)]
    pub mode: SecurityMode,
}

impl Default for SecurityCfg {
    fn default() -> Self {
        Self { mode: SecurityMode::DenyAll }
    }
}

/// Security enforcement modes.
#[derive(Debug, Clone, Copy, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum SecurityMode {
    /// Deny all non-admin surfaces unless explicitly allowed.
    #[default]
    DenyAll,
    /// Developer convenience: allow KV/facets without a macaroon.
    DevAllow,
    /// Delegate verification to external auth/policy service (future).
    External,
}

/// Facet loader configuration.
#[derive(Debug, Clone, Deserialize, Default)]
pub struct FacetsCfg {
    /// Enable manifest-driven facets.
    #[serde(default)]
    pub enabled: bool,
    /// Directory containing `*.toml` facet manifests.
    #[serde(default)]
    pub dir: Option<String>,
}

```

### crates/micronode/src/config/validate.rs
<a id="crates-micronode-src-config-validate-rs"></a>

```rust
//! RO:WHAT — Validation for Micronode configuration.
//! RO:WHY  — Catch invalid configs early (on startup) with clear
//!           error messages instead of failing deep in runtime code.
//! RO:INTERACTS — Called from `config::load::load_config` once TOML
//!                and env overlays have been applied.
//! RO:INVARIANTS —
//!   - Bind address must be usable (non-zero port).
//!   - `StorageEngine::Sled` requires a non-empty path.
//!   - Validation never mutates the config.

use crate::errors::{Error, Result};

use super::schema::{Config, StorageEngine};

/// Validate a fully assembled configuration.
///
/// Returns `Ok(())` if the config is usable; otherwise returns
/// `Error::Config` with a human-readable description.
pub fn validate(cfg: &Config) -> Result<()> {
    // Basic sanity on server.bind.
    if cfg.server.bind.port() == 0 {
        return Err(Error::Config("server.bind must not use port 0 (ephemeral)".to_string()));
    }

    // Storage posture checks.
    match cfg.storage.engine {
        StorageEngine::Mem => {
            // In-memory is always valid; path is ignored.
        }
        StorageEngine::Sled => {
            // Sled requires a non-empty path so we don't silently spray
            // data into the working directory.
            let path_ok =
                cfg.storage.path.as_deref().map(|s| !s.trim().is_empty()).unwrap_or(false);

            if !path_ok {
                return Err(Error::Config(
                    "storage.engine=\"sled\" requires storage.path to be set and non-empty"
                        .to_string(),
                ));
            }
        }
    }

    Ok(())
}

```

### crates/micronode/src/errors.rs
<a id="crates-micronode-src-errors-rs"></a>

```rust
//! RO:WHAT — Error types for Micronode (foundation).
//! RO:WHY  — Stable envelopes and anyhow interop.
//! RO:INVARIANTS — Avoid leaking secrets; messages deterministic for SDKs.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("config: {0}")]
    Config(String),
    #[error("internal error")]
    Internal,
}

pub type Result<T> = std::result::Result<T, Error>;

```

### crates/micronode/src/facets/feed.rs
<a id="crates-micronode-src-facets-feed-rs"></a>

```rust
// crates/micronode/src/facets/feed.rs
//! RO:WHAT — Placeholder for feed/fanout facet wiring.
//! RO:WHY  — Feed-style workloads (timelines, notifications) are a primary
//!           target for Micronode facets; this file will bridge to svc-mailbox
//!           and svc-index in future iterations.
//! RO:INTERACTS — Planned: `svc-index`, `svc-mailbox`, `svc-storage` adapters.
//! RO:STATUS — Stub only; no runtime behavior yet.

#[derive(Debug, Clone)]
pub struct FeedFacetConfig {
    // TODO: topic/bucket config, retention, fanout policies.
    _placeholder: (),
}

```

### crates/micronode/src/facets/graph.rs
<a id="crates-micronode-src-facets-graph-rs"></a>

```rust
// crates/micronode/src/facets/graph.rs
//! RO:WHAT — Placeholder for graph/index facet wiring.
//! RO:WHY  — Graph-style queries (follows, relationships, recommendations)
//!           will be hosted as facets backed by `svc-index`.
//! RO:STATUS — Stub only; no runtime behavior yet.

#[derive(Debug, Clone)]
pub struct GraphFacetConfig {
    // TODO: index families, graph projections, query presets.
    _placeholder: (),
}

```

### crates/micronode/src/facets/loader.rs
<a id="crates-micronode-src-facets-loader-rs"></a>

```rust
//! RO:WHAT — Facet registry loader for manifest-driven facets.
//! RO:WHY  — Reads all `*.toml` manifests from a directory and returns a registry.
//! RO:INVARIANTS — Unique facet IDs; route validation applied; static files must exist.

use super::manifest::FacetManifest;
use crate::errors::{Error, Result};
use std::{
    collections::HashSet,
    fs,
    path::{Path, PathBuf},
};

#[derive(Debug, Clone)]
pub struct FacetRegistry {
    pub manifests: Vec<FacetManifest>,
}

pub fn load_facets(dir: &Path) -> Result<FacetRegistry> {
    if !dir.exists() {
        return Err(Error::Config(format!("facet dir {:?} does not exist", dir)));
    }
    if !dir.is_dir() {
        return Err(Error::Config(format!("facet dir {:?} is not a directory", dir)));
    }

    let mut manifests = Vec::new();
    let mut ids = HashSet::new();

    for entry in fs::read_dir(dir).map_err(|e| Error::Config(format!("read_dir {:?}: {e}", dir)))? {
        let entry = entry.map_err(|e| Error::Config(format!("read_dir entry error: {e}")))?;
        let path = entry.path();
        if path.extension().and_then(|s| s.to_str()) != Some("toml") {
            continue;
        }

        let s = fs::read_to_string(&path)
            .map_err(|e| Error::Config(format!("read {:?}: {e}", path)))?;
        let manifest: FacetManifest =
            toml::from_str(&s).map_err(|e| Error::Config(format!("parse {:?}: {e}", path)))?;
        manifest.validate().map_err(|msg| Error::Config(format!("validate {:?}: {msg}", path)))?;

        if !ids.insert(manifest.facet.id.clone()) {
            return Err(Error::Config(format!("duplicate facet id: {}", manifest.facet.id)));
        }

        // Extra static checks: file must exist.
        if let super::manifest::FacetKind::Static = manifest.facet.kind {
            for r in &manifest.route {
                if let Some(ref f) = r.file {
                    let fp = PathBuf::from(f);
                    if !fp.exists() {
                        return Err(Error::Config(format!("static file not found: {:?}", fp)));
                    }
                }
            }
        }

        manifests.push(manifest);
    }

    Ok(FacetRegistry { manifests })
}

```

### crates/micronode/src/facets/manifest.rs
<a id="crates-micronode-src-facets-manifest-rs"></a>

```rust
//! RO:WHAT — Facet manifest schema (TOML).
//! RO:WHY  — Declarative facets loaded from a directory.
//! RO:FORMAT —
//!   [[route]]
//!   method = "GET" | "POST"
//!   path = "/ping"
//!   # for kind="static":
//!   file = "configs/static/hello.txt"
//!
//!   [facet]
//!   id = "docs"
//!   kind = "static" | "echo" | "proxy"

use serde::Deserialize;

#[derive(Debug, Clone, Deserialize)]
pub struct FacetManifest {
    pub facet: FacetHeader,
    #[serde(default)]
    pub route: Vec<RouteSpec>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct FacetHeader {
    pub id: String,
    #[serde(rename = "kind")]
    pub kind: FacetKind,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum FacetKind {
    Static,
    Echo,
    Proxy,
}

#[derive(Debug, Clone, Deserialize)]
pub struct RouteSpec {
    /// "GET" or "POST" (case-insensitive accepted by our parser).
    pub method: String,
    /// Must start with "/".
    pub path: String,
    /// For Static kind: local file to serve for GET.
    #[serde(default)]
    pub file: Option<String>,
}

impl FacetManifest {
    /// Minimal validation and normalization.
    pub fn validate(&self) -> Result<(), String> {
        if self.facet.id.trim().is_empty() {
            return Err("facet.id must not be empty".into());
        }
        for r in &self.route {
            if !r.path.starts_with('/') {
                return Err(format!("route.path must start with '/': {}", r.path));
            }
            let m = r.method.to_ascii_uppercase();
            if m != "GET" && m != "POST" {
                return Err(format!("route.method must be GET or POST: {}", r.method));
            }
            if let FacetKind::Static = self.facet.kind {
                if m != "GET" {
                    return Err("static routes must be GET".into());
                }
                if r.file.as_ref().map(|s| s.is_empty()).unwrap_or(true) {
                    return Err("static route requires non-empty 'file'".into());
                }
            }
        }
        Ok(())
    }
}

```

### crates/micronode/src/facets/media.rs
<a id="crates-micronode-src-facets-media-rs"></a>

```rust
// crates/micronode/src/facets/media.rs
//! RO:WHAT — Placeholder for media facet wiring.
//! RO:WHY  — Media upload/transform pipelines (thumbnails, transcoding) sit
//!           behind Micronode and svc-storage; this file will hold configs.
//! RO:STATUS — Stub only; no runtime behavior yet.

#[derive(Debug, Clone)]
pub struct MediaFacetConfig {
    // TODO: allowed mime types, size caps, transform presets.
    _placeholder: (),
}

```

### crates/micronode/src/facets/mod.rs
<a id="crates-micronode-src-facets-mod-rs"></a>

```rust
//! RO:WHAT — Facet surface composition and demo/meta handlers.
//! RO:WHY  — Centralize facet mounting (demo + manifest-driven) and meta truth.
//! RO:INTERACTS — config::schema::SecurityMode, layers::security::RequireAuthLayer,
//!                facets::{loader,manifest}, axum Router.
//! RO:INVARIANTS —
//!   - `mount()` is safe to call when facets are disabled or loader fails.
//!   - `mount_with_registry()` mounts only manifest-driven routes and a truthful
//!     `/facets/meta` describing them.
//!   - Manifest route paths are used *exactly* as declared (no extra prefixes).
//!   - In `SecurityMode::DevAllow`, manifest facets are *not* gated by auth.
//!   - In stricter modes (DenyAll/External), manifest facets are gated via
//!     `RequireAuthLayer`.
//! RO:SECURITY —
//!   - Static facets: dev-friendly in `DevAllow`, gated in stricter modes.
//!   - Echo/proxy facets: also dev-open in `DevAllow`, gated otherwise.
//! RO:TEST — Covered by integration tests in `tests/facets_loader.rs`
//!           and by the global auth-gate tests.

use crate::config::schema::SecurityMode;
use crate::layers::security::RequireAuthLayer;
use axum::{
    body::Body,
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use serde::Serialize;

pub mod loader;
pub mod manifest;

use loader::FacetRegistry;
use manifest::{FacetKind, FacetManifest};

/// Mount demo facet + empty meta when loader is disabled or empty.
/// Generic over router state `S` (must satisfy Axum’s Router bounds).
///
/// Used by `app::build_router` when:
///   - facets are disabled, or
///   - loader fails / dir missing.
///
/// This keeps a *predictable* surface for operators:
///   - `GET /facets/demo/ping`
///   - `GET /facets/meta` (with `loaded: []`)
pub fn mount<S>(router: Router<S>) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    router.route("/facets/demo/ping", get(demo_ping)).route("/facets/meta", get(meta_empty))
}

/// Mount facets using a concrete registry.
///
/// Generic over router state `S`.
///
/// Behavior:
///   - Always mounts a truthful `GET /facets/meta` listing all manifests.
///   - Mounts each manifest’s routes *exactly* as declared in the manifest
///     (no additional prefix).
///   - Gating:
///       * `SecurityMode::DevAllow`  => facets are *not* wrapped in
///         `RequireAuthLayer` (dev-friendly).
///       * Any other mode (DenyAll/External/…) => facets are wrapped in
///         `RequireAuthLayer`, mirroring KV semantics.
///
/// This is what the `facets_loader` integration tests exercise.
pub fn mount_with_registry<S>(
    mut router: Router<S>,
    reg: FacetRegistry,
    mode: SecurityMode,
) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    // If nothing is loaded, fall back to demo + empty meta for sanity.
    if reg.manifests.is_empty() {
        return mount(router);
    }

    // Truthful meta endpoint, listing all loaded facets.
    //
    // NOTE: We capture the summary at mount time — good enough for current
    // design where manifests are loaded once at boot.
    let meta = Meta { loaded: reg.manifests.iter().map(FacetSummary::from).collect() };
    let meta_clone = meta.clone();
    router = router.route(
        "/facets/meta",
        get(move || {
            let meta = meta_clone.clone();
            async move { Json(meta) }
        }),
    );

    // Mount each manifest's routes EXACTLY as declared in the manifest.
    // No extra base prefix; tests expect the literal paths.
    for m in &reg.manifests {
        let sub = build_router_for_manifest::<S>(m);

        router = match mode {
            // DevAllow => facets are dev-friendly: no auth gate here.
            SecurityMode::DevAllow => router.merge(sub),

            // All stricter modes (DenyAll, External, etc.) => gate via RequireAuth.
            _ => router.merge(sub.layer(RequireAuthLayer::new(mode))),
        };
    }

    router
}

/// Build a sub-router for a single manifest.
///
/// The router returned here is *not* gated by auth; callers decide whether to
/// wrap it with `RequireAuthLayer` or not based on `SecurityMode`.
fn build_router_for_manifest<S>(m: &FacetManifest) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    let mut r = Router::new();

    match m.facet.kind {
        FacetKind::Echo => {
            for rs in &m.route {
                let path = rs.path.clone();
                match rs.method.to_ascii_uppercase().as_str() {
                    "GET" => {
                        r = r.route(&path, get(echo_handler));
                    }
                    "POST" => {
                        r = r.route(&path, post(echo_handler));
                    }
                    _ => {
                        // Unknown methods are ignored; manifest validation should
                        // have caught bad methods earlier.
                    }
                }
            }
        }
        FacetKind::Static => {
            for rs in &m.route {
                let path = rs.path.clone();
                let file = rs.file.clone().expect("validated: file present for static facets");
                // Capture the file path by clone into the handler closure.
                r = r.route(&path, get(move || static_handler(file.clone())));
            }
        }
        FacetKind::Proxy => {
            // Placeholder: 501 Not Implemented for all declared routes.
            //
            // Future: wire this to svc-index / svc-storage / other services.
            for rs in &m.route {
                let path = rs.path.clone();
                match rs.method.to_ascii_uppercase().as_str() {
                    "GET" => {
                        r = r.route(&path, get(proxy_not_implemented));
                    }
                    "POST" => {
                        r = r.route(&path, post(proxy_not_implemented));
                    }
                    _ => {}
                }
            }
        }
    }

    r
}

// -------- Handlers --------

async fn demo_ping() -> &'static str {
    "pong"
}

async fn meta_empty() -> Json<Meta> {
    Json(Meta { loaded: vec![] })
}

// Keep echo simple to avoid needing Axum's `query` feature.
// We just return a static acknowledgement JSON.
async fn echo_handler() -> Json<serde_json::Value> {
    Json(serde_json::json!({ "echo": "ok" }))
}

async fn static_handler(file: String) -> (StatusCode, Body) {
    match tokio::fs::read(file).await {
        Ok(bytes) => (StatusCode::OK, Body::from(bytes)),
        Err(_) => (StatusCode::NOT_FOUND, Body::from("not found")),
    }
}

// Temporary placeholder for proxy facets.
async fn proxy_not_implemented() -> StatusCode {
    StatusCode::NOT_IMPLEMENTED
}

// -------- Meta types --------

#[derive(Debug, Clone, Serialize)]
struct Meta {
    loaded: Vec<FacetSummary>,
}

#[derive(Debug, Clone, Serialize)]
struct FacetSummary {
    id: String,
    kind: String,
    routes: Vec<RouteSummary>,
}

#[derive(Debug, Clone, Serialize)]
struct RouteSummary {
    method: String,
    path: String,
}

impl From<&FacetManifest> for FacetSummary {
    fn from(m: &FacetManifest) -> Self {
        Self {
            id: m.facet.id.clone(),
            kind: match m.facet.kind {
                FacetKind::Static => "static".into(),
                FacetKind::Echo => "echo".into(),
                FacetKind::Proxy => "proxy".into(),
            },
            routes: m
                .route
                .iter()
                .map(|r| RouteSummary {
                    method: r.method.to_ascii_uppercase(),
                    path: r.path.clone(),
                })
                .collect(),
        }
    }
}

```

### crates/micronode/src/facets/search.rs
<a id="crates-micronode-src-facets-search-rs"></a>

```rust
// crates/micronode/src/facets/search.rs
//! RO:WHAT — Placeholder for search facet wiring.
//! RO:WHY  — Search endpoints (full-text, filters) will surface svc-index
//!           capabilities via Micronode facets.
//! RO:STATUS — Stub only; no runtime behavior yet.

#[derive(Debug, Clone)]
pub struct SearchFacetConfig {
    // TODO: index names, query limits, ranking configs.
    _placeholder: (),
}

```

### crates/micronode/src/http/admin.rs
<a id="crates-micronode-src-http-admin-rs"></a>

```rust
//! RO:WHAT — Admin plane: /metrics, /healthz, /readyz, /version.
//! RO:WHY  — Golden surfaces; shared by all RON services.
//! RO:INVARIANTS — Truthful readyz; explicit dev override in handler.

use crate::{observability, state::AppState};
use axum::{extract::State, http::StatusCode, response::IntoResponse};
use prometheus::{Encoder, TextEncoder};

pub async fn metrics(_: State<AppState>) -> impl IntoResponse {
    let families = prometheus::gather();
    let mut buf = Vec::new();
    let _ = TextEncoder::new().encode(&families, &mut buf);
    (StatusCode::OK, buf)
}

pub async fn healthz() -> impl IntoResponse {
    observability::health::handler().await
}

pub async fn readyz(State(st): State<AppState>) -> impl IntoResponse {
    observability::ready::handler(st.probes.clone()).await
}

pub async fn version() -> impl IntoResponse {
    observability::version::handler().await
}

```

### crates/micronode/src/http/kv.rs
<a id="crates-micronode-src-http-kv-rs"></a>

```rust
//! RO:WHAT — KV v1 HTTP handlers: PUT/GET/DELETE /kv/{bucket}/{key}.
//! RO:WHY  — Provide a minimal key/value API for Micronode, backed by Storage.
//! RO:INTERACTS — state::AppState (storage), storage::Storage, layers (body cap, decode guard).
//! RO:INVARIANTS — Binary-safe; no JSON; caps/enforced by layers; no auth yet.
//! RO:METRICS — HTTP metrics handled by global middleware; KV domain metrics later.
//! RO:CONFIG — No per-route config yet; concurrency/body caps are applied in app.rs.
//! RO:SECURITY — No auth/policy here; must be added via middleware in a later step.
//! RO:TEST — To be covered by integration tests (kv_roundtrip, guard_behavior).

use crate::state::AppState;
use axum::{
    body::Bytes,
    extract::{Path, State},
    http::{header, StatusCode},
    response::IntoResponse,
};

/// PUT /kv/{bucket}/{key}
///
/// Body is treated as opaque bytes with `Content-Type: application/octet-stream`.
/// Returns 201 on create, 204 on update, 500 on internal errors.
pub async fn put_kv(
    State(st): State<AppState>,
    Path((bucket, key)): Path<(String, String)>,
    body: Bytes,
) -> impl IntoResponse {
    match st.storage.put(&bucket, &key, &body) {
        Ok(true) => StatusCode::CREATED,
        Ok(false) => StatusCode::NO_CONTENT,
        Err(_e) => StatusCode::INTERNAL_SERVER_ERROR,
    }
}

/// GET /kv/{bucket}/{key}
///
/// Returns 200 with raw bytes and `Content-Type: application/octet-stream`
/// or 404 if the key is absent.
pub async fn get_kv(
    State(st): State<AppState>,
    Path((bucket, key)): Path<(String, String)>,
) -> impl IntoResponse {
    match st.storage.get(&bucket, &key) {
        Ok(Some(bytes)) => {
            (StatusCode::OK, [(header::CONTENT_TYPE, "application/octet-stream")], bytes)
                .into_response()
        }
        Ok(None) => StatusCode::NOT_FOUND.into_response(),
        Err(_e) => StatusCode::INTERNAL_SERVER_ERROR.into_response(),
    }
}

/// DELETE /kv/{bucket}/{key}
///
/// Returns 204 if a value was deleted, 404 if it did not exist.
pub async fn delete_kv(
    State(st): State<AppState>,
    Path((bucket, key)): Path<(String, String)>,
) -> impl IntoResponse {
    match st.storage.delete(&bucket, &key) {
        Ok(true) => StatusCode::NO_CONTENT,
        Ok(false) => StatusCode::NOT_FOUND,
        Err(_e) => StatusCode::INTERNAL_SERVER_ERROR,
    }
}

```

### crates/micronode/src/http/mod.rs
<a id="crates-micronode-src-http-mod-rs"></a>

```rust
//! RO:WHAT — HTTP handlers (admin + basic routes + dev).
//! RO:WHY  — Keep app.rs readable.

pub mod admin;
pub mod kv;
pub mod routes;

pub mod dev {
    pub use super::routes::dev::echo;
}

```

### crates/micronode/src/http/routes.rs
<a id="crates-micronode-src-http-routes-rs"></a>

```rust
//! RO:WHAT — Public and dev routes for Micronode.

use axum::{http::StatusCode, Json};
use serde_json::{json, Value};

// --- /v1/ping ---
pub async fn ping() -> Json<Value> {
    Json(json!({ "pong": true }))
}

// --- /dev/echo ---
// Echoes JSON payload deterministically. Requires Content-Type: application/json
// and (by policy) Content-Length (enforced by BodyCap layer).
pub mod dev {
    use super::*;
    use axum::response::IntoResponse;

    /// Echo JSON back; reject non-JSON early.
    pub async fn echo(Json(body): Json<Value>) -> impl IntoResponse {
        (StatusCode::OK, Json(body))
    }
}

```

### crates/micronode/src/layers/body_cap.rs
<a id="crates-micronode-src-layers-bodycap-rs"></a>

```rust
// crates/micronode/src/layers/body_cap.rs
//! RO:WHAT  — Header-level body cap + content-length policy.
//! RO:WHY   — Enforce explicit Content-Length only on methods that typically
//!            carry bodies (POST/PUT/PATCH). Don't force it for GET/DELETE.
//! RO:NOTE  — Still reject if a Content-Length is present but exceeds the cap.
//! RO:HTTP  — 411 Length Required; 413 Payload Too Large.

use axum::http::{Request, StatusCode};
use axum::response::IntoResponse;
use std::convert::Infallible;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use tower::{Layer, Service};

#[derive(Clone, Copy)]
pub struct BodyCapLayer {
    cap_bytes: usize,
}

impl BodyCapLayer {
    pub fn new(cap_bytes: usize) -> Self {
        Self { cap_bytes }
    }
}

impl<S> Layer<S> for BodyCapLayer {
    type Service = BodyCapService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        BodyCapService { inner, cap_bytes: self.cap_bytes }
    }
}

#[derive(Clone)]
pub struct BodyCapService<S> {
    inner: S,
    cap_bytes: usize,
}

impl<S, B> Service<Request<B>> for BodyCapService<S>
where
    S: Service<Request<B>, Response = axum::response::Response> + Clone + Send + 'static,
    S::Future: Send + 'static,
    B: Send + 'static,
{
    type Response = S::Response;
    type Error = Infallible;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        // Delegate to inner; if inner errors, we still return Ready(Ok(())) and
        // map to 500 in call() to avoid bubbling error types here.
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Ready(Err(_)) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
        }
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        let mut inner = self.inner.clone();
        let cap = self.cap_bytes;

        // Methods that typically *carry* a body and must declare Content-Length explicitly.
        let requires_len = matches!(
            *req.method(),
            axum::http::Method::POST | axum::http::Method::PUT | axum::http::Method::PATCH
        );

        // Inspect Content-Length if present.
        let len_opt = req
            .headers()
            .get(axum::http::header::CONTENT_LENGTH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse::<usize>().ok());

        // If a Content-Length is present on ANY method, enforce the cap.
        if let Some(len) = len_opt {
            if len > cap {
                return Box::pin(async move {
                    Ok((StatusCode::PAYLOAD_TOO_LARGE, "payload too large").into_response())
                });
            }
        }

        // For methods that *require* an explicit Content-Length, enforce presence.
        if requires_len && len_opt.is_none() {
            return Box::pin(async move {
                Ok((StatusCode::LENGTH_REQUIRED, "length required").into_response())
            });
        }

        Box::pin(async move {
            Ok(inner.call(req).await.unwrap_or_else(|_| {
                (StatusCode::INTERNAL_SERVER_ERROR, "internal error").into_response()
            }))
        })
    }
}

```

### crates/micronode/src/layers/concurrency.rs
<a id="crates-micronode-src-layers-concurrency-rs"></a>

```rust
//! RO:WHAT — Per-route non-blocking concurrency cap (429 when saturated).
//! RO:WHY  — Shed load early without stalling worker threads.
//! RO:AXUM — Tower Layer to satisfy Axum 0.7 trait bounds.

use axum::{
    body::Body,
    http::Request,
    response::{IntoResponse, Response},
};
use http::StatusCode;
use std::{
    convert::Infallible,
    future::Future,
    pin::Pin,
    sync::Arc,
    task::{Context, Poll},
};
use tokio::sync::Semaphore;
use tower::{Layer, Service};

type BoxFut = Pin<Box<dyn Future<Output = Result<Response, Infallible>> + Send + 'static>>;

#[derive(Clone)]
pub struct ConcurrencyLayer {
    sema: Arc<Semaphore>,
}

impl ConcurrencyLayer {
    pub fn new(sema: Arc<Semaphore>) -> Self {
        Self { sema }
    }
}

impl<S> Layer<S> for ConcurrencyLayer {
    type Service = ConcurrencyService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        ConcurrencyService { inner, sema: self.sema.clone() }
    }
}

#[derive(Clone)]
pub struct ConcurrencyService<S> {
    inner: S,
    sema: Arc<Semaphore>,
}

impl<S> Service<Request<Body>> for ConcurrencyService<S>
where
    S: Service<Request<Body>, Response = Response, Error = Infallible> + Clone + Send + 'static,
    S::Future: Send + 'static,
{
    type Response = Response;
    type Error = Infallible;
    type Future = BoxFut;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
            Poll::Ready(Err(_)) => Poll::Ready(Ok(())),
        }
    }

    fn call(&mut self, req: Request<Body>) -> Self::Future {
        let mut inner = self.inner.clone();

        // Use OWNED permit so it is 'static-safe inside the async block.
        match self.sema.clone().try_acquire_owned() {
            Ok(permit) => Box::pin(async move {
                let resp = inner.call(req).await?;
                drop(permit); // explicit for clarity
                Ok(resp)
            }),
            Err(_) => Box::pin(async move {
                Ok((StatusCode::TOO_MANY_REQUESTS, "concurrency limit exceeded").into_response())
            }),
        }
    }
}

```

### crates/micronode/src/layers/decode_guard.rs
<a id="crates-micronode-src-layers-decodeguard-rs"></a>

```rust
// crates/micronode/src/layers/decode_guard.rs
//! RO:WHAT — Simple decode policy guard: reject any Content-Encoding and stacked encodings.
//! RO:WHY  — We don't transparently decompress; callers must send identity bodies.

use axum::{
    body::Body,
    http::{header, Request, StatusCode},
    middleware::Next,
    response::{IntoResponse, Response},
};

/// Stateless decode guard: 415 on any Content-Encoding; 415 on stacked encodings ("," in header).
pub async fn guard(req: Request<Body>, next: Next) -> Response {
    match req.headers().get(header::CONTENT_ENCODING) {
        None => next.run(req).await,
        Some(hv) => {
            let enc = match hv.to_str() {
                Ok(s) => s,
                Err(_) => {
                    return (StatusCode::UNSUPPORTED_MEDIA_TYPE, "invalid Content-Encoding header")
                        .into_response();
                }
            };

            if enc.contains(',') {
                return (
                    StatusCode::UNSUPPORTED_MEDIA_TYPE,
                    "stacked content encodings are not supported",
                )
                    .into_response();
            }

            (StatusCode::UNSUPPORTED_MEDIA_TYPE, "compressed request bodies are not supported")
                .into_response()
        }
    }
}

```

### crates/micronode/src/layers/mod.rs
<a id="crates-micronode-src-layers-mod-rs"></a>

```rust
//! RO:WHAT — Ingress guard layers (body cap, decode guard, concurrency).
//! RO:WHY  — Enforce limits *before* heavy work; deterministic early rejects.

pub mod body_cap;
pub mod concurrency;
pub mod decode_guard;
pub mod security;

```

### crates/micronode/src/layers/security.rs
<a id="crates-micronode-src-layers-security-rs"></a>

```rust
// crates/micronode/src/layers/security.rs
//! RO:WHAT — Security ingress layers.
//!
//! 1) `SecurityLayer`: extract raw macaroons into request extensions.
//! 2) `RequireAuthLayer`: enforce a simple, config-driven policy (MVP).
//!
//! RO:WHY — Keep handlers simple; centralize capability plumbing and gating.
//!
//! RO:INTERACTS — Uses `security::auth_macaroon::extract_raw_macaroon` and `RawMacaroon`.
//!
//! RO:INVARIANTS —
//! - Extraction never rejects and never logs token contents.
//! - Enforcement is deny-by-default unless `security.mode = "dev_allow"`.
//! - For now, `external` behaves like `deny_all` (until ron-auth wiring).
//!
//! RO:TEST — Covered by `tests/auth_gate.rs` and existing HTTP integration tests.

use crate::config::schema::SecurityMode;
use crate::security::auth_macaroon::{extract_raw_macaroon, RawMacaroon};
use axum::{
    body::Body,
    http::{header, Request, StatusCode},
    response::{IntoResponse, Response},
};
use std::{
    convert::Infallible,
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};
use tower::{Layer, Service};

type BoxFut = Pin<Box<dyn Future<Output = Result<Response, Infallible>> + Send + 'static>>;

// ===============================
// 1) Extraction: SecurityLayer
// ===============================

/// Layer type used in app.rs for capability extraction.
#[derive(Clone, Default)]
pub struct SecurityLayer;

impl SecurityLayer {
    pub fn new() -> Self {
        Self
    }
}

impl<S> Layer<S> for SecurityLayer {
    type Service = SecurityService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        SecurityService { inner }
    }
}

#[derive(Clone)]
pub struct SecurityService<S> {
    inner: S,
}

impl<S> Service<Request<Body>> for SecurityService<S>
where
    S: Service<Request<Body>, Response = Response, Error = Infallible> + Clone + Send + 'static,
    S::Future: Send + 'static,
{
    type Response = Response;
    type Error = Infallible;
    type Future = BoxFut;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
            // Hide inner readiness errors behind 500 in call()
            Poll::Ready(Err(_)) => Poll::Ready(Ok(())),
        }
    }

    fn call(&mut self, mut req: Request<Body>) -> Self::Future {
        let mut inner = self.inner.clone();

        // Extract a RawMacaroon (if present) and park it in extensions.
        if let Some(mac) = extract_raw_macaroon(&req) {
            req.extensions_mut().insert::<RawMacaroon>(mac);
        }

        Box::pin(async move {
            Ok(inner.call(req).await.unwrap_or_else(|_| {
                (StatusCode::INTERNAL_SERVER_ERROR, "internal error").into_response()
            }))
        })
    }
}

// ===============================
// 2) Enforcement: RequireAuthLayer
// ===============================

/// Policy enforcement layer. Deny-by-default unless `DevAllow` is set.
#[derive(Clone, Copy)]
pub struct RequireAuthLayer {
    mode: SecurityMode,
}

impl RequireAuthLayer {
    pub fn new(mode: SecurityMode) -> Self {
        Self { mode }
    }
}

impl<S> Layer<S> for RequireAuthLayer {
    type Service = RequireAuthService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        RequireAuthService { inner, mode: self.mode }
    }
}

#[derive(Clone)]
pub struct RequireAuthService<S> {
    inner: S,
    mode: SecurityMode,
}

impl<S> Service<Request<Body>> for RequireAuthService<S>
where
    S: Service<Request<Body>, Response = Response, Error = Infallible> + Clone + Send + 'static,
    S::Future: Send + 'static,
{
    type Response = Response;
    type Error = Infallible;
    type Future = BoxFut;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
            // Hide inner readiness errors behind 500 in call()
            Poll::Ready(Err(_)) => Poll::Ready(Ok(())),
        }
    }

    fn call(&mut self, req: Request<Body>) -> Self::Future {
        let mut inner = self.inner.clone();
        let mode = self.mode;

        Box::pin(async move {
            match mode {
                SecurityMode::DevAllow => {
                    // DX-friendly: allow without header.
                    Ok(inner.call(req).await.unwrap_or_else(|_| {
                        (StatusCode::INTERNAL_SERVER_ERROR, "internal error").into_response()
                    }))
                }
                SecurityMode::DenyAll | SecurityMode::External => {
                    // External behaves like deny_all until wired to ron-auth.
                    let has_mac = req.extensions().get::<RawMacaroon>().is_some();

                    if !has_mac {
                        // 401 + WWW-Authenticate: Macro realm="micronode"
                        let resp = (
                            StatusCode::UNAUTHORIZED,
                            [(header::WWW_AUTHENTICATE, r#"Macro realm="micronode""#)],
                            "missing capability macaroon",
                        )
                            .into_response();
                        Ok(resp)
                    } else {
                        // Present but not allowed by current policy.
                        Ok((StatusCode::FORBIDDEN, "capability not allowed by policy")
                            .into_response())
                    }
                }
            }
        })
    }
}

```

### crates/micronode/src/lib.rs
<a id="crates-micronode-src-lib-rs"></a>

```rust
//! RO:WHAT — Micronode library surface (router assembly, config, observability).
//! RO:WHY  — Expose the pieces that tests, benches, and other crates need:
//!           router builder, config, concurrency plane, adapters, and HTTP layers.
//! RO:INTERACTS — Used by integration tests (admin, KV, facets, backpressure, CLI).

#![forbid(unsafe_code)]

pub mod adapters;
pub mod app;
pub mod cli;
pub mod concurrency;
pub mod config;
pub mod errors;
pub mod facets;
pub mod http;
pub mod layers;
pub mod limits;
pub mod observability;
pub mod security;
pub mod state;
pub mod storage;
pub mod types;

pub use app::build_router;

```

### crates/micronode/src/limits.rs
<a id="crates-micronode-src-limits-rs"></a>

```rust
//! RO:WHAT — Central HTTP/OAP limit constants (foundation only).
//! RO:WHY  — Hardening blueprint: size/time/concurrency must be explicit.
//! RO:INVARIANTS — OAP max_frame=1MiB; decoded body cap defaults to 1MiB.

pub const OAP_MAX_FRAME_BYTES: usize = 1_048_576; // 1 MiB
pub const HTTP_BODY_CAP_BYTES: usize = 1_048_576; // 1 MiB

```

### crates/micronode/src/main.rs
<a id="crates-micronode-src-main-rs"></a>

```rust
//! RO:WHAT — Micronode binary entry: load config, init logs, wire readiness, run HTTP.
//! RO:WHY  — Single-binary Micronode with truthful /readyz and dev override.
//! RO:INVARIANTS — No locks across .await; flip readiness probes at the right moments.

#![forbid(unsafe_code)]

use micronode::{app::build_router, config::load::load_config, observability::logging};
use ron_kernel::wait_for_ctrl_c;
use std::net::SocketAddr;
use tracing::{error, info};

#[tokio::main(flavor = "multi_thread")]
async fn main() {
    logging::init();

    // Load config
    let cfg = match load_config() {
        Ok(c) => c,
        Err(e) => {
            error!("config load failed: {e:#}");
            std::process::exit(2);
        }
    };

    // Build router and capture state
    let (router, st) = build_router(cfg.clone());

    // Probe: config successfully loaded
    st.probes.set_cfg_loaded(true);

    let bind: SocketAddr = cfg.server.bind;
    info!("micronode starting on http://{bind}");

    // Bind listener (readiness depends on this)
    let listener = match tokio::net::TcpListener::bind(bind).await {
        Ok(l) => {
            st.probes.set_listeners_bound(true);
            l
        }
        Err(e) => {
            error!("bind failed on {bind}: {e:#}");
            std::process::exit(98);
        }
    };

    // We've registered /metrics; treat exporter as "bound" (process-exposed).
    st.probes.set_metrics_bound(true);

    // Run server with graceful shutdown
    let server = axum::serve(listener, router).with_graceful_shutdown(async {
        wait_for_ctrl_c().await;
        info!("shutdown signal received");
    });

    if let Err(e) = server.await {
        error!("server error: {e:#}");
    }
}

```

### crates/micronode/src/observability/health.rs
<a id="crates-micronode-src-observability-health-rs"></a>

```rust
//! RO:WHAT — /healthz handler adapter (thin wrapper if we need custom shape later).
//! RO:WHY  — Keep admin.rs simple.
//! RO:INVARIANTS — Truthful.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct Health {
    ok: bool,
}

pub async fn handler() -> impl IntoResponse {
    Json(Health { ok: true })
}

```

### crates/micronode/src/observability/http_metrics.rs
<a id="crates-micronode-src-observability-httpmetrics-rs"></a>

```rust
//! RO:WHAT — Minimal HTTP metrics middleware (request count + latency).
//! RO:WHY  — Golden metrics parity across services, with stable metric names:
//!           `micronode_http_requests_total` and `micronode_request_latency_seconds`.
//!
//! RO:INVARIANTS —
//!   - Never propagates errors (Error = Infallible).
//!   - Records a 500 status in metrics if the inner service errors.
//!   - No locks held across `.await`.
//!
//! RO:METRICS —
//!   - micronode_http_requests_total{method,route,status}
//!   - micronode_request_latency_seconds
//!
//! RO:CONFIG — Transparent; router decides which routes are wrapped.

use std::{
    convert::Infallible,
    future::Future,
    pin::Pin,
    sync::OnceLock,
    task::{Context, Poll},
    time::Instant,
};

use axum::{body::Body, http::Request, response::Response};
use prometheus::{Histogram, HistogramOpts, IntCounterVec, Opts};
use tower::{Layer, Service};
use tracing::error;

// --- Static metric families (initialized on first use) ---

static REQS: OnceLock<IntCounterVec> = OnceLock::new();
static LAT: OnceLock<Histogram> = OnceLock::new();

fn reqs() -> &'static IntCounterVec {
    REQS.get_or_init(|| {
        let opts = Opts::new(
            "micronode_http_requests_total",
            "Total HTTP requests processed by Micronode",
        );
        let vec = IntCounterVec::new(opts, &["method", "route", "status"])
            .expect("construct micronode_http_requests_total");

        prometheus::default_registry()
            .register(Box::new(vec.clone()))
            .expect("register micronode_http_requests_total");

        vec
    })
}

fn lat() -> &'static Histogram {
    LAT.get_or_init(|| {
        let opts = HistogramOpts::new(
            "micronode_request_latency_seconds",
            "HTTP request latency observed by Micronode",
        )
        .buckets(prometheus::DEFAULT_BUCKETS.to_vec());

        let hist = Histogram::with_opts(opts).expect("construct micronode_request_latency_seconds");

        prometheus::default_registry()
            .register(Box::new(hist.clone()))
            .expect("register micronode_request_latency_seconds");

        hist
    })
}

// --- Tower Layer implementation ---

#[derive(Clone, Default)]
pub struct HttpMetricsLayer;

impl<S> Layer<S> for HttpMetricsLayer {
    type Service = HttpMetrics<S>;

    fn layer(&self, inner: S) -> Self::Service {
        HttpMetrics { inner }
    }
}

#[derive(Clone)]
pub struct HttpMetrics<S> {
    inner: S,
}

impl<S> Service<Request<Body>> for HttpMetrics<S>
where
    S: Service<Request<Body>, Response = Response> + Clone + Send + 'static,
    S::Error: std::error::Error + Send + Sync + 'static,
    S::Future: Send + 'static,
{
    type Response = S::Response;
    type Error = Infallible;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        match self.inner.poll_ready(cx) {
            Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
            Poll::Pending => Poll::Pending,
            Poll::Ready(Err(e)) => {
                // For foundation cut, we log readiness errors but don't propagate them.
                error!("HttpMetrics inner not ready: {e}");
                Poll::Ready(Ok(()))
            }
        }
    }

    fn call(&mut self, req: Request<Body>) -> Self::Future {
        let method = req.method().as_str().to_owned();
        let route = req.uri().path().to_owned();
        let start = Instant::now();

        let mut inner = self.inner.clone();

        Box::pin(async move {
            let result = inner.call(req).await;
            let elapsed = start.elapsed().as_secs_f64();

            match result {
                Ok(resp) => {
                    let status = resp.status().as_u16().to_string();
                    reqs().with_label_values(&[&method, &route, &status]).inc();
                    lat().observe(elapsed);
                    Ok(resp)
                }
                Err(e) => {
                    error!("handler error in HttpMetrics: {e}");
                    // Record as a 500 in metrics.
                    let status = String::from("500");
                    reqs().with_label_values(&[&method, &route, &status]).inc();
                    lat().observe(elapsed);

                    let resp = Response::builder()
                        .status(500)
                        .body(Body::from("internal error"))
                        .expect("build 500 response in HttpMetrics");

                    Ok(resp)
                }
            }
        })
    }
}

/// Convenience constructor so app.rs can stay clean.
pub fn layer() -> HttpMetricsLayer {
    HttpMetricsLayer
}

/// Prewarm so the metric families are registered and visible at `/metrics`
/// even before the first real request hits.
pub fn prewarm() {
    let _ = reqs();
    let _ = lat();
}

```

### crates/micronode/src/observability/logging.rs
<a id="crates-micronode-src-observability-logging-rs"></a>

```rust
//! RO:WHAT — Tracing subscriber initialization.
//! RO:WHY  — Deterministic logs with env filter.

use tracing_subscriber::{fmt, EnvFilter};

pub fn init() {
    let filter = std::env::var("RUST_LOG").unwrap_or_else(|_| "info,micronode=debug".to_string());
    let _ = fmt().with_env_filter(EnvFilter::new(filter)).try_init();
}

```

### crates/micronode/src/observability/metrics.rs
<a id="crates-micronode-src-observability-metrics-rs"></a>

```rust


```

### crates/micronode/src/observability/mod.rs
<a id="crates-micronode-src-observability-mod-rs"></a>

```rust
//! RO:WHAT — Observability surfaces: logging and version/health/ready adapters.
//! RO:WHY  — Keep app.rs lean; centralize obs stack.

pub mod health;
pub mod http_metrics;
pub mod logging;
pub mod ready;
pub mod version;
// `metrics` module is kept for future richer gauges/counters; currently a stub.
pub mod metrics;

```

### crates/micronode/src/observability/ready.rs
<a id="crates-micronode-src-observability-ready-rs"></a>

```rust
//! RO:WHAT — Readiness probes and `/readyz` handler (truthful by default).
//! RO:WHY  — Operators need a machine-readable snapshot of liveness gates.
//! RO:INVARIANTS
//!   - Required probes: listeners_bound && cfg_loaded.
//!   - Optional probes: metrics_bound, deps_ok (storage/index/etc).
//!   - Dev override via MICRONODE_DEV_READY=1 returns 200 immediately.

use axum::{http::StatusCode, response::IntoResponse, Json};
use serde::Serialize;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

#[derive(Debug)]
pub struct ReadyProbes {
    listeners_bound: AtomicBool,
    cfg_loaded: AtomicBool,
    metrics_bound: AtomicBool,
    deps_ok: AtomicBool, // placeholder: storage/index/queue/etc
}

impl ReadyProbes {
    /// Construct probes with a conservative-but-truthful baseline for the
    /// current Micronode profile.
    ///
    /// For the in-memory storage engine, `deps_ok` is effectively always true
    /// once the process is up: there is no fallible external dependency to
    /// gate on. We initialise `deps_ok` to true so that "truthful" mode
    /// reflects reality today.
    ///
    /// When we add a fallible engine (sled / overlay / remote index), that
    /// engine's open result should drive `set_deps_ok(false|true)` instead.
    pub fn new() -> Self {
        Self {
            listeners_bound: AtomicBool::new(false),
            cfg_loaded: AtomicBool::new(false),
            metrics_bound: AtomicBool::new(false),
            deps_ok: AtomicBool::new(true),
        }
    }

    // --- Setters (flip true when satisfied) ---

    pub fn set_listeners_bound(&self, v: bool) {
        self.listeners_bound.store(v, Ordering::Release);
    }

    pub fn set_cfg_loaded(&self, v: bool) {
        self.cfg_loaded.store(v, Ordering::Release);
    }

    pub fn set_metrics_bound(&self, v: bool) {
        self.metrics_bound.store(v, Ordering::Release);
    }

    pub fn set_deps_ok(&self, v: bool) {
        self.deps_ok.store(v, Ordering::Release);
    }

    // --- Snapshot & decision ---

    pub fn snapshot(&self) -> ReadySnapshot {
        ReadySnapshot {
            listeners_bound: self.listeners_bound.load(Ordering::Acquire),
            cfg_loaded: self.cfg_loaded.load(Ordering::Acquire),
            metrics_bound: self.metrics_bound.load(Ordering::Acquire),
            deps_ok: self.deps_ok.load(Ordering::Acquire),
        }
    }
}

// Clippy: new-without-default — keep `new()` as the semantic ctor and
// delegate `Default` to it.
impl Default for ReadyProbes {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct ReadySnapshot {
    pub listeners_bound: bool,
    pub cfg_loaded: bool,
    pub metrics_bound: bool,
    pub deps_ok: bool,
}

impl ReadySnapshot {
    /// REQUIRED probes for 200 OK. Adjust here if you want stricter gates.
    ///
    /// Today we keep this minimal: Micronode is "ready" once it is listening
    /// and config has been successfully loaded. Optional probes such as
    /// metrics_bound and deps_ok are still included in the JSON payload for
    /// operators and dashboards but do not flip the readiness bit.
    pub fn required_ready(&self) -> bool {
        self.listeners_bound && self.cfg_loaded
    }
}

#[derive(Serialize)]
#[serde(deny_unknown_fields)]
struct ReadyReport {
    ready: bool,
    probes: ReadySnapshot,
    mode: &'static str, // "dev-forced" or "truthful"
}

pub async fn handler(probes: Arc<ReadyProbes>) -> impl IntoResponse {
    // Dev override: force ready for local benches/smokes.
    if matches!(
        std::env::var("MICRONODE_DEV_READY").as_deref(),
        Ok("1") | Ok("true") | Ok("TRUE") | Ok("on") | Ok("ON")
    ) {
        let snap = probes.snapshot();
        let report = ReadyReport { ready: true, probes: snap, mode: "dev-forced" };
        return (StatusCode::OK, Json(report)).into_response();
    }

    let snap = probes.snapshot();
    let ok = snap.required_ready();
    let status = if ok { StatusCode::OK } else { StatusCode::SERVICE_UNAVAILABLE };

    let report = ReadyReport { ready: ok, probes: snap, mode: "truthful" };

    (status, Json(report)).into_response()
}

```

### crates/micronode/src/observability/version.rs
<a id="crates-micronode-src-observability-version-rs"></a>

```rust
//! RO:WHAT — /version payload.
//! RO:WHY  — Build provenance for ops.

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct VersionResp<'a> {
    name: &'a str,
    version: &'a str,
    built_at_unix: u64,
}

pub async fn handler() -> impl IntoResponse {
    let built =
        option_env!("MICRONODE_BUILD_UNIX").and_then(|s| s.parse::<u64>().ok()).unwrap_or(0);
    Json(VersionResp {
        name: "micronode",
        version: env!("CARGO_PKG_VERSION"),
        built_at_unix: built,
    })
}

```

### crates/micronode/src/security/amnesia.rs
<a id="crates-micronode-src-security-amnesia-rs"></a>

```rust
// crates/micronode/src/security/amnesia.rs
//! RO:WHAT — Amnesia posture helpers (RAM-only by default, persistence opt-in).
//! RO:WHY  — Micronode is designed to be "amnesia-first", avoiding durable writes
//!           unless the operator explicitly opts into persistence.
//! RO:INTERACTS — Uses process environment only; callers use this to decide which
//!                storage engine or profile to pick.
//! RO:INVARIANTS — Default posture is `Enabled` and env parsing never panics.
//! RO:CONFIG — `MICRO_AMNESIA` and legacy `MICRO_PERSIST` influence posture.
//! RO:SECURITY — Favor amnesia when configs are ambiguous and never silently
//!               enable persistence.
//! RO:TEST — Future `tests/amnesia_proof.rs` should walk env matrices.

/// Effective amnesia posture for this process.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AmnesiaPosture {
    /// Amnesia ON — prefer RAM-only behavior, no durable writes.
    Enabled,
    /// Amnesia OFF — persistence allowed (subject to storage/profile).
    Disabled,
}

/// Returns the effective amnesia posture, considering environment overrides.
///
/// Priority:
/// 1. `MICRO_AMNESIA` (truthy/falsy).
/// 2. `MICRO_PERSIST` (legacy; truthy disables amnesia).
/// 3. Default: `AmnesiaPosture::Enabled`.
pub fn posture_from_env() -> AmnesiaPosture {
    use std::env;

    if let Ok(val) = env::var("MICRO_AMNESIA") {
        match classify_bool(&val) {
            Some(Boolish::True) => return AmnesiaPosture::Enabled,
            Some(Boolish::False) => return AmnesiaPosture::Disabled,
            None => {}
        }
    }

    if let Ok(val) = env::var("MICRO_PERSIST") {
        if matches!(classify_bool(&val), Some(Boolish::True)) {
            return AmnesiaPosture::Disabled;
        }
    }

    AmnesiaPosture::Enabled
}

/// Convenience: `true` if amnesia is enabled (RAM-only posture).
pub fn amnesia_enabled() -> bool {
    matches!(posture_from_env(), AmnesiaPosture::Enabled)
}

/// Convenience: `true` if persistence is allowed (amnesia disabled).
pub fn persistence_allowed() -> bool {
    !amnesia_enabled()
}

/// Internal classification for env bool-likes.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Boolish {
    True,
    False,
}

/// Classify a string as a "truthy" or "falsy" value, or return `None` if unknown.
fn classify_bool(s: &str) -> Option<Boolish> {
    let v = s.trim();
    if v.is_empty() {
        return None;
    }

    let lower = v.to_ascii_lowercase();

    match lower.as_str() {
        "1" | "true" | "on" | "yes" => Some(Boolish::True),
        "0" | "false" | "off" | "no" => Some(Boolish::False),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classify_bool_truthy_and_falsy() {
        assert_eq!(classify_bool("1"), Some(Boolish::True));
        assert_eq!(classify_bool("true"), Some(Boolish::True));
        assert_eq!(classify_bool("TRUE"), Some(Boolish::True));
        assert_eq!(classify_bool("on"), Some(Boolish::True));
        assert_eq!(classify_bool("yes"), Some(Boolish::True));

        assert_eq!(classify_bool("0"), Some(Boolish::False));
        assert_eq!(classify_bool("false"), Some(Boolish::False));
        assert_eq!(classify_bool("FALSE"), Some(Boolish::False));
        assert_eq!(classify_bool("off"), Some(Boolish::False));
        assert_eq!(classify_bool("no"), Some(Boolish::False));

        assert_eq!(classify_bool(""), None);
        assert_eq!(classify_bool("   "), None);
        assert_eq!(classify_bool("maybe"), None);
    }

    #[test]
    fn posture_defaults_to_amnesia_enabled() {
        let posture = posture_from_env();
        let _ = posture;
    }
}

```

### crates/micronode/src/security/auth_macaroon.rs
<a id="crates-micronode-src-security-authmacaroon-rs"></a>

```rust
// crates/micronode/src/security/auth_macaroon.rs
//! RO:WHAT — Minimal macaroon/capability extraction helpers for HTTP requests.
//! RO:WHY  — Keep header parsing logic out of handlers and treat macaroons as
//!           opaque blobs that downstream auth services can verify.
//! RO:INTERACTS — `http` handlers can call `extract_raw_macaroon(&Request<Body>)`.
//! RO:INVARIANTS — Never panic on malformed headers and never log token contents.
//! RO:CONFIG — Uses an `Authorization` header with the `Macro <token>` scheme.
//! RO:SECURITY — This module only parses macaroons; verification happens elsewhere.
//! RO:TEST — Covered by unit tests here and by higher-level integration tests.

use http::{header, Request};

/// Scheme prefix for macaroon-style capabilities carried in `Authorization`.
///
/// Example: `Authorization: Macro aGVsbG8uLi4`.
pub const MACROON_SCHEME: &str = "macro";

/// Opaque wrapper around a raw macaroon/capability token.
#[derive(Debug, Clone)]
pub struct RawMacaroon {
    token: String,
}

impl RawMacaroon {
    pub fn new(token: String) -> Self {
        Self { token }
    }

    pub fn as_str(&self) -> &str {
        &self.token
    }

    pub fn into_inner(self) -> String {
        self.token
    }
}

/// Attempt to extract a `RawMacaroon` from an HTTP request.
///
/// We look for an `Authorization` header of the form `Macro <token>`
/// and match the scheme case-insensitively.
pub fn extract_raw_macaroon<B>(req: &Request<B>) -> Option<RawMacaroon> {
    let hdr = req.headers().get(header::AUTHORIZATION)?;
    let value = hdr.to_str().ok()?.trim();

    let mut parts = value.splitn(2, char::is_whitespace);
    let scheme = parts.next()?.trim();
    let token = parts.next().unwrap_or("").trim();

    if scheme.eq_ignore_ascii_case(MACROON_SCHEME) && !token.is_empty() {
        Some(RawMacaroon::new(token.to_owned()))
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use http::{header, Request};

    #[test]
    fn extract_valid_macroon_authorization() {
        let req = Request::builder()
            .method("GET")
            .uri("/v1/kv/demo/k")
            .header(header::AUTHORIZATION, "Macro abc123")
            .body(())
            .unwrap();

        let mac = extract_raw_macaroon(&req).expect("expected macaroon");
        assert_eq!(mac.as_str(), "abc123");
    }

    #[test]
    fn extract_is_case_insensitive_on_scheme() {
        let req = Request::builder()
            .method("GET")
            .uri("/v1/kv/demo/k")
            .header(header::AUTHORIZATION, "mAcRo xyz")
            .body(())
            .unwrap();

        let mac = extract_raw_macaroon(&req).expect("expected macaroon");
        assert_eq!(mac.as_str(), "xyz");
    }

    #[test]
    fn extract_rejects_unrelated_schemes_or_missing_token() {
        let req = Request::builder()
            .method("GET")
            .uri("/v1/kv/demo/k")
            .header(header::AUTHORIZATION, "Bearer something")
            .body(())
            .unwrap();
        assert!(extract_raw_macaroon(&req).is_none());

        let req = Request::builder()
            .method("GET")
            .uri("/v1/kv/demo/k")
            .header(header::AUTHORIZATION, "Macro")
            .body(())
            .unwrap();
        assert!(extract_raw_macaroon(&req).is_none());

        let req = Request::builder().method("GET").uri("/v1/kv/demo/k").body(()).unwrap();
        assert!(extract_raw_macaroon(&req).is_none());
    }

    #[test]
    fn raw_macaroon_wrapper_roundtrips() {
        let mac = RawMacaroon::new("token-123".to_string());
        assert_eq!(mac.as_str(), "token-123");
        let owned = mac.clone().into_inner();
        assert_eq!(owned, "token-123");
    }
}

```

### crates/micronode/src/security/mod.rs
<a id="crates-micronode-src-security-mod-rs"></a>

```rust
// crates/micronode/src/security/mod.rs
//! RO:WHAT — Security helpers for Micronode (amnesia posture, capability extraction).
//! RO:WHY  — Keep core security decisions such as amnesia-first posture and macaroon
//!           headers in one place.
//! RO:INTERACTS — `amnesia` reads env toggles and `auth_macaroon` extracts raw
//!                macaroons from HTTP requests.
//! RO:INVARIANTS — Defaults are amnesia-first and macaroons are treated as opaque blobs.
//! RO:CONFIG — Env keys for amnesia include `MICRO_AMNESIA` and a legacy `MICRO_PERSIST`.
//! RO:SECURITY — This module does not verify capabilities; that work lives in
//!                `ron-auth` and `ron-policy`.
//! RO:TEST — To be covered by `tests/amnesia_proof.rs` and future security tests.

pub mod amnesia;
pub mod auth_macaroon;

// PQ / TLS modules are kept as stubs for now; they will be fleshed out later.
pub mod pq_config;
pub mod pq_observe;
pub mod pq_toggle;
pub mod tls_rustls;

```

### crates/micronode/src/security/pq_config.rs
<a id="crates-micronode-src-security-pqconfig-rs"></a>

```rust


```

### crates/micronode/src/security/pq_observe.rs
<a id="crates-micronode-src-security-pqobserve-rs"></a>

```rust


```

### crates/micronode/src/security/pq_toggle.rs
<a id="crates-micronode-src-security-pqtoggle-rs"></a>

```rust


```

### crates/micronode/src/security/tls_rustls.rs
<a id="crates-micronode-src-security-tlsrustls-rs"></a>

```rust


```

### crates/micronode/src/state.rs
<a id="crates-micronode-src-state-rs"></a>

```rust
//! RO:WHAT — Process state container: config, metrics, health, readiness probes, storage.
//! RO:WHY  — Keep shared handles in one place for Axum State.
//! RO:INTERACTS — config::schema::Config, observability::ready::ReadyProbes, ron_kernel::Metrics, storage::MemStore.
//! RO:INVARIANTS — No locks across `.await`; handles are clone-friendly; storage is behind a trait.
//! RO:METRICS — Metrics handle exported via /metrics (Prometheus).
//! RO:CONFIG — Config drives server bind/dev routes (storage engine later).
//! RO:SECURITY — No capabilities enforced here (auth/policy lives at handlers).
//! RO:TEST — Covered by HTTP integration tests that exercise AppState via routes.

use crate::config::schema::Config;
use crate::observability::ready::ReadyProbes;
use crate::storage::{DynStorage, MemStore};
use ron_kernel::metrics::health::HealthState;
use ron_kernel::Metrics;
use std::sync::Arc;

#[derive(Clone)]
pub struct AppState {
    pub cfg: Config,
    pub metrics: Arc<Metrics>,    // exported via /metrics
    pub health: Arc<HealthState>, // liveness
    pub probes: Arc<ReadyProbes>, // readiness (truthful)
    pub storage: DynStorage,      // key/value engine (mem today, pluggable later)
}

impl AppState {
    pub fn new(cfg: Config) -> Self {
        // false = we don't auto-serve exporter here (we expose /metrics via axum)
        let metrics: Arc<Metrics> = Metrics::new(false);
        let health = Arc::new(HealthState::new());
        let probes = Arc::new(ReadyProbes::new());

        // For now Micronode always boots with the in-memory store.
        // Later, Config::storage.engine will select sled vs mem.
        let storage: DynStorage = Arc::new(MemStore::new());

        // Baseline liveness true; readiness remains truthful via probes.
        health.set("micronode", true);

        Self { cfg, metrics, health, probes, storage }
    }
}

```

### crates/micronode/src/storage/mod.rs
<a id="crates-micronode-src-storage-mod-rs"></a>

```rust
//! RO:WHAT — Storage abstraction for Micronode (KV engine + in-memory implementation).
//! RO:WHY  — Give Micronode a boring key/value API that can later plug sled/RocksDB/etc.
//! RO:INTERACTS — Used by state::AppState and HTTP KV handlers (http::kv).
//! RO:INVARIANTS — No locks across `.await`; operations are short, bounded, and sync.
//! RO:METRICS — KV ops/bytes metrics can be layered on top later (domain counters).
//! RO:CONFIG — Engine selection will come from Config (engine="mem" | "sled") in a later step.
//! RO:SECURITY — No auth here; capability/policy checks live at HTTP layer.
//! RO:TEST — Unit tests for MemStore + HTTP integration tests for KV routes (future).

use crate::errors::Result;
use parking_lot::RwLock;
use std::collections::HashMap;
use std::sync::Arc;

/// Trait for Micronode KV engines.
///
/// This is intentionally small and synchronous; HTTP handlers stay async and
/// call into this trait without holding locks across `.await`.
pub trait Storage: Send + Sync {
    /// Insert or overwrite a value.
    ///
    /// Returns `Ok(true)` if the key was newly created, `Ok(false)` if it
    /// replaced an existing value.
    fn put(&self, bucket: &str, key: &str, value: &[u8]) -> Result<bool>;

    /// Fetch a value, if present.
    fn get(&self, bucket: &str, key: &str) -> Result<Option<Vec<u8>>>;

    /// Delete a value.
    ///
    /// Returns `Ok(true)` if a value existed and was removed, `Ok(false)` if
    /// the key was absent.
    fn delete(&self, bucket: &str, key: &str) -> Result<bool>;
}

/// Shared trait object type for storage engines.
pub type DynStorage = Arc<dyn Storage + Send + Sync>;

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
struct BucketKey {
    bucket: String,
    key: String,
}

impl BucketKey {
    fn new(bucket: &str, key: &str) -> Self {
        Self { bucket: bucket.to_owned(), key: key.to_owned() }
    }
}

/// Simple in-memory store backed by a `RwLock<HashMap<BucketKey, Vec<u8>>>`.
///
/// Intended for:
///   - dev/prototyping
///   - amnesia-first micronode profiles
///   - tests
#[derive(Debug, Default)]
pub struct MemStore {
    inner: RwLock<HashMap<BucketKey, Vec<u8>>>,
}

impl MemStore {
    pub fn new() -> Self {
        Self::default()
    }
}

impl Storage for MemStore {
    fn put(&self, bucket: &str, key: &str, value: &[u8]) -> Result<bool> {
        let k = BucketKey::new(bucket, key);
        let mut guard = self.inner.write();
        let existed = guard.insert(k, value.to_vec()).is_some();
        Ok(!existed)
    }

    fn get(&self, bucket: &str, key: &str) -> Result<Option<Vec<u8>>> {
        let k = BucketKey::new(bucket, key);
        let guard = self.inner.read();
        Ok(guard.get(&k).cloned())
    }

    fn delete(&self, bucket: &str, key: &str) -> Result<bool> {
        let k = BucketKey::new(bucket, key);
        let mut guard = self.inner.write();
        Ok(guard.remove(&k).is_some())
    }
}

// In the next step we can add:
//
// #[cfg(feature = "sled-store")]
// pub mod sled_store;
//
// and implement `Storage` for a sled-backed engine.

```

### crates/micronode/src/storage/sled_store.rs
<a id="crates-micronode-src-storage-sledstore-rs"></a>

```rust
// crates/micronode/src/storage/sled_store.rs
//! RO:WHAT — Sled-backed Storage adapter (bucket = tree; key = binary value).
//! RO:MODE — Behind `sled-store` feature; not used by default.
//! RO:ERRS — Map sled errors to `Error::Internal` (beta scope).

#[cfg(feature = "sled-store")]
mod sled_adapter {
    use super::super::{Storage};
    use crate::errors::{Error, Result};
    use std::sync::Arc;

    pub struct SledStore {
        db: sled::Db,
    }

    impl SledStore {
        pub fn open(path: &str) -> Result<Arc<Self>> {
            let db = sled::open(path).map_err(|_| Error::Internal)?;
            Ok(Arc::new(Self { db }))
        }

        #[inline]
        fn tree(&self, bucket: &str) -> Result<sled::Tree> {
            self.db.open_tree(bucket).map_err(|_| Error::Internal)
        }
    }

    impl Storage for SledStore {
        fn put(&self, bucket: &str, key: &str, val: &[u8]) -> Result<()> {
            let t = self.tree(bucket)?;
            t.insert(key.as_bytes(), val).map_err(|_| Error::Internal)?;
            Ok(())
        }

        fn get(&self, bucket: &str, key: &str) -> Result<Option<Vec<u8>>> {
            let t = self.tree(bucket)?;
            let v = t.get(key.as_bytes()).map_err(|_| Error::Internal)?;
            Ok(v.map(|ivec| ivec.to_vec()))
        }

        fn del(&self, bucket: &str, key: &str) -> Result<bool> {
            let t = self.tree(bucket)?;
            let removed = t.remove(key.as_bytes()).map_err(|_| Error::Internal)?;
            Ok(removed.is_some())
        }
    }
}

// Public re-export only when feature is enabled.
#[cfg(feature = "sled-store")]
pub use sled_adapter::SledStore;

```

### crates/micronode/src/types.rs
<a id="crates-micronode-src-types-rs"></a>

```rust
//! RO:WHAT — Shared DTOs for tiny endpoints (/version, dev echo).
//! RO:WHY  — Keep handler files small and composable.
//! RO:INVARIANTS — DTO hygiene: #[serde(deny_unknown_fields)].

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Version {
    pub name: &'static str,
    pub version: &'static str,
    pub built_at_unix: u64,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Echo {
    pub message: String,
}

```

### crates/micronode/tests/admin_parity.rs
<a id="crates-micronode-tests-adminparity-rs"></a>

```rust
//! RO:WHAT — Integration tests for Micronode admin plane.
//! RO:WHY  — Ensure `/healthz`, `/readyz`, `/version`, `/metrics` are wired
//!           and behave sanely in-process (no external binaries needed).
//! RO:HOW  — Spin up an ephemeral axum server using `build_router` and
//!           hit it with `reqwest`.
//!
//! These are intentionally high-level smoke tests:
//!   - If they fail, the node is not “basically alive”.
//!   - They double as a template for future KV / guard tests.

use std::{net::SocketAddr, time::Duration};

use micronode::app::build_router;
use micronode::config::schema::{Config, Server};
use reqwest::StatusCode;
use tokio::task::JoinHandle;

/// Spawn an in-process Micronode instance on an ephemeral port.
///
/// This mirrors the main binary’s bootstrap pattern but avoids config
/// files and uses a synthetic `Config` pointing at `127.0.0.1:0`.
async fn spawn_micronode() -> (SocketAddr, JoinHandle<()>) {
    // Bind an ephemeral port first so we know where to hit the server.
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.expect("bind test listener");
    let addr = listener.local_addr().expect("get local address for test listener");

    // Minimal config: bind address + dev routes (handy for future tests).
    let cfg = Config { server: Server { bind: addr, dev_routes: true }, ..Config::default() };

    // Build router + state the same way the binary does.
    let (router, state) = build_router(cfg);

    // Flip readiness probes to a “healthy” state.
    //
    // This matches what the main binary does after binding listeners
    // and wiring metrics. For now we treat deps_ok as true because the
    // in-memory store has no external failure mode.
    state.probes.set_cfg_loaded(true);
    state.probes.set_listeners_bound(true);
    state.probes.set_metrics_bound(true);
    state.probes.set_deps_ok(true);

    // Run the server in the background. Dropping the handle will cancel it.
    let handle = tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, router).await {
            eprintln!("[micronode-test] server error: {err}");
        }
    });

    (addr, handle)
}

#[tokio::test]
async fn admin_endpoints_are_healthy_and_observable() {
    let (addr, _handle) = spawn_micronode().await;
    let base = format!("http://{}", addr);

    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(2))
        .build()
        .expect("build reqwest client");

    // /healthz — must be 200 and JSON { "ok": true }.
    let health = client.get(format!("{base}/healthz")).send().await.expect("GET /healthz");
    assert!(health.status().is_success(), "expected 2xx from /healthz, got {}", health.status());
    let health_body: serde_json::Value = health.json().await.expect("parse /healthz json");
    assert_eq!(
        health_body["ok"],
        serde_json::Value::Bool(true),
        "expected /healthz.ok == true, got {health_body}"
    );

    // /readyz — must be 200 and JSON { "ready": true, ... } in truthful mode.
    let ready = client.get(format!("{base}/readyz")).send().await.expect("GET /readyz");
    assert_eq!(ready.status(), StatusCode::OK, "expected 200 from /readyz, got {}", ready.status());
    let ready_body: serde_json::Value = ready.json().await.expect("parse /readyz json");
    assert_eq!(
        ready_body["ready"],
        serde_json::Value::Bool(true),
        "expected /readyz.ready == true, got {ready_body}"
    );

    // /version — must be 200 and at least contain `name: "micronode"`.
    let version = client.get(format!("{base}/version")).send().await.expect("GET /version");
    assert!(version.status().is_success(), "expected 2xx from /version, got {}", version.status());
    let version_body: serde_json::Value = version.json().await.expect("parse /version json");
    assert_eq!(
        version_body["name"],
        serde_json::Value::String("micronode".to_string()),
        "expected /version.name == \"micronode\", got {version_body}"
    );

    // /metrics — must be 200 and contain at least the micronode HTTP series.
    let metrics = client.get(format!("{base}/metrics")).send().await.expect("GET /metrics");
    assert!(metrics.status().is_success(), "expected 2xx from /metrics, got {}", metrics.status());
    let metrics_text = metrics.text().await.expect("read /metrics text");

    assert!(
        metrics_text.contains("micronode_http_requests_total"),
        "expected /metrics to contain micronode_http_requests_total; got:\n{}",
        metrics_text
    );
    assert!(
        metrics_text.contains("micronode_request_latency_seconds"),
        "expected /metrics to contain micronode_request_latency_seconds; got:\n{}",
        metrics_text
    );
}

```

### crates/micronode/tests/amnesia_proof.rs
<a id="crates-micronode-tests-amnesiaproof-rs"></a>

```rust


```

### crates/micronode/tests/auth_gate.rs
<a id="crates-micronode-tests-authgate-rs"></a>

```rust
//! RO:WHAT — Integration tests for Micronode auth enforcement (MVP layer).
//! RO:WHY  — Prove deny-by-default semantics and DX-friendly dev_allow mode.
//! RO:TESTS —
//!   1) deny_all without header -> 401 + WWW-Authenticate
//!   2) deny_all with header    -> 403
//!   3) dev_allow without header -> 201/200 on KV

use std::{net::SocketAddr, time::Duration};

use micronode::app::build_router;
use micronode::config::schema::{Config, SecurityCfg, SecurityMode, Server};
use reqwest::StatusCode;
use tokio::task::JoinHandle;

/// Spawn an in-process Micronode instance on an ephemeral port with the given security mode.
async fn spawn_with_security(mode: SecurityMode) -> (SocketAddr, JoinHandle<()>) {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.expect("bind test listener");
    let addr = listener.local_addr().expect("local address");

    let cfg = Config {
        server: Server { bind: addr, dev_routes: false },
        security: SecurityCfg { mode },
        ..Config::default()
    };

    let (router, state) = build_router(cfg);

    // Make readiness truthful for the in-memory engine.
    state.probes.set_cfg_loaded(true);
    state.probes.set_listeners_bound(true);
    state.probes.set_metrics_bound(true);
    state.probes.set_deps_ok(true);

    let handle = tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, router).await {
            eprintln!("[micronode-auth-test] server error: {err}");
        }
    });

    (addr, handle)
}

#[tokio::test]
async fn deny_all_without_header_yields_401_www_authenticate() {
    let (addr, _handle) = spawn_with_security(SecurityMode::DenyAll).await;
    let base = format!("http://{}", addr);
    let key_url = format!("{base}/v1/kv/a/k");

    let client =
        reqwest::Client::builder().timeout(Duration::from_secs(2)).build().expect("client");

    // Attempt a PUT without Authorization: expect 401 + WWW-Authenticate
    let put = client
        .put(&key_url)
        .header("content-type", "application/octet-stream")
        .body("hello")
        .send()
        .await
        .expect("PUT missing auth");
    assert_eq!(put.status(), StatusCode::UNAUTHORIZED, "expected 401, got {}", put.status());
    let hdr = put.headers().get("www-authenticate").and_then(|v| v.to_str().ok()).unwrap_or("");
    assert!(
        hdr.to_ascii_lowercase().contains("macro"),
        "expected Macro scheme in WWW-Authenticate, got {hdr:?}"
    );
}

#[tokio::test]
async fn deny_all_with_header_yields_403() {
    let (addr, _handle) = spawn_with_security(SecurityMode::DenyAll).await;
    let base = format!("http://{}", addr);
    let key_url = format!("{base}/v1/kv/a/k");

    let client =
        reqwest::Client::builder().timeout(Duration::from_secs(2)).build().expect("client");

    // With a dummy Macro token we still deny in MVP (no external auth yet)
    let put = client
        .put(&key_url)
        .header("content-type", "application/octet-stream")
        .header("authorization", "Macro dummy-token")
        .body("hello")
        .send()
        .await
        .expect("PUT with dummy auth");
    assert_eq!(put.status(), StatusCode::FORBIDDEN, "expected 403, got {}", put.status());
}

#[tokio::test]
async fn dev_allow_permits_kv_without_header() {
    let (addr, _handle) = spawn_with_security(SecurityMode::DevAllow).await;
    let base = format!("http://{}", addr);
    let key_url = format!("{base}/v1/kv/a/k");

    let client =
        reqwest::Client::builder().timeout(Duration::from_secs(2)).build().expect("client");

    // 1) PUT without Authorization should succeed in dev_allow.
    let put = client
        .put(&key_url)
        .header("content-type", "application/octet-stream")
        .body("hello")
        .send()
        .await
        .expect("PUT /v1/kv/a/k");
    assert_eq!(put.status(), StatusCode::CREATED, "expected 201, got {}", put.status());

    // 2) GET should return the value.
    let get = client.get(&key_url).send().await.expect("GET");
    assert_eq!(get.status(), StatusCode::OK, "expected 200, got {}", get.status());
    let body = get.bytes().await.expect("read body");
    assert_eq!(&body[..], b"hello");
}

```

### crates/micronode/tests/backpressure.rs
<a id="crates-micronode-tests-backpressure-rs"></a>

```rust
//! RO:WHAT — Integration-style tests for Micronode backpressure behavior.
//! RO:WHY  — Assert that the concurrency layer sheds overload with 429 and that
//!           the concurrency registry builds distinct, bounded pools.
//!
//! These tests operate entirely in-process (no real TCP sockets), driving the
//! Axum `Router` directly.

use std::sync::Arc;

use axum::{body::Body, routing::get, Router};
use http::{Request, StatusCode};
use micronode::{
    concurrency::{ConcurrencyConfig, ConcurrencyRegistry},
    layers::concurrency::ConcurrencyLayer,
};
use tokio::sync::Semaphore;
use tower::ServiceExt as _; // for `Router::oneshot`

#[tokio::test]
async fn concurrency_layer_sheds_with_429_when_pool_is_exhausted() {
    // Limit=1 and we hold the only permit up front so the layer sees a
    // saturated pool and must respond with 429 immediately.
    let sema = Arc::new(Semaphore::new(1));
    let _held = sema.clone().acquire_owned().await.expect("failed to acquire initial permit");

    let app =
        Router::new().route("/hot", get(|| async { "ok" })).layer(ConcurrencyLayer::new(sema));

    let req = Request::builder().uri("/hot").body(Body::empty()).expect("build request");

    let resp = app.oneshot(req).await.expect("router call failed");

    assert_eq!(
        resp.status(),
        StatusCode::TOO_MANY_REQUESTS,
        "expected 429 from ConcurrencyLayer when pool is exhausted"
    );
}

#[tokio::test]
async fn concurrency_registry_builds_distinct_pools_per_class() {
    let cfg = ConcurrencyConfig::default();
    let registry = ConcurrencyRegistry::from_config(&cfg);

    let admin = registry.get("http_admin");
    let kv = registry.get("http_kv");

    // Pointers must differ; these are distinct semaphores for distinct budgets.
    let admin_ptr: *const Semaphore = &*admin;
    let kv_ptr: *const Semaphore = &*kv;

    assert_ne!(admin_ptr, kv_ptr, "admin and kv should have distinct concurrency pools");

    // Both pools should honour their configured caps.
    assert_eq!(
        cfg.http_admin.max_inflight,
        admin.available_permits(),
        "admin pool should be initialized with the configured max_inflight"
    );
    assert_eq!(
        cfg.http_kv.max_inflight,
        kv.available_permits(),
        "kv pool should be initialized with the configured max_inflight"
    );
}

```

### crates/micronode/tests/cli_smoke.rs
<a id="crates-micronode-tests-clismoke-rs"></a>

```rust
//! RO:WHAT — Smoke tests for Micronode CLI surface.
//! RO:WHY  — Ensure `Cli::from_env()` produces a sensible default shape and
//!           that the public enums/types remain stable across refactors.

use micronode::cli::{Cli, Command, Profile};

#[test]
fn default_cli_uses_serve_command() {
    let cli = Cli::from_env();

    match cli.command() {
        Command::Serve(opts) => {
            // Default profile should be `Dev` to favor DX.
            assert_eq!(opts.profile, Profile::Dev);
            // Dev routes should be on by default.
            assert!(opts.dev_routes);
        }
        other => panic!("expected default command to be Serve(..), got {other:?}"),
    }
}

```

### crates/micronode/tests/facets_loader.rs
<a id="crates-micronode-tests-facetsloader-rs"></a>

```rust
//! RO:WHAT — Facet loader integration tests.
//! RO:WHY  — Prove manifest-driven loading and basic handlers; loader errors block readiness.

use std::{fs, net::SocketAddr, path::PathBuf, time::Duration};

use micronode::app::build_router;
use micronode::config::schema::{Config, FacetsCfg, SecurityCfg, SecurityMode, Server};
use reqwest::StatusCode;
use tokio::task::JoinHandle;

async fn spawn_with_facets(dir: PathBuf, mode: SecurityMode) -> (SocketAddr, JoinHandle<()>) {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.expect("bind test listener");
    let addr = listener.local_addr().unwrap();

    let cfg = Config {
        server: Server { bind: addr, dev_routes: false },
        security: SecurityCfg { mode },
        facets: FacetsCfg { enabled: true, dir: Some(dir.to_string_lossy().to_string()) },
        ..Config::default()
    };

    let (router, state) = build_router(cfg);

    // Truthful readiness: mark other gates true; facets gate is handled by build_router.
    state.probes.set_cfg_loaded(true);
    state.probes.set_listeners_bound(true);
    state.probes.set_metrics_bound(true);

    let handle = tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, router).await {
            eprintln!("[micronode-facet-test] server error: {err}");
        }
    });

    (addr, handle)
}

#[tokio::test]
async fn loads_static_and_echo_facets_and_enforces_auth() {
    // Temp dir with manifests + static file.
    let tmp = tempfile::tempdir().unwrap();
    let d = tmp.path();

    // Static file
    let file_path = d.join("hello.txt");
    fs::write(&file_path, b"hi\n").unwrap();

    // Static facet manifest
    let static_toml = format!(
        r#"
[facet]
id = "docs"
kind = "static"

[[route]]
method = "GET"
path = "/hello"
file = "{}"
"#,
        file_path.to_string_lossy()
    );
    fs::write(d.join("docs.toml"), static_toml).unwrap();

    // Echo facet manifest
    let echo_toml = r#"
[facet]
id = "echoer"
kind = "echo"

[[route]]
method = "GET"
path = "/who"
"#;
    fs::write(d.join("echo.toml"), echo_toml).unwrap();

    // Spawn in deny_all (requires auth, expect 401 for facets).
    let (addr, _h) = spawn_with_facets(d.to_path_buf(), SecurityMode::DenyAll).await;
    let base = format!("http://{}", addr);

    let client = reqwest::Client::builder().timeout(Duration::from_secs(2)).build().unwrap();

    // Meta should list both facets.
    let meta = client.get(format!("{base}/facets/meta")).send().await.unwrap();
    assert_eq!(meta.status(), StatusCode::OK);
    let j: serde_json::Value = meta.json().await.unwrap();
    let list = j.get("loaded").and_then(|v| v.as_array()).unwrap();
    assert_eq!(list.len(), 2);

    // GET /facets/docs/hello should be gated (401)
    let f = client.get(format!("{base}/facets/docs/hello")).send().await.unwrap();
    assert_eq!(f.status(), StatusCode::UNAUTHORIZED);

    // Now spawn dev_allow and ensure it returns content.
    let (addr2, _h2) = spawn_with_facets(d.to_path_buf(), SecurityMode::DevAllow).await;
    let base2 = format!("http://{}", addr2);
    let client2 = reqwest::Client::new();

    let f2 = client2.get(format!("{base2}/facets/docs/hello")).send().await.unwrap();
    assert_eq!(f2.status(), StatusCode::OK);
    let body = f2.text().await.unwrap();
    assert!(body.contains("hi"));
}

#[tokio::test]
async fn bad_manifest_blocks_readiness() {
    let tmp = tempfile::tempdir().unwrap();
    let d = tmp.path();

    // Bad: missing leading slash in path
    let bad_toml = r#"
[facet]
id = "bad"
kind = "echo"

[[route]]
method = "GET"
path = "nope"
"#;
    fs::write(d.join("bad.toml"), bad_toml).unwrap();

    let (addr, _h) = spawn_with_facets(d.to_path_buf(), SecurityMode::DevAllow).await;
    let base = format!("http://{}", addr);
    let client = reqwest::Client::new();
    let r = client.get(format!("{base}/readyz")).send().await.unwrap();
    // We set deps_ok = false on loader error, so readyz should NOT be ready (usually 200 with ready=false or non-200 depending on your impl).
    assert!(r.status().is_success() || r.status().is_server_error()); // tolerate either shape
    let t = r.text().await.unwrap();
    assert!(t.to_ascii_lowercase().contains("ready") || t.to_ascii_lowercase().contains("false"));
}

```

### crates/micronode/tests/facets_proxy.rs
<a id="crates-micronode-tests-facetsproxy-rs"></a>

```rust
// crates/micronode/tests/facets_proxy.rs
//! RO:WHAT — Integration tests for Micronode facet hosting.
//! RO:WHY  — Prove that we can mount a facet (demo) and reach it via HTTP
//!           using the same in-process router used by benches.

use axum::body::Body;
use http::{Request, StatusCode};
use micronode::{build_router, config::schema::Config};
use tower::ServiceExt as _; // for Router::oneshot

#[tokio::test]
async fn demo_facet_ping_works() {
    let cfg = Config::default();
    let (router, _state) = build_router(cfg);

    let resp = router
        .oneshot(
            Request::builder().method("GET").uri("/facets/demo/ping").body(Body::empty()).unwrap(),
        )
        .await
        .expect("router error");

    assert_eq!(resp.status(), StatusCode::OK);
}

#[tokio::test]
async fn facets_meta_endpoint_is_wired() {
    let cfg = Config::default();
    let (router, _state) = build_router(cfg);

    let resp = router
        .oneshot(Request::builder().method("GET").uri("/facets/_meta").body(Body::empty()).unwrap())
        .await
        .expect("router error");

    assert_eq!(resp.status(), StatusCode::OK);
}

```

### crates/micronode/tests/guard_behavior.rs
<a id="crates-micronode-tests-guardbehavior-rs"></a>

```rust
//! RO:WHAT — Integration tests for Micronode guard behavior (decode + body cap).
//! RO:WHY  — Assert that `DecodeGuard` and `BodyCapLayer` behave as specified
//!           on real HTTP routes (no mock services).
//!
//! RO:INVARIANTS —
//!   - Any `Content-Encoding` on guarded routes yields 415.
//!   - Payloads over `HTTP_BODY_CAP_BYTES` yield 413.
//!
//! These tests exercise `/dev/echo`, which is wired with:
//!   DecodeGuard -> BodyCapLayer -> ConcurrencyLayer -> handler.

use std::{net::SocketAddr, time::Duration};

use micronode::app::build_router;
use micronode::config::schema::{Config, Server};
use micronode::limits::HTTP_BODY_CAP_BYTES;
use reqwest::StatusCode;
use tokio::task::JoinHandle;

/// Spawn an in-process Micronode instance on an ephemeral port, with
/// dev routes enabled and readiness probes flipped to "healthy".
async fn spawn_micronode() -> (SocketAddr, JoinHandle<()>) {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.expect("bind test listener");
    let addr = listener.local_addr().expect("get local address for test listener");

    let cfg = Config { server: Server { bind: addr, dev_routes: true }, ..Config::default() };

    let (router, state) = build_router(cfg);

    state.probes.set_cfg_loaded(true);
    state.probes.set_listeners_bound(true);
    state.probes.set_metrics_bound(true);
    state.probes.set_deps_ok(true);

    let handle = tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, router).await {
            eprintln!("[micronode-guard-test] server error: {err}");
        }
    });

    (addr, handle)
}

#[tokio::test]
async fn decode_guard_rejects_any_content_encoding() {
    let (addr, _handle) = spawn_micronode().await;
    let base = format!("http://{}", addr);
    let url = format!("{base}/dev/echo");

    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(2))
        .build()
        .expect("build reqwest client");

    let resp = client
        .post(&url)
        .header("content-type", "application/json")
        .header("content-encoding", "gzip")
        .body(r#"{"message":"hi"}"#)
        .send()
        .await
        .expect("POST /dev/echo with content-encoding");

    assert_eq!(
        resp.status(),
        StatusCode::UNSUPPORTED_MEDIA_TYPE,
        "expected 415 from DecodeGuard on any Content-Encoding, got {}",
        resp.status()
    );
}

#[tokio::test]
async fn body_cap_enforces_max_payload_size() {
    let (addr, _handle) = spawn_micronode().await;
    let base = format!("http://{}", addr);
    let url = format!("{base}/dev/echo");

    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(5))
        .build()
        .expect("build reqwest client");

    // Construct a payload that is one byte over the configured cap.
    let over_cap_len = (HTTP_BODY_CAP_BYTES as usize).saturating_add(1);
    let payload = vec![b'a'; over_cap_len];

    let resp = client
        .post(&url)
        .header("content-type", "application/json")
        .body(payload)
        .send()
        .await
        .expect("POST /dev/echo with over-cap payload");

    assert_eq!(
        resp.status(),
        StatusCode::PAYLOAD_TOO_LARGE,
        "expected 413 from BodyCapLayer for payload > HTTP_BODY_CAP_BYTES, got {}",
        resp.status()
    );
}

```

### crates/micronode/tests/kv_roundtrip.rs
<a id="crates-micronode-tests-kvroundtrip-rs"></a>

```rust
//! RO:WHAT — KV roundtrip test (PUT/GET/DELETE) under dev_allow.
//! RO:WHY  — Default security mode is deny_all; for this behavioral test we
//!           exercise the storage surface in DX mode.
//! RO:INVARIANTS — Ensures status codes and body echo match expectations.

use std::{net::SocketAddr, time::Duration};

use micronode::app::build_router;
use micronode::config::schema::{Config, SecurityCfg, SecurityMode, Server};
use reqwest::StatusCode;
use tokio::task::JoinHandle;

async fn spawn_dev_allow() -> (SocketAddr, JoinHandle<()>) {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.expect("bind test listener");
    let addr = listener.local_addr().expect("local address");

    let cfg = Config {
        server: Server { bind: addr, dev_routes: false },
        security: SecurityCfg { mode: SecurityMode::DevAllow },
        ..Config::default()
    };

    let (router, state) = build_router(cfg);

    // Make readiness truthful for the in-memory engine.
    state.probes.set_cfg_loaded(true);
    state.probes.set_listeners_bound(true);
    state.probes.set_metrics_bound(true);
    state.probes.set_deps_ok(true);

    let handle = tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, router).await {
            eprintln!("[micronode-kv-roundtrip] server error: {err}");
        }
    });

    (addr, handle)
}

#[tokio::test]
async fn kv_put_get_delete_roundtrip() {
    let (addr, _handle) = spawn_dev_allow().await;
    let base = format!("http://{}", addr);
    let key_url = format!("{base}/v1/kv/demo/k");

    let client =
        reqwest::Client::builder().timeout(Duration::from_secs(2)).build().expect("client");

    // PUT
    let put = client
        .put(&key_url)
        .header("content-type", "application/octet-stream")
        .body("hello")
        .send()
        .await
        .expect("PUT /v1/kv/demo/k");
    assert_eq!(put.status(), StatusCode::CREATED, "expected 201 Created, got {}", put.status());

    // GET
    let get = client.get(&key_url).send().await.expect("GET /v1/kv/demo/k");
    assert_eq!(get.status(), StatusCode::OK, "expected 200 OK, got {}", get.status());
    let body = get.bytes().await.expect("read body");
    assert_eq!(&body[..], b"hello");

    // DELETE
    let del = client.delete(&key_url).send().await.expect("DELETE /v1/kv/demo/k");
    assert_eq!(
        del.status(),
        StatusCode::NO_CONTENT,
        "expected 204 No Content, got {}",
        del.status()
    );
}

```

### crates/micronode/tests/oap_limits.rs
<a id="crates-micronode-tests-oaplimits-rs"></a>

```rust


```

### crates/micronode/tests/pq_fallback.rs
<a id="crates-micronode-tests-pqfallback-rs"></a>

```rust


```

### crates/micronode/tests/pq_modes.rs
<a id="crates-micronode-tests-pqmodes-rs"></a>

```rust


```

### crates/micronode/tests_chaos/degrade_shed.rs
<a id="crates-micronode-testschaos-degradeshed-rs"></a>

```rust

```

### crates/micronode/tests_loom/shutdown_interleavings.rs
<a id="crates-micronode-testsloom-shutdowninterleavings-rs"></a>

```rust

```

### crates/micronode/tests_property/oap_fuzz.rs
<a id="crates-micronode-testsproperty-oapfuzz-rs"></a>

```rust

```

### crates/micronode/tests_property/pq_handshake_props.rs
<a id="crates-micronode-testsproperty-pqhandshakeprops-rs"></a>

```rust

```

