<!-- Generated by scripts/collect_codebundles.sh on 2025-10-30T22:11:24Z -->
# ALLCODEBUNDLES — Beta Crates

_This file aggregates CODEBUNDLE.MD from beta-complete crates for review/sharing._

**Included crates (order):**

- ron-kernel
- ron-bus
- ron-proto
- ron-metrics
- oap
- ron-transport
- ryker
- svc-overlay
- svc-dht
- ron-naming
- ron-storage
- svc-index
- ron-policy


---



# ron-kernel

_Source: crates/ron-kernel/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:47:24Z -->
# Code Bundle — `ron-kernel`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-kernel/.cargo/config.toml](#crates-ron-kernel--cargo-config-toml)
- [crates/ron-kernel/.github/workflows/kernel-ci.yml](#crates-ron-kernel--github-workflows-kernel-ci-yml)
- [crates/ron-kernel/.github/workflows/rust.yml](#crates-ron-kernel--github-workflows-rust-yml)
- [crates/ron-kernel/Cargo.toml](#crates-ron-kernel-Cargo-toml)
- [crates/ron-kernel/benches/a2_publish_many.rs](#crates-ron-kernel-benches-a2publishmany-rs)
- [crates/ron-kernel/benches/a3_autotune_cap.rs](#crates-ron-kernel-benches-a3autotunecap-rs)
- [crates/ron-kernel/benches/bus_batch.rs](#crates-ron-kernel-benches-busbatch-rs)
- [crates/ron-kernel/benches/bus_lag_vs_publish.rs](#crates-ron-kernel-benches-buslagvspublish-rs)
- [crates/ron-kernel/benches/bus_multi_subscribers.rs](#crates-ron-kernel-benches-busmultisubscribers-rs)
- [crates/ron-kernel/benches/bus_overflow_drop.rs](#crates-ron-kernel-benches-busoverflowdrop-rs)
- [crates/ron-kernel/benches/bus_publish.rs](#crates-ron-kernel-benches-buspublish-rs)
- [crates/ron-kernel/benches/bus_publish_matrix.rs](#crates-ron-kernel-benches-buspublishmatrix-rs)
- [crates/ron-kernel/benches/bus_soa.rs](#crates-ron-kernel-benches-bussoa-rs)
- [crates/ron-kernel/benches/metrics_encode.rs](#crates-ron-kernel-benches-metricsencode-rs)
- [crates/ron-kernel/benches/publish_edge_matrix.rs](#crates-ron-kernel-benches-publishedgematrix-rs)
- [crates/ron-kernel/benches/readiness_handler.rs](#crates-ron-kernel-benches-readinesshandler-rs)
- [crates/ron-kernel/deny.toml](#crates-ron-kernel-deny-toml)
- [crates/ron-kernel/examples/kernel_demo.rs](#crates-ron-kernel-examples-kerneldemo-rs)
- [crates/ron-kernel/examples/minimal_supervision.rs](#crates-ron-kernel-examples-minimalsupervision-rs)
- [crates/ron-kernel/examples/publish_smoke.rs](#crates-ron-kernel-examples-publishsmoke-rs)
- [crates/ron-kernel/fuzz/cfg_parser.rs](#crates-ron-kernel-fuzz-cfgparser-rs)
- [crates/ron-kernel/rust-toolchain.toml](#crates-ron-kernel-rust-toolchain-toml)
- [crates/ron-kernel/scripts/ci_public_api.sh](#crates-ron-kernel-scripts-cipublicapi-sh)
- [crates/ron-kernel/scripts/enforce_ro_headers.sh](#crates-ron-kernel-scripts-enforceroheaders-sh)
- [crates/ron-kernel/scripts/perf_gate.sh](#crates-ron-kernel-scripts-perfgate-sh)
- [crates/ron-kernel/scripts/render_mermaid.sh](#crates-ron-kernel-scripts-rendermermaid-sh)
- [crates/ron-kernel/scripts/ron_kernel_smoke.sh](#crates-ron-kernel-scripts-ronkernelsmoke-sh)
- [crates/ron-kernel/scripts/run_kernel_benches.sh](#crates-ron-kernel-scripts-runkernelbenches-sh)
- [crates/ron-kernel/scripts/run_mog_b1.sh](#crates-ron-kernel-scripts-runmogb1-sh)
- [crates/ron-kernel/src/amnesia.rs](#crates-ron-kernel-src-amnesia-rs)
- [crates/ron-kernel/src/bus/backoff.rs](#crates-ron-kernel-src-bus-backoff-rs)
- [crates/ron-kernel/src/bus/bounded.rs](#crates-ron-kernel-src-bus-bounded-rs)
- [crates/ron-kernel/src/bus/capacity.rs](#crates-ron-kernel-src-bus-capacity-rs)
- [crates/ron-kernel/src/bus/mod.rs](#crates-ron-kernel-src-bus-mod-rs)
- [crates/ron-kernel/src/bus/mog_edge_notify.rs](#crates-ron-kernel-src-bus-mogedgenotify-rs)
- [crates/ron-kernel/src/bus/soa.rs](#crates-ron-kernel-src-bus-soa-rs)
- [crates/ron-kernel/src/bus/test.rs](#crates-ron-kernel-src-bus-test-rs)
- [crates/ron-kernel/src/bus/topic.rs](#crates-ron-kernel-src-bus-topic-rs)
- [crates/ron-kernel/src/config/cell.rs](#crates-ron-kernel-src-config-cell-rs)
- [crates/ron-kernel/src/config/mod.rs](#crates-ron-kernel-src-config-mod-rs)
- [crates/ron-kernel/src/config/validation.rs](#crates-ron-kernel-src-config-validation-rs)
- [crates/ron-kernel/src/config/watcher.rs](#crates-ron-kernel-src-config-watcher-rs)
- [crates/ron-kernel/src/events.rs](#crates-ron-kernel-src-events-rs)
- [crates/ron-kernel/src/health/mod.rs](#crates-ron-kernel-src-health-mod-rs)
- [crates/ron-kernel/src/internal/constants.rs](#crates-ron-kernel-src-internal-constants-rs)
- [crates/ron-kernel/src/internal/mod.rs](#crates-ron-kernel-src-internal-mod-rs)
- [crates/ron-kernel/src/internal/types.rs](#crates-ron-kernel-src-internal-types-rs)
- [crates/ron-kernel/src/lib.rs](#crates-ron-kernel-src-lib-rs)
- [crates/ron-kernel/src/metrics/buffer.rs](#crates-ron-kernel-src-metrics-buffer-rs)
- [crates/ron-kernel/src/metrics/exporter.rs](#crates-ron-kernel-src-metrics-exporter-rs)
- [crates/ron-kernel/src/metrics/health.rs](#crates-ron-kernel-src-metrics-health-rs)
- [crates/ron-kernel/src/metrics/mod.rs](#crates-ron-kernel-src-metrics-mod-rs)
- [crates/ron-kernel/src/metrics/readiness.rs](#crates-ron-kernel-src-metrics-readiness-rs)
- [crates/ron-kernel/src/mog_autotune.rs](#crates-ron-kernel-src-mogautotune-rs)
- [crates/ron-kernel/src/shutdown.rs](#crates-ron-kernel-src-shutdown-rs)
- [crates/ron-kernel/src/supervisor/backoff.rs](#crates-ron-kernel-src-supervisor-backoff-rs)
- [crates/ron-kernel/src/supervisor/child.rs](#crates-ron-kernel-src-supervisor-child-rs)
- [crates/ron-kernel/src/supervisor/lifecycle.rs](#crates-ron-kernel-src-supervisor-lifecycle-rs)
- [crates/ron-kernel/src/supervisor/mod.rs](#crates-ron-kernel-src-supervisor-mod-rs)
- [crates/ron-kernel/testing/performance/publish_matrix.toml](#crates-ron-kernel-testing-performance-publishmatrix-toml)
- [crates/ron-kernel/tests/amnesia_label.rs](#crates-ron-kernel-tests-amnesialabel-rs)
- [crates/ron-kernel/tests/autotune_capacity.rs](#crates-ron-kernel-tests-autotunecapacity-rs)
- [crates/ron-kernel/tests/autotune_sanity.rs](#crates-ron-kernel-tests-autotunesanity-rs)
- [crates/ron-kernel/tests/bus_basics.rs](#crates-ron-kernel-tests-busbasics-rs)
- [crates/ron-kernel/tests/bus_bounded.rs](#crates-ron-kernel-tests-busbounded-rs)
- [crates/ron-kernel/tests/bus_close_semantics.rs](#crates-ron-kernel-tests-busclosesemantics-rs)
- [crates/ron-kernel/tests/bus_contract.rs](#crates-ron-kernel-tests-buscontract-rs)
- [crates/ron-kernel/tests/edge_notify_loom.rs](#crates-ron-kernel-tests-edgenotifyloom-rs)
- [crates/ron-kernel/tests/health_ready.rs](#crates-ron-kernel-tests-healthready-rs)
- [crates/ron-kernel/tests/loom_bus.rs](#crates-ron-kernel-tests-loombus-rs)
- [crates/ron-kernel/tests/metrics_amnesia.rs](#crates-ron-kernel-tests-metricsamnesia-rs)
- [crates/ron-kernel/tests/metrics_smoke.rs](#crates-ron-kernel-tests-metricssmoke-rs)
- [crates/ron-kernel/tests/property_config.rs](#crates-ron-kernel-tests-propertyconfig-rs)
- [crates/ron-kernel/tests/public_api.rs](#crates-ron-kernel-tests-publicapi-rs)
- [crates/ron-kernel/tests/readiness_degrades.rs](#crates-ron-kernel-tests-readinessdegrades-rs)
- [crates/ron-kernel/tests/soa_smoke.rs](#crates-ron-kernel-tests-soasmoke-rs)
- [crates/ron-kernel/tests/supervisor_backoff.rs](#crates-ron-kernel-tests-supervisorbackoff-rs)
- [crates/ron-kernel/tests/supervisor_backoff_integ.rs](#crates-ron-kernel-tests-supervisorbackoffinteg-rs)
- [crates/ron-kernel/tests/tls_type_invariance.rs](#crates-ron-kernel-tests-tlstypeinvariance-rs)
- [crates/ron-kernel/tests/watcher_integ.rs](#crates-ron-kernel-tests-watcherinteg-rs)

### crates/ron-kernel/.cargo/config.toml
<a id="crates-ron-kernel--cargo-config-toml"></a>

```toml
[build]
rustflags = []

[term]
verbose = false

```

### crates/ron-kernel/.github/workflows/kernel-ci.yml
<a id="crates-ron-kernel--github-workflows-kernel-ci-yml"></a>

```yaml
name: kernel-ci
on: [push, pull_request]
jobs:
  public-api:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo install cargo-public-api || true
      - run: cargo public-api -p ron-kernel2 || true
  mermaid:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          for f in $(git ls-files 'crates/ron-kernel2/docs/*.mmd' 2>/dev/null); do
            mmdc -i "$f" -o "${f%.mmd}.svg"
          done

```

### crates/ron-kernel/.github/workflows/rust.yml
<a id="crates-ron-kernel--github-workflows-rust-yml"></a>

```yaml
name: rust
on: [push, pull_request]
jobs:
  test:
    strategy:
      matrix:
        amnesia: [off, on]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Build
        run: cargo build -p ron-kernel2
      - name: Test
        run: AMNESIA=${{ matrix.amnesia }} cargo test -p ron-kernel2 --all-features
  loom:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run loom tests (ignored)
        run: RUSTFLAGS="--cfg loom" cargo test -p ron-kernel2 -- --ignored

```

### crates/ron-kernel/Cargo.toml
<a id="crates-ron-kernel-Cargo-toml"></a>

```toml
[package]
name = "ron-kernel"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false

[lib]
name = "ron_kernel"
path = "src/lib.rs"

[features]
# Optional features can be added here (e.g., "kameo")
default = []
# Enable Loom model-checking tests with: cargo test -p ron-kernel --features loom
loom = ["dep:loom"]
#MOG - Phase A:
bus_edge_notify = []   # edge-triggered, coalesced wakeups per subscriber
bus_batch = []         # publish_many(&[T]) single-fence/notify
bus_autotune_cap = []  # cap defaults chosen by N subscribers, warn on oversized caps
metrics_buf = []       # per-thread metrics buffering with periodic flush
#MOG - Phase B: 
bus_soa = []           # SoA ring + per-slot ready bitmask (Arc<T> payload to keep 100% safe)
bus_interest = []      # variant/topic bitmask filtering per subscriber
bus_coalesce = []      # coalesce wakeups by K/Δt thresholds (optional latency trade)
local_dispatch = []    # example helpers/patterns; not a kernel core change


[dependencies]
# Core async
tokio = { version = "1", features = ["macros", "rt-multi-thread", "signal", "time", "io-util", "sync", "net", "fs"] }

# Loom must be optional because the 'loom' feature references it via dep:loom
loom = { version = "0.7", optional = true, default-features = false }

# HTTP stack (workspace standard pins implied)
axum = { version = "0.7", features = ["tokio", "http1", "http2", "json"], default-features = false }
tower = "0.5"
tower-http = { version = "0.6.6", features = ["trace"] }

# Metrics/obs
prometheus = "0.14"
once_cell = "1.19"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }

# Concurrency/locking
parking_lot = "0.12"

# Config & serde
serde = { version = "1.0", features = ["derive"] }
serde_json = "1"
toml = "0.8"

# Misc
anyhow = "1.0"
thiserror = "1.0"

# TLS is intentionally not enforced here (transport services handle it)
tokio-rustls = "0.26.2"
notify = "6"
rand = "0.9"
futures = "0.3"
humantime-serde = "1"

cfg-if = "1"


[dev-dependencies]
reqwest = { version = "0.12", features = ["rustls-tls-native-roots", "json"] }
# Enable "async" so benches can use b.to_async(&rt)
criterion = { version = "0.5", features = ["html_reports", "async"] }
tempfile = "3"
parking_lot = "0.12"

[[bench]]
name = "bus_publish"
harness = false

[[bench]]
name = "bus_lag_vs_publish"
harness = false

[[bench]]
name = "metrics_encode"
harness = false

[[bench]]
name = "bus_overflow_drop"
harness = false

[[bench]]
name = "readiness_handler"
harness = false

[[bench]]
name = "bus_multi_subscribers"
harness = false

[[bench]]
name = "bus_publish_matrix"
harness = false


[[bench]]
name = "bus_batch"
harness = false

[[bench]]
name = "a3_autotune_cap"
harness = false
required-features = ["bus_autotune_cap"]

[[bench]]
name = "a2_publish_many"
harness = false

[[bench]]
name = "bus_soa"
harness = false

```

### crates/ron-kernel/benches/a2_publish_many.rs
<a id="crates-ron-kernel-benches-a2publishmany-rs"></a>

```rust
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use ron_kernel::bus::bounded::Bus;
use std::time::Duration;
use tokio::sync::broadcast;

// Drain helper (same shape as other benches).
fn drain_now<T: Clone + Send + 'static>(rx: &mut broadcast::Receiver<T>) -> usize {
    use tokio::sync::broadcast::error::TryRecvError::*;
    let mut n = 0usize;
    loop {
        match rx.try_recv() {
            Ok(_) => n += 1,
            Err(Empty) => break,
            Err(Lagged(_)) => continue,
            Err(Closed) => break,
        }
    }
    n
}

fn bench_a2_batch_vs_single(c: &mut Criterion) {
    // single-threaded RT for stability
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_time()
        .build()
        .unwrap();

    let mut group = c.benchmark_group("a2_publish_many");
    let subs_set = [1usize, 4]; // focus where notify matters
    let cap = 64usize; // tuned sweet spot from MOG
    let bursts = [1usize, 1_000, 5_000, 10_000];

    for &subs in &subs_set {
        for &batch_len in &bursts {
            group.throughput(Throughput::Elements(batch_len as u64));

            // Baseline: single publishes in a loop (no bus_batch feature needed)
            group.bench_with_input(
                BenchmarkId::new(
                    "single_loop",
                    format!("subs={subs},cap={cap},n={batch_len}"),
                ),
                &(),
                |b, _| {
                    rt.block_on(async {
                        let bus: Bus<u64> = Bus::with_capacity(cap);
                        let mut rxs: Vec<_> = (0..subs).map(|_| bus.subscribe()).collect();

                        b.iter(|| {
                            for i in 0..batch_len as u64 {
                                let _ = bus.publish(i);
                            }
                            for rx in &mut rxs {
                                let _ = drain_now(rx);
                            }
                        });
                    });
                },
            );

            // A2: publish_many (feature-gated); when feature off, this target won’t exist
            #[cfg(feature = "bus_batch")]
            group.bench_with_input(
                BenchmarkId::new(
                    "publish_many",
                    format!("subs={subs},cap={cap},n={batch_len}"),
                ),
                &(),
                |b, _| {
                    rt.block_on(async {
                        let bus: Bus<u64> = Bus::with_capacity(cap);
                        let mut rxs: Vec<_> = (0..subs).map(|_| bus.subscribe()).collect();

                        // preallocate batch to avoid alloc noise in iter
                        let batch: Vec<u64> = (0..batch_len as u64).collect();

                        b.iter(|| {
                            let _ = bus.publish_many(&batch);
                            for rx in &mut rxs {
                                let _ = drain_now(rx);
                            }
                        });
                    });
                },
            );
        }
    }
    group.finish();
}

criterion_group! {
    name = benches;
    config = {
        Criterion::default()
            .measurement_time(Duration::from_secs(8))
            .warm_up_time(Duration::from_secs(3))
            .sample_size(20)
    };
    targets = bench_a2_batch_vs_single
}
criterion_main!(benches);

```

### crates/ron-kernel/benches/a3_autotune_cap.rs
<a id="crates-ron-kernel-benches-a3autotunecap-rs"></a>

```rust
#![cfg(feature = "bus_autotune_cap")]
use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};
use ron_kernel::autotune_capacity;

fn bench_autotune_mapping(c: &mut Criterion) {
    let mut g = c.benchmark_group("a3_autotune_mapping");

    for &n in &[1usize, 4, 16, 64, 128] {
        g.bench_with_input(BenchmarkId::from_parameter(n), &n, |b, &n| {
            b.iter(|| {
                let mut s = 0usize;
                for _ in 0..1024 {
                    s ^= autotune_capacity(n, None);
                }
                black_box(s)
            })
        });
    }

    g.bench_function("override_192", |b| {
        b.iter(|| black_box(autotune_capacity(16, Some(192))))
    });

    g.finish();
}

criterion_group!(benches, bench_autotune_mapping);
criterion_main!(benches);

```

### crates/ron-kernel/benches/bus_batch.rs
<a id="crates-ron-kernel-benches-busbatch-rs"></a>

```rust
//! RO:WHAT
//! Bench the bounded Bus<T> publish paths with and without batching.
//!
//! RO:WHY
//! A2 (bus_batch) should reduce notify/wake amplification and fence costs by
//! batching multiple publishes into one sweep with <=1 notify. This bench *must*
//! be env-configurable so we can sweep fanout/cap/burst from the shell.
//!
//! RO:INTERACTS
//! - Uses `ron_kernel::bus::bounded::Bus` directly.
//! - Feature flag `bus_batch` enables the batch path.
//! - Criterion for timing.
//!
//! RO:INVARIANTS
//! - Public API untouched (bench only).
//! - No panics under capacity pressure; drops are handled inside Bus.
//! - Single-threaded Tokio runtime for stability.

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use std::env;
use std::time::Duration;

// We bench the kernel Bus<T> directly.
use ron_kernel::bus::bounded::Bus;

// A small POD event for hot-path measurement.
#[derive(Clone)]
#[allow(dead_code)]
struct Ev(u64);

fn getenv<T: std::str::FromStr>(key: &str, default: T) -> T {
    env::var(key)
        .ok()
        .and_then(|s| s.parse::<T>().ok())
        .unwrap_or(default)
}

// Drain helper: non-blocking, like our EdgeReceiver::try_recv_now_or_never().
fn drain_now<T: Clone + Send + 'static>(rx: &mut tokio::sync::broadcast::Receiver<T>) -> usize {
    use tokio::sync::broadcast::error::TryRecvError::*;
    let mut n = 0usize;
    loop {
        match rx.try_recv() {
            Ok(_) => {
                n += 1;
            }
            Err(Empty) => break,
            Err(Lagged(_)) => continue,
            Err(Closed) => break,
        }
    }
    n
}

fn bench_bus_batch(c: &mut Criterion) {
    // Env-driven configuration (defaults match previous behavior).
    let subs = getenv::<usize>("RON_BENCH_FANOUT", 4);
    let cap = getenv::<usize>("RON_BENCH_CAP", 64);
    let burst = getenv::<usize>("RON_BENCH_BURST", 128);

    eprintln!(
        "[bench cfg] subs={}, cap={}, burst={}  (set RON_BENCH_FANOUT/CAP/BURST to override)",
        subs, cap, burst
    );

    // Single-threaded runtime for stable numbers.
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_time()
        .build()
        .unwrap();

    let mut g = c.benchmark_group("bus_batch");

    // --- Single publish baseline ---------------------------------------------------------
    g.throughput(Throughput::Elements(10_000));
    g.measurement_time(Duration::from_secs(10));
    g.warm_up_time(Duration::from_secs(3));

    g.bench_with_input(
        BenchmarkId::new(
            "publish_single",
            format!("subs={subs},cap={cap},burst={burst}"),
        ),
        &(),
        |b, _| {
            rt.block_on(async {
                let bus: Bus<Ev> = Bus::with_capacity(cap);
                // spawn subscribers
                let mut rxs: Vec<_> = (0..subs).map(|_| bus.subscribe()).collect();
                b.iter(|| {
                    for i in 0..10_000u64 {
                        let _ = bus.publish(Ev(i));
                    }
                    // drain
                    for rx in &mut rxs {
                        let _ = drain_now(rx);
                    }
                    black_box(());
                });
            });
        },
    );

    // --- Batch publish (A2) --------------------------------------------------------------
    #[cfg(feature = "bus_batch")]
    {
        g.throughput(Throughput::Elements(10_000));
        g.bench_with_input(
            BenchmarkId::new(
                "publish_many",
                format!("subs={subs},cap={cap},burst={burst}"),
            ),
            &(),
            |b, _| {
                rt.block_on(async {
                    let bus: Bus<Ev> = Bus::with_capacity(cap);
                    let mut rxs: Vec<_> = (0..subs).map(|_| bus.subscribe()).collect();

                    let mut batch = Vec::with_capacity(burst.max(1));
                    b.iter(|| {
                        batch.clear();
                        // total elements = 10_000 per iter (≈ 10_000 / burst batches)
                        for i in 0..10_000u64 {
                            batch.push(Ev(i));
                            if batch.len() == burst {
                                let _ = bus.publish_many(&batch);
                                batch.clear();
                            }
                        }
                        if !batch.is_empty() {
                            let _ = bus.publish_many(&batch);
                            batch.clear();
                        }
                        // drain
                        for rx in &mut rxs {
                            let _ = drain_now(rx);
                        }
                        black_box(());
                    });
                });
            },
        );
    }

    g.finish();
}

criterion_group! {
    name = benches;
    config = Criterion::default()
        .measurement_time(Duration::from_secs(6))
        .warm_up_time(Duration::from_secs(2))
        .sample_size(40);
    targets = bench_bus_batch
}
criterion_main!(benches);

```

### crates/ron-kernel/benches/bus_lag_vs_publish.rs
<a id="crates-ron-kernel-benches-buslagvspublish-rs"></a>

```rust
/*!
RO: benches/bus_lag_vs_publish.rs
WHAT: Compare publish throughput under no-subscriber vs single slow subscriber.
WHY : Validate non-blocking publish w/ slow receiver (bounded cost, drops on recv side).
NOTE: Group config tuned to avoid "unable to complete samples" warnings on many machines.
*/

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, SamplingMode};
use ron_kernel::{Bus, KernelEvent, Metrics};
use std::time::Duration;
use tokio::runtime::Builder;

const INNER_PUBLISHES: usize = 25_000;

fn bench_bus_lag_vs_publish(c: &mut Criterion) {
    let rt = Builder::new_multi_thread().enable_all().build().unwrap();

    let mut group = c.benchmark_group("bus_lag_vs_publish");
    group.sampling_mode(SamplingMode::Flat);
    group.sample_size(60);
    group.warm_up_time(Duration::from_secs(2));
    group.measurement_time(Duration::from_secs(8));

    // no_subscribers (upper-bound publish cost)
    group.bench_with_input(
        BenchmarkId::new("no_subscribers", INNER_PUBLISHES),
        &(),
        |b, _| {
            b.iter(|| {
                rt.block_on(async {
                    let metrics = Metrics::new(false);
                    let bus: Bus<KernelEvent> = metrics.make_bus(1024);
                    for i in 0..black_box(INNER_PUBLISHES) {
                        let _ = bus.publish(KernelEvent::ConfigUpdated { version: i as u64 });
                    }
                });
            });
        },
    );

    // one_slow_subscriber (non-blocking publish should remain bounded)
    group.bench_with_input(
        BenchmarkId::new("one_slow_subscriber", INNER_PUBLISHES),
        &(),
        |b, _| {
            b.iter(|| {
                rt.block_on(async {
                    let metrics = Metrics::new(false);
                    let bus: Bus<KernelEvent> = metrics.make_bus(64);

                    let mut rx = bus.subscribe();
                    let slow = tokio::spawn(async move {
                        loop {
                            match rx.recv().await {
                                Ok(_e) => {
                                    tokio::time::sleep(Duration::from_micros(black_box(20))).await
                                }
                                Err(_) => break,
                            }
                        }
                    });

                    for i in 0..black_box(INNER_PUBLISHES) {
                        let _ = bus.publish(KernelEvent::ConfigUpdated { version: i as u64 });
                    }

                    drop(bus);
                    let _ = slow.await;
                });
            });
        },
    );

    group.finish();
}

criterion_group!(benches, bench_bus_lag_vs_publish);
criterion_main!(benches);

```

### crates/ron-kernel/benches/bus_multi_subscribers.rs
<a id="crates-ron-kernel-benches-busmultisubscribers-rs"></a>

```rust
/*!
RO: benches/bus_multi_subscribers.rs
WHAT: Publish throughput with 0, 1, and 16 draining subscribers.
WHY : Show fan-out cost growth as subscriber count rises.
*/

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, SamplingMode};
use ron_kernel::{Bus, KernelEvent, Metrics};
use std::time::Duration;
use tokio::runtime::Builder;

const INNER_PUBLISHES: usize = 10_000;

fn bench_bus_publish(c: &mut Criterion) {
    let rt = Builder::new_multi_thread().enable_all().build().unwrap();

    let mut group = c.benchmark_group("bus_publish");
    group.sampling_mode(SamplingMode::Flat);
    group.sample_size(60);
    group.warm_up_time(Duration::from_secs(2));
    group.measurement_time(Duration::from_secs(8));

    // 0 subscribers
    group.bench_with_input(
        BenchmarkId::new("0_subscribers", INNER_PUBLISHES),
        &(),
        |b, _| {
            b.iter(|| {
                rt.block_on(async {
                    let metrics = Metrics::new(false);
                    let bus: Bus<KernelEvent> = metrics.make_bus(1024);
                    for i in 0..black_box(INNER_PUBLISHES) {
                        let _ = bus.publish(KernelEvent::ConfigUpdated { version: i as u64 });
                    }
                });
            });
        },
    );

    // 1 subscriber (draining)
    group.bench_with_input(
        BenchmarkId::new("1_subscriber", INNER_PUBLISHES),
        &(),
        |b, _| {
            b.iter(|| {
                rt.block_on(async {
                    let metrics = Metrics::new(false);
                    let bus: Bus<KernelEvent> = metrics.make_bus(1024);

                    let mut rx = bus.subscribe();
                    let drain = tokio::spawn(async move { while let Ok(_ev) = rx.recv().await {} });

                    for i in 0..black_box(INNER_PUBLISHES) {
                        let _ = bus.publish(KernelEvent::ConfigUpdated { version: i as u64 });
                    }

                    drop(bus);
                    let _ = drain.await;
                });
            });
        },
    );

    // 16 subscribers (draining)
    group.bench_with_input(
        BenchmarkId::new("16_subscribers", INNER_PUBLISHES),
        &(),
        |b, _| {
            b.iter(|| {
                rt.block_on(async {
                    let metrics = Metrics::new(false);
                    let bus: Bus<KernelEvent> = metrics.make_bus(2048);

                    let mut joins = Vec::new();
                    for _ in 0..16 {
                        let mut rx = bus.subscribe();
                        joins.push(tokio::spawn(async move {
                            while let Ok(_ev) = rx.recv().await {}
                        }));
                    }

                    for i in 0..black_box(INNER_PUBLISHES) {
                        let _ = bus.publish(KernelEvent::ConfigUpdated { version: i as u64 });
                    }

                    drop(bus);
                    for j in joins {
                        let _ = j.await;
                    }
                });
            });
        },
    );

    group.finish();
}

criterion_group!(benches, bench_bus_publish);
criterion_main!(benches);

```

### crates/ron-kernel/benches/bus_overflow_drop.rs
<a id="crates-ron-kernel-benches-busoverflowdrop-rs"></a>

```rust
/*!
RO: benches/bus_overflow_drop.rs
WHAT: Stress bounded bus with a slow subscriber; ensure publish cost is bounded.
WHY : Validate overflow path keeps publisher fast (drops accounted on recv side).
*/

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, SamplingMode};
use ron_kernel::{Bus, KernelEvent, Metrics};
use std::time::Duration;
use tokio::runtime::Builder;

const INNER_PUBLISHES: usize = 50_000;

fn bench_overflow(c: &mut Criterion) {
    let rt = Builder::new_multi_thread().enable_all().build().unwrap();

    let mut group = c.benchmark_group("bus_overflow");
    group.sampling_mode(SamplingMode::Flat);
    group.sample_size(60);
    group.warm_up_time(Duration::from_secs(2));
    group.measurement_time(Duration::from_secs(8));

    group.bench_with_input(
        BenchmarkId::new("slow_single_subscriber", INNER_PUBLISHES),
        &(),
        |b, _| {
            b.iter(|| {
                rt.block_on(async {
                    let metrics = Metrics::new(false);
                    // Small capacity to induce overflow quickly
                    let bus: Bus<KernelEvent> = metrics.make_bus(32);

                    let mut rx = bus.subscribe();
                    let slow = tokio::spawn(async move {
                        loop {
                            match rx.recv().await {
                                Ok(_e) => {
                                    tokio::time::sleep(Duration::from_micros(black_box(50))).await
                                }
                                Err(_) => break,
                            }
                        }
                    });

                    for i in 0..black_box(INNER_PUBLISHES) {
                        let _ = bus.publish(KernelEvent::ConfigUpdated { version: i as u64 });
                    }

                    drop(bus);
                    let _ = slow.await;
                });
            });
        },
    );

    group.finish();
}

criterion_group!(benches, bench_overflow);
criterion_main!(benches);

```

### crates/ron-kernel/benches/bus_publish.rs
<a id="crates-ron-kernel-benches-buspublish-rs"></a>

```rust
//! RO:WHAT — Bus publish perf: steady-state + bursty (classic vs edge, fanout, tunable caps).
//! RO:WHY  — Show real-world wins by:
//!           • steady-state apples-to-apples,
//!           • burst benches with draining + configurable fanout,
//!           • optional publisher epoch (yield between bursts),
//!           • configurable bus cap to avoid queue backpressure (critical).
//! RO:NOTE — Only `publish()`/`publish_many()` are timed; setup/drain outside hot loops.

use std::{env, time::Duration};

#[cfg(feature = "bus_batch")]
use criterion::BatchSize;
use criterion::{
    black_box, criterion_group, criterion_main, BenchmarkId, Criterion, SamplingMode, Throughput,
};

use ron_kernel::{KernelEvent, Metrics};
use tokio::sync::broadcast::error::RecvError;

// ----------------------------- Env toggles -----------------------------

fn getenv_usize(keys: &[&str], default_: usize) -> usize {
    for k in keys {
        if let Ok(v) = env::var(k) {
            if let Ok(n) = v.parse::<usize>() {
                if n > 0 {
                    return n;
                }
            }
        }
    }
    default_
}

fn getenv_bool(keys: &[&str]) -> bool {
    for k in keys {
        if let Ok(v) = env::var(k) {
            let s = v.to_ascii_lowercase();
            if s == "1" || s == "true" || s == "yes" || s == "on" {
                return true;
            }
            if s == "0" || s == "false" || s == "no" || s == "off" {
                return false;
            }
        }
    }
    false
}

// Accept both RON_* and plain keys (your earlier runs used BURST/CAP).
fn burst_size() -> usize {
    getenv_usize(&["RON_BURST", "BURST", "RON_BENCH_BURST"], 256)
}
fn fanout() -> usize {
    getenv_usize(&["RON_FANOUT", "FANOUT", "RON_BENCH_FANOUT"], 4)
}
fn pub_epoch_yield() -> bool {
    getenv_bool(&["RON_BENCH_PUB_YIELD", "PUB_YIELD"])
}
fn burst_cap() -> usize {
    getenv_usize(&["RON_CAP", "CAP", "RON_BENCH_CAP"], 2048)
}
fn tls_flush_threshold() -> usize {
    getenv_usize(&["RON_TLS_FLUSH_THRESHOLD", "TLS_THRESH"], 64)
}

// ------------------------------ Utilities -----------------------------

#[inline(always)]
fn publish_burst<B: Publisher<KernelEvent>>(bus: &B, n: usize) {
    for _ in 0..n {
        let _ = black_box(bus.publish(KernelEvent::Shutdown));
    }
}

trait Publisher<T> {
    fn publish(&self, t: T) -> usize;
}
impl Publisher<KernelEvent> for ron_kernel::bus::bounded::Bus<KernelEvent> {
    #[inline(always)]
    fn publish(&self, t: KernelEvent) -> usize {
        self.publish(t)
    }
}

fn spawn_classic_drains(
    rt: &tokio::runtime::Runtime,
    bus: &ron_kernel::bus::bounded::Bus<KernelEvent>,
    n: usize,
) {
    for _ in 0..n {
        let mut rx = bus.subscribe();
        rt.spawn(async move {
            loop {
                match rx.recv().await {
                    Ok(_msg) => {}
                    Err(RecvError::Lagged(_)) => continue,
                    Err(RecvError::Closed) => break,
                }
            }
        });
    }
}

#[cfg(feature = "bus_edge_notify")]
fn spawn_edge_drains(
    rt: &tokio::runtime::Runtime,
    bus: &ron_kernel::bus::bounded::Bus<KernelEvent>,
    n: usize,
) {
    use ron_kernel::bus::bounded::EdgeReceiver;
    for idx in 0..n {
        let mut sub: EdgeReceiver<KernelEvent> = bus.subscribe_edge();
        rt.spawn(async move {
            sub.run_drain_loop(idx).await;
        });
    }
}

// -------------------------------- Benches -----------------------------

fn bench_publish(c: &mut Criterion) {
    // Log config once per run so threshold sweeps are easy to map in output.
    let tls_thresh = tls_flush_threshold();
    let burst = burst_size();
    let fanout_n = fanout();
    let cap = burst_cap();
    eprintln!(
        "[bench cfg] RON_TLS_FLUSH_THRESHOLD={}, burst={}, fanout={}, cap={}",
        tls_thresh, burst, fanout_n, cap
    );

    // ============ Group 1: steady-state (classic, idle subscriber) ============
    let mut steady = c.benchmark_group(format!("bus_publish_steady (tls_thresh={})", tls_thresh));
    steady.sampling_mode(SamplingMode::Flat);
    steady.sample_size(80);
    steady.warm_up_time(Duration::from_secs(1));
    steady.measurement_time(Duration::from_secs(6));

    // (A) no subscribers — cap=64 (small, stable)
    {
        let metrics = Metrics::new(true);
        let bus = metrics.make_bus::<KernelEvent>(64);
        steady.bench_with_input(
            BenchmarkId::new("no_subscribers", "publish()"),
            &(),
            |b, _| {
                b.iter(|| {
                    let _ = black_box(bus.publish(KernelEvent::Shutdown));
                });
            },
        );
    }

    // (B) one subscriber (idle; no recv) — cap=64
    {
        let metrics = Metrics::new(true);
        let bus = metrics.make_bus::<KernelEvent>(64);
        let _rx = bus.subscribe(); // keep alive; no recv()
        steady.bench_with_input(
            BenchmarkId::new("one_subscriber", "publish()"),
            &(),
            |b, _| {
                b.iter(|| {
                    let _ = black_box(bus.publish(KernelEvent::Shutdown));
                });
            },
        );
    }

    // (C) lagged subscriber (cap=1; no recv)
    {
        let metrics = Metrics::new(true);
        let bus = metrics.make_bus::<KernelEvent>(1);
        let _rx = bus.subscribe(); // keep alive; no recv()
        steady.bench_with_input(
            BenchmarkId::new("lagged_subscriber_cap1", "publish()"),
            &(),
            |b, _| {
                b.iter(|| {
                    let _ = black_box(bus.publish(KernelEvent::Shutdown));
                });
            },
        );
    }
    steady.finish();

    // Runtime for burst groups
    let rt = tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .expect("tokio rt");

    // ============ Group 2: Bursty — CLASSIC recv drain (fanout) ============
    let mut bursty_classic = c.benchmark_group(format!(
        "bus_publish_bursty_classic (tls_thresh={})",
        tls_thresh
    ));
    bursty_classic.sampling_mode(SamplingMode::Flat);
    bursty_classic.sample_size(60);
    bursty_classic.warm_up_time(Duration::from_secs(1));
    bursty_classic.measurement_time(Duration::from_secs(6));

    let label = format!("burst{}_fanout{}_cap{}", burst, fanout_n, cap);

    // (C1) classic fanout; cap=CAP (avoid backpressure)
    {
        let metrics = Metrics::new(true);
        let bus = metrics.make_bus::<KernelEvent>(cap);
        spawn_classic_drains(&rt, &bus, fanout_n);

        bursty_classic.throughput(Throughput::Elements(burst as u64));
        bursty_classic.bench_with_input(BenchmarkId::new("classic_fanout", &label), &(), |b, _| {
            b.iter(|| {
                publish_burst(&bus, burst);
                if pub_epoch_yield() {
                    rt.block_on(async { tokio::task::yield_now().await });
                }
            });
        });

        rt.block_on(async { tokio::task::yield_now().await });
    }

    // (C2) classic lagged fanout; cap=1 (pressure path)
    {
        let metrics = Metrics::new(true);
        let bus = metrics.make_bus::<KernelEvent>(1);
        spawn_classic_drains(&rt, &bus, fanout_n);

        let label_lag = format!("burst{}_fanout{}_cap{}", burst, fanout_n, 1);
        bursty_classic.throughput(Throughput::Elements(burst as u64));
        bursty_classic.bench_with_input(
            BenchmarkId::new("classic_lagged_fanout", &label_lag),
            &(),
            |b, _| {
                b.iter(|| {
                    publish_burst(&bus, burst);
                    if pub_epoch_yield() {
                        rt.block_on(async { tokio::task::yield_now().await });
                    }
                });
            },
        );

        rt.block_on(async { tokio::task::yield_now().await });
    }

    bursty_classic.finish();

    // ============ Group 3: Bursty — EDGE recv drain (fanout, gated) ============
    #[cfg(feature = "bus_edge_notify")]
    {
        let mut bursty_edge = c.benchmark_group(format!(
            "bus_publish_bursty_edge (tls_thresh={})",
            tls_thresh
        ));
        bursty_edge.sampling_mode(SamplingMode::Flat);
        bursty_edge.sample_size(60);
        bursty_edge.warm_up_time(Duration::from_secs(1));
        bursty_edge.measurement_time(Duration::from_secs(6));

        let burst = burst_size();
        let fanout_n = fanout();
        let cap = burst_cap();
        let label = format!("burst{}_fanout{}_cap{}", burst, fanout_n, cap);

        // (E1) edge fanout; cap=CAP
        {
            let metrics = Metrics::new(true);
            let bus = metrics.make_bus::<KernelEvent>(cap);
            spawn_edge_drains(&rt, &bus, fanout_n);

            bursty_edge.throughput(Throughput::Elements(burst as u64));
            bursty_edge.bench_with_input(BenchmarkId::new("edge_fanout", &label), &(), |b, _| {
                b.iter(|| {
                    publish_burst(&bus, burst);
                    if pub_epoch_yield() {
                        rt.block_on(async { tokio::task::yield_now().await });
                    }
                });
            });

            rt.block_on(async { tokio::task::yield_now().await });
        }

        // (E2) edge lagged fanout; cap=1
        {
            let metrics = Metrics::new(true);
            let bus = metrics.make_bus::<KernelEvent>(1);
            spawn_edge_drains(&rt, &bus, fanout_n);

            let label_lag = format!("burst{}_fanout{}_cap{}", burst, fanout_n, 1);
            bursty_edge.throughput(Throughput::Elements(burst as u64));
            bursty_edge.bench_with_input(
                BenchmarkId::new("edge_lagged_fanout", &label_lag),
                &(),
                |b, _| {
                    b.iter(|| {
                        publish_burst(&bus, burst);
                        if pub_epoch_yield() {
                            rt.block_on(async { tokio::task::yield_now().await });
                        }
                    });
                },
            );

            rt.block_on(async { tokio::task::yield_now().await });
        }

        bursty_edge.finish();
    }
}

#[cfg(feature = "bus_batch")]
fn bench_publish_batched(c: &mut Criterion) {
    // ========= Group 4: Bursty — **BATCHED** publish_many (fanout), real A2 path =========
    let tls_thresh = tls_flush_threshold();
    let mut bursty_batched = c.benchmark_group(format!(
        "bus_publish_bursty_batched (tls_thresh={})",
        tls_thresh
    ));
    bursty_batched.sampling_mode(SamplingMode::Flat);
    bursty_batched.sample_size(60);
    bursty_batched.warm_up_time(Duration::from_secs(1));
    bursty_batched.measurement_time(Duration::from_secs(6));

    let rt = tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .expect("tokio rt");

    let burst = burst_size();
    let fanout_n = fanout();
    let cap = burst_cap();
    let label = format!("burst{}_fanout{}_cap{}", burst, fanout_n, cap);

    // (B1) batched fanout; cap=CAP (no backpressure)
    {
        let metrics = Metrics::new(true);
        let bus = metrics.make_bus::<KernelEvent>(cap);
        spawn_classic_drains(&rt, &bus, fanout_n);

        bursty_batched.throughput(Throughput::Elements(burst as u64));
        bursty_batched.bench_with_input(BenchmarkId::new("batched_fanout", &label), &(), |b, _| {
            // Prepare per-iter batch without timing the setup (A2 hot path only):
            b.iter_batched_ref(
                || {
                    let mut v = Vec::with_capacity(burst);
                    v.resize(burst, KernelEvent::Shutdown);
                    v
                },
                |batch| {
                    #[allow(unused_must_use)]
                    {
                        bus.publish_many(black_box(&mut batch[..]));
                    }
                    if pub_epoch_yield() {
                        rt.block_on(async { tokio::task::yield_now().await });
                    }
                },
                BatchSize::SmallInput,
            );
        });

        rt.block_on(async { tokio::task::yield_now().await });
    }

    // (B2) batched **lagged** fanout; cap=1 (pressure path)
    {
        let metrics = Metrics::new(true);
        let bus = metrics.make_bus::<KernelEvent>(1);
        spawn_classic_drains(&rt, &bus, fanout_n);

        let label_lag = format!("burst{}_fanout{}_cap{}", burst, fanout_n, 1);
        bursty_batched.throughput(Throughput::Elements(burst as u64));
        bursty_batched.bench_with_input(
            BenchmarkId::new("batched_lagged_fanout", &label_lag),
            &(),
            |b, _| {
                b.iter_batched_ref(
                    || {
                        let mut v = Vec::with_capacity(burst);
                        v.resize(burst, KernelEvent::Shutdown);
                        v
                    },
                    |batch| {
                        #[allow(unused_must_use)]
                        {
                            bus.publish_many(black_box(&mut batch[..]));
                        }
                        if pub_epoch_yield() {
                            rt.block_on(async { tokio::task::yield_now().await });
                        }
                    },
                    BatchSize::SmallInput,
                );
            },
        );

        rt.block_on(async { tokio::task::yield_now().await });
    }

    bursty_batched.finish();
}

// ---- Criterion mains (feature-gated so you can `--features bus_batch`) ----

#[cfg(feature = "bus_batch")]
criterion_group!(benches, bench_publish, bench_publish_batched);

#[cfg(not(feature = "bus_batch"))]
criterion_group!(benches, bench_publish);

criterion_main!(benches);

```

### crates/ron-kernel/benches/bus_publish_matrix.rs
<a id="crates-ron-kernel-benches-buspublishmatrix-rs"></a>

```rust
/*!
RO: benches/bus_publish_matrix.rs
WHAT: Parameterized publish() cost across subscriber counts and capacities.
WHY : Locate sweet spots for default capacity vs fan-out cost.
NOTE: Subscribers actively drain to avoid unbounded lag skewing results.
*/

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, SamplingMode};
use ron_kernel::{Bus, KernelEvent, Metrics};
use std::time::Duration;
use tokio::runtime::Builder;

const CAPS: &[usize] = &[32, 64, 128, 256, 4096];
const SUBS: &[usize] = &[0, 1, 4, 16];
const INNER_PUBLISHES: usize = 10_000;

fn bench_bus_publish_matrix(c: &mut Criterion) {
    let rt = Builder::new_multi_thread().enable_all().build().unwrap();

    let mut group = c.benchmark_group("bus_publish_matrix");
    group.sampling_mode(SamplingMode::Flat);
    group.sample_size(60);
    group.warm_up_time(Duration::from_secs(2));
    group.measurement_time(Duration::from_secs(8));

    for &subs in SUBS {
        for &cap in CAPS {
            let id = BenchmarkId::new("publish", format!("subs{}_cap{}", subs, cap));
            group.bench_with_input(id, &(), |b, _| {
                b.iter(|| {
                    rt.block_on(async {
                        let metrics = Metrics::new(false);
                        let bus: Bus<KernelEvent> = metrics.make_bus(cap);

                        // spawn drains
                        let mut joins = Vec::new();
                        for _ in 0..subs {
                            let mut rx = bus.subscribe();
                            joins.push(tokio::spawn(async move {
                                while let Ok(_ev) = rx.recv().await {}
                            }));
                        }

                        for i in 0..black_box(INNER_PUBLISHES) {
                            let _ = bus.publish(KernelEvent::ConfigUpdated { version: i as u64 });
                        }

                        drop(bus);
                        for j in joins {
                            let _ = j.await;
                        }
                    });
                });
            });
        }
    }

    group.finish();
}

criterion_group!(benches, bench_bus_publish_matrix);
criterion_main!(benches);

```

### crates/ron-kernel/benches/bus_soa.rs
<a id="crates-ron-kernel-benches-bussoa-rs"></a>

```rust
// benches/bus_soa.rs
//
// RO:WHAT
// - Criterion bench entrypoint for the SoA backend.
// - Compiles cleanly whether or not the "bus_soa" feature is enabled.
//
// RO:WHY
// - Cargo builds all benches during `cargo bench`. Without guarding, this file
//   would emit E0601 (no main) when the feature is off.
//
// RO:INTERACTS
// - Uses Criterion only when "bus_soa" is enabled.
// - When the feature is disabled, provides a tiny stub `main()` so the bench
//   target still builds and the rest of the suite can run.
//
// RO:INVARIANTS
// - Never pull SoA symbols unless the feature is on.
// - Keep a deterministic group name for CI diffing even if the body is trivial.

#[cfg(not(feature = "bus_soa"))]
fn main() {
    // Feature not enabled; benign stub so `cargo bench` can proceed.
    // Tip: run with `--features bus_soa` to enable this bench's real body.
    eprintln!("bench 'bus_soa' compiled without --features bus_soa; skipping.");
}

#[cfg(feature = "bus_soa")]
mod soa_bench {
    use criterion::{criterion_group, criterion_main, Criterion};

    // If you already have shared bench helpers, import them here, e.g.:
    // use ron_kernel::bench_support::{run_publish_matrix_soa, BenchCfg};

    // Minimal placeholder so the bench runs even before the SoA runner lands.
    // Replace with your real SoA matrix once implemented.
    fn bench_bus_soa(c: &mut Criterion) {
        let mut group = c.benchmark_group("bus_soa");
        // TODO: swap this placeholder with the real SoA publish/deliver matrix.
        group.bench_function("noop_build_only", |b| b.iter(|| 0u64));
        group.finish();
    }

    criterion_group!(name = soa; config = Criterion::default(); targets = bench_bus_soa);
    criterion_main!(soa);
}

```

### crates/ron-kernel/benches/metrics_encode.rs
<a id="crates-ron-kernel-benches-metricsencode-rs"></a>

```rust
/*!
RO: benches/metrics_encode.rs
WHAT: Measure Prometheus registry gather+encode cost (drift guard).
WHY : Catch accidental cardinality/registry growth; not a throughput contest.
*/

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, SamplingMode};
use prometheus::Encoder;
use ron_kernel::Metrics;
use std::time::Duration;

fn bench_metrics(c: &mut Criterion) {
    let mut group = c.benchmark_group("metrics");
    group.sampling_mode(SamplingMode::Flat);
    group.sample_size(60);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(6));

    group.bench_with_input(
        BenchmarkId::new("gather+encode_text", "registry"),
        &(),
        |b, _| {
            b.iter(|| {
                let metrics = Metrics::new(false);
                metrics.set_amnesia(true); // ensure non-empty registry
                let families = (*metrics).registry.gather();
                let mut buf = Vec::new();
                prometheus::TextEncoder::new()
                    .encode(&families, &mut buf)
                    .unwrap();
                black_box(buf.len());
            });
        },
    );

    group.finish();
}

criterion_group!(benches, bench_metrics);
criterion_main!(benches);

```

### crates/ron-kernel/benches/publish_edge_matrix.rs
<a id="crates-ron-kernel-benches-publishedgematrix-rs"></a>

```rust
use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use std::time::Duration;
use tokio::sync::broadcast;

// Measure publish throughput across (subs × capacity) matrix using only public API.
// This bench compiles with/without features (bus_edge_notify, bus_batch).

use ron_kernel::bus::bounded::Bus;

// Drain helper: non-blocking drain, like a simple “now_or_never” for broadcast.
fn drain_now<T: Clone + Send + 'static>(rx: &mut broadcast::Receiver<T>) -> usize {
    use tokio::sync::broadcast::error::TryRecvError::*;
    let mut n = 0usize;
    loop {
        match rx.try_recv() {
            Ok(_) => n += 1,
            Err(Empty) => break,
            Err(Lagged(_)) => continue, // skip lagged; keep draining to head
            Err(Closed) => break,
        }
    }
    n
}

#[cfg(feature = "bus_edge_notify")]
mod edge_metrics {
    use prometheus::proto::MetricType;
    use prometheus::Registry;

    pub fn snapshot(reg: &Registry, name: &str) -> u64 {
        let mut sum = 0f64;
        for mf in reg.gather() {
            if mf.name() == name && mf.get_field_type() == MetricType::COUNTER {
                for m in mf.get_metric() {
                    if let Some(c) = m.get_counter().as_ref() {
                        // rust-protobuf 3.x style: scalar getter is `value()`
                        sum += c.value();
                    }
                }
            }
        }
        sum as u64
    }

    pub fn default_registry() -> Registry {
        prometheus::default_registry().clone()
    }
}

fn bench_publish_edge_matrix(c: &mut Criterion) {
    // Single-threaded runtime for more stable results
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_time()
        .build()
        .unwrap();

    let mut group = c.benchmark_group("publish_edge_matrix");
    // Tunable matrix; keep small for CI time but representative for perf
    let subs_set = [0usize, 1, 4, 16];
    let caps_set = [32usize, 64, 128, 256];

    // Amount of work per iteration (elements pushed)
    const ELEMS: u64 = 50_000;

    #[cfg(feature = "bus_edge_notify")]
    let reg = edge_metrics::default_registry();

    for &subs in &subs_set {
        for &cap in &caps_set {
            group.throughput(Throughput::Elements(ELEMS));
            group.bench_with_input(
                BenchmarkId::new("publish_single", format!("subs={subs},cap={cap}")),
                &(),
                |b, _| {
                    rt.block_on(async {
                        let bus: Bus<u64> = Bus::with_capacity(cap);

                        // Spawn subscribers
                        let mut rxs: Vec<_> = (0..subs).map(|_| bus.subscribe()).collect();

                        #[cfg(feature = "bus_edge_notify")]
                        let sends_before = edge_metrics::snapshot(&reg, "bus_notify_sends_total");
                        #[cfg(feature = "bus_edge_notify")]
                        let suppressed_before =
                            edge_metrics::snapshot(&reg, "bus_notify_suppressed_total");

                        b.iter(|| {
                            // Producer: push ELEMS events
                            for i in 0..ELEMS {
                                let _ = bus.publish(i);
                            }
                            // Drain for fairness (so next iter starts empty)
                            for rx in &mut rxs {
                                let _ = drain_now(rx);
                            }
                            black_box(())
                        });

                        #[cfg(feature = "bus_edge_notify")]
                        {
                            let sends_after =
                                edge_metrics::snapshot(&reg, "bus_notify_sends_total");
                            let suppressed_after =
                                edge_metrics::snapshot(&reg, "bus_notify_suppressed_total");
                            let sends = sends_after.saturating_sub(sends_before);
                            let suppressed =
                                suppressed_after.saturating_sub(suppressed_before);
                            let total = sends + suppressed;
                            if total > 0 {
                                let pct = (suppressed as f64) * 100.0 / (total as f64);
                                eprintln!(
                                    "[edge] subs={subs}, cap={cap}: sends={sends}, suppressed={suppressed} ({pct:.1}% suppressed)"
                                );
                            }
                        }
                    });
                },
            );
        }
    }
    group.finish();
}

criterion_group! {
    name = benches;
    config = {
        Criterion::default()
            .measurement_time(Duration::from_secs(8))
            .warm_up_time(Duration::from_secs(3))
            .sample_size(20)
    };
    targets = bench_publish_edge_matrix
}
criterion_main!(benches);

```

### crates/ron-kernel/benches/readiness_handler.rs
<a id="crates-ron-kernel-benches-readinesshandler-rs"></a>

```rust
/*!
RO: benches/readiness_handler.rs
WHAT: Measure axum handler overhead for the readiness gate.
WHY : Ensure /readyz is microseconds-fast in both states.
*/

use axum::http::StatusCode;
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, SamplingMode};
use ron_kernel::metrics::health::HealthState;
use ron_kernel::metrics::readiness::{readyz_handler, Readiness};
use std::time::Duration;
use tokio::runtime::Builder;

fn bench_readyz(c: &mut Criterion) {
    let rt = Builder::new_multi_thread().enable_all().build().unwrap();

    let mut group = c.benchmark_group("readyz");
    group.sampling_mode(SamplingMode::Flat);
    group.sample_size(60);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(6));

    // not_ready
    group.bench_with_input(BenchmarkId::new("not_ready", "handler()"), &(), |b, _| {
        b.iter(|| {
            rt.block_on(async {
                let health = HealthState::new();
                let ready = Readiness::new(health.clone());
                let resp = readyz_handler(ready).await;
                assert_eq!(resp.status(), StatusCode::SERVICE_UNAVAILABLE);
            });
        });
    });

    // ready
    group.bench_with_input(BenchmarkId::new("ready", "handler()"), &(), |b, _| {
        b.iter(|| {
            rt.block_on(async {
                let health = HealthState::new();
                let ready = Readiness::new(health.clone());
                ready.set_config_loaded(true);
                health.set("kernel", true);
                let resp = readyz_handler(ready).await;
                assert_eq!(resp.status(), StatusCode::OK);
            });
        });
    });

    group.finish();
}

criterion_group!(benches, bench_readyz);
criterion_main!(benches);

```

### crates/ron-kernel/deny.toml
<a id="crates-ron-kernel-deny-toml"></a>

```toml
[advisories]
yanked = "deny"
unmaintained = "deny"
vulnerability = "deny"
[licenses]
allow = ["MIT", "Apache-2.0"]

```

### crates/ron-kernel/examples/kernel_demo.rs
<a id="crates-ron-kernel-examples-kerneldemo-rs"></a>

```rust
// crates/ron-kernel/examples/kernel_demo.rs
//
// Minimal runnable demo for ron-kernel surfaces.
// - Exposes /metrics, /healthz, /readyz
// - Reads RON_CONFIG (default: /tmp/ron-kernel.toml) and toggles amnesia on real content change
// - Publishes KernelEvent::ConfigUpdated { version } on each change
//
// ENV:
//   RON_CONFIG=/tmp/ron-kernel.toml   # optional; default shown
//   RON_AMNESIA=1                     # optional; force amnesia=1 at startup

use ron_kernel::metrics::readiness::Readiness;
use ron_kernel::{wait_for_ctrl_c, Bus, HealthState, KernelEvent, Metrics};
use std::{
    env, fs,
    net::SocketAddr,
    time::{Duration, SystemTime},
};
use tokio::task::JoinHandle;

#[tokio::main]
async fn main() {
    // Core kernel surfaces
    let metrics = Metrics::new(false);
    let health = HealthState::new();
    let ready = Readiness::new(health.clone());

    // HTTP exporter (metrics / health / ready)
    let bind: SocketAddr = "127.0.0.1:9600".parse().unwrap();
    let (_handle, local) = metrics
        .clone()
        .serve(bind, health.clone(), ready.clone())
        .await
        .expect("metrics/health/ready server to bind");
    println!("metrics:  http://{}/metrics", local);
    println!("healthz:  http://{}/healthz", local);
    println!("readyz :  http://{}/readyz", local);

    // Config source
    let cfg_path = env::var("RON_CONFIG").unwrap_or_else(|_| "/tmp/ron-kernel.toml".to_string());
    println!("edit {} or set RON_AMNESIA=1 to see updates", cfg_path);

    // Seed readiness + amnesia
    // Mark kernel service healthy for demo visibility; /readyz still waits for config_loaded=true.
    health.set("kernel", true);

    // Apply env override immediately for a quick sanity check; else seed from file.
    let mut config_loaded = false;
    if let Ok(v) = env::var("RON_AMNESIA") {
        if v == "1" || v.eq_ignore_ascii_case("true") {
            metrics.set_amnesia(true);
            config_loaded = true;
        }
    } else if let Some(a) = read_amnesia_flag(&cfg_path) {
        metrics.set_amnesia(a);
        config_loaded = true;
    }
    if config_loaded {
        ready.set_config_loaded(true);
    }

    // Bus for demo events
    let bus: Bus<KernelEvent> = Bus::new().with_metrics(metrics.clone());

    // --- A3: Capacity Autotune (feature-gated) --------------------------------
    // For demo purposes we assume ~4 global subscribers. This computes a cache-friendly
    // capacity and exports it via the `bus_cap_selected` gauge. When the feature is OFF,
    // this block is not compiled and no behavior changes.
    #[cfg(feature = "bus_autotune_cap")]
    {
        // If you later expose a Bus::with_capacity(cap) builder path, you can pass `cap` there.
        // For now, we record and print the selection for observability.
        let expected_subs = 4usize;
        let cap = ron_kernel::bus::capacity::autotune_capacity(expected_subs, None);
        println!(
            "autotune: expected_subs={} → selected bus cap = {}",
            expected_subs, cap
        );
    }
    // ---------------------------------------------------------------------------

    // Poller: detect real content changes, apply amnesia, publish ConfigUpdated
    let poller: JoinHandle<()> = tokio::spawn({
        let metrics = metrics.clone();
        let ready = ready.clone();
        let bus = bus.clone();
        let cfg_path = cfg_path.clone();
        async move {
            let mut last_hash: Option<u64> = None;
            let mut version: u64 = 1;

            loop {
                let (hash, amnesia) = match read_file_and_hash(&cfg_path) {
                    Some((h, a)) => (Some(h), Some(a)),
                    None => (None, None),
                };

                if hash.is_some() && hash != last_hash {
                    // We have a real change; mark config loaded and flip amnesia.
                    ready.set_config_loaded(true);
                    if let Some(a) = amnesia {
                        metrics.set_amnesia(a);
                    }
                    bus.publish(KernelEvent::ConfigUpdated { version });
                    println!(
                        "kernel event: ConfigUpdated {{ version: {} }} → amnesia={:?}",
                        version, amnesia
                    );
                    version = version.saturating_add(1);
                    last_hash = hash;
                }

                tokio::time::sleep(Duration::from_millis(500)).await;
            }
        }
    });

    println!("press Ctrl-C to stop …");
    wait_for_ctrl_c().await;
    poller.abort(); // best-effort cleanup
}

// --- helpers ---------------------------------------------------------------

// Parse `amnesia = true|false` from a TOML-ish line.
fn read_amnesia_flag(path: &str) -> Option<bool> {
    let s = fs::read_to_string(path).ok()?;
    for line in s.lines() {
        let t = line.trim();
        if t.starts_with("amnesia") && t.contains('=') {
            let val = t.splitn(2, '=').nth(1)?.trim();
            let val = val.trim_matches(|c: char| c == '"' || c.is_ascii_whitespace());
            return Some(val.eq_ignore_ascii_case("true"));
        }
    }
    None
}

// Read file and return (content_hash, amnesia_flag) using a tiny FNV-1a 64-bit hash.
fn read_file_and_hash(path: &str) -> Option<(u64, bool)> {
    let s = fs::read_to_string(path).ok()?;
    let mut hasher = Fnv1a64::new();
    hasher.update(s.as_bytes());
    // Fold in mtime to ensure delta on edits even if content normalizes
    if let Ok(meta) = fs::metadata(path) {
        if let Ok(mtime) = meta.modified() {
            if let Ok(dur) = mtime.duration_since(SystemTime::UNIX_EPOCH) {
                hasher.update(&dur.as_nanos().to_le_bytes());
            }
        }
    }
    let amnesia = s.lines().any(|line| {
        let t = line.trim();
        t.starts_with("amnesia")
            && t.contains('=')
            && t.splitn(2, '=')
                .nth(1)
                .map(|v| {
                    v.trim()
                        .trim_matches(|c: char| c == '"' || c.is_ascii_whitespace())
                        .eq_ignore_ascii_case("true")
                })
                .unwrap_or(false)
    });
    Some((hasher.finish(), amnesia))
}

// Tiny FNV-1a (64-bit) hasher (self-contained).
struct Fnv1a64(u64);
impl Fnv1a64 {
    fn new() -> Self {
        Self(0xcbf29ce484222325)
    } // offset basis
    fn update(&mut self, bytes: &[u8]) {
        const PRIME: u64 = 0x100000001b3;
        let mut h = self.0;
        for b in bytes {
            h ^= *b as u8 as u64;
            h = h.wrapping_mul(PRIME);
        }
        self.0 = h;
    }
    fn finish(&self) -> u64 {
        self.0
    }
}

```

### crates/ron-kernel/examples/minimal_supervision.rs
<a id="crates-ron-kernel-examples-minimalsupervision-rs"></a>

```rust
use std::net::SocketAddr;
use std::time::Duration;

use ron_kernel::metrics::readiness::Readiness;
use ron_kernel::{HealthState, KernelEvent, Metrics};

#[tokio::main]
async fn main() {
    // Metrics + readiness demo server
    let metrics = Metrics::new(false);
    let health = HealthState::new();
    let ready = Readiness::new(health.clone());
    ready.set_config_loaded(true);

    let (handle, local) = metrics
        .clone()
        .serve(
            "127.0.0.1:0".parse::<SocketAddr>().unwrap(),
            health.clone(),
            ready.clone(),
        )
        .await
        .unwrap();
    println!("metrics at http://{}/metrics", local);

    // Build a generic bus and attach metrics
    let bus = metrics.make_bus::<KernelEvent>(1024);

    // === Subscriber task =====================================================
    #[cfg(feature = "bus_edge_notify")]
    {
        // Edge-aware subscriber: disciplined drain loop (A5)
        let mut sub = bus.subscribe_edge();
        tokio::spawn(async move {
            // sub_index is for labeling; not used by the inlined helper today
            sub.run_drain_loop(0).await;
        });
    }

    #[cfg(not(feature = "bus_edge_notify"))]
    {
        // Classic subscriber: just recv in a loop
        let mut rx = bus.subscribe();
        tokio::spawn(async move { while rx.recv().await.is_ok() {} });
    }
    // ========================================================================

    // === Publisher demo workload ============================================
    // If `bus_batch` is enabled, publish in bursts via publish_many (A2).
    // Otherwise fall back to single-message publishes.
    #[cfg(feature = "bus_batch")]
    {
        // Replace the publisher loop (demo) to exercise batches
        let bus2 = bus.clone();
        tokio::spawn(async move {
            let mut v = 0u64;
            let mut scratch = Vec::with_capacity(256);
            loop {
                scratch.clear();
                for _ in 0..128 {
                    scratch.push(KernelEvent::ConfigUpdated { version: v });
                    v = v.wrapping_add(1);
                }
                // A2: single-sweep publish
                let _ = bus2.publish_many(&scratch);
                tokio::time::sleep(Duration::from_millis(25)).await;
            }
        });
    }

    #[cfg(not(feature = "bus_batch"))]
    {
        // One-at-a-time publisher (original behavior)
        let bus2 = bus.clone();
        tokio::spawn(async move {
            let mut v = 0u64;
            loop {
                let _ = bus2.publish(KernelEvent::ConfigUpdated { version: v });
                v = v.wrapping_add(1);
                tokio::time::sleep(Duration::from_millis(50)).await;
            }
        });
    }
    // ========================================================================

    tokio::signal::ctrl_c().await.unwrap();
    handle.abort();
}

```

### crates/ron-kernel/examples/publish_smoke.rs
<a id="crates-ron-kernel-examples-publishsmoke-rs"></a>

```rust
//! RO:WHAT
//! Minimal smoke to exercise the bus and expose counters over /metrics.
//!
//! RO:WHY
//! Validate A2 (bus_batch) in a live process and make it trivial to curl the
//! exporter and confirm notify/batch/publish counters move.
//!
//! RO:INTERACTS
//! - ron_kernel::Metrics (serves /metrics on ephemeral port)
//! - ron_kernel::bus::bounded::{Bus, EdgeReceiver} (feature-gated)
//!
//! RO:INVARIANTS
//! - Runs indefinitely until Ctrl-C.
//! - Env-driven config for subs/cap/burst/tick to avoid code edits.

use std::{env, time::Duration};
use tokio::time::{interval, sleep};

use ron_kernel::Metrics;

fn getenv<T: std::str::FromStr>(key: &str, default: T) -> T {
    env::var(key)
        .ok()
        .and_then(|s| s.parse::<T>().ok())
        .unwrap_or(default)
}

#[tokio::main(flavor = "multi_thread")]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // --- Metrics + HTTP on an ephemeral port (":0") ---
    let metrics = Metrics::new(false);
    let (_server, addr) = {
        use ron_kernel::metrics::{health::HealthState, readiness::Readiness};
        let health = HealthState::new();
        let ready = Readiness::new(health.clone());
        // bind to :0 so OS picks a free port
        metrics
            .clone()
            .serve(([127, 0, 0, 1], 0).into(), health, ready)
            .await?
    };
    println!("metrics:  http://{}/metrics", addr);
    println!("healthz:  http://{}/healthz", addr);
    println!("readyz :  http://{}/readyz", addr);
    println!("curl these in another terminal; press Ctrl-C here to stop …");

    // --- Config via env (defaults are sane for laptops) ---
    let cap = getenv::<usize>("RON_BENCH_CAP", 4096);
    let subs = getenv::<usize>("RON_BENCH_FANOUT", 4);
    let burst = getenv::<usize>("RON_BENCH_BURST", 256);
    let tick_ms = getenv::<u64>("RON_TICK_MS", 1000);
    println!(
        "[example cfg] subs={}, cap={}, burst={}, tick_ms={}",
        subs, cap, burst, tick_ms
    );

    // --- Bus + subscribers (edge receivers if feature enabled) ---
    let bus = metrics.make_bus::<u64>(cap);

    #[cfg(feature = "bus_edge_notify")]
    {
        use ron_kernel::bus::bounded::EdgeReceiver;
        for i in 0..subs {
            let mut edge: EdgeReceiver<u64> = bus.subscribe_edge();
            tokio::spawn(async move {
                edge.run_drain_loop(i).await;
            });
        }
    }
    #[cfg(not(feature = "bus_edge_notify"))]
    {
        // FIX: no need for `mut` on the Vec binding
        let rxs: Vec<_> = (0..subs).map(|_| bus.subscribe()).collect();
        for mut rx in rxs {
            let m = metrics.clone();
            tokio::spawn(async move {
                loop {
                    // Drain as events arrive; account lag/drops via handle_recv if provided.
                    let _ = ron_kernel::bus::bounded::Bus::<u64>::handle_recv(
                        rx.recv().await,
                        Some(&m),
                    );
                }
            });
        }
    }

    // --- Periodic publisher ---
    // Aim for "burst" elements per tick. With bus_batch ON, this is one publish_many per burst.
    let mut tick = interval(Duration::from_millis(tick_ms));
    let mut next = 0u64;

    loop {
        tick.tick().await;

        #[cfg(feature = "bus_batch")]
        {
            // One batch per tick; adjust tick_ms to control overall rate
            let mut buf = Vec::with_capacity(burst);
            buf.clear();
            for _ in 0..burst {
                buf.push(next);
                next = next.wrapping_add(1);
            }
            let _ = bus.publish_many(&buf);
        }

        #[cfg(not(feature = "bus_batch"))]
        {
            for _ in 0..burst {
                let _ = bus.publish(next);
                next = next.wrapping_add(1);
            }
        }

        // Give TLS flusher a beat between bursts (if metrics_buf is on).
        sleep(Duration::from_millis(50)).await;
    }

    #[allow(unreachable_code)]
    {
        Ok(())
    }
}

```

### crates/ron-kernel/fuzz/cfg_parser.rs
<a id="crates-ron-kernel-fuzz-cfgparser-rs"></a>

```rust
// fuzz target placeholder for config validation/precedence
fn main() {}

```

### crates/ron-kernel/rust-toolchain.toml
<a id="crates-ron-kernel-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt","clippy"]

```

### crates/ron-kernel/scripts/ci_public_api.sh
<a id="crates-ron-kernel-scripts-cipublicapi-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
cargo install cargo-public-api >/dev/null 2>&1 || true
cargo public-api -p ron-kernel --simplified

```

### crates/ron-kernel/scripts/enforce_ro_headers.sh
<a id="crates-ron-kernel-scripts-enforceroheaders-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Enforce presence of "RO:" header lines near the top of every Rust source file.
# Skips files under target/ and any generated code paths.

fail() { echo "RO header missing in: $1" >&2; exit 1; }

git ls-files 'crates/ron-kernel/**/*.rs' \
  | grep -vE '^target/' \
  | while read -r file; do
      head -n 25 "$file" | grep -q 'RO:' || fail "$file"
    done

echo "RO header check passed."

```

### crates/ron-kernel/scripts/perf_gate.sh
<a id="crates-ron-kernel-scripts-perfgate-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Usage:
#   STRICT=0 ROUNDS=3 MEASTIME=10 bash crates/ron-kernel/scripts/perf_gate.sh
#   STRICT=1 ROUNDS=7 MEASTIME=20 bash crates/ron-kernel/scripts/perf_gate.sh   # CI/server

ROUNDS="${ROUNDS:-3}"
MEASTIME="${MEASTIME:-10}"

BASE_CLASSIC="core-2025-10-22"
BASE_BATCHED="core-2025-10-22-batched"

if ! command -v critcmp >/dev/null 2>&1; then
  echo "critcmp not found. Installing..."
  cargo install critcmp
fi

# Thresholds
one_sub_regress_pct=10     # batched one_sub may not be >10% slower than classic
fanout_gain_pct=8          # local default
lagged_gain_pct=8          # local default
if [[ "${STRICT:-0}" == "1" ]]; then
  fanout_gain_pct=15
  lagged_gain_pct=8
fi

ns_from_token() {
  local tok="$1" time unit
  time="$(echo "$tok" | sed -E 's/±.*//')"
  unit="$(echo "$tok" | sed -E 's/.*(ns|µs|ms)$/\1/')"
  case "$unit" in
    ns) awk -v v="$time" 'BEGIN{printf "%.6f", v}' ;;
    µs) awk -v v="$time" 'BEGIN{printf "%.6f", v*1000}' ;;
    ms) awk -v v="$time" 'BEGIN{printf "%.6f", v*1000000}' ;;
  esac
}

extract_time_ns() {
  local group="$1" cmp_out="$2" which="$3"
  # which: "first" for classic time on that row, "last" for batched time on that row
  local line tok
  line="$(echo "$cmp_out" | grep -F "$group" | tail -n1 || true)"
  [[ -z "$line" ]] && { echo "NaN"; return; }
  if [[ "$which" == "first" ]]; then
    tok="$(echo "$line" | grep -Eo '[0-9]+(\.[0-9]+)?±[0-9\.]+(ns|µs|ms)' | head -n1)"
  else
    tok="$(echo "$line" | grep -Eo '[0-9]+(\.[0-9]+)?±[0-9\.]+(ns|µs|ms)' | tail -n1)"
  fi
  ns_from_token "$tok"
}

median() { awk '{a[NR]=$1} END{ n=NR; asort(a); if(n%2) printf "%.6f", a[(n+1)/2]; else printf "%.6f", (a[n/2]+a[n/2+1])/2 }'; }
pct_improve(){ awk -v a="$1" -v b="$2" 'BEGIN{ printf "%.2f", (a-b)/a*100 }'; }

classic_fanout_ns=(); batched_fanout_ns=()
classic_lagged_ns=(); batched_lagged_ns=()
classic_one_ns=();    batched_one_ns=()

for r in $(seq 1 "$ROUNDS"); do
  echo "=== Round $r/$ROUNDS: classic (measurement ${MEASTIME}s)"
  cargo bench -p ron-kernel --bench bus_publish \
    -- --warm-up-time 3 --measurement-time "${MEASTIME}" --save-baseline "${BASE_CLASSIC}"

  echo "=== Round $r/$ROUNDS: batched (measurement ${MEASTIME}s)"
  cargo bench -p ron-kernel --features "bus_batch,metrics_buf" --bench bus_publish \
    -- --warm-up-time 3 --measurement-time "${MEASTIME}" --save-baseline "${BASE_BATCHED}"

  CMP_OUT="$(critcmp "${BASE_CLASSIC}" "${BASE_BATCHED}")"
  echo "$CMP_OUT"

  cf="$(extract_time_ns 'classic_fanout/burst256_fanout4_cap2048' "$CMP_OUT" "first")"
  bf="$(extract_time_ns 'batched_fanout/burst256_fanout4_cap2048' "$CMP_OUT" "last")"
  cl="$(extract_time_ns 'classic_lagged_fanout/burst256_fanout4_cap1' "$CMP_OUT" "first")"
  bl="$(extract_time_ns 'batched_lagged_fanout/burst256_fanout4_cap1' "$CMP_OUT" "last")"
  co="$(extract_time_ns 'one_subscriber/publish()' "$CMP_OUT" "first")"
  bo="$(extract_time_ns 'one_subscriber/publish()' "$CMP_OUT" "last")"

  classic_fanout_ns+=("$cf");   batched_fanout_ns+=("$bf")
  classic_lagged_ns+=("$cl");   batched_lagged_ns+=("$bl")
  classic_one_ns+=("$co");      batched_one_ns+=("$bo")
done

mf="$(printf "%s\n" "${classic_fanout_ns[@]}" | median)"
nbf="$(printf "%s\n" "${batched_fanout_ns[@]}" | median)"
ml="$(printf "%s\n" "${classic_lagged_ns[@]}" | median)"
nbl="$(printf "%s\n" "${batched_lagged_ns[@]}" | median)"
mo="$(printf "%s\n" "${classic_one_ns[@]}" | median)"
nbo="$(printf "%s\n" "${batched_one_ns[@]}" | median)"

echo "---- MEDIANS (ns) ----"
echo "classic fanout : $mf"
echo "batched fanout : $nbf"
echo "classic lagged : $ml"
echo "batched lagged : $nbl"
echo "classic one_sub: $mo"
echo "batched one_sub: $nbo"

fanout_delta="$(pct_improve "$mf" "$nbf")"
lagged_delta="$(pct_improve "$ml" "$nbl")"
one_delta="$(pct_improve "$mo" "$nbo")"

echo "improve fanout : ${fanout_delta}%"
echo "improve lagged : ${lagged_delta}%"
echo "improve one_sub: ${one_delta}%"

fail=0
awk -v d="$one_delta"  -v thr="-$one_sub_regress_pct" 'BEGIN{ if (d < thr) exit 1 }' || { echo "FAIL: one_sub regression exceeds '${one_sub_regress_pct}%'"; fail=1; }
awk -v d="$fanout_delta" -v thr="$fanout_gain_pct"     'BEGIN{ if (d < thr) exit 1 }' || { echo "FAIL: fanout gain < '${fanout_gain_pct}%'"; fail=1; }
awk -v d="$lagged_delta" -v thr="$lagged_gain_pct"     'BEGIN{ if (d < thr) exit 1 }' || { echo "FAIL: lagged gain < '${lagged_gain_pct}%'"; fail=1; }

if [[ "$fail" -ne 0 ]]; then
  echo "PERF GATE FAILED"
  exit 1
fi
echo "PERF GATE PASSED"

```

### crates/ron-kernel/scripts/render_mermaid.sh
<a id="crates-ron-kernel-scripts-rendermermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
which mmdc >/dev/null || npm i -g @mermaid-js/mermaid-cli
for f in $(git ls-files 'crates/ron-kernel2/docs/*.mmd' 2>/dev/null); do
  mmdc -i "$f" -o "${f%.mmd}.svg"
done

```

### crates/ron-kernel/scripts/ron_kernel_smoke.sh
<a id="crates-ron-kernel-scripts-ronkernelsmoke-sh"></a>

```bash
#!/usr/bin/env bash
# Verifies: build+tests, demo boots, config loads (seed after boot), /metrics|/healthz OK,
# readiness polled but non-fatal, amnesia=false -> 0 then amnesia=true -> 1 via watcher.

set -euo pipefail

curl_status() { curl -s -o /dev/null -w "%{http_code}" "$1"; }
fail() { echo "ERROR: $*" 1>&2; exit 1; }

echo "[1/9] Build & test"
cargo build -p ron-kernel
cargo test  -p ron-kernel

echo "[2/9] Start example (kernel_demo) on 127.0.0.1:0"
LOGFILE="$(mktemp)"
RON_AMNESIA=0 cargo run -p ron-kernel --example kernel_demo >"$LOGFILE" 2>&1 &
APP_PID=$!
trap 'kill -TERM $APP_PID >/dev/null 2>&1 || true; rm -f "$LOGFILE" /tmp/ron-kernel.toml' EXIT

echo "Waiting for server to print URLs… (log: $LOGFILE)"
for i in {1..120}; do
  grep -q "metrics:" "$LOGFILE" && break || sleep 0.2
done

ADDR="$(grep -m1 -E 'metrics:' "$LOGFILE" | sed -n 's#.*http://\([^/]*\)/metrics.*#\1#p')"
[ -n "${ADDR:-}" ] || fail "could not discover server address from logs"
echo "Discovered addr: $ADDR"

METRICS_URL="http://$ADDR/metrics"
HEALTHZ_URL="http://$ADDR/healthz"
READYZ_URL="http://$ADDR/readyz"

echo "[3/9] Seed config AFTER boot so watcher observes first load"
cat > /tmp/ron-kernel.toml <<'TOML'
version = 1
amnesia = false
TOML
sleep 0.8

echo "[4/9] Poll /readyz up to 10s (non-fatal if it stays 503)"
READY=0
for i in {1..100}; do
  code="$(curl_status "$READYZ_URL" || true)"
  [ "$code" = "200" ] && { READY=1; break; }
  [ "$i" -eq 1 ] && echo "initial /readyz code: ${code:-curl-failed}"
  sleep 0.1
done
if [ "$READY" -eq 1 ]; then
  echo "readyz OK (200)"
else
  echo "readyz still $code — continuing (non-fatal)"
fi

echo "[5/9] Curl /metrics and /healthz"
curl -fsS "$METRICS_URL" | head -n 5 >/dev/null
curl -fsS "$HEALTHZ_URL" >/dev/null
echo "Surfaces OK"

read_amnesia() { curl -fsS "$METRICS_URL" | awk '/^amnesia_mode[[:space:]]/{print $2; exit}'; }

echo "[6/9] Read baseline amnesia_mode"
BASE="$(read_amnesia || true)"
echo "amnesia baseline: ${BASE:-unset}"

echo "[7/9] Force amnesia=false → expect metric 0"
cat > /tmp/ron-kernel.toml <<'TOML'
version = 2
amnesia = false
TOML
sleep 0.8
A0="$(read_amnesia || true)"
echo "amnesia after false: ${A0:-unset}"
[ "${A0:-x}" = "0" ] || { echo "--- metrics sample ---"; curl -fsS "$METRICS_URL" | head -n 50; fail "expected amnesia_mode=0"; }

echo "[8/9] Force amnesia=true → expect metric 1"
cat > /tmp/ron-kernel.toml <<'TOML'
version = 3
amnesia = true
TOML
sleep 0.8
A1="$(read_amnesia || true)"
echo "amnesia after true:  ${A1:-unset}"
[ "${A1:-x}" = "1" ] || { echo "--- metrics sample ---"; curl -fsS "$METRICS_URL" | head -n 50; fail "expected amnesia_mode=1"; }

echo "[9/9] Done — killing example"
kill -TERM $APP_PID
wait $APP_PID || true
echo "Smoke passed ✅"

```

### crates/ron-kernel/scripts/run_kernel_benches.sh
<a id="crates-ron-kernel-scripts-runkernelbenches-sh"></a>

```bash
#!/usr/bin/env bash
# RO: scripts/run_kernel_benches.sh
set -euo pipefail

echo "=== System ==="
uname -a || true
rustc -Vv
cargo -V

echo
echo "=== Running benches (stable) ==="
cargo bench -p ron-kernel

echo
echo "=== Criterion reports ==="
echo "Open: target/criterion/report/index.html"

```

### crates/ron-kernel/scripts/run_mog_b1.sh
<a id="crates-ron-kernel-scripts-runmogb1-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Run SoA micro benches and tests (B1).
# RO:WHY  — Repeatable ritual for quick signal before Bus wiring.
# RO:INTERACTS — benches/bus_soa.rs; tests/soa_smoke.rs; Cargo features.
# RO:INVARIANTS — non-destructive; no feature bleed into other benches.

set -euo pipefail

echo "[MOG B1] build+test (feature=bus_soa)"
cargo test -p ron-kernel --features bus_soa -- tests:: # narrow run
cargo test -p ron-kernel --features bus_soa

echo "[MOG B1] benches (feature=bus_soa)"
cargo bench -p ron-kernel --features bus_soa --bench bus_soa

```

### crates/ron-kernel/src/amnesia.rs
<a id="crates-ron-kernel-src-amnesia-rs"></a>

```rust
//! RO:WHAT — Amnesia mode: single source of truth + metrics hook.
//! RO:WHY  — Pillar 1 (Kernel): central flag for RAM-first ops; SEC/RES concern.
//! RO:INTERACTS — metrics::exporter::Metrics (amnesia gauge), config::watcher/apply, readiness (orthogonal).
//! RO:INVARIANTS — lock-free reads; coherent under races; never gates readiness; updates metrics atomically.
//! RO:METRICS/LOGS — metrics.amnesia_mode (0/1 or label on="true|false") kept in sync on set().
//! RO:CONFIG — toggled by ConfigUpdated (from watcher); env RON_AMNESIA may also flip it.
//! RO:SECURITY — no secrets; boolean only.
//! RO:TEST HOOKS — unit: toggle coherency; integ: watcher flip updates gauge.

use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};

use crate::metrics::exporter::Metrics;

/// Amnesia flag with atomic semantics and metrics synchronization.
#[derive(Clone, Debug)]
pub struct Amnesia(Arc<AtomicBool>);

impl Amnesia {
    /// Create with initial state.
    pub fn new(initial: bool) -> Self {
        Self(Arc::new(AtomicBool::new(initial)))
    }

    /// Read current state (lock-free).
    #[inline]
    pub fn get(&self) -> bool {
        self.0.load(Ordering::Relaxed)
    }

    /// Set state and synchronize the exported gauge.
    ///
    /// Never blocks; safe to call from config apply or env poller.
    pub fn set(&self, on: bool, metrics: &Metrics) {
        self.0.store(on, Ordering::Relaxed);
        metrics.set_amnesia(on);
    }
}

```

### crates/ron-kernel/src/bus/backoff.rs
<a id="crates-ron-kernel-src-bus-backoff-rs"></a>

```rust
//! Two-phase backoff helper for publisher slow paths (bench/SoA use).
//! Default is ultra-light: short spin (16) then yield. Tunable via env:
//!   RON_PUB_SPIN   => u32 spins (max 256; default 16)
//!   RON_PUB_YIELD  => "0" disables yield, anything else enables (default ON)

use std::cell::Cell;
use std::sync::OnceLock;
use std::thread;

#[derive(Copy, Clone)]
pub struct TwoPhaseBackoff {
    spins_left: Cell<u32>,
    yield_enabled: bool,
}

impl TwoPhaseBackoff {
    #[inline]
    pub fn new() -> Self {
        static SPINS: OnceLock<u32> = OnceLock::new();
        static YIELD: OnceLock<bool> = OnceLock::new();

        let spins = *SPINS.get_or_init(|| {
            std::env::var("RON_PUB_SPIN")
                .ok()
                .and_then(|v| v.parse::<u32>().ok())
                .filter(|&n| n <= 256)
                .unwrap_or(16)
        });
        let yield_enabled = *YIELD.get_or_init(|| {
            std::env::var("RON_PUB_YIELD").map(|v| v != "0").unwrap_or(true)
        });

        Self { spins_left: Cell::new(spins), yield_enabled }
    }

    /// Call when publish cannot immediately progress (slot full/lagged).
    #[inline]
    pub fn tick(&self) {
        let left = self.spins_left.get();
        if left > 0 {
            std::hint::spin_loop();
            self.spins_left.set(left - 1);
        } else if self.yield_enabled {
            thread::yield_now();
        } else {
            std::hint::spin_loop();
        }
    }

    #[inline]
    pub fn reset(&self) {
        self.spins_left.set(16);
    }
}

```

### crates/ron-kernel/src/bus/bounded.rs
<a id="crates-ron-kernel-src-bus-bounded-rs"></a>

```rust
//! Bounded, non-blocking in-process broadcast bus.
//!
//! MOG (features):
//! - `bus_edge_notify`: coalesced per-subscriber wake via `pending` bit + disciplined drain.
//! - `bus_batch`: batch publishing API with single notify sweep (A2).
//! - `metrics_buf`: thread-local buffering for hot-path counters (publish/notify).

use std::sync::Arc;

use tokio::sync::broadcast;
use tokio::sync::broadcast::error::RecvError;

#[cfg(feature = "bus_edge_notify")]
use {
    std::sync::{Mutex, Weak},
    tokio::sync::Notify,
};

use crate::Metrics;

#[cfg(feature = "bus_edge_notify")]
use crate::bus::mog_edge_notify::{prom_metrics::PromMetrics, EdgeNotify};

/// Kernel bus wrapper around `tokio::broadcast`.
#[derive(Clone)]
pub struct Bus<T: Clone + Send + 'static> {
    tx: broadcast::Sender<T>,
    metrics: Option<Arc<Metrics>>,

    #[cfg(feature = "bus_edge_notify")]
    edge: Arc<EdgeRegistry>,
}

impl<T: Clone + Send + 'static> Bus<T> {
    pub fn new() -> Self {
        let (tx, _rx) = broadcast::channel::<T>(1024);
        Self {
            tx,
            metrics: None,
            #[cfg(feature = "bus_edge_notify")]
            edge: Arc::new(EdgeRegistry::default()),
        }
    }

    pub fn with_capacity(capacity: usize) -> Self {
        let (tx, _rx) = broadcast::channel::<T>(capacity);
        Self {
            tx,
            metrics: None,
            #[cfg(feature = "bus_edge_notify")]
            edge: Arc::new(EdgeRegistry::default()),
        }
    }

    pub fn with_metrics(mut self, metrics: Arc<Metrics>) -> Self {
        self.metrics = Some(metrics);
        self
    }

    #[inline]
    pub fn receiver_count(&self) -> usize {
        self.tx.receiver_count()
    }

    /// Single publish (existing path), with optional TLS metrics buffering.
    pub fn publish(&self, msg: T) -> usize {
        let receivers = self.tx.receiver_count();

        if receivers == 0 {
            if let Some(m) = &self.metrics {
                // Count as "published attempt" + explicit "no receivers".
                #[cfg(feature = "metrics_buf")]
                {
                    if let Some(hot) = m.hot() {
                        hot.inc_published();
                    }
                }
                #[cfg(not(feature = "metrics_buf"))]
                {
                    m.bus_published_total.inc();
                }
                m.bus_no_receivers_total.inc();
            }
            return 0;
        }

        match self.tx.send(msg) {
            Ok(_) => {
                // Account publish on the hot path.
                if let Some(m) = &self.metrics {
                    #[cfg(feature = "metrics_buf")]
                    {
                        if let Some(hot) = m.hot() {
                            hot.inc_published();
                        }
                    }
                    #[cfg(not(feature = "metrics_buf"))]
                    {
                        m.bus_published_total.inc();
                    }
                }

                // Coalesced edge-notify sweep if enabled.
                #[cfg(feature = "bus_edge_notify")]
                self.edge_sweep();

                receivers
            }
            Err(_e) => {
                if let Some(m) = &self.metrics {
                    m.bus_dropped_total.inc();
                }
                0
            }
        }
    }

    /// A2: Batch publish with one notify sweep at the end (feature-gated).
    #[cfg(feature = "bus_batch")]
    pub fn publish_many(&self, batch: &[T]) -> usize {
        if batch.is_empty() {
            return 0;
        }

        let receivers = self.tx.receiver_count();
        if receivers == 0 {
            if let Some(m) = &self.metrics {
                // Visibility: attempted to publish N items with no listeners.
                #[cfg(feature = "metrics_buf")]
                {
                    if let Some(hot) = m.hot() {
                        hot.add_published(batch.len() as u64);
                    }
                }
                #[cfg(not(feature = "metrics_buf"))]
                {
                    m.bus_published_total.inc_by(batch.len() as u64);
                }
                m.bus_no_receivers_total.inc_by(batch.len() as u64);
                m.bus_batch_publish_total.inc();
                m.bus_batch_len_histogram.observe(batch.len() as f64);
            }
            return 0;
        }

        // Send all elements; if any send fails (closed), account drop and stop.
        let mut sent = 0usize;
        for item in batch {
            match self.tx.send(item.clone()) {
                Ok(_) => sent += 1,
                Err(_e) => {
                    if let Some(m) = &self.metrics {
                        m.bus_dropped_total.inc();
                    }
                    break;
                }
            }
        }

        // One coalesced edge-notify sweep (A2).
        #[cfg(feature = "bus_edge_notify")]
        self.edge_sweep();

        if let Some(m) = &self.metrics {
            if sent > 0 {
                #[cfg(feature = "metrics_buf")]
                {
                    if let Some(hot) = m.hot() {
                        hot.add_published(sent as u64);
                    }
                }
                #[cfg(not(feature = "metrics_buf"))]
                {
                    m.bus_published_total.inc_by(sent as u64);
                }
            }
            m.bus_batch_publish_total.inc();
            m.bus_batch_len_histogram.observe(batch.len() as f64);
        }

        receivers
    }

    /// Subscribe and get a classical broadcast `Receiver<T>` (feature-agnostic).
    pub fn subscribe(&self) -> broadcast::Receiver<T> {
        self.tx.subscribe()
    }

    pub fn handle_recv(
        res: Result<T, broadcast::error::RecvError>,
        metrics: Option<&Metrics>,
    ) -> Option<T> {
        match res {
            Ok(v) => Some(v),
            Err(broadcast::error::RecvError::Lagged(n)) => {
                if let Some(m) = metrics {
                    m.bus_receiver_lag_total.inc_by(n as u64);
                }
                None
            }
            Err(broadcast::error::RecvError::Closed) => None,
        }
    }

    // === Internal: one sweep across live subscribers to deliver a single notify per sub ======

    #[cfg(feature = "bus_edge_notify")]
    fn edge_sweep(&self) {
        // Prometheus metrics for A1/A5 (counters + per-sub pending gauge internally updated
        // by the receiver drain loops). Small, stateless helper.
        let prom = PromMetrics::default();

        let mut sent = 0u64;
        let mut suppressed = 0u64;

        self.edge.with_signals(|signals| {
            signals.retain(|w| w.upgrade().is_some());
            for w in signals.iter() {
                if let Some(sig) = w.upgrade() {
                    // RELAXED is sufficient: visibility is handled by ring fences.
                    if EdgeNotify::maybe_mark_pending_and_should_wake_metrics(&sig.pending, &prom) {
                        sig.notify.notify_one();
                        sent += 1;
                    } else {
                        suppressed += 1;
                    }
                }
            }
        });

        if let Some(m) = &self.metrics {
            // Route 'sends' through TLS buffer when enabled; 'suppressed' stays direct.
            #[cfg(feature = "metrics_buf")]
            {
                if sent > 0 {
                    if let Some(hot) = m.hot() {
                        // Count one notify per sweep (keep it simple on hot path).
                        hot.inc_notify();
                    }
                }
            }
            #[cfg(not(feature = "metrics_buf"))]
            {
                if sent > 0 {
                    m.bus_notify_sends_total.inc_by(sent);
                }
            }

            if suppressed > 0 {
                m.bus_notify_suppressed_total.inc_by(suppressed);
            }
        }
    }

    // === MOG subscriber helpers (feature-gated) ============================================

    /// Subscribe with an internal edge signal (pending bit + Notify) used to coalesce wakes.
    #[cfg(feature = "bus_edge_notify")]
    pub fn subscribe_edge(&self) -> EdgeReceiver<T> {
        let rx = self.tx.subscribe();
        let signal = Arc::new(EdgeSignal::default());
        self.edge.register_signal(&signal);
        EdgeReceiver {
            signal,
            rx,
            metrics: self.metrics.clone(),
        }
    }
}

/// Receiver wrapper (unchanged shape).
pub struct Receiver<T: Clone + Send + 'static> {
    inner: broadcast::Receiver<T>,
    metrics: Option<Arc<Metrics>>,
}

impl<T: Clone + Send + 'static> Receiver<T> {
    pub fn new(inner: broadcast::Receiver<T>, metrics: Option<Arc<Metrics>>) -> Self {
        Self { inner, metrics }
    }

    pub async fn recv(&mut self) -> Option<T> {
        loop {
            match self.inner.recv().await {
                Ok(v) => return Some(v),
                Err(RecvError::Lagged(n)) => {
                    if let Some(m) = &self.metrics {
                        m.bus_receiver_lag_total.inc_by(n as u64);
                    }
                    continue;
                }
                Err(RecvError::Closed) => return None,
            }
        }
    }
}

/* ======== MOG helpers and types (feature-gated; minimal, generic-safe) ==================== */

#[cfg(feature = "bus_edge_notify")]
#[derive(Default)]
struct EdgeRegistry {
    signals: Mutex<Vec<Weak<EdgeSignal>>>,
}

#[cfg(feature = "bus_edge_notify")]
impl EdgeRegistry {
    fn register_signal(&self, sig: &Arc<EdgeSignal>) {
        self.signals.lock().unwrap().push(Arc::downgrade(sig));
    }
    fn with_signals<F: FnOnce(&mut Vec<Weak<EdgeSignal>>) -> ()>(&self, f: F) {
        let mut guard = self.signals.lock().unwrap();
        f(&mut guard);
    }
}

#[cfg(feature = "bus_edge_notify")]
#[derive(Default)]
struct EdgeSignal {
    pending: std::sync::atomic::AtomicBool,
    notify: Notify,
}

#[cfg(feature = "bus_edge_notify")]
pub struct EdgeReceiver<T: Clone + Send + 'static> {
    signal: Arc<EdgeSignal>,
    rx: broadcast::Receiver<T>,
    metrics: Option<Arc<Metrics>>,
}

#[cfg(feature = "bus_edge_notify")]
impl<T: Clone + Send + 'static> EdgeReceiver<T> {
    #[inline]
    pub fn try_recv_now_or_never(&mut self) -> usize {
        use tokio::sync::broadcast::error::TryRecvError::*;
        let mut drained = 0usize;
        loop {
            match self.rx.try_recv() {
                Ok(_msg) => drained += 1,
                Err(Empty) => break,
                Err(Lagged(n)) => {
                    if let Some(m) = &self.metrics {
                        m.bus_receiver_lag_total.inc_by(n as u64);
                    }
                }
                Err(Closed) => break,
            }
        }
        drained
    }

    #[inline]
    pub async fn await_notify(&self) {
        self.signal.notify.notified().await;
    }

    #[inline]
    pub fn pending(&self) -> &std::sync::atomic::AtomicBool {
        &self.signal.pending
    }
    #[inline]
    pub fn notify(&self) -> &Notify {
        &self.signal.notify
    }

    /// Disciplined drain loop (A5) with race check and per-sub pending gauge.
    pub async fn run_drain_loop(&mut self, sub_index: usize) {
        // Prom metrics handle `bus_sub_pending{sub}` updates.
        let prom = PromMetrics::default();

        loop {
            // Drain in bounded bursts to amortize wakes while keeping latency tight.
            let mut drained = 0usize;
            loop {
                let n = self.try_recv_now_or_never();
                if n == 0 {
                    break;
                }
                drained += n;
                if drained >= 1024 {
                    break;
                }
            }

            // Race check — if a publish raced our clear, keep draining (skip await).
            if EdgeNotify::after_drain_race_check(self.pending(), &prom, sub_index) {
                continue;
            }

            // Await next wake to avoid ping-pong.
            self.await_notify().await;
        }
    }
}

```

### crates/ron-kernel/src/bus/capacity.rs
<a id="crates-ron-kernel-src-bus-capacity-rs"></a>

```rust
//! RO:WHAT
//!   Capacity autotune helper for the bounded bus ring.
//!
//! RO:WHY
//!   Picking a too-large cap is cache-hostile; too-small can increase churn/drops.
//!   This feature-gated helper chooses a sweet-spot cap from expected subscriber
//!   count with guardrails and observability (Prometheus counters/gauges).
//!
//! RO:INTERACTS
//!   - Used by examples (kernel_demo) and callers that want reasonable defaults.
//!   - Exposes Prometheus metrics via the *default* registry.
//!
//! RO:INVARIANTS
//!   - Public kernel API remains frozen; this is an internal helper.
//!   - When feature `bus_autotune_cap` is OFF, callers should not reference it.
//!   - Caps returned are restricted to {64, 128, 256} unless explicitly overridden.
//!
//! RO:TESTS
//!   - Unit: mapping for key N (0,1,4,5,16,17,64,128)
//!   - Property: monotone in N; override respected; warnings on >256
//!
//! RO:SAFETY
//!   - No `unsafe`. Pure computation + metrics.
//!
//! RO:METRICS
//!   - `bus_autotune_warn_total{reason="cap_gt_256"}`
//!   - `bus_cap_selected` (gauge)

#![cfg(feature = "bus_autotune_cap")]

use once_cell::sync::Lazy;
use prometheus::{opts, register_gauge, register_int_counter_vec, Gauge, IntCounterVec};

/// Warn counter for guardrails.
static AUTOTUNE_WARN_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        opts!("bus_autotune_warn_total", "Autotune guardrail warnings"),
        &["reason"]
    )
    .expect("register bus_autotune_warn_total")
});

/// Last selected cap (observability).
static BUS_CAP_SELECTED: Lazy<Gauge> = Lazy::new(|| {
    register_gauge!(
        "bus_cap_selected",
        "Current bus capacity selected by autotune"
    )
    .expect("register bus_cap_selected")
});

/// Choose a cache-friendly capacity from an expected subscriber count `expected_subs`.
/// If `override_cap` is provided, it always wins (and may be any power-of-two the caller desires).
/// Guardrail: when the *effective* cap exceeds 256, we emit a warning counter.
///
/// Mapping (when `override_cap` is `None`):
///   - N ≤ 4   → 64
///   - N ≤ 16  → 128
///   - else    → 256 (warn if caller later uses >256)
pub fn autotune_capacity(expected_subs: usize, override_cap: Option<usize>) -> usize {
    let cap = match override_cap {
        Some(c) => c,
        None => {
            if expected_subs <= 4 {
                64
            } else if expected_subs <= 16 {
                128
            } else {
                256
            }
        }
    };

    if cap > 256 {
        AUTOTUNE_WARN_TOTAL.with_label_values(&["cap_gt_256"]).inc();
    }

    BUS_CAP_SELECTED.set(cap as f64);
    cap
}

/// Helper for tests/benches to reset gauge (kept for internal use).
#[cfg(test)]
pub fn __test_reset_metrics() {
    BUS_CAP_SELECTED.set(0.0);
}

```

### crates/ron-kernel/src/bus/mod.rs
<a id="crates-ron-kernel-src-bus-mod-rs"></a>

```rust
//! Bus module index.
//!
//! Layout:
//! - `bounded.rs`          : tokio::broadcast/AoS backend (default)
//! - `soa.rs`              : SoA ring backend (feature: bus_soa)
//! - `mog_edge_notify.rs`  : A1/A5 helpers (edge-triggered notify + disciplined drain)
//! - `capacity.rs`         : A3 autotune helper (feature: bus_autotune_cap)
//!
//! RO:WHAT
//!   Central selector + feature-gated helpers for the kernel bus.
//!
//! RO:WHY
//!   Keep call-sites stable while we experiment with a SoA backend.
//!   When `bus_soa` is enabled, we re-export SoA *under* a `bounded`-shaped
//!   module so existing paths (`crate::bus::bounded::Bus`) remain valid.
//!
//! RO:INVARIANTS
//!   - Public API stays stable; features are OFF-by-default.
//!   - No `unsafe` here.
//!   - `crate::bus::bounded::Bus` always exists and compiles.
//!
//! RO:INTERACTS
//!   - `bounded.rs` (default AoS) or `soa.rs` (feature=bus_soa) as the active backend.
//!   - `mog_edge_notify.rs` when feature `bus_edge_notify` is on.
//!   - `capacity.rs` when feature `bus_autotune_cap` is on.

#![allow(clippy::module_inception)] // for the bounded re-export wrapper when bus_soa is on

/// A3: Capacity autotune helper (feature-gated).
#[cfg(feature = "bus_autotune_cap")]
pub mod capacity;

#[cfg(feature = "bus_autotune_cap")]
pub use capacity::autotune_capacity;

/// Default backend (`bounded`) when SoA is NOT enabled.
#[cfg(not(feature = "bus_soa"))]
pub mod bounded;

/// Optional SoA backend (feature: bus_soa).
#[cfg(feature = "bus_soa")]
pub mod soa;

/// When `bus_soa` is ON, re-export SoA items under a `bounded`-shaped module
/// so `crate::bus::bounded::Bus` remains valid at existing call-sites.
/// We keep `pub mod soa;` above so advanced users can still import `soa::*`
/// explicitly if they want to.
#[cfg(feature = "bus_soa")]
pub mod bounded {
    pub use super::soa::*;
}

/// A1/A5 helpers (edge-triggered notify + disciplined drain).
#[cfg(feature = "bus_edge_notify")]
pub mod mog_edge_notify;

// ---------------------------------------------------------------------------
// Convenience re-exports (non-breaking):
//   - These make `use crate::bus::Bus;` work regardless of backend.
//   - Purely additive; they do not remove or rename any existing items.
// ---------------------------------------------------------------------------

pub use bounded::{Bus, Receiver};

#[cfg(feature = "bus_edge_notify")]
pub use bounded::EdgeReceiver;

```

### crates/ron-kernel/src/bus/mog_edge_notify.rs
<a id="crates-ron-kernel-src-bus-mogedgenotify-rs"></a>

```rust
// crates/ron-kernel/src/bus/mog_edge_notify.rs

/*!
MOG A1 + A5 — Edge-Triggered Notify + Disciplined Drain
Feature: `bus_edge_notify`

Internal helpers:
- Coalesce wakeups per subscriber using a `pending` bit (A1).
- Disciplined drain loop that clears `pending` safely and avoids ping-pong wakes (A5).

Public API: **None** (internal only). Wire these helpers into the bus internals.
Zero behavior change unless the bus calls into this module under the `bus_edge_notify` feature.
*/

#![cfg(feature = "bus_edge_notify")]
#![deny(unsafe_code)]

use core::sync::atomic::{AtomicBool, Ordering};

/// Minimal metrics hook used by this module.
/// Keep it decoupled; provide a Prometheus impl below (optional).
pub trait EdgeMetrics: Send + Sync + 'static {
    fn inc_notify_sent(&self) {}
    fn inc_notify_suppressed(&self) {}
    fn set_sub_pending(&self, _sub_idx: usize, _val: bool) {}
}
impl EdgeMetrics for () {}

/// Per-subscriber edge notifier (stateless; state lives in passed-in atomics).
#[derive(Default, Debug)]
pub struct EdgeNotify;

impl EdgeNotify {
    /// Publisher-side: set `pending` to true. If we transitioned 0→1, caller should send a wake.
    /// (Legacy signature — no metrics.)
    #[inline(always)]
    pub fn maybe_mark_pending_and_should_wake(pending: &AtomicBool) -> bool {
        // Relaxed is sufficient: message visibility comes from the ring’s Release/Acquire.
        let prev = pending.swap(true, Ordering::Relaxed);
        !prev
    }

    /// Publisher-side (metrics-aware): increments sends/suppressed counters.
    #[inline(always)]
    pub fn maybe_mark_pending_and_should_wake_metrics<M: EdgeMetrics>(
        pending: &AtomicBool,
        metrics: &M,
    ) -> bool {
        let prev = pending.swap(true, Ordering::Relaxed);
        if !prev {
            metrics.inc_notify_sent();
            true
        } else {
            metrics.inc_notify_suppressed();
            false
        }
    }

    /// Subscriber-side (legacy): clear `pending=false` after draining and perform a race check.
    /// Returns `true` if new work arrived during/after the clear.
    ///
    /// NOTE: Kept for compatibility, but prefer `after_drain_race_check()` below,
    /// which uses a stronger detection pattern.
    #[inline(always)]
    pub fn clear_pending_and_race_check(pending: &AtomicBool) -> bool {
        let _was_set = pending.swap(false, Ordering::Relaxed);
        pending.load(Ordering::Relaxed)
    }

    /// Subscriber-side: disciplined race-check after draining.
    ///
    /// Pattern:
    ///   drain_all();
    ///   if EdgeNotify::after_drain_race_check(pending, metrics, sub_idx) { continue; }
    ///   await_notify();
    ///
    /// Returns `true` if a publish raced after we cleared pending — the caller should
    /// skip awaiting and re-enter the drain loop immediately.
    #[inline(always)]
    pub fn after_drain_race_check<M: EdgeMetrics>(
        pending: &AtomicBool,
        metrics: &M,
        sub_idx: usize,
    ) -> bool {
        // 1) Clear pending (we are about to await).
        pending.store(false, Ordering::Relaxed);
        metrics.set_sub_pending(sub_idx, false);

        // 2) Race detect: if a publisher set it after our clear, swap(false) returns true.
        let raced = pending.swap(false, Ordering::Relaxed);
        if raced {
            // Re-arm to true so subsequent publishers get suppression (coalescing continues).
            pending.store(true, Ordering::Relaxed);
            metrics.set_sub_pending(sub_idx, true);
        }
        raced
    }

    /// Subscriber-side: disciplined drain loop.
    ///
    /// - `try_recv_now` must drain ALL available items and return the number drained.
    /// - `await_notify` waits for a single notification (e.g., `notify.notified().await`).
    pub async fn drain_loop<TryNow, AwaitFut, M>(
        &self,
        sub_idx: usize,
        pending: &AtomicBool,
        mut try_recv_now: TryNow,
        mut await_notify: impl FnMut() -> AwaitFut,
        metrics: &M,
    ) where
        TryNow: FnMut() -> usize,
        AwaitFut: core::future::Future<Output = ()>,
        M: EdgeMetrics,
    {
        metrics.set_sub_pending(sub_idx, true);
        loop {
            // 1) Drain everything currently available.
            loop {
                let n = try_recv_now();
                if n == 0 {
                    break;
                }
            }

            // 2) Clear pending + race check. If raced, keep draining (skip await).
            if Self::after_drain_race_check(pending, metrics, sub_idx) {
                continue;
            }

            // 3) Await next wake to avoid ping-pong.
            await_notify().await;
            metrics.set_sub_pending(sub_idx, true);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use core::sync::atomic::AtomicBool;

    #[test]
    fn publisher_edges_are_coalesced() {
        let pending = AtomicBool::new(false);

        // First mark triggers a wake
        assert!(EdgeNotify::maybe_mark_pending_and_should_wake(&pending));
        // Further marks coalesce (no additional wakes)
        assert!(!EdgeNotify::maybe_mark_pending_and_should_wake(&pending));
        assert!(!EdgeNotify::maybe_mark_pending_and_should_wake(&pending));

        // After a normal after-drain race check with no race, we should be clear
        let raced = EdgeNotify::after_drain_race_check(&pending, &(), 0);
        assert!(!raced);

        // Next publish becomes a new edge again
        assert!(EdgeNotify::maybe_mark_pending_and_should_wake(&pending));
    }

    #[test]
    fn after_drain_no_race_returns_false() {
        let pending = AtomicBool::new(true);
        // Simulate: we drained; now we do the after-drain check; no concurrent publisher
        let raced = EdgeNotify::after_drain_race_check(&pending, &(), 0);
        assert!(!raced, "no publisher raced; should return false");
        assert!(!pending.load(Ordering::Relaxed), "pending remains false");
    }
}

/// Optional: Prometheus-backed metrics for A1/A5 (counters + per-sub gauge).
/// Enable by constructing `PromMetrics` and passing &PromMetrics to drain/publish paths.
#[cfg(feature = "bus_edge_notify")]
pub mod prom_metrics {
    use super::EdgeMetrics;
    use once_cell::sync::Lazy;
    use prometheus::{opts, register_int_counter, register_int_gauge_vec, IntCounter, IntGaugeVec};

    static NOTIFY_SENDS_TOTAL: Lazy<IntCounter> = Lazy::new(|| {
        register_int_counter!(opts!(
            "bus_notify_sends_total",
            "Notify calls performed on 0→1 edges"
        ))
        .expect("register bus_notify_sends_total")
    });

    static NOTIFY_SUPPRESSED_TOTAL: Lazy<IntCounter> = Lazy::new(|| {
        register_int_counter!(opts!(
            "bus_notify_suppressed_total",
            "Notify attempts suppressed because subscriber was already pending"
        ))
        .expect("register bus_notify_suppressed_total")
    });

    static SUB_PENDING: Lazy<IntGaugeVec> = Lazy::new(|| {
        register_int_gauge_vec!(
            "bus_sub_pending",
            "Pending bit per subscriber (0|1)",
            &["sub"]
        )
        .expect("register bus_sub_pending")
    });

    /// Prometheus-backed EdgeMetrics. Label is `sub` with the numeric index.
    #[derive(Clone, Default)]
    pub struct PromMetrics;

    impl EdgeMetrics for PromMetrics {
        #[inline(always)]
        fn inc_notify_sent(&self) {
            NOTIFY_SENDS_TOTAL.inc();
        }
        #[inline(always)]
        fn inc_notify_suppressed(&self) {
            NOTIFY_SUPPRESSED_TOTAL.inc();
        }
        #[inline(always)]
        fn set_sub_pending(&self, sub_idx: usize, val: bool) {
            SUB_PENDING
                .with_label_values(&[&format!("{sub_idx}")])
                .set(if val { 1 } else { 0 });
        }
    }
}

```

### crates/ron-kernel/src/bus/soa.rs
<a id="crates-ron-kernel-src-bus-soa-rs"></a>

```rust
#![cfg(feature = "bus_soa")]

//! SoA (Structure-of-Arrays) ring backend for the in-process bus.

use core::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};
use std::sync::Arc;
use tokio::sync::Notify;

use crate::Metrics;
use tokio::sync::broadcast::error::RecvError;

#[cfg(feature = "bus_edge_notify")]
mod edge_helper {
    use core::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
    use std::sync::{Arc, Weak};
    use tokio::sync::Notify;

    #[derive(Default)]
    pub struct EdgeSignal {
        pub notify: Notify,
        pub pending: AtomicBool,
    }

    pub struct EdgeNotify;

    impl EdgeNotify {
        #[inline]
        pub fn set_pending_and_notify(sig: &Arc<EdgeSignal>) -> bool {
            let prev = sig.pending.swap(true, Ordering::AcqRel);
            if !prev {
                sig.notify.notify_one();
            }
            !prev
        }
        #[inline]
        pub fn clear_pending_and_race_check(pending: &AtomicBool) -> bool {
            let _was_set = pending.swap(false, Ordering::AcqRel);
            pending.load(Ordering::Relaxed)
        }
    }

    /// Reader-friendly registry with occasional GC and O(1) "is there anyone?" fast-path.
    #[derive(Default)]
    pub struct EdgeRegistry {
        pub signals: parking_lot::RwLock<Vec<Weak<EdgeSignal>>>,
        pub gc_tick: AtomicUsize,
        pub active: AtomicUsize, // count of live edge subscribers
    }

    impl EdgeRegistry {
        pub fn register(&self, sig: &Arc<EdgeSignal>) {
            let mut w = self.signals.write();
            w.push(Arc::downgrade(sig));
            self.active.fetch_add(1, Ordering::Relaxed);
        }

        pub fn deregister(&self) {
            self.active.fetch_sub(1, Ordering::Relaxed);
        }

        /// Iterate with a read-lock. Return `true` if any dead Weak were seen.
        pub fn for_each_with_read<F: FnMut(&Arc<EdgeSignal>)>(&self, mut f: F) -> bool {
            let r = self.signals.read();
            let mut saw_dead = false;
            for w in r.iter() {
                if let Some(sig) = w.upgrade() {
                    f(&sig);
                } else {
                    saw_dead = true;
                }
            }
            saw_dead
        }

        /// Occasionally compact dead entries. Called rarely to avoid write-lock churn.
        pub fn maybe_gc(&self, saw_dead: bool) {
            if !saw_dead {
                return;
            }
            let tick = self.gc_tick.fetch_add(1, Ordering::Relaxed);
            if (tick & 63) != 0 {
                return;
            }
            let mut w = self.signals.write();
            w.retain(|weak| weak.strong_count() > 0);
        }
    }
}
#[cfg(feature = "bus_edge_notify")]
use edge_helper::{EdgeNotify, EdgeRegistry, EdgeSignal};

// ===== Slot ==================================================================

// Keep it lean: no per-message Arc; clone T under a Mutex like the bounded backend.
pub(crate) struct Slot<T> {
    seq: AtomicU64,
    msg: parking_lot::Mutex<Option<T>>,
    ready_mask: AtomicU64,
}
impl<T> Slot<T> {
    fn new() -> Self {
        Self {
            seq: AtomicU64::new(0),
            msg: parking_lot::Mutex::new(None),
            ready_mask: AtomicU64::new(0),
        }
    }
}

// ===== Bus ===================================================================

pub struct Bus<T: Clone + Send + 'static> {
    cap: usize,
    seq: Arc<AtomicU64>,
    slots: Arc<Vec<Slot<T>>>,

    subs_in_use: Arc<parking_lot::Mutex<[bool; 64]>>,
    sub_count: Arc<parking_lot::Mutex<usize>>,

    global_notify: Arc<Notify>,

    publishers: Arc<AtomicUsize>,
    closed: Arc<AtomicBool>,

    metrics: Option<Arc<Metrics>>,

    #[cfg(feature = "bus_edge_notify")]
    edge: Arc<EdgeRegistry>,
}

impl<T: Clone + Send + 'static> Bus<T> {
    pub fn new() -> Self {
        Self::with_capacity(1024)
    }

    pub fn with_capacity(cap: usize) -> Self {
        let mut v = Vec::with_capacity(cap);
        for _ in 0..cap {
            v.push(Slot::new());
        }
        Self {
            cap,
            seq: Arc::new(AtomicU64::new(0)),
            slots: Arc::new(v),
            subs_in_use: Arc::new(parking_lot::Mutex::new([false; 64])),
            sub_count: Arc::new(parking_lot::Mutex::new(0)),
            global_notify: Arc::new(Notify::new()),
            publishers: Arc::new(AtomicUsize::new(1)),
            closed: Arc::new(AtomicBool::new(false)),
            metrics: None,
            #[cfg(feature = "bus_edge_notify")]
            edge: Arc::new(EdgeRegistry::default()),
        }
    }

    pub fn with_metrics(mut self, metrics: Arc<Metrics>) -> Self {
        self.metrics = Some(metrics);
        self
    }

    #[inline]
    pub fn receiver_count(&self) -> usize {
        *self.sub_count.lock()
    }

    #[inline]
    fn current_mask(&self) -> u64 {
        let subs = self.subs_in_use.lock();
        let mut mask: u64 = 0;
        for bit in 0..64 {
            if subs[bit] {
                mask |= 1u64 << bit;
            }
        }
        mask
    }

    /// Writer order:
    /// 1) payload -> msg (under lock)
    /// 2) ready_mask.store(mask, Release)
    /// 3) seq.store(next, Release)
    #[inline]
    fn publish_inner(&self, val: T, mask: u64, do_wake: bool) -> usize {
        let rc = self.receiver_count();
        if rc == 0 {
            if let Some(m) = &self.metrics {
                m.bus_no_receivers_total.inc();
            }
            return 0;
        }

        let next = self.seq.fetch_add(1, Ordering::AcqRel) + 1;
        let idx = (next as usize) % self.cap;

        {
            let mut guard = self.slots[idx].msg.lock();
            *guard = Some(val);
        }
        self.slots[idx].ready_mask.store(mask, Ordering::Release);
        self.slots[idx].seq.store(next, Ordering::Release);

        if let Some(m) = &self.metrics {
            m.bus_published_total.inc();
        }

        if do_wake {
            #[cfg(feature = "bus_edge_notify")]
            {
                // O(1) fast-path: if no edge subscribers, skip the whole sweep.
                if self.edge.active.load(Ordering::Relaxed) != 0 {
                    self.edge_sweep();
                }
            }
            #[cfg(not(feature = "bus_edge_notify"))]
            self.global_notify.notify_waiters();
        }

        rc
    }

    pub fn publish(&self, msg: T) -> usize {
        let mask = self.current_mask();
        self.publish_inner(msg, mask, true)
    }

    #[cfg(feature = "bus_batch")]
    pub fn publish_many(&self, batch: &[T]) -> usize {
        if batch.is_empty() {
            return 0;
        }
        let rc = self.receiver_count();
        if rc == 0 {
            if let Some(m) = &self.metrics {
                m.bus_no_receivers_total.inc_by(batch.len() as u64);
                m.bus_batch_publish_total.inc();
                m.bus_batch_len_histogram.observe(batch.len() as f64);
            }
            return 0;
        }
        let mask = self.current_mask();
        for item in batch {
            let _ = self.publish_inner(item.clone(), mask, false);
        }

        #[cfg(feature = "bus_edge_notify")]
        {
            if self.edge.active.load(Ordering::Relaxed) != 0 {
                self.edge_sweep();
            }
        }
        #[cfg(not(feature = "bus_edge_notify"))]
        self.global_notify.notify_waiters();

        if let Some(m) = &self.metrics {
            m.bus_batch_publish_total.inc();
            m.bus_batch_len_histogram.observe(batch.len() as f64);
        }
        rc
    }

    pub fn subscribe(&self) -> Receiver<T> {
        let (id, _count) = {
            let mut used = self.subs_in_use.lock();
            let mut idx: Option<usize> = None;
            for i in 0..64 {
                if !used[i] {
                    used[i] = true;
                    idx = Some(i);
                    break;
                }
            }
            let mut sc = self.sub_count.lock();
            if idx.is_some() {
                *sc += 1;
            }
            (idx.expect("up to 64 subscribers"), *sc)
        };

        let tail = self.seq.load(Ordering::Acquire);
        Receiver {
            bus_cap: self.cap,
            ring: self.slots.clone(),
            tail,
            id: id as u8,
            global_notify: self.global_notify.clone(),
            _metrics: self.metrics.clone(),
            subs_in_use: Arc::clone(&self.subs_in_use),
            sub_count: Arc::clone(&self.sub_count),
            closed: Arc::clone(&self.closed),
            seq: Arc::clone(&self.seq),
        }
    }

    #[cfg(feature = "bus_edge_notify")]
    pub fn subscribe_edge(&self) -> EdgeReceiver<T> {
        let inner = self.subscribe();
        let signal = Arc::new(EdgeSignal::default());
        self.edge.register(&signal);
        EdgeReceiver {
            inner,
            signal,
            registry: Arc::clone(&self.edge),
        }
    }

    #[inline]
    pub fn handle_recv(res: Result<T, RecvError>, metrics: Option<&Metrics>) -> Option<T> {
        match res {
            Ok(v) => Some(v),
            Err(RecvError::Lagged(_)) => {
                if let Some(m) = metrics {
                    m.bus_receiver_lag_total.inc_by(1);
                }
                None
            }
            Err(RecvError::Closed) => None,
        }
    }

    #[cfg(feature = "bus_edge_notify")]
    fn edge_sweep(&self) {
        let mut sent = 0u64;
        let mut suppressed = 0u64;

        let saw_dead = self.edge.for_each_with_read(|sig| {
            if EdgeNotify::set_pending_and_notify(sig) {
                sent += 1;
            } else {
                suppressed += 1;
            }
        });
        self.edge.maybe_gc(saw_dead);

        if let Some(m) = &self.metrics {
            if sent > 0 {
                m.bus_notify_sends_total.inc_by(sent);
            }
            if suppressed > 0 {
                m.bus_notify_suppressed_total.inc_by(suppressed);
            }
        }
    }
}

impl<T: Clone + Send + 'static> Clone for Bus<T> {
    fn clone(&self) -> Self {
        self.publishers.fetch_add(1, Ordering::AcqRel);
        Self {
            cap: self.cap,
            seq: Arc::clone(&self.seq),
            slots: Arc::clone(&self.slots),
            subs_in_use: Arc::clone(&self.subs_in_use),
            sub_count: Arc::clone(&self.sub_count),
            global_notify: Arc::clone(&self.global_notify),
            publishers: Arc::clone(&self.publishers),
            closed: Arc::clone(&self.closed),
            metrics: self.metrics.clone(),
            #[cfg(feature = "bus_edge_notify")]
            edge: Arc::clone(&self.edge),
        }
    }
}

impl<T: Clone + Send + 'static> Drop for Bus<T> {
    fn drop(&mut self) {
        if self.publishers.fetch_sub(1, Ordering::AcqRel) == 1 {
            self.closed.store(true, Ordering::Release);
            self.global_notify.notify_waiters();
        }
    }
}

// ===== Receiver ==============================================================

pub struct Receiver<T: Clone + Send + 'static> {
    pub(crate) bus_cap: usize,
    pub(crate) ring: Arc<Vec<Slot<T>>>,
    pub(crate) tail: u64,
    pub(crate) id: u8,
    pub(crate) global_notify: Arc<Notify>,
    pub(crate) _metrics: Option<Arc<Metrics>>,
    pub(crate) subs_in_use: Arc<parking_lot::Mutex<[bool; 64]>>,
    pub(crate) sub_count: Arc<parking_lot::Mutex<usize>>,
    pub(crate) closed: Arc<AtomicBool>,
    pub(crate) seq: Arc<AtomicU64>,
}

impl<T: Clone + Send + 'static> Receiver<T> {
    pub async fn recv(&mut self) -> Result<T, RecvError> {
        loop {
            let next = self.tail + 1;
            let idx = (next as usize) % self.bus_cap;
            let slot = &self.ring[idx];

            let slot_seq = slot.seq.load(Ordering::Acquire);

            if slot_seq > next {
                let delta = slot_seq - next;
                self.tail = slot_seq - 1;
                return Err(RecvError::Lagged(delta));
            }

            if slot_seq == 0 || slot_seq < next {
                if self.closed.load(Ordering::Acquire) {
                    let cur = self.seq.load(Ordering::Acquire);
                    if cur < next {
                        return Err(RecvError::Closed);
                    }
                }
                self.global_notify.notified().await;
                continue;
            }

            let bit = 1u64 << (self.id as u64);
            let prev_mask = slot.ready_mask.fetch_and(!bit, Ordering::AcqRel);
            if (prev_mask & bit) == 0 {
                self.tail = slot_seq;
                return Err(RecvError::Lagged(1));
            }

            let cloned = {
                let guard = slot.msg.lock();
                let v = guard.as_ref().expect("payload must exist if bit was set");
                v.clone()
            };

            self.tail = slot_seq;
            return Ok(cloned);
        }
    }
}

impl<T: Clone + Send + 'static> Drop for Receiver<T> {
    fn drop(&mut self) {
        let mut used = self.subs_in_use.lock();
        used[self.id as usize] = false;
        let mut c = self.sub_count.lock();
        *c = c.saturating_sub(1);
    }
}

// ===== Edge Receiver =========================================================

#[cfg(feature = "bus_edge_notify")]
pub struct EdgeReceiver<T: Clone + Send + 'static> {
    pub(crate) inner: Receiver<T>,
    pub(crate) signal: Arc<EdgeSignal>,
    pub(crate) registry: Arc<EdgeRegistry>,
}

#[cfg(feature = "bus_edge_notify")]
impl<T: Clone + Send + 'static> EdgeReceiver<T> {
    #[inline]
    pub fn try_recv_now_or_never(&mut self) -> usize {
        let mut drained = 0usize;
        loop {
            let next = self.inner.tail + 1;
            let idx = (next as usize) % self.inner.bus_cap;
            let slot = &self.inner.ring[idx];

            let slot_seq = slot.seq.load(Ordering::Acquire);
            if slot_seq == 0 || slot_seq < next {
                break;
            }
            if slot_seq > next {
                self.inner.tail = slot_seq - 1;
                continue;
            }

            let bit = 1u64 << (self.inner.id as u64);
            let prev_mask = slot.ready_mask.fetch_and(!bit, Ordering::AcqRel);
            if (prev_mask & bit) == 0 {
                self.inner.tail = slot_seq;
                continue;
            }

            {
                let guard = slot.msg.lock();
                let _ = guard.as_ref().expect("payload must exist if bit was set");
            }

            self.inner.tail = slot_seq;
            drained += 1;
        }
        drained
    }

    pub async fn run_drain_loop(&mut self, _sub_index: usize) {
        loop {
            let mut total = 0usize;
            loop {
                let n = self.try_recv_now_or_never();
                if n == 0 {
                    break;
                }
                total += n;
                if total >= 1024 {
                    break;
                }
            }
            let raced = edge_helper::EdgeNotify::clear_pending_and_race_check(&self.signal.pending);
            if raced {
                continue;
            }
            if total == 0 {
                self.signal.notify.notified().await;
                continue;
            }
            self.signal.notify.notified().await;
        }
    }

    pub async fn drain(&mut self, max: usize) -> usize {
        if max == 0 {
            return 0;
        }
        let mut drained = 0usize;
        while drained < max {
            match self.inner.recv().await {
                Ok(_v) => drained += 1,
                Err(RecvError::Lagged(_)) => {}
                Err(RecvError::Closed) => break,
            }
        }
        drained
    }

    #[inline]
    pub async fn await_notify(&self) {
        self.signal.notify.notified().await;
    }
    pub fn pending(&self) -> &core::sync::atomic::AtomicBool {
        &self.signal.pending
    }
}

#[cfg(feature = "bus_edge_notify")]
impl<T: Clone + Send + 'static> Drop for EdgeReceiver<T> {
    fn drop(&mut self) {
        // Mark one fewer active edge subscriber; Weak will GC later.
        self.registry.deregister();
    }
}

```

### crates/ron-kernel/src/bus/test.rs
<a id="crates-ron-kernel-src-bus-test-rs"></a>

```rust
/*!
Unit tests for the Bus contract (lives next to the implementation so it runs with unit tests too).

Contract under test:
- Zero subscribers: publish returns 0 and increments bus_no_receivers_total.
- One subscriber: publish returns 1 and does NOT increment bus_no_receivers_total again.

These are intentionally minimal: they do not receive messages; they only validate publish semantics + metrics.
*/

#![cfg(test)]

use crate::events::KernelEvent;
use crate::Metrics;

#[test]
fn publish_with_zero_subscribers_returns_zero_and_counts_metric() {
    let metrics = Metrics::new(false);
    let bus = metrics.make_bus(8);

    let before = metrics.bus_no_receivers_total.get();
    let delivered = bus.publish(KernelEvent::ConfigUpdated { version: 1 });
    assert_eq!(delivered, 0, "zero subscribers must yield 0");
    let after = metrics.bus_no_receivers_total.get();
    assert_eq!(
        after,
        before + 1,
        "bus_no_receivers_total must increment on publish with zero subscribers"
    );
}

#[test]
fn publish_with_one_subscriber_returns_one_and_metric_stays_flat() {
    let metrics = Metrics::new(false);
    let bus = metrics.make_bus(8);

    // establish baseline and add one subscriber
    let base = metrics.bus_no_receivers_total.get();
    let _rx = bus.subscribe();

    // publish and assert 1
    let delivered = bus.publish(KernelEvent::ConfigUpdated { version: 2 });
    assert_eq!(delivered, 1, "one subscriber must yield 1");

    // metric must not increment in this case
    let now = metrics.bus_no_receivers_total.get();
    assert_eq!(
        now, base,
        "bus_no_receivers_total must NOT increment when at least one subscriber exists"
    );
}

```

### crates/ron-kernel/src/bus/topic.rs
<a id="crates-ron-kernel-src-bus-topic-rs"></a>

```rust
//! RO:WHAT — Topic-scoped buses (internal utility).
//! RO:WHY  — Allows internal modules/tests to use name-scoped buses without changing public API.
//! RO:INTERACTS — bus::bounded::Bus, metrics (optional).
//! RO:INVARIANTS — No cross-topic delivery; lazy create; no external re-export.
//! RO:METRICS/LOGS — bus_topics_total (gauge).
//! RO:CONFIG — N/A.
//! RO:SECURITY — N/A.

#![allow(dead_code)]

use std::{collections::HashMap, sync::Arc};
use parking_lot::RwLock;

use super::bounded::Bus;
use crate::metrics::exporter::Metrics;

pub type Topic = &'static str;

#[derive(Default)]
pub struct TopicBus<T: Clone + Send + 'static> {
    inner: RwLock<HashMap<Topic, Bus<T>>>,
    metrics: Option<Arc<Metrics>>,
}

impl<T: Clone + Send + 'static> TopicBus<T> {
    pub fn new() -> Self {
        Self {
            inner: RwLock::new(HashMap::new()),
            metrics: None,
        }
    }

    pub fn with_metrics(mut self, metrics: Arc<Metrics>) -> Self {
        self.metrics = Some(metrics);
        self
    }

    pub fn topic(&self, name: Topic) -> Bus<T> {
        let mut guard = self.inner.write();
        if let Some(bus) = guard.get(name) {
            return bus.clone();
        }
        let bus = match &self.metrics {
            Some(m) => Bus::new().with_metrics(m.clone()),
            None => Bus::new(),
        };
        guard.insert(name, bus.clone());
        if let Some(m) = &self.metrics {
            // FIX: use the correct gauge field name from Metrics
            m.bus_topics_total.set(guard.len() as i64);
        }
        bus
    }
}

```

### crates/ron-kernel/src/config/cell.rs
<a id="crates-ron-kernel-src-config-cell-rs"></a>

```rust
//! RO:WHAT — Tiny interior-mutable holder for `Config` with get/set.
//! RO:WHY  — Several subsystems (watcher, HTTP surfaces) need a shared view.
//! RO:INTERACTS — Used by `config::watcher` to apply hot-reloads.
//! RO:INVARIANTS — Reads are lock-free clone; writes replace atomically.

use parking_lot::RwLock;
use std::sync::Arc;

use super::Config;

#[derive(Clone)]
pub struct ConfigCell {
    inner: Arc<RwLock<Config>>,
}

impl ConfigCell {
    pub fn new(init: Config) -> Self {
        Self {
            inner: Arc::new(RwLock::new(init)),
        }
    }

    /// Snapshot the current config (cheap clone).
    #[inline]
    pub fn get(&self) -> Config {
        self.inner.read().clone()
    }

    /// Replace with a new config, returning the old snapshot.
    #[inline]
    pub fn set(&self, new_cfg: Config) -> Config {
        let mut w = self.inner.write();
        let old = w.clone();
        *w = new_cfg;
        old
    }
}

```

### crates/ron-kernel/src/config/mod.rs
<a id="crates-ron-kernel-src-config-mod-rs"></a>

```rust
/*!
Config — load + hot-reload + event emission.

Rules:
- Precedence: ENV > FILE > DEFAULTS.
- Autobump version if a semantic toggle (e.g., amnesia) changes without explicit version.
- No-op writes do not emit `ConfigUpdated`.

Surface (kept minimal/by-canon):
- `Config` — current kernel config (version, amnesia).
- `ConfigUpdated` — DTO used by reload/apply decision paths.
- `ConfigCell` — tiny Arc<RwLock<Config>> for shared access (watcher/HTTP/etc.).
- `validation` — guardrails for field sanity.
- `watcher` — polling file-watcher that applies hot-reloads and emits events.
*/

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::{env, fs, path::Path};

// Submodules (exported)
pub mod cell;
pub mod validation;
pub mod watcher;

pub use cell::ConfigCell;

/// Kernel configuration loaded from file/env with sane defaults.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Config {
    /// Monotonically increasing config version used to order updates.
    pub version: u64,
    /// When `true`, run in amnesia mode (RAM-only posture surfaced to metrics).
    pub amnesia: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            version: 1,
            amnesia: true, // keep your current default; demo flips this live via watcher/ENV
        }
    }
}

/// DTO published on the bus when a new configuration becomes active.
#[derive(Debug, Clone)]
pub struct ConfigUpdated {
    /// Version that became active after reload/autobump.
    pub version: u64,
}

/// Load configuration from `path` (if it exists), then apply ENV overrides.
///
/// ENV precedence:
/// - `RON_AMNESIA` — truthy strings: `1|true|on|yes` (case-insensitive)
/// - `RON_VERSION` — `u64` parse
pub fn load_from(path: impl AsRef<Path>) -> Result<Config> {
    // Defaults
    let mut cfg = Config::default();

    // File
    if path.as_ref().exists() {
        let raw = fs::read_to_string(path.as_ref()).with_context(|| "read config file")?;
        let from_file: Config = toml::from_str(&raw).with_context(|| "parse toml")?;
        cfg = from_file;
    }

    // ENV overrides
    if let Ok(s) = env::var("RON_AMNESIA") {
        cfg.amnesia = is_truthy(&s);
    }

    if let Ok(v) = env::var("RON_VERSION") {
        cfg.version = v.parse::<u64>().with_context(|| "RON_VERSION parse")?;
    }

    // Final guardrails
    validation::validate(&cfg)?;

    Ok(cfg)
}

/// Compare `old` vs `new` and decide if we should emit `ConfigUpdated`.
///
/// Logic:
/// - No-op (identical) → `None`
/// - Only `amnesia` flipped and version unchanged → **autobump** and emit
/// - Any change with version increase → emit
pub fn apply_reload(old: &Config, mut new: Config) -> Option<ConfigUpdated> {
    if new == *old {
        return None;
    }

    // Guardrails (defensive): keep decisions on validated data.
    if validation::validate(&new).is_err() {
        // Invalid new config ⇒ do not emit; caller may log/telemetry an error.
        return None;
    }

    let amnesia_changed = new.amnesia != old.amnesia;
    let version_increased = new.version > old.version;

    if amnesia_changed && !version_increased {
        // Autobump: preserve monotonic versioning on semantic-only flips.
        new.version = old.version.saturating_add(1);
        return Some(ConfigUpdated {
            version: new.version,
        });
    }

    if version_increased || amnesia_changed {
        return Some(ConfigUpdated {
            version: new.version,
        });
    }

    None
}

/// Accepts "1|true|on|yes" (case-insensitive) as truthy; everything else is false.
#[inline]
fn is_truthy(s: &str) -> bool {
    matches!(
        s.trim().to_ascii_lowercase().as_str(),
        "1" | "true" | "on" | "yes"
    )
}

```

### crates/ron-kernel/src/config/validation.rs
<a id="crates-ron-kernel-src-config-validation-rs"></a>

```rust
//! RO:WHAT — Pure validation/sanitization for `Config`.
//! RO:WHY  — Keeps I/O out of validation; enables property/fuzz tests; SEC/RES concern.
//! RO:INTERACTS — config::watcher (apply), metrics/readiness (config_loaded), events.
//! RO:INVARIANTS — Deterministic; no side effects; clamps to safe ranges; deny unknown fields on struct.
//! RO:METRICS/LOGS — N/A.
//! RO:CONFIG — Validates {version, amnesia}; extend as struct grows.
//! RO:SECURITY — Reject malformed values early.
//! RO:TEST HOOKS — table tests; property: idempotent sanitize.

use crate::Config; // expected re-export at crate root per project notes

#[derive(thiserror::Error, Debug)]
pub enum ConfigError {
    #[error("version must be >= {0}")]
    InvalidVersion(u64),
}

const VERSION_MIN: u64 = 1;

/// Validate a config snapshot against canonical guardrails.
///
/// Current canon:
/// - `version` must be >= 1 (monotonic sequence used for ordering reloads)
/// - `amnesia` is a boolean (always valid)
pub fn validate(cfg: &Config) -> Result<(), ConfigError> {
    if cfg.version < VERSION_MIN {
        return Err(ConfigError::InvalidVersion(VERSION_MIN));
    }
    Ok(())
}

/// Sanitize a config by clamping to safe ranges, preserving semantics.
/// Idempotent: calling twice yields the same result.
///
/// Current canon:
/// - Clamp `version` to at least 1
/// - `amnesia` unchanged (boolean)
pub fn sanitize(mut cfg: Config) -> Result<Config, ConfigError> {
    if cfg.version < VERSION_MIN {
        cfg.version = VERSION_MIN;
    }
    // `amnesia` requires no changes.
    validate(&cfg)?;
    Ok(cfg)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn validate_ok() {
        let cfg = Config {
            version: 1,
            amnesia: false,
        };
        assert!(validate(&cfg).is_ok());
    }

    #[test]
    fn validate_rejects_version_zero() {
        let cfg = Config {
            version: 0,
            amnesia: true,
        };
        assert!(validate(&cfg).is_err());
    }

    #[test]
    fn sanitize_clamps_version_and_is_idempotent() {
        let cfg = Config {
            version: 0,
            amnesia: true,
        };
        let a = sanitize(cfg).unwrap();
        assert_eq!(a.version, 1);
        assert!(a.amnesia);

        let b = sanitize(a.clone()).unwrap();
        assert_eq!(a, b); // idempotent
    }
}

```

### crates/ron-kernel/src/config/watcher.rs
<a id="crates-ron-kernel-src-config-watcher-rs"></a>

```rust
//! RO:WHAT — Config watchers: filesystem (TOML) + env poller.
//! RO:WHY  — Hot-reload posture without blocking; keep amnesia gauge in sync.
//! RO:INVARIANTS — Non-blocking; no locks across .await; errors are logged and ignored; only emit on real change.

use anyhow::Context;
use notify::{
    Config as NotifyConfig, Event, EventKind, RecommendedWatcher, RecursiveMode, Watcher,
};
use std::{env, path::PathBuf, sync::Arc};
use tokio::{fs, sync::mpsc, task};

use super::{validation::validate, Config, ConfigCell};
use crate::bus::bounded::Bus;
use crate::events::KernelEvent;
use crate::Metrics;

/// Spawn a file watcher on a TOML file. On write/create, parse and apply if changed.
pub fn spawn_file_watcher(
    path: PathBuf,
    cell: ConfigCell,
    bus: Bus<KernelEvent>,
    metrics: Arc<Metrics>,
    autobump: bool,
) {
    let (tx, mut rx) = mpsc::unbounded_channel::<()>();

    // Blocking thread for notify (keeps OS handle alive).
    let path_clone = path.clone();
    let _handle = task::spawn_blocking(move || {
        let tx_inner = tx.clone();
        let mut watcher: RecommendedWatcher = RecommendedWatcher::new(
            move |res: Result<Event, notify::Error>| {
                if let Ok(event) = res {
                    match event.kind {
                        EventKind::Create(_) | EventKind::Modify(_) => {
                            let _ = tx_inner.send(());
                        }
                        _ => {}
                    }
                }
            },
            NotifyConfig::default(),
        )
        .expect("create watcher");

        watcher
            .watch(&path_clone, RecursiveMode::NonRecursive)
            .expect("watch path");

        loop {
            std::thread::park();
        }
    });

    // Async side: on signal, reload and apply.
    tokio::spawn(async move {
        while let Some(()) = rx.recv().await {
            if let Err(e) = reload_from_file(&path, &cell, &bus, &metrics, autobump).await {
                eprintln!("[kernel.config] failed to reload {:?}: {e:#}", path);
            }
        }
    });
}

/// Reload the config from TOML and apply it (only if changed). May autobump version.
async fn reload_from_file(
    path: &PathBuf,
    cell: &ConfigCell,
    bus: &Bus<KernelEvent>,
    metrics: &Arc<Metrics>,
    autobump: bool,
) -> anyhow::Result<()> {
    let bytes = fs::read(path)
        .await
        .with_context(|| format!("read {:?}", path))?;
    let text = String::from_utf8_lossy(&bytes);
    let mut file_cfg: Config =
        toml::from_str(&text).with_context(|| format!("parse TOML {:?}", path))?;

    // Validate before touching shared state.
    validate(&file_cfg).with_context(|| "validate file config")?;

    let old = cell.get();

    // CONTENT-based change: in our minimal config, content == {amnesia}
    let content_changed = old.amnesia != file_cfg.amnesia;

    if !autobump {
        // Strict mode: apply only when the whole struct differs.
        if old == file_cfg {
            return Ok(());
        }
        // Apply as-is (file controls version).
        cell.set(file_cfg.clone());
        metrics.set_amnesia(file_cfg.amnesia);
        let _ = bus.publish(KernelEvent::ConfigUpdated {
            version: file_cfg.version,
        });
        return Ok(());
    }

    // Autobump mode: apply only when content changes; set version = max(file.version, old.version + 1).
    if content_changed {
        if file_cfg.version <= old.version {
            file_cfg.version = old.version.saturating_add(1);
        }
        cell.set(file_cfg.clone());
        metrics.set_amnesia(file_cfg.amnesia);
        let _ = bus.publish(KernelEvent::ConfigUpdated {
            version: file_cfg.version,
        });
        return Ok(());
    }

    // No content change. Optionally adopt a higher version from file (no event).
    if file_cfg.version > old.version {
        let mut next = old.clone();
        next.version = file_cfg.version;
        cell.set(next);
        // No event — content unchanged; version-only bump is local bookkeeping.
    }

    Ok(())
}

/// Spawn an env poller that checks a single key and toggles amnesia on change.
/// Values: on|off|true|false|1|0 (case-insensitive). Emits only on real change; may autobump.
pub fn spawn_env_poller(
    key: &'static str,
    poll_secs: u64,
    cell: ConfigCell,
    bus: Bus<KernelEvent>,
    metrics: Arc<Metrics>,
    autobump: bool,
) {
    tokio::spawn(async move {
        // Seed from env on boot, if present.
        if let Some(v) = read_bool_env(key) {
            let old = cell.get();
            if old.amnesia != v {
                let mut next = old.clone();
                next.amnesia = v;
                if autobump {
                    next.version = next.version.saturating_add(1);
                }
                // Validate the prospective config before apply (should always pass).
                if validate(&next).is_ok() {
                    cell.set(next.clone());
                    metrics.set_amnesia(next.amnesia);
                    let _ = bus.publish(KernelEvent::ConfigUpdated {
                        version: next.version,
                    });
                }
            }
        }

        let mut last = read_bool_env(key);
        let mut interval = tokio::time::interval(std::time::Duration::from_secs(poll_secs));
        loop {
            interval.tick().await;
            let curr = read_bool_env(key);
            if curr != last {
                last = curr;
                if let Some(v) = curr {
                    let old = cell.get();
                    if old.amnesia != v {
                        let mut next = old.clone();
                        next.amnesia = v;
                        if autobump {
                            next.version = next.version.saturating_add(1);
                        }
                        if validate(&next).is_ok() {
                            cell.set(next.clone());
                            metrics.set_amnesia(next.amnesia);
                            let _ = bus.publish(KernelEvent::ConfigUpdated {
                                version: next.version,
                            });
                        }
                    }
                }
            }
        }
    });
}

/// Parse boolean-ish env values.
fn read_bool_env(key: &str) -> Option<bool> {
    env::var(key)
        .ok()
        .and_then(|s| match s.to_ascii_lowercase().as_str() {
            "1" | "true" | "on" | "yes" => Some(true),
            "0" | "false" | "off" | "no" => Some(false),
            _ => None,
        })
}

```

### crates/ron-kernel/src/events.rs
<a id="crates-ron-kernel-src-events-rs"></a>

```rust
//! RO:WHAT — KernelEvent enum shared across the kernel bus.
//! RO:WHY  — Central, stable event vocabulary for kernel interactions.
//! RO:INVARIANTS — Backward-compatible additions only; no breaking renames.

/// Events published on the kernel bus.
#[derive(Debug, Clone)]
pub enum KernelEvent {
    /// Health probe from a service (declarative signal).
    Health {
        /// Service name emitting the health status.
        service: String,
        /// Whether the service currently reports healthy.
        ok: bool,
    },
    /// Configuration updated to a monotonic version.
    ConfigUpdated {
        /// Version that became active.
        version: u64,
    },
    /// A supervised service crashed (supervisor should record+restart).
    ServiceCrashed {
        /// Service name that crashed.
        service: String,
    },
    /// Request orderly shutdown of the kernel.
    Shutdown,
}

```

### crates/ron-kernel/src/health/mod.rs
<a id="crates-ron-kernel-src-health-mod-rs"></a>

```rust
/*!
Health state — liveness vs readiness (degrade-first).

- Uses `parking_lot::RwLock` (faster, no poisoning).
- `all_ready()` governs `/readyz` (true → 200, false → 503 + `Retry-After: 1`).
- `missing()` returns a stable list for `/readyz` body.
*/

use parking_lot::RwLock;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

/// Snapshot of coarse-grained health used by kernel/demo routes.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct HealthSnapshot {
    /// True when essential services are running (supervisors satisfied).
    pub services_ok: bool,
    /// True when configuration load completed and is valid.
    pub config_loaded: bool,
    /// Current amnesia posture (observable; not part of readiness truth).
    pub amnesia: bool,
}

/// Mutable health state with cheap readers and exclusive writers.
#[derive(Debug, Default)]
pub struct HealthState {
    inner: RwLock<HealthSnapshot>,
}

impl HealthState {
    /// Construct a new health state wrapped in `Arc`.
    pub fn new() -> Arc<Self> {
        Arc::new(Self {
            inner: RwLock::new(HealthSnapshot::default()),
        })
    }

    /// Mutate the snapshot in place.
    pub fn set(&self, f: impl FnOnce(&mut HealthSnapshot)) {
        let mut guard = self.inner.write();
        f(&mut guard);
    }

    /// Obtain a cheap cloned snapshot.
    pub fn snapshot(&self) -> HealthSnapshot {
        self.inner.read().clone()
    }

    /// Readiness policy: *both* services and config must be OK.
    pub fn all_ready(&self) -> bool {
        let s = self.inner.read();
        s.services_ok && s.config_loaded
    }

    /// Names of components that currently prevent readiness.
    pub fn missing(&self) -> Vec<String> {
        let s = self.inner.read();
        let mut out = Vec::new();
        if !s.services_ok {
            out.push("services".to_string());
        }
        if !s.config_loaded {
            out.push("config".to_string());
        }
        out
    }
}

```

### crates/ron-kernel/src/internal/constants.rs
<a id="crates-ron-kernel-src-internal-constants-rs"></a>

```rust
//! RO:WHAT — Centralized constants for kernel tuning and invariants.
//! RO:WHY  — Keep perf/backpressure and retry limits consistent with blueprints (avoid drift).
//! RO:INTERACTS — bus capacity (bus::Bus), supervisor backoff (supervisor), readiness (metrics).
//! RO:INVARIANTS — bounded queues; backoff caps; no unbounded growth anywhere.

/// Default broadcast capacity per sender (bounded).
#[allow(dead_code)]
pub const DEFAULT_BUS_CAPACITY: usize = 4096;

/// Supervisor backoff: initial delay in milliseconds.
pub const SUP_BACKOFF_MS_START: u64 = 100;

/// Supervisor backoff cap in milliseconds (jittered up to this).
pub const SUP_BACKOFF_MS_CAP: u64 = 30_000;

```

### crates/ron-kernel/src/internal/mod.rs
<a id="crates-ron-kernel-src-internal-mod-rs"></a>

```rust
//! RO:WHAT — Internal glue (non-public) for kernel constants and helpers.
//! RO:WHY  — Keep public surface frozen; avoid leaking new types.
//! RO:INTERACTS — constants used by bus/supervisor; not re-exported.
pub mod constants;

```

### crates/ron-kernel/src/internal/types.rs
<a id="crates-ron-kernel-src-internal-types-rs"></a>

```rust
//! RO:WHAT — Internal shared type aliases and small enums.
//! RO:WHY  — Reduces duplication and drift across modules; GOV/RES concern.
//! RO:INTERACTS — supervisor, metrics, bus, readiness, config.
//! RO:INVARIANTS — No heavy deps; stable aliases only; no cross-await locks introduced.
//! RO:METRICS/LOGS — N/A.
//! RO:CONFIG — N/A.
//! RO:SECURITY — N/A.
//! RO:TEST HOOKS — Type-only; covered transitively by module tests.

use std::time::Duration;

pub type ServiceName = &'static str;
pub type Version = u64;
pub type Millis = u64;
pub type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;

/// Default bounded channel capacity for the in-process bus.
pub const DEFAULT_BUS_CAPACITY: usize = 1024;

/// Reason a supervised child stopped.
#[derive(Debug, Clone)]
pub enum CrashReason {
    Panic(String),
    Exit(i32),
    Oom,
    Error(String),
    Unknown,
}

/// Jitter bounds helper.
#[inline]
pub fn clamp_duration(v: Duration, min: Duration, max: Duration) -> Duration {
    if v < min {
        min
    } else if v > max {
        max
    } else {
        v
    }
}

```

### crates/ron-kernel/src/lib.rs
<a id="crates-ron-kernel-src-lib-rs"></a>

```rust
//! # ron-kernel — microkernel core
//!
//! RO:WHAT
//!   Crate root for the RustyOnions microkernel. Exposes the frozen public API:
//!   `Bus`, `KernelEvent`, `Metrics`, `HealthState`, `Config`, and `wait_for_ctrl_c()`.
//!
//! RO:WHY
//!   Provide lifecycle/supervision, readiness gates, config hot-reload, bounded event bus,
//!   and canonical observability surfaces (/metrics, /healthz, /readyz) for nodes.
//!
//! RO:INVARIANTS
//!   - Public API is semver-guarded; perf toggles live behind features and default OFF.
//!   - Readiness contract: `/readyz` returns 503 until BOTH (config_loaded && services_healthy).
//!   - Concurrency: no locks across `.await`; bounded channels; one receiver per task.
//!   - Amnesia mode surfaced via metrics (`amnesia_mode` gauge) and events.
//!
//! See: `examples/kernel_demo` for an integration sanity run.
#![forbid(unsafe_code)]
#![deny(clippy::all, clippy::pedantic)]
#![allow(clippy::module_name_repetitions)]

/// A3 helper — capacity autotune — re-exported at crate root for stable imports in tests/benches.
#[cfg(feature = "bus_autotune_cap")]
pub use crate::bus::autotune_capacity;

// -----------------------------------------------------------------------------
// Internal structure
// -----------------------------------------------------------------------------

pub mod internal {
    pub mod types;
}

pub mod amnesia;

pub mod events; // KernelEvent enum
pub mod shutdown; // wait_for_ctrl_c()

// IMPORTANT: use the directory module so we pick up `bus/mod.rs` and its feature wiring.
// (Previously this was an inline `pub mod bus { ... }`, which prevented `bus/mod.rs` from loading.)
pub mod bus;

pub mod metrics;

// Use your existing config module (which itself may declare submodules like watcher/validation)
pub mod config;

// Supervision
pub mod supervisor {
    pub mod backoff;
    pub mod child;
    pub mod lifecycle;
}

// -----------------------------------------------------------------------------
// Frozen public API re-exports (SemVer-guarded)
// -----------------------------------------------------------------------------
pub use crate::bus::bounded::Bus;
pub use crate::config::Config;
pub use crate::events::KernelEvent;
pub use crate::metrics::exporter::Metrics;
pub use crate::metrics::health::HealthState;
pub use crate::shutdown::wait_for_ctrl_c;

// If you maintain an experimental MOG helper module at crate root, keep this.
// If it doesn't exist in your tree, comment/remove the next line to avoid compile errors.
pub mod mog_autotune;

```

### crates/ron-kernel/src/metrics/buffer.rs
<a id="crates-ron-kernel-src-metrics-buffer-rs"></a>

```rust
//! RO:WHAT — Thread-local metric buffers for hot-path counters (feature: metrics_buf).
//! RO:WHY  — PERF: remove atomics from publish path; flush deltas on a timer or threshold.
//! RO:INTERACTS — metrics::exporter::Metrics (Prometheus registry)
//! RO:INVARIANTS — no locks across .await on hot path; best-effort flush on drop
//! RO:METRICS — bus_metrics_tls_flush_total (+ existing counters)
//! RO:CONFIG — flush interval (ms), flush threshold (events)
//! RO:TEST — unit: tls_no_loss_on_drop(); fuzz: interleaved_flush_ordering()

#![cfg(feature = "metrics_buf")]

use prometheus::IntCounter;
use std::{cell::Cell, sync::Arc};
use tokio::sync::Mutex;

thread_local! {
    static PUBLISHED_BUF: Cell<u64> = const { Cell::new(0) };
    static NOTIFY_BUF:    Cell<u64> = const { Cell::new(0) };
}

// Shared sinks owned by the exporter; hot path writes to TLS cells and we flush into these.
#[derive(Clone)]
pub struct BufferedSinks {
    pub published: IntCounter,
    pub notify: IntCounter,
    pub tls_flush_total: IntCounter,
    // threshold for flushing TLS buffers
    flush_threshold: Arc<usize>,
}

impl BufferedSinks {
    pub fn new(
        published: IntCounter,
        notify: IntCounter,
        tls_flush_total: IntCounter,
        flush_threshold: usize,
    ) -> Self {
        // Guardrail: enforce a minimum of 64 to avoid per-message flush in prod.
        Self {
            published,
            notify,
            tls_flush_total,
            flush_threshold: Arc::new(flush_threshold.max(64)),
        }
    }

    #[inline]
    pub fn add_published(&self, n: u64) {
        if n == 0 {
            return;
        }
        PUBLISHED_BUF.with(|c| c.set(c.get().saturating_add(n)));
        self.maybe_flush();
    }

    #[inline]
    pub fn add_notify(&self, n: u64) {
        if n == 0 {
            return;
        }
        NOTIFY_BUF.with(|c| c.set(c.get().saturating_add(n)));
        self.maybe_flush();
    }

    #[inline]
    fn maybe_flush(&self) {
        let thr = *self.flush_threshold as u64;
        let mut do_flush = false;
        PUBLISHED_BUF.with(|c| {
            if c.get() >= thr {
                do_flush = true;
            }
        });
        NOTIFY_BUF.with(|c| {
            if c.get() >= thr {
                do_flush = true;
            }
        });
        if do_flush {
            self.flush();
        }
    }

    pub fn flush(&self) {
        let mut p = 0u64;
        let mut n = 0u64;
        PUBLISHED_BUF.with(|c| {
            p = c.get();
            c.set(0);
        });
        NOTIFY_BUF.with(|c| {
            n = c.get();
            c.set(0);
        });
        if p != 0 {
            self.published.inc_by(p);
        }
        if n != 0 {
            self.notify.inc_by(n);
        }
        if p != 0 || n != 0 {
            self.tls_flush_total.inc();
        }
    }
}

// Background pump handle (periodically flush TLS buffers into shared counters).
#[derive(Clone)]
pub struct FlushPump {
    sinks: BufferedSinks,
    // keep a stop latch if you want (not strictly required in the kernel's long-lived proc)
    stop: Arc<Mutex<bool>>,
}

impl FlushPump {
    pub fn new(sinks: BufferedSinks) -> Self {
        Self {
            sinks,
            stop: Arc::new(Mutex::new(false)),
        }
    }

    /// Convenience for exporter: build a pump from the hot counters facade.
    pub fn new_from_hot(hot: Arc<HotCounters>) -> Self {
        // Same module, can access the inner to clone sinks.
        Self::new(hot.0.clone())
    }

    pub async fn run(self, interval_ms: u64) {
        let mut ticker =
            tokio::time::interval(std::time::Duration::from_millis(interval_ms.max(1)));
        loop {
            ticker.tick().await;
            if *self.stop.lock().await {
                break;
            }
            self.sinks.flush();
        }
    }
}

// Public facade used by the bus (hot path).
#[derive(Clone)]
pub struct HotCounters(pub(super) BufferedSinks);

impl HotCounters {
    pub fn new(sinks: BufferedSinks) -> Self {
        Self(sinks)
    }
    #[inline]
    pub fn inc_published(&self) {
        self.0.add_published(1);
    }
    #[inline]
    pub fn add_published(&self, n: u64) {
        self.0.add_published(n);
    }
    #[inline]
    pub fn inc_notify(&self) {
        self.0.add_notify(1);
    }
}

/// Best-effort drop flush to avoid counter loss on thread teardown.
impl Drop for HotCounters {
    fn drop(&mut self) {
        self.0.flush();
    }
}

```

### crates/ron-kernel/src/metrics/exporter.rs
<a id="crates-ron-kernel-src-metrics-exporter-rs"></a>

```rust
//! RO:WHAT — Prometheus exporter + metrics registry; mounts /metrics, /healthz, /readyz.
//! RO:WHY  — Observability pillar; RED metrics and kernel signals for ops; PERF/RES concerns.
//! RO:PERF — Optional thread-local metrics buffering (feature: `metrics_buf`) removes atomics from the hot path.
//! RO:MOG  — A1/A5 edge notify counters; A2 batch publish counters; TLS buffer flush counter.

use std::{net::SocketAddr, sync::Arc};

use axum::{routing::get, Router};
use prometheus::{
    Encoder, Histogram, HistogramOpts, IntCounter, IntCounterVec, IntGauge, Opts, Registry,
    TextEncoder,
};
use tokio::{net::TcpListener, task::JoinHandle};

use crate::internal::types::{BoxError, ServiceName};
use crate::metrics::{health::HealthState, readiness::Readiness};
use crate::Bus;

#[cfg(feature = "metrics_buf")]
use crate::metrics::buffer::{BufferedSinks, FlushPump, HotCounters};

/// Kernel metrics registry and handles.
#[derive(Clone)]
pub struct Metrics {
    pub registry: Registry,
    pub request_latency_seconds: Histogram,

    pub service_restarts_total: IntCounterVec,

    // Bus counters/gauges
    pub bus_published_total: IntCounter,
    pub bus_no_receivers_total: IntCounter,
    pub bus_receiver_lag_total: IntCounter,
    pub bus_dropped_total: IntCounter,
    pub bus_topics_total: IntGauge,

    // MOG A1/A5 telemetry
    pub bus_notify_sends_total: IntCounter,
    pub bus_notify_suppressed_total: IntCounter,

    // MOG A2 telemetry
    pub bus_batch_publish_total: IntCounter,
    pub bus_batch_len_histogram: Histogram,

    // TLS metrics buffering visibility
    #[cfg(feature = "metrics_buf")]
    pub bus_metrics_tls_flush_total: IntCounter,

    // Expose configured TLS threshold as a gauge for easy verification
    #[cfg(feature = "metrics_buf")]
    pub bus_metrics_tls_threshold: IntGauge,

    pub amnesia_mode: IntGauge,

    // Hot-path counters facade (kept behind Arc to avoid per-call Drop)
    #[cfg(feature = "metrics_buf")]
    hot: Option<Arc<HotCounters>>,
}

impl Metrics {
    pub fn new(initial_amnesia: bool) -> Arc<Self> {
        let registry = Registry::new();

        let request_latency_seconds = Histogram::with_opts(
            HistogramOpts::new(
                "request_latency_seconds",
                "Kernel request latency (seconds)",
            )
            .buckets(vec![
                0.0005, 0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0,
            ]),
        )
        .expect("histogram");

        let service_restarts_total = IntCounterVec::new(
            Opts::new(
                "service_restarts_total",
                "Total restarts of supervised services",
            ),
            &["service"],
        )
        .expect("counter vec");

        let bus_published_total = IntCounter::with_opts(Opts::new(
            "bus_published_total",
            "Total messages published on kernel bus",
        ))
        .unwrap();
        let bus_no_receivers_total = IntCounter::with_opts(Opts::new(
            "bus_no_receivers_total",
            "Publishes with zero receivers",
        ))
        .unwrap();
        let bus_receiver_lag_total = IntCounter::with_opts(Opts::new(
            "bus_receiver_lag_total",
            "Lagged/missed messages observed by receivers",
        ))
        .unwrap();
        let bus_dropped_total = IntCounter::with_opts(Opts::new(
            "bus_dropped_total",
            "Messages dropped due to closed/overrun channel",
        ))
        .unwrap();
        let bus_topics_total = IntGauge::with_opts(Opts::new(
            "bus_topics_total",
            "Number of distinct topic buses",
        ))
        .unwrap();

        // A1/A5
        let bus_notify_sends_total = IntCounter::with_opts(Opts::new(
            "bus_notify_sends_total",
            "Edge-triggered notifies sent to subscribers",
        ))
        .unwrap();
        let bus_notify_suppressed_total = IntCounter::with_opts(Opts::new(
            "bus_notify_suppressed_total",
            "Notifies suppressed by pending=true (coalesced)",
        ))
        .unwrap();

        // A2
        let bus_batch_publish_total = IntCounter::with_opts(Opts::new(
            "bus_batch_publish_total",
            "Calls to publish_many (A2)",
        ))
        .unwrap();
        let bus_batch_len_histogram = Histogram::with_opts(
            HistogramOpts::new("bus_batch_len_histogram", "publish_many batch sizes (A2)").buckets(
                vec![
                    1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0, 1024.0,
                ],
            ),
        )
        .expect("histogram");

        // Amnesia gauge
        let amnesia_mode =
            IntGauge::with_opts(Opts::new("amnesia_mode", "1 when amnesia mode is enabled"))
                .unwrap();

        // Register all
        registry
            .register(Box::new(request_latency_seconds.clone()))
            .unwrap();
        registry
            .register(Box::new(service_restarts_total.clone()))
            .unwrap();
        registry
            .register(Box::new(bus_published_total.clone()))
            .unwrap();
        registry
            .register(Box::new(bus_no_receivers_total.clone()))
            .unwrap();
        registry
            .register(Box::new(bus_receiver_lag_total.clone()))
            .unwrap();
        registry
            .register(Box::new(bus_dropped_total.clone()))
            .unwrap();
        registry
            .register(Box::new(bus_topics_total.clone()))
            .unwrap();
        registry
            .register(Box::new(bus_notify_sends_total.clone()))
            .unwrap();
        registry
            .register(Box::new(bus_notify_suppressed_total.clone()))
            .unwrap();
        registry
            .register(Box::new(bus_batch_publish_total.clone()))
            .unwrap();
        registry
            .register(Box::new(bus_batch_len_histogram.clone()))
            .unwrap();
        registry.register(Box::new(amnesia_mode.clone())).unwrap();

        // TLS buffering metrics
        #[cfg(feature = "metrics_buf")]
        let bus_metrics_tls_flush_total = {
            let c = IntCounter::with_opts(Opts::new(
                "bus_metrics_tls_flush_total",
                "TLS metrics buffer flushes (visibility when buffering is enabled)",
            ))
            .unwrap();
            registry.register(Box::new(c.clone())).ok();
            c
        };

        #[cfg(feature = "metrics_buf")]
        let bus_metrics_tls_threshold = {
            let g = IntGauge::with_opts(Opts::new(
                "bus_metrics_tls_threshold",
                "Configured TLS flush threshold",
            ))
            .unwrap();
            registry.register(Box::new(g.clone())).ok();
            g
        };

        // Choose and publish the threshold; construct sinks + hot facade.
        #[cfg(feature = "metrics_buf")]
        let (hot, chosen_threshold) = {
            let threshold: usize = 64; // tune under benches (64..512)
            let sinks = BufferedSinks::new(
                bus_published_total.clone(),
                bus_notify_sends_total.clone(),
                bus_metrics_tls_flush_total.clone(),
                threshold,
            );
            (Some(Arc::new(HotCounters::new(sinks))), threshold)
        };

        #[cfg(feature = "metrics_buf")]
        {
            bus_metrics_tls_threshold.set(chosen_threshold as i64);
            tracing::info!(
                threshold = chosen_threshold,
                "metrics_buf enabled; TLS flush threshold configured"
            );
        }

        let me = Arc::new(Self {
            registry,
            request_latency_seconds,
            service_restarts_total,
            bus_published_total,
            bus_no_receivers_total,
            bus_receiver_lag_total,
            bus_dropped_total,
            bus_topics_total,
            bus_notify_sends_total,
            bus_notify_suppressed_total,
            bus_batch_publish_total,
            bus_batch_len_histogram,
            #[cfg(feature = "metrics_buf")]
            bus_metrics_tls_flush_total,
            #[cfg(feature = "metrics_buf")]
            bus_metrics_tls_threshold,
            amnesia_mode,
            #[cfg(feature = "metrics_buf")]
            hot,
        });

        me.set_amnesia(initial_amnesia);
        me
    }

    pub fn set_amnesia(&self, on: bool) {
        self.amnesia_mode.set(if on { 1 } else { 0 });
    }

    /// Start HTTP server exposing /metrics, /healthz, /readyz.
    pub async fn serve(
        self: Arc<Self>,
        addr: SocketAddr,
        health: HealthState,
        ready: Readiness,
    ) -> Result<(JoinHandle<()>, SocketAddr), BoxError> {
        let listener = TcpListener::bind(addr).await?;
        let local = listener.local_addr()?;

        let registry = self.registry.clone();
        let app = Router::new()
            .route(
                "/metrics",
                get(move || {
                    let registry = registry.clone();
                    async move {
                        let mf = registry.gather();
                        let mut buf = Vec::new();
                        TextEncoder::new().encode(&mf, &mut buf).unwrap();
                        (axum::http::StatusCode::OK, buf)
                    }
                }),
            )
            .route(
                "/healthz",
                get({
                    let health = health.clone();
                    move || crate::metrics::health::healthz_handler(health.clone())
                }),
            )
            .route(
                "/readyz",
                get({
                    let ready = ready.clone();
                    move || crate::metrics::readiness::readyz_handler(ready.clone())
                }),
            );

        let handle = tokio::spawn(async move {
            axum::serve(listener, app).await.ok();
        });

        #[cfg(feature = "metrics_buf")]
        if let Some(hot) = self.hot.clone() {
            let pump = FlushPump::new_from_hot(hot);
            tokio::spawn(async move { pump.run(200).await }); // ~200ms cadence
        }

        Ok((handle, local))
    }

    pub fn inc_restart(&self, service: ServiceName) {
        self.service_restarts_total
            .with_label_values(&[service])
            .inc();
    }

    pub fn make_bus<T: Clone + Send + 'static>(self: &Arc<Self>, capacity: usize) -> Bus<T> {
        use crate::bus::bounded::Bus;
        Bus::with_capacity(capacity).with_metrics(self.clone())
    }

    #[cfg(feature = "metrics_buf")]
    #[inline]
    pub fn hot(&self) -> Option<&HotCounters> {
        self.hot.as_deref()
    }
}

```

### crates/ron-kernel/src/metrics/health.rs
<a id="crates-ron-kernel-src-metrics-health-rs"></a>

```rust
use std::collections::BTreeMap;
use std::sync::Arc;

use axum::{response::IntoResponse, Json};
use parking_lot::RwLock;

use crate::internal::types::ServiceName;

#[derive(Clone)]
pub struct HealthState {
    inner: Arc<RwLock<BTreeMap<ServiceName, bool>>>,
}

impl HealthState {
    pub fn new() -> Self {
        Self {
            inner: Arc::new(RwLock::new(BTreeMap::new())),
        }
    }

    pub fn set(&self, service: ServiceName, ok: bool) {
        let mut w = self.inner.write();
        w.insert(service, ok);
    }

    pub fn snapshot(&self) -> BTreeMap<ServiceName, bool> {
        self.inner.read().clone()
    }

    pub fn all_ready(&self) -> bool {
        // Not ready until at least one service has reported AND all are healthy.
        let r = self.inner.read();
        !r.is_empty() && r.values().all(|v| *v)
    }
}

pub async fn healthz_handler(state: HealthState) -> impl IntoResponse {
    if state.all_ready() {
        let body = serde_json::to_value(state.snapshot()).unwrap();
        (axum::http::StatusCode::OK, Json(body))
    } else {
        let body = state
            .snapshot()
            .into_iter()
            .filter(|(_, ok)| !*ok)
            .map(|(k, _)| k)
            .collect::<Vec<_>>();
        (
            axum::http::StatusCode::SERVICE_UNAVAILABLE,
            Json(serde_json::json!({ "unhealthy": body })),
        )
    }
}

impl Default for HealthState {
    fn default() -> Self {
        Self::new()
    }
}

```

### crates/ron-kernel/src/metrics/mod.rs
<a id="crates-ron-kernel-src-metrics-mod-rs"></a>

```rust
//! RO:WHAT — Metrics module index and re-exports for RON-CORE.
//! RO:WHY  — Centralize exporter + health + readiness; expose optional TLS buffering at `metrics::buffer`.

pub mod exporter;
pub mod health;
pub mod readiness;

// Declare the submodule *unconditionally* so the name `crate::metrics::buffer` always exists.
// The file itself is feature-gated internally, so this is safe in all builds.
pub mod buffer;

// Re-export the primary metrics type so call-sites can use `crate::metrics::Metrics`.
pub use exporter::Metrics;

// Convenience re-exports (common call-sites).
pub use health::HealthState;
pub use readiness::Readiness;

```

### crates/ron-kernel/src/metrics/readiness.rs
<a id="crates-ron-kernel-src-metrics-readiness-rs"></a>

```rust
use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};

use axum::{response::IntoResponse, Json};

use crate::metrics::health::HealthState;

#[derive(Clone)]
pub struct Readiness {
    health: HealthState,
    config_loaded: Arc<AtomicBool>,
}

impl Readiness {
    pub fn new(health: HealthState) -> Self {
        Self {
            health,
            config_loaded: Arc::new(AtomicBool::new(false)),
        }
    }

    pub fn set_config_loaded(&self, yes: bool) {
        self.config_loaded.store(yes, Ordering::Relaxed);
    }

    pub fn ready(&self) -> bool {
        self.config_loaded.load(Ordering::Relaxed) && self.health.all_ready()
    }
}

pub async fn readyz_handler(state: Readiness) -> axum::response::Response {
    if state.ready() {
        (
            axum::http::StatusCode::OK,
            Json(serde_json::json!({ "ready": true })),
        )
            .into_response()
    } else {
        let mut missing = vec![];
        if !state
            .config_loaded
            .load(std::sync::atomic::Ordering::Relaxed)
        {
            missing.push("config");
        }
        if !state.health.all_ready() {
            missing.push("services");
        }
        let mut resp = axum::response::Response::new(
            serde_json::to_vec(&serde_json::json!({ "missing": missing }))
                .unwrap()
                .into(),
        );
        *resp.status_mut() = axum::http::StatusCode::SERVICE_UNAVAILABLE;
        resp.headers_mut()
            .insert("Retry-After", axum::http::HeaderValue::from_static("3"));
        resp
    }
}

```

### crates/ron-kernel/src/mog_autotune.rs
<a id="crates-ron-kernel-src-mogautotune-rs"></a>

```rust
/*!
MOG A3 — Capacity Autotune + Guardrails (feature: `bus_autotune_cap`)

Purpose:
- Provide a safe, side-effect free helper to pick a ring/channel capacity from the expected load.
- This does NOT mutate global state; callers must opt-in to use it.

Integration:
- Call `autotune_capacity(expected_subs, override_cap)` from your Bus builder.
- If `override_cap` is `Some`, it wins (after normalization).
- Otherwise (feature ON) we choose plateaus: <=4 → 64, <=16 → 128, else → 256.
- Feature OFF: conservative 128 default.

Observability:
- Warn if finalized capacity >256 (cache-hostile territory for typical workloads).

Safety:
- No panics. Always returns >= 2. Overrides are rounded to power-of-two and clamped.
*/

#![allow(dead_code)] // until wired in by a builder

use core::cmp::{max, min};

/// Guardrail constants.
const MIN_CAP: usize = 2;
const MAX_CAP: usize = 65_536;

// Plateau levels (power-of-two, cache-friendly)
const PLATEAU_SMALL: usize = 64;
const PLATEAU_MED: usize = 128;
const PLATEAU_LARGE: usize = 256;

/// Returns a recommended capacity given the expected subscriber count
/// and an optional explicit override.
///
/// Feature gating:
/// - `bus_autotune_cap` **enabled**: use plateau heuristic when `override_cap` is None.
/// - Feature **disabled**: honor override (normalized) or fall back to 128.
///
/// Invariants:
/// - Never returns < 2.
/// - Final result is rounded to the next power-of-two and clamped to [2, 65_536].
#[allow(unused_variables)]
pub fn autotune_capacity(expected_subs: usize, override_cap: Option<usize>) -> usize {
    // 1) If caller provides override, it wins after normalization & guardrails.
    if let Some(c) = override_cap {
        return finalize_cap(c);
    }

    // 2) Otherwise pick via heuristic (if feature enabled), or a conservative default.
    let raw = {
        cfg_if::cfg_if! {
            if #[cfg(feature = "bus_autotune_cap")] {
                if expected_subs <= 4 {
                    PLATEAU_SMALL
                } else if expected_subs <= 16 {
                    PLATEAU_MED
                } else {
                    PLATEAU_LARGE
                }
            } else {
                // Feature disabled: predictable default before guardrails.
                128
            }
        }
    };

    // 3) Apply guardrails uniformly (also handles any future changes safely).
    finalize_cap(raw)
}

/// Apply guardrails to any incoming capacity (from override or heuristic):
/// - minimum of 2
/// - clamped to 65_536
/// - rounded up to next power-of-two
/// - warns if result > 256 (likely cache-hostile for typical workloads)
#[inline(always)]
fn finalize_cap(cap: usize) -> usize {
    let bounded = min(max(cap, MIN_CAP), MAX_CAP);
    let pow2 = next_pow2(bounded);

    if pow2 > PLATEAU_LARGE {
        tracing::warn!(
            cap = pow2,
            "bus_autotune_cap: capacity >256 is likely cache-hostile; consider 64/128/256 unless proven otherwise"
        );
    }
    pow2
}

/// Round up to the next power-of-two with a floor of 2.
#[inline(always)]
fn next_pow2(n: usize) -> usize {
    if n <= MIN_CAP {
        return MIN_CAP;
    }
    // `next_power_of_two` on usize is well-defined for n>0 and will not overflow
    // under our clamp (MAX_CAP = 65_536).
    n.next_power_of_two()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn override_is_normalized_pow2_and_clamped() {
        assert_eq!(autotune_capacity(0, Some(1)), 2);
        assert_eq!(autotune_capacity(0, Some(3)), 4);
        assert_eq!(autotune_capacity(0, Some(64)), 64);
        assert_eq!(autotune_capacity(0, Some(65_000)), 65_536);
        assert_eq!(autotune_capacity(0, Some(100_000)), 65_536);
    }

    #[test]
    fn default_when_disabled_is_reasonable() {
        // This holds regardless of feature; with feature ON, values are >=64,
        // with feature OFF default is 128 before guardrails.
        let cap = autotune_capacity(8, None);
        assert!(cap >= 64);
        assert!(cap <= MAX_CAP);
    }

    #[test]
    fn heuristic_plateaus_are_expected_when_enabled() {
        // These assertions hold for feature-enabled builds; for feature-off they
        // still validate general bounds.
        let small = autotune_capacity(1, None);
        let mid = autotune_capacity(8, None);
        let big = autotune_capacity(32, None);

        assert!(small >= PLATEAU_SMALL, "small expected ≥64, got {}", small);
        assert!(
            mid >= PLATEAU_SMALL && mid <= PLATEAU_LARGE,
            "mid in [64,256], got {}",
            mid
        );
        assert!(big >= PLATEAU_MED, "big expected ≥128, got {}", big);
        assert!(big <= MAX_CAP);
    }
}

```

### crates/ron-kernel/src/shutdown.rs
<a id="crates-ron-kernel-src-shutdown-rs"></a>

```rust
//! RO:WHAT — Helper to await Ctrl+C for cooperative shutdown.
//! RO:WHY  — Common pattern for binaries to align with kernel readiness and graceful stop.
//! RO:INTERACTS — May be used to trigger KernelEvent::Shutdown by callers (kernel doesn't emit it automatically).
//! RO:INVARIANTS — async-signal safe; no blocking in Drop.

/// Wait for a Ctrl+C signal.
pub async fn wait_for_ctrl_c() {
    let _ = tokio::signal::ctrl_c().await;
}

```

### crates/ron-kernel/src/supervisor/backoff.rs
<a id="crates-ron-kernel-src-supervisor-backoff-rs"></a>

```rust
//! RO:WHAT — Jittered exponential backoff with cap and reset.
//! RO:WHY  — Prevents thundering herds on crash-loops; RES concern.
//! RO:INTERACTS — lifecycle.rs (sleep scheduling), child.rs (restart cadence).
//! RO:INVARIANTS — Monotone until cap; jitter bounded; no panics on edge cases.
//! RO:METRICS/LOGS — None (observed externally by restart counters).
//! RO:CONFIG — init/max/factor/jitter ranges validated by config layer.
//! RO:SECURITY — N/A.
//! RO:TEST HOOKS — unit: sequence grows; jitter within bounds; reset works.

use rand::{rng, Rng};
use std::time::Duration;

#[derive(Debug, Clone)]
pub struct Backoff {
    current: Duration,
    init: Duration,
    max: Duration,
    factor: f64,
    jitter: f64, // 0.2 => ±20%
}

impl Backoff {
    pub fn new(init: Duration, max: Duration, factor: f64, jitter: f64) -> Self {
        let init = if init.is_zero() {
            Duration::from_millis(100)
        } else {
            init
        };
        let max = if max < init { init } else { max };
        let factor = if factor < 1.0 { 1.0 } else { factor };
        let jitter = jitter.clamp(0.0, 1.0);
        Self {
            current: init,
            init,
            max,
            factor,
            jitter,
        }
    }

    pub fn next(&mut self) -> Duration {
        let base = self.current;
        // prepare next (monotone up to cap)
        let next =
            Duration::from_secs_f64((base.as_secs_f64() * self.factor).min(self.max.as_secs_f64()));
        self.current = next;

        // apply jitter to current sleep (the 'base' value)
        if self.jitter == 0.0 {
            return base;
        }
        let j = rng().random_range(-self.jitter..=self.jitter);
        let secs = base.as_secs_f64() * (1.0 + j);
        Duration::from_secs_f64(secs.clamp(self.init.as_secs_f64(), self.max.as_secs_f64()))
    }

    pub fn reset(&mut self) {
        self.current = self.init;
    }
}

```

### crates/ron-kernel/src/supervisor/child.rs
<a id="crates-ron-kernel-src-supervisor-child-rs"></a>

```rust
use std::future::Future;
use tokio::task;

use crate::events::KernelEvent;
use crate::internal::types::{BoxError, ServiceName};
use crate::metrics::exporter::Metrics;
use crate::Bus;

pub async fn run_once<F, Fut>(
    name: ServiceName,
    metrics: &Metrics,
    bus: &Bus<KernelEvent>,
    work: F,
) -> Result<(), BoxError>
where
    F: Fn() -> Fut + Send + Sync + 'static,
    Fut: Future<Output = Result<(), BoxError>> + Send + 'static,
{
    let join = task::spawn(async move { work().await }).await;

    match join {
        Ok(Ok(())) => {
            metrics.inc_restart(name);
            bus.publish(KernelEvent::ServiceCrashed {
                service: name.to_string(),
            });
            Ok(())
        }
        Ok(Err(e)) => {
            metrics.inc_restart(name);
            bus.publish(KernelEvent::ServiceCrashed {
                service: name.to_string(),
            });
            Err(e)
        }
        Err(_join_err) => {
            metrics.inc_restart(name);
            bus.publish(KernelEvent::ServiceCrashed {
                service: name.to_string(),
            });
            Ok(())
        }
    }
}

```

### crates/ron-kernel/src/supervisor/lifecycle.rs
<a id="crates-ron-kernel-src-supervisor-lifecycle-rs"></a>

```rust
use std::collections::VecDeque;
use std::time::{Duration, Instant};

use crate::events::KernelEvent;
use crate::internal::types::{BoxError, ServiceName};
use crate::metrics::{exporter::Metrics, health::HealthState};
use crate::Bus;

use super::backoff::Backoff;
use super::child::run_once;

pub struct Supervisor {
    name: ServiceName,
    metrics: Metrics,
    bus: Bus<KernelEvent>,
    health: HealthState,
    backoff: Backoff,
    max_restarts: u32,
    window: Duration,
    recent: VecDeque<Instant>,
}

impl Supervisor {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        name: ServiceName,
        metrics: Metrics,
        bus: Bus<KernelEvent>,
        health: HealthState,
        backoff: Backoff,
        max_restarts: u32,
        window: Duration,
    ) -> Self {
        Self {
            name,
            metrics,
            bus,
            health,
            backoff,
            max_restarts,
            window,
            recent: VecDeque::with_capacity(max_restarts as usize + 1),
        }
    }

    pub async fn run<F, Fut>(&mut self, work: F) -> !
    where
        F: Fn() -> Fut + Send + Sync + Clone + 'static,
        Fut: std::future::Future<Output = Result<(), BoxError>> + Send + 'static,
    {
        self.health.set(self.name, true);
        loop {
            let factory = work.clone();
            let _ = run_once(self.name, &self.metrics, &self.bus, factory).await;
            self.health.set(self.name, false);

            let now = Instant::now();
            self.recent.push_back(now);
            while let Some(&front) = self.recent.front() {
                if now.duration_since(front) > self.window {
                    self.recent.pop_front();
                } else {
                    break;
                }
            }
            if self.recent.len() as u32 > self.max_restarts {
                let _ = self.backoff.next();
                let cap = self.backoff.next();
                tokio::time::sleep(cap).await;
                continue;
            }

            let sleep = self.backoff.next();
            tokio::time::sleep(sleep).await;
            self.health.set(self.name, true);
        }
    }
}

```

### crates/ron-kernel/src/supervisor/mod.rs
<a id="crates-ron-kernel-src-supervisor-mod-rs"></a>

```rust
//! RO:WHAT — Crash-only supervision with jittered exponential backoff and labeled restart metrics.
//! RO:WHY  — RESilience: children may crash; we restart with backoff and publish ServiceCrashed.
//! RO:INTERACTS — metrics::Metrics (service_restarts_total{service}); bus::Bus (ServiceCrashed).
//! RO:INVARIANTS — jittered backoff (100ms→30s cap), intensity cap optional; no lock across .await.

use crate::{events::KernelEvent, metrics::Metrics};
use anyhow::Result;
use rand::{rng, Rng};
use std::future::Future;
use tokio::time::{sleep, Duration};

fn jitter_ms(base: u64) -> u64 {
    if base <= 1 {
        return 1;
    }
    let mut r = rng();
    let half = base / 2;
    half + r.random_range(0..half.max(1))
}

/// Supervise an async child factory. On error, increments labeled restart metric and emits ServiceCrashed.
/// The `spawn` closure should create a fresh future each attempt.
pub async fn supervise_with_backoff<Fut, Spawn>(
    service: &str,
    metrics: Metrics,
    bus: crate::bus::Bus,
    mut spawn: Spawn,
) -> !
where
    Fut: Future<Output = Result<()>> + Send + 'static,
    Spawn: FnMut() -> Fut + Send + 'static,
{
    let service_name = service.to_string();
    let mut backoff = crate::internal::constants::SUP_BACKOFF_MS_START;

    loop {
        let res = spawn().await;
        if let Err(err) = res {
            // Publish crash and count a restart.
            let _ = bus.publish(KernelEvent::ServiceCrashed {
                service: service_name.clone(),
                reason: err.to_string(),
            });
            metrics
                .service_restarts_total
                .with_label_values(&[&service_name])
                .inc();
        }
        // Sleep with jitter (cap at 30s).
        backoff = (backoff.saturating_mul(2)).min(crate::internal::constants::SUP_BACKOFF_MS_CAP);
        let sleep_ms = jitter_ms(backoff);
        sleep(Duration::from_millis(sleep_ms)).await;
    }
}

#[cfg(test)]
mod tests {
    use super::jitter_ms;

    #[test]
    fn jitter_is_within_bounds_and_nonzero() {
        // Basic sanity: jitter must be at least 1 and not exceed base.
        for &base in &[2, 4, 8, 16, 32, 64, 128] {
            let j = jitter_ms(base);
            assert!(j >= 1, "jitter must be >=1");
            assert!(j <= base, "jitter must be <= base (got {} for {})", j, base);
        }
        // Base 1 -> clamped to 1.
        assert_eq!(jitter_ms(1), 1);
        assert_eq!(jitter_ms(0), 1);
    }
}

```

### crates/ron-kernel/testing/performance/publish_matrix.toml
<a id="crates-ron-kernel-testing-performance-publishmatrix-toml"></a>

```toml
[runs.default]
publish_rps = [100, 500, 1000]
fanout = [1, 4, 8]
duration_secs = 30

```

### crates/ron-kernel/tests/amnesia_label.rs
<a id="crates-ron-kernel-tests-amnesialabel-rs"></a>

```rust
use ron_kernel::Metrics;

#[test]
fn amnesia_gauge_flips_between_0_and_1() {
    let metrics = Metrics::new(false);

    // starts at 0
    assert_eq!(metrics.amnesia_mode.get(), 0);

    // flip on -> 1
    metrics.set_amnesia(true);
    assert_eq!(metrics.amnesia_mode.get(), 1);

    // flip off -> 0
    metrics.set_amnesia(false);
    assert_eq!(metrics.amnesia_mode.get(), 0);
}

```

### crates/ron-kernel/tests/autotune_capacity.rs
<a id="crates-ron-kernel-tests-autotunecapacity-rs"></a>

```rust
#![cfg(feature = "bus_autotune_cap")]
use ron_kernel::autotune_capacity;

#[test]
fn mapping_basic_thresholds() {
    assert_eq!(autotune_capacity(0, None), 64);
    assert_eq!(autotune_capacity(1, None), 64);
    assert_eq!(autotune_capacity(4, None), 64);
    assert_eq!(autotune_capacity(5, None), 128);
    assert_eq!(autotune_capacity(16, None), 128);
    assert_eq!(autotune_capacity(17, None), 256);
    assert_eq!(autotune_capacity(64, None), 256);
}

#[test]
fn override_is_respected() {
    assert_eq!(autotune_capacity(1, Some(128)), 128);
    assert_eq!(autotune_capacity(32, Some(64)), 64);
}

#[test]
fn monotone_in_n_with_default_map() {
    let mut prev = 0;
    for n in 0..200 {
        let cap = autotune_capacity(n, None);
        assert!(cap >= prev);
        prev = cap;
    }
}

```

### crates/ron-kernel/tests/autotune_sanity.rs
<a id="crates-ron-kernel-tests-autotunesanity-rs"></a>

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_autotune(c: &mut Criterion) {
    let mut g = c.benchmark_group("autotune");
    g.bench_function("expected_4_none", |b| {
        b.iter(|| {
            let mut sum = 0usize;
            for n in 0..1000 {
                // Call through a small trampoline to avoid LTO folding in release.
                sum ^= tramp(4 + (n & 1));
            }
            black_box(sum)
        })
    });
    g.finish();
}

#[inline(never)]
fn tramp(expected: usize) -> usize {
    ron_kernel::mog_autotune::autotune_capacity(expected, None)
}

criterion_group!(benches, bench_autotune);
criterion_main!(benches);

```

### crates/ron-kernel/tests/bus_basics.rs
<a id="crates-ron-kernel-tests-busbasics-rs"></a>

```rust
use ron_kernel::{Bus, KernelEvent, Metrics};

#[tokio::test]
async fn zero_and_one_subscriber_paths() {
    let metrics = Metrics::new(false);
    let bus: Bus<KernelEvent> = Bus::new().with_metrics(metrics.clone());

    // 0 subscribers -> publish returns 0
    let delivered = bus.publish(KernelEvent::Shutdown);
    assert_eq!(
        delivered, 0,
        "no subscribers -> delivered count should be 0"
    );

    // subscribe one receiver -> publish returns 1
    let mut rx = bus.subscribe();
    let delivered2 = bus.publish(KernelEvent::Shutdown);
    assert_eq!(delivered2, 1, "one subscriber -> delivered should be 1");

    // drain without lag (and exercise helper)
    let _ = Bus::handle_recv(rx.recv().await, Some(&metrics));
}

```

### crates/ron-kernel/tests/bus_bounded.rs
<a id="crates-ron-kernel-tests-busbounded-rs"></a>

```rust
//! Bounded bus: lag accounting and publish semantics.

use ron_kernel::{Bus, KernelEvent, Metrics};

#[tokio::test]
async fn lagged_receiver_increments_lag_counter_and_publish_counts() {
    let metrics = Metrics::new(false);
    // small capacity to force lag quickly
    let bus: Bus<KernelEvent> = Bus::with_capacity(8).with_metrics(metrics.clone());
    let mut rx = bus.subscribe();

    // With one subscriber, publish returns 1
    let n = bus.publish(KernelEvent::ConfigUpdated { version: 1 });
    assert_eq!(n, 1);

    // Overflow receiver by sending many without reading
    for i in 0..2048usize {
        let _ = bus.publish(KernelEvent::ConfigUpdated { version: i as u64 });
    }

    // Receiver sees either a value or Lagged; account via helper
    let _ = Bus::handle_recv(rx.recv().await, Some(&metrics));

    // We should have observed some lag
    assert!(
        metrics.bus_receiver_lag_total.get() > 0,
        "expected bus_receiver_lag_total to increase"
    );
}

```

### crates/ron-kernel/tests/bus_close_semantics.rs
<a id="crates-ron-kernel-tests-busclosesemantics-rs"></a>

```rust
//! When the sender is dropped, broadcast receivers observe `Closed`.

use ron_kernel::Bus;

#[tokio::test]
async fn receiver_observes_closed_on_sender_drop() {
    let bus: Bus<String> = Bus::with_capacity(8);
    let mut rx = bus.subscribe();

    // Drop all senders (cloned senders would need dropping too; we have only one)
    drop(bus);

    // Receiver should now get Err(Closed)
    let res = rx.recv().await;
    assert!(matches!(
        res,
        Err(tokio::sync::broadcast::error::RecvError::Closed)
    ));
}

```

### crates/ron-kernel/tests/bus_contract.rs
<a id="crates-ron-kernel-tests-buscontract-rs"></a>

```rust
use ron_kernel::{Bus, KernelEvent, Metrics};

#[tokio::test]
async fn publish_zero_subscribers_counts_and_returns_zero() {
    let metrics = Metrics::new(false);
    let bus: Bus<KernelEvent> = Bus::new().with_metrics(metrics.clone());

    let n = bus.publish(KernelEvent::Shutdown);
    assert_eq!(n, 0);

    let m = bus.publish(KernelEvent::Shutdown);
    assert_eq!(m, 0);
}

#[tokio::test]
async fn publish_with_subscriber_returns_one() {
    let metrics = Metrics::new(false);
    let bus: Bus<KernelEvent> = Bus::new().with_metrics(metrics.clone());
    let mut rx = bus.subscribe();

    let n = bus.publish(KernelEvent::Shutdown);
    assert_eq!(n, 1);

    let _ = Bus::handle_recv(rx.recv().await, Some(&metrics));
}

#[tokio::test]
async fn lagged_receiver_increments_lag_counter() {
    let metrics = Metrics::new(false);
    let bus: Bus<String> = Bus::new().with_metrics(metrics.clone());
    let mut rx = bus.subscribe();

    for i in 0..2048 {
        let _ = bus.publish(format!("m{i}"));
    }

    let _ = Bus::handle_recv(rx.recv().await, Some(&metrics));
}

```

### crates/ron-kernel/tests/edge_notify_loom.rs
<a id="crates-ron-kernel-tests-edgenotifyloom-rs"></a>

```rust
#![cfg(all(feature = "bus_edge_notify", feature = "loom"))]

//! RO:WHAT
//!   Loom litmus tests for lost-wake and drain-after-clear races.
//!
//! RO:WHY
//!   Ensure the pending bit pattern guarantees no lost wakeups.
//!
//! NOTE
//!   Uses `loom`'s std shims; keep test tiny to avoid state explosion.

use loom::sync::Arc;
use loom::thread;
use std::sync::atomic::{AtomicBool, Ordering};

#[test]
fn lost_wake_is_prevented() {
    loom::model(|| {
        let pending = Arc::new(AtomicBool::new(false));

        // Publisher: set pending and "notify if 0->1".
        let p = {
            let pending = pending.clone();
            thread::spawn(move || {
                let was = pending.swap(true, Ordering::Relaxed);
                // if !was { notify(); }  // modeled implicitly
                was
            })
        };

        // Subscriber: drain, clear, then race-check.
        let s = {
            let pending = pending.clone();
            thread::spawn(move || {
                // drain_all(); // modeled as already drained
                pending.store(false, Ordering::Relaxed);
                // race check
                let raced = pending.swap(false, Ordering::Relaxed);
                if raced {
                    // re-arm
                    pending.store(true, Ordering::Relaxed);
                }
                raced
            })
        };

        let _pub_was_pending = p.join().unwrap();
        let raced = s.join().unwrap();

        // If publisher observed 0->1 and subscriber cleared, either:
        // - race detected (raced=true), subscriber will continue draining
        // - or subscriber awaits but pending remains true (observed by next poll)
        // We assert that *eventually* pending is true if race happened.
        if raced {
            assert!(pending.load(Ordering::Relaxed));
        }
    });
}

```

### crates/ron-kernel/tests/health_ready.rs
<a id="crates-ron-kernel-tests-healthready-rs"></a>

```rust
//! Readiness and health endpoints: handler semantics (no actual HTTP client).
use std::net::SocketAddr;

use axum::http::StatusCode;
use ron_kernel::metrics::readiness::{readyz_handler, Readiness};
use ron_kernel::{HealthState, Metrics};

#[tokio::test]
async fn readiness_transitions_to_ok_when_config_and_services_ready() {
    let metrics = Metrics::new(false);
    let health = HealthState::new();
    let ready = Readiness::new(health.clone());

    // Start server just to ensure the router builds; we won't fetch it here.
    let (_handle, _addr) = metrics
        .clone()
        .serve(
            "127.0.0.1:0".parse::<SocketAddr>().unwrap(),
            health.clone(),
            ready.clone(),
        )
        .await
        .unwrap();

    // Initially not ready (config not loaded)
    let resp = readyz_handler(ready.clone()).await;
    assert_eq!(resp.status(), StatusCode::SERVICE_UNAVAILABLE);

    // Make both gates true
    ready.set_config_loaded(true);
    health.set("svc", true);

    // Now the handler should return 200 OK
    let ok_resp = readyz_handler(ready.clone()).await;
    assert_eq!(ok_resp.status(), StatusCode::OK);
}

```

### crates/ron-kernel/tests/loom_bus.rs
<a id="crates-ron-kernel-tests-loombus-rs"></a>

```rust
//! Loom interleavings for Bus subscribe/publish ensure no panics or deadlocks.
//! Run with: cargo test -p ron-kernel --features loom -- --nocapture

#![cfg(feature = "loom")]

use loom::thread;
use ron_kernel::{Bus, KernelEvent, Metrics};

#[test]
fn bus_publish_subscribe_concurrent() {
    loom::model(|| {
        let metrics = Metrics::new(false);
        let bus: Bus<KernelEvent> = metrics.make_bus(8);

        let bus_pub = bus.clone();
        let t_pub = thread::spawn(move || {
            let _ = bus_pub.publish(KernelEvent::Shutdown);
            let _ = bus_pub.publish(KernelEvent::ConfigUpdated { version: 1 });
        });

        let bus_sub = bus.clone();
        let t_sub = thread::spawn(move || {
            let mut rx = bus_sub.subscribe();
            let _ = rx.recv();
            let _ = rx.recv();
        });

        t_pub.join().unwrap();
        t_sub.join().unwrap();
    });
}

```

### crates/ron-kernel/tests/metrics_amnesia.rs
<a id="crates-ron-kernel-tests-metricsamnesia-rs"></a>

```rust
//! Ensures amnesia_mode gauge flips 0 <-> 1 and is exposed by the exporter.

use prometheus::Encoder; // brings TextEncoder::encode into scope
use ron_kernel::metrics::health::HealthState;
use ron_kernel::metrics::readiness::Readiness;
use ron_kernel::Metrics;

#[tokio::test]
async fn amnesia_mode_gauge_flips_and_exports() {
    let metrics = Metrics::new(false);

    // Sanity: initial seed should be 0
    {
        // NOTE: 'registry' is a field on Metrics; metrics is Arc<Metrics>
        let families = (*metrics).registry.gather();
        let mut buf = Vec::new();
        prometheus::TextEncoder::new()
            .encode(&families, &mut buf)
            .unwrap();
        let text = String::from_utf8(buf).unwrap();
        assert!(
            text.contains("amnesia_mode 0"),
            "expected amnesia_mode 0 at start, got:\n{text}"
        );
    }

    metrics.set_amnesia(true);
    {
        let families = (*metrics).registry.gather();
        let mut buf = Vec::new();
        prometheus::TextEncoder::new()
            .encode(&families, &mut buf)
            .unwrap();
        let text = String::from_utf8(buf).unwrap();
        assert!(
            text.contains("amnesia_mode 1"),
            "expected amnesia_mode 1 after flip, got:\n{text}"
        );
    }

    // Boot the HTTP exporter quickly to catch regressions in wiring.
    let health = HealthState::new();
    let ready = Readiness::new(health.clone());
    ready.set_config_loaded(true);
    health.set("kernel", true);

    let (_handle, bound) = metrics
        .clone()
        .serve("127.0.0.1:0".parse().unwrap(), health, ready)
        .await
        .unwrap();
    assert_ne!(bound.port(), 0);
}

```

### crates/ron-kernel/tests/metrics_smoke.rs
<a id="crates-ron-kernel-tests-metricssmoke-rs"></a>

```rust
//! Smoke test: Metrics::serve mounts routes and binds successfully.

use std::net::SocketAddr;

use ron_kernel::metrics::readiness::Readiness;
use ron_kernel::{HealthState, Metrics};

#[tokio::test]
async fn metrics_server_binds_and_runs() {
    let metrics = Metrics::new(false);
    let health = HealthState::new();
    let ready = Readiness::new(health.clone());

    // Toggle minimal readiness so /readyz can return 200 once needed
    ready.set_config_loaded(true);
    health.set("kernel", true);

    let addr: SocketAddr = "127.0.0.1:0".parse().unwrap();
    let (handle, bound) = metrics
        .clone()
        .serve(addr, health.clone(), ready.clone())
        .await
        .unwrap();

    // bound should be a real ephemeral port
    assert_ne!(bound.port(), 0);

    // shut it down
    handle.abort();
}

```

### crates/ron-kernel/tests/property_config.rs
<a id="crates-ron-kernel-tests-propertyconfig-rs"></a>

```rust
//! Aligns integer values with float checks.

use ron_kernel::Metrics;

#[test]
fn property_config_sanity_numbers_cast() {
    // this test just needs Metrics in scope; we don't actually use it.
    let _metrics = Metrics::new(false);

    // pretend these came from a config (i64s):
    let v0: i64 = 0;
    let v1: i64 = 1;
    let v2: i64 = 0;

    // cast to f64 before float math
    assert!((v0 as f64 - 0.0).abs() < f64::EPSILON);
    assert!((v1 as f64 - 1.0).abs() < f64::EPSILON);
    assert!((v2 as f64 - 0.0).abs() < f64::EPSILON);
}

```

### crates/ron-kernel/tests/public_api.rs
<a id="crates-ron-kernel-tests-publicapi-rs"></a>

```rust
//! Verifies the frozen public API is re-exported at the crate root.
//! Fails to compile if any item disappears or moves.

use ron_kernel::{wait_for_ctrl_c, Bus, Config, HealthState, KernelEvent, Metrics};

#[test]
fn api_compiles_and_names_resolve() {
    // Type names resolve? good enough for compile-time surface guard.
    let _ = std::any::type_name::<Bus<KernelEvent>>();
    let _ = std::any::type_name::<Metrics>();
    let _ = std::any::type_name::<HealthState>();
    let _ = std::any::type_name::<Config>();
    let _ = wait_for_ctrl_c as fn() -> _;
}

```

### crates/ron-kernel/tests/readiness_degrades.rs
<a id="crates-ron-kernel-tests-readinessdegrades-rs"></a>

```rust
//! /readyz returns 503 until both gates (config_loaded & services_ok) are true.

use axum::http::StatusCode;
use ron_kernel::metrics::health::HealthState;
use ron_kernel::metrics::readiness::{readyz_handler, Readiness};
use ron_kernel::Metrics;

#[tokio::test]
async fn readiness_degrades_then_ok() {
    let _metrics = Metrics::new(false); // ensures registry initialized, but not required here
    let health = HealthState::new();
    let ready = Readiness::new(health.clone());

    // Initially: both gates false -> 503
    let resp = readyz_handler(ready.clone()).await;
    assert_eq!(resp.status(), StatusCode::SERVICE_UNAVAILABLE);

    // Flip just one gate -> still 503
    ready.set_config_loaded(true);
    let resp = readyz_handler(ready.clone()).await;
    assert_eq!(resp.status(), StatusCode::SERVICE_UNAVAILABLE);

    // Flip services_ok via HealthState -> 200
    health.set("kernel", true);
    let resp = readyz_handler(ready.clone()).await;
    assert_eq!(resp.status(), StatusCode::OK);
}

```

### crates/ron-kernel/tests/soa_smoke.rs
<a id="crates-ron-kernel-tests-soasmoke-rs"></a>

```rust
//! RO:WHAT — Integration smoke for SoA backend under the `bus_soa` feature.
//! RO:WHY  — Ensure crate-level feature compiles & basic flows hold.

#![cfg(feature = "bus_soa")]

use ron_kernel::bus::bounded::Bus; // bounded is re-exported to SoA when feature=bus_soa
use tokio::runtime::Runtime;

#[test]
fn feature_compiles_and_basic_flow_ok() {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let bus: Bus<u64> = Bus::with_capacity(16);
        let mut rx = bus.subscribe();
        let _rc = bus.publish(42);
        // bounded-style: recv returns Result<T, Lagged>, use handle_recv to map to Option
        let got = Bus::handle_recv(rx.recv().await, None);
        assert_eq!(got, Some(42));
    });
}

```

### crates/ron-kernel/tests/supervisor_backoff.rs
<a id="crates-ron-kernel-tests-supervisorbackoff-rs"></a>

```rust
use ron_kernel::Metrics;

/// Minimal invariant: the supervisor restart counter should be usable and
/// monotonically increasing under a service label. This stands in until the
/// real supervisor backoff is wired.
#[test]
fn service_restart_counter_increments_monotonically() {
    let metrics = Metrics::new(false);

    // Simulate a supervisor incrementing a labeled counter.
    let ctr = metrics.service_restarts_total.with_label_values(&["demo"]);

    let before = ctr.get();
    ctr.inc();
    let after1 = ctr.get();
    assert_eq!(after1, before + 1, "inc() should add exactly 1");

    ctr.inc_by(5);
    let after2 = ctr.get();
    assert_eq!(after2, after1 + 5, "inc_by(5) should add exactly 5");
}

```

### crates/ron-kernel/tests/supervisor_backoff_integ.rs
<a id="crates-ron-kernel-tests-supervisorbackoffinteg-rs"></a>

```rust
use std::time::{Duration, Instant};

use ron_kernel::metrics::readiness::Readiness;
use ron_kernel::supervisor::{backoff::Backoff, lifecycle::Supervisor};
use ron_kernel::{Bus, HealthState, KernelEvent, Metrics};

#[tokio::test]
async fn supervisor_restarts_and_backoff_grows() {
    let metrics = Metrics::new(false);
    let health = HealthState::new();
    let ready = Readiness::new(health.clone());
    ready.set_config_loaded(true);

    let bus: Bus<KernelEvent> = Bus::new().with_metrics(metrics.clone());

    let work =
        || async { Err::<(), Box<dyn std::error::Error + Send + Sync + 'static>>("fail".into()) };

    let mut sup = Supervisor::new(
        "testsvc",
        (*metrics).clone(),
        bus.clone(),
        health.clone(),
        Backoff::new(
            Duration::from_millis(100),
            Duration::from_millis(400),
            2.0,
            0.0,
        ),
        100,
        Duration::from_secs(10),
    );

    let start = Instant::now();
    let h = tokio::spawn(async move { sup.run(work).await });

    tokio::time::sleep(Duration::from_millis(850)).await;
    h.abort();

    // read the counter from the *_total vec
    let c = metrics
        .service_restarts_total
        .with_label_values(&["testsvc"])
        .get();
    assert!(c >= 3, "expected >=3 restarts, got {}", c);

    let elapsed = start.elapsed();
    assert!(elapsed >= Duration::from_millis(300));
}

```

### crates/ron-kernel/tests/tls_type_invariance.rs
<a id="crates-ron-kernel-tests-tlstypeinvariance-rs"></a>

```rust
//! Compile-time guard: the crate must use `tokio_rustls::rustls::ServerConfig`.
//! If someone swaps to `rustls::ServerConfig` directly, this test will fail to compile.

#[test]
fn tls_type_is_tokio_rustls_serverconfig() {
    // This function will fail to compile if the type path is wrong.
    fn _requires_tokio_rustls(_: &tokio_rustls::rustls::ServerConfig) {}

    // Name resolution check (uses the type so clippy doesn’t flag it as unused).
    let _typename = std::any::type_name::<tokio_rustls::rustls::ServerConfig>();

    // Keep a phantom value to ensure the path remains valid across refactors.
    let _phantom: Option<&tokio_rustls::rustls::ServerConfig> = None;

    // No runtime assertions needed—the compile-time type checks above are the point.
}

```

### crates/ron-kernel/tests/watcher_integ.rs
<a id="crates-ron-kernel-tests-watcherinteg-rs"></a>

```rust
//! Integration glue: exercise ConfigUpdated emission + amnesia gauge flip.

use std::fs;
use std::time::Duration;

use ron_kernel::{Bus, KernelEvent, Metrics};

#[tokio::test]
async fn amnesia_flip_emits_single_update() {
    let dir = tempfile::tempdir().unwrap();
    let cfg_path = dir.path().join("ron-kernel.toml");
    fs::write(
        &cfg_path,
        "amnesia = false\nhttp_port = 0\nrequest_timeout_ms = 1000\n",
    )
    .unwrap();

    let metrics = Metrics::new(false);
    let bus: Bus<KernelEvent> = Bus::new().with_metrics(metrics.clone());
    let mut rx = bus.subscribe();

    // Simulate watcher apply; replace with real watcher if present.
    tokio::spawn({
        let metrics = metrics.clone();
        let bus = bus.clone();
        async move {
            metrics.set_amnesia(true);
            bus.publish(KernelEvent::ConfigUpdated { version: 1 });
        }
    });

    let mut updates = 0u32;
    let deadline = tokio::time::Instant::now() + Duration::from_millis(500);

    loop {
        let now = tokio::time::Instant::now();
        if now >= deadline {
            break;
        }
        let remaining = deadline - now;

        // Bound this await so the loop can re-check the deadline.
        match tokio::time::timeout(remaining, rx.recv()).await {
            Ok(Ok(ev)) => {
                if let KernelEvent::ConfigUpdated { .. } = ev {
                    updates += 1;
                }
            }
            Ok(Err(_lagged)) => {
                // Ignore lag for this test: we're only counting ConfigUpdated.
            }
            Err(_elapsed) => {
                // No message before deadline — exit loop.
                break;
            }
        }
    }

    assert_eq!(updates, 1, "expected exactly one ConfigUpdated");
    metrics.set_amnesia(false);
}

```



---



# ron-bus

_Source: crates/ron-bus/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:47:47Z -->
# Code Bundle — `ron-bus`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-bus/.cargo/config.toml](#crates-ron-bus--cargo-config-toml)
- [crates/ron-bus/.clippy.toml](#crates-ron-bus--clippy-toml)
- [crates/ron-bus/.github/workflows/ci.yml](#crates-ron-bus--github-workflows-ci-yml)
- [crates/ron-bus/.github/workflows/coverage.yml](#crates-ron-bus--github-workflows-coverage-yml)
- [crates/ron-bus/.github/workflows/nightly-chaos.yml](#crates-ron-bus--github-workflows-nightly-chaos-yml)
- [crates/ron-bus/.github/workflows/render-mermaid.yml](#crates-ron-bus--github-workflows-render-mermaid-yml)
- [crates/ron-bus/Cargo.toml](#crates-ron-bus-Cargo-toml)
- [crates/ron-bus/benches/ab_compare.rs](#crates-ron-bus-benches-abcompare-rs)
- [crates/ron-bus/benches/latency.rs](#crates-ron-bus-benches-latency-rs)
- [crates/ron-bus/benches/overflow.rs](#crates-ron-bus-benches-overflow-rs)
- [crates/ron-bus/benches/throughput.rs](#crates-ron-bus-benches-throughput-rs)
- [crates/ron-bus/deny.toml](#crates-ron-bus-deny-toml)
- [crates/ron-bus/examples/publish_smoke.rs](#crates-ron-bus-examples-publishsmoke-rs)
- [crates/ron-bus/rust-toolchain.toml](#crates-ron-bus-rust-toolchain-toml)
- [crates/ron-bus/scripts/smoke_ron_bus.sh](#crates-ron-bus-scripts-smokeronbus-sh)
- [crates/ron-bus/scripts/update_api_snapshot.sh](#crates-ron-bus-scripts-updateapisnapshot-sh)
- [crates/ron-bus/src/bus.rs](#crates-ron-bus-src-bus-rs)
- [crates/ron-bus/src/config.rs](#crates-ron-bus-src-config-rs)
- [crates/ron-bus/src/errors.rs](#crates-ron-bus-src-errors-rs)
- [crates/ron-bus/src/event.rs](#crates-ron-bus-src-event-rs)
- [crates/ron-bus/src/internal/channel.rs](#crates-ron-bus-src-internal-channel-rs)
- [crates/ron-bus/src/internal/depth_estimator.rs](#crates-ron-bus-src-internal-depthestimator-rs)
- [crates/ron-bus/src/internal/mod.rs](#crates-ron-bus-src-internal-mod-rs)
- [crates/ron-bus/src/lib.rs](#crates-ron-bus-src-lib-rs)
- [crates/ron-bus/src/metrics.rs](#crates-ron-bus-src-metrics-rs)
- [crates/ron-bus/src/prelude.rs](#crates-ron-bus-src-prelude-rs)
- [crates/ron-bus/tests/api_surface.rs](#crates-ron-bus-tests-apisurface-rs)
- [crates/ron-bus/tests/capacity_cutover.rs](#crates-ron-bus-tests-capacitycutover-rs)
- [crates/ron-bus/tests/chaos_amnesia.rs](#crates-ron-bus-tests-chaosamnesia-rs)
- [crates/ron-bus/tests/fanout_ok.rs](#crates-ron-bus-tests-fanoutok-rs)
- [crates/ron-bus/tests/graceful_shutdown.rs](#crates-ron-bus-tests-gracefulshutdown-rs)
- [crates/ron-bus/tests/lagged_overflow_smoke.rs](#crates-ron-bus-tests-laggedoverflowsmoke-rs)
- [crates/ron-bus/tests/loom_model.rs](#crates-ron-bus-tests-loommodel-rs)
- [crates/ron-bus/tests/pq_labels_feature.rs](#crates-ron-bus-tests-pqlabelsfeature-rs)
- [crates/ron-bus/tests/property_bus.rs](#crates-ron-bus-tests-propertybus-rs)
- [crates/ron-bus/tests/receiver_ownership.rs](#crates-ron-bus-tests-receiverownership-rs)

### crates/ron-bus/.cargo/config.toml
<a id="crates-ron-bus--cargo-config-toml"></a>

```toml
[alias]
lint = "clippy -p ron-bus -- -D warnings"
test-all = "test -p ron-bus --all-features"
ci-check = "fmt --all && clippy -D warnings && test -p ron-bus"
bench-all = "bench -p ron-bus"

```

### crates/ron-bus/.clippy.toml
<a id="crates-ron-bus--clippy-toml"></a>

```toml
# Keep lock-across-await and pedantic checks tight (placeholder)
warn-on-all-wildcard-imports = true

```

### crates/ron-bus/.github/workflows/ci.yml
<a id="crates-ron-bus--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
          components: rustfmt, clippy
      - run: cargo fmt --all --check
      - run: cargo clippy -p ron-bus2 -- -D warnings
      - run: cargo test -p ron-bus2 --all-features
      - run: cargo test -p ron-bus2 --doc

```

### crates/ron-bus/.github/workflows/coverage.yml
<a id="crates-ron-bus--github-workflows-coverage-yml"></a>

```yaml
name: coverage
on:
  push:
    branches: [ main ]
  pull_request:
jobs:
  cover:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
      - name: Run coverage (placeholder)
        run: echo "Implement tarpaulin/grcov coverage here with Bronze/Silver/Gold thresholds"

```

### crates/ron-bus/.github/workflows/nightly-chaos.yml
<a id="crates-ron-bus--github-workflows-nightly-chaos-yml"></a>

```yaml
name: nightly-chaos
on:
  schedule:
    - cron: "0 3 * * *"
jobs:
  chaos:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.80.0
      - name: Run ignored chaos tests (placeholder)
        run: cargo test -p ron-bus2 -- --ignored --nocapture

```

### crates/ron-bus/.github/workflows/render-mermaid.yml
<a id="crates-ron-bus--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          mkdir -p docs/diagrams
          for f in $(git ls-files 'docs/diagrams/*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out"
          done

```

### crates/ron-bus/Cargo.toml
<a id="crates-ron-bus-Cargo-toml"></a>

```toml
[package]
name = "ron-bus"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RustyOnions in-process broadcast bus (bounded, lossy, observable-by-host)"
rust-version = "1.80"
readme = "README.md"
repository = "https://example.com/RustyOnions" # update when ready

[features]
default = []
tracing = ["dep:tracing"]
pq-labels = []            # labels-only; no crypto here
loom = []                 # dev-only (cfg guarded in tests)

[dependencies]
tokio = { version = "1.48.0", features = ["sync", "rt", "macros", "time"] }
tracing = { version = "0.1.41", optional = true }
serde = { version = "1.0", features = ["derive"], optional = true }

[dev-dependencies]
tokio = { version = "1.48.0", features = ["rt-multi-thread", "macros", "time", "sync"] }
loom = "0.7"
criterion = "0.5"
flume = "0.11"
async-channel = "2"


[[bench]]
name = "throughput"
harness = false

[[bench]]
name = "latency"
harness = false

[[bench]]
name = "ab_compare"
harness = false


[[example]]
name = "publish_smoke"

```

### crates/ron-bus/benches/ab_compare.rs
<a id="crates-ron-bus-benches-abcompare-rs"></a>

```rust
//! RO:WHAT  — A/B microbench: ron-bus vs tokio::broadcast vs flume/async-channel.
//! RO:WHY   — Credible, apples-to-apples comparison for README claims.
//! RO:INTERACTS — ron_bus::{Bus, BusConfig, Event}; tokio runtime controlled here.
//! RO:INVARIANTS — Same fanout/capacity/runtime; comparable small POD payloads.
//! RO:NOTES — Microbench only; real-world variance expected.

use criterion::{criterion_group, criterion_main, Criterion};
use tokio::runtime::Builder;

// SUT
use ron_bus::{Bus, BusConfig, Event};

// Baselines
use async_channel as ac;
use flume as fl;
use tokio::sync::broadcast as tbc;

fn bench_publish(c: &mut Criterion) {
    let rt = Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .unwrap();

    let mut group = c.benchmark_group("ab_publish_cap1024_subs8");
    group.sample_size(50);
    // NOTE: No fixed warm-up/measurement times here: allow CLI flags to control it.

    // Params (keep identical across contenders)
    let cap_usize: usize = 1024;
    let cap_u32: u32 = cap_usize.try_into().unwrap();
    let subs: usize = 8;

    // ----------------- ron-bus -----------------
    group.bench_function("ron_bus_publish", |b| {
        b.iter(|| {
            rt.block_on(async {
                let bus = Bus::new(BusConfig::new().with_capacity(cap_u32)).unwrap();
                let tx = bus.sender();

                // Create N independent receivers (one per task)
                let rxs = (0..subs).map(|_| bus.subscribe()).collect::<Vec<_>>();

                // Drain tasks: break on Shutdown OR on channel close
                let mut tasks = Vec::with_capacity(subs);
                for mut rx in rxs {
                    tasks.push(tokio::spawn(async move {
                        loop {
                            match rx.recv().await {
                                Ok(Event::Shutdown) => break,
                                Ok(_) => {}
                                Err(_) => break,
                            }
                        }
                    }));
                }

                // Publish a small batch
                for i in 0u64..10_000 {
                    let _ = tx.send(Event::ConfigUpdated { version: i });
                }
                let _ = tx.send(Event::Shutdown);

                // IMPORTANT: drop the sender so receivers observe close and exit
                drop(tx);

                for t in tasks {
                    let _ = t.await;
                }
            })
        })
    });

    // ----------------- tokio::broadcast -----------------
    group.bench_function("tokio_broadcast_publish", |b| {
        b.iter(|| {
            rt.block_on(async {
                let (tx, _) = tbc::channel::<u64>(cap_usize);

                // Each subscriber comes from subscribe(); Receiver is NOT clonable.
                let mut tasks = Vec::with_capacity(subs);
                for _ in 0..subs {
                    let mut rx = tx.subscribe();
                    tasks.push(tokio::spawn(
                        async move { while rx.recv().await.is_ok() {} },
                    ));
                }

                for i in 0u64..10_000 {
                    let _ = tx.send(i);
                }
                drop(tx); // receivers will get Err and exit

                for t in tasks {
                    let _ = t.await;
                }
            })
        })
    });

    // ----------------- flume (bounded MPMC) -----------------
    group.bench_function("flume_mpmc_publish", |b| {
        b.iter(|| {
            rt.block_on(async {
                let (tx, rx) = fl::bounded::<u64>(cap_usize);

                let mut tasks = Vec::with_capacity(subs);
                for _ in 0..subs {
                    let rx = rx.clone();
                    tasks.push(tokio::spawn(async move {
                        while rx.recv_async().await.is_ok() {}
                    }));
                }

                for i in 0u64..10_000 {
                    let _ = tx.send(i);
                }
                drop(tx);

                for t in tasks {
                    let _ = t.await;
                }
            })
        })
    });

    // ----------------- async-channel (bounded MPMC) -----------------
    group.bench_function("async_channel_mpmc_publish", |b| {
        b.iter(|| {
            rt.block_on(async {
                let (tx, rx) = ac::bounded::<u64>(cap_usize);

                let mut tasks = Vec::with_capacity(subs);
                for _ in 0..subs {
                    let rx = rx.clone();
                    tasks.push(tokio::spawn(
                        async move { while rx.recv().await.is_ok() {} },
                    ));
                }

                for i in 0u64..10_000 {
                    let _ = tx.send(i).await;
                }
                drop(tx);

                for t in tasks {
                    let _ = t.await;
                }
            })
        })
    });

    group.finish();
}

criterion_group!(benches, bench_publish);
criterion_main!(benches);

```

### crates/ron-bus/benches/latency.rs
<a id="crates-ron-bus-benches-latency-rs"></a>

```rust
//! RO:WHAT — Receive-side latency microbench (deterministic runtime).
//! RO:WHY  — Reduce scheduler variance while preserving original iter_custom style.
//! RO:INTERACTS — Bus, BusConfig, Event.
//! RO:NOTES — Single-thread runtime; measures time to recv `iters` events; clean shutdown.

use std::time::Duration;

use criterion::{criterion_group, criterion_main, Criterion};
use ron_bus::{Bus, BusConfig, Event};
use tokio::runtime::Builder;

fn recv_latency_one_publisher(c: &mut Criterion) {
    // Use a single-thread runtime to reduce scheduler jitter vs multi-thread.
    let rt = Builder::new_current_thread()
        .enable_all()
        .build()
        .expect("tokio rt");

    let mut group = c.benchmark_group("recv_latency_one_publisher");
    group.sample_size(100);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(8));
    group.noise_threshold(0.02);
    group.significance_level(0.01);

    group.bench_function("recv_latency_one_publisher", |b| {
        b.iter_custom(|iters| {
            rt.block_on(async move {
                // Fresh bus per measurement to avoid cross-iter state bleed.
                let bus = Bus::new(BusConfig::new().with_capacity(1024)).unwrap();
                let tx = bus.sender();
                let mut rx = bus.subscribe();

                // Publisher: send exactly `iters` events, then Shutdown.
                let pubber = tokio::spawn({
                    let tx = tx.clone();
                    async move {
                        for i in 0..iters {
                            // Small POD payload path; minimal branching.
                            let _ = tx.send(Event::ConfigUpdated { version: i });
                        }
                        let _ = tx.send(Event::Shutdown);
                        // Drop to ensure receivers can observe close if needed.
                        drop(tx);
                    }
                });

                // Measure time to consume exactly `iters` relevant events.
                let start = std::time::Instant::now();
                let mut seen = 0u64;
                loop {
                    match rx.recv().await {
                        Ok(Event::ConfigUpdated { .. }) => {
                            seen += 1;
                            if seen == iters {
                                break;
                            }
                        }
                        Ok(Event::Shutdown) => break, // belt-and-suspenders
                        Err(_) => break,              // sender dropped
                        _ => {}
                    }
                }
                // Ensure publisher task is done before returning elapsed time.
                let _ = pubber.await;
                start.elapsed()
            })
        });
    });

    group.finish();
}

criterion_group!(benches, recv_latency_one_publisher);
criterion_main!(benches);

```

### crates/ron-bus/benches/overflow.rs
<a id="crates-ron-bus-benches-overflow-rs"></a>

```rust
// overflow bench placeholder

```

### crates/ron-bus/benches/throughput.rs
<a id="crates-ron-bus-benches-throughput-rs"></a>

```rust
//! RO:WHAT — Criterion throughput bench for ron-bus (sync harness + async runtime inside)
//! RO:WHY  — Avoid Criterion's async adapters; drive Tokio ourselves via block_on()
//! RO:INTERACTS — Bus, BusConfig, Event; isolated Tokio runtimes per bench
//! RO:INVARIANTS — bounded channel; no background tasks from the library
//! RO:NOTES — Coarse microbench; for deep dives, use repo-wide harness & baselines.

use std::time::Duration;

use criterion::{black_box, criterion_group, criterion_main, Criterion};
use ron_bus::{Bus, BusConfig, Event};
use tokio::runtime::Builder;

/// Busy-work to simulate a "slow" subscriber without OS sleep jitter.
/// Tune `ns` once on your machine if needed.
#[inline]
fn burn_cycles(ns: u64) {
    // The body is intentionally simple integer math; adjust divisor to match ~ns cost.
    let iters = ns / 10;
    let mut x = 0u64;
    for i in 0..iters {
        // LCG-ish mixing; keep it opaque to optimizer.
        x = x.wrapping_mul(1664525).wrapping_add(i ^ 1013904223u64);
        std::hint::black_box(x);
    }
}

/// Publish cost with zero subscribers draining.
fn bench_publish_zero_subs(c: &mut Criterion) {
    // Current-thread runtime is enough here.
    let rt = Builder::new_current_thread().enable_all().build().unwrap();

    let mut group = c.benchmark_group("publish_zero_subs");
    group.sample_size(100);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(8));
    group.noise_threshold(0.02);
    group.significance_level(0.01);

    group.bench_function("publish_zero_subs", |b| {
        b.iter_custom(|iters| {
            rt.block_on(async move {
                // Setup is outside the measured window.
                let bus = Bus::new(BusConfig::new().with_capacity(1024)).unwrap();
                let tx = bus.sender();

                let start = std::time::Instant::now();
                for _ in 0..iters {
                    // Measure only the send loop.
                    let _ = black_box(&tx).send(Event::ConfigUpdated { version: 1 });
                }
                start.elapsed()
            })
        });
    });

    group.finish();
}

/// Publish throughput with 8 draining subscribers (fast consumers).
fn bench_publish_eight_subs(c: &mut Criterion) {
    let rt = Builder::new_multi_thread()
        .worker_threads(4)
        .enable_all()
        .build()
        .unwrap();

    let mut group = c.benchmark_group("publish_eight_subs");
    group.sample_size(100);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(8));
    group.noise_threshold(0.02);
    group.significance_level(0.01);

    group.bench_function("publish_eight_subs", |b| {
        b.iter_custom(|iters| {
            rt.block_on(async move {
                let bus = Bus::new(BusConfig::new().with_capacity(2048)).unwrap();
                let tx = bus.sender();

                // Spawn fast draining subscribers.
                let mut rxs = Vec::new();
                for _ in 0..8 {
                    rxs.push(bus.subscribe());
                }
                for mut rx in rxs {
                    tokio::spawn(async move {
                        while let Ok(ev) = rx.recv().await {
                            criterion::black_box(ev);
                        }
                    });
                }

                // Measure only the publish loop.
                let start = std::time::Instant::now();
                for i in 0..iters {
                    let _ = tx.send(Event::ConfigUpdated { version: i });
                }
                // Ensure convergence.
                let _ = tx.send(Event::Shutdown);
                start.elapsed()
            })
        });
    });

    group.finish();
}

/// Publish while one subscriber is intentionally slow to induce Lagged(n).
fn bench_publish_with_one_slow_subscriber(c: &mut Criterion) {
    let rt = Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .unwrap();

    let mut group = c.benchmark_group("publish_with_one_slow_subscriber");
    group.sample_size(100);
    group.warm_up_time(Duration::from_secs(1));
    group.measurement_time(Duration::from_secs(8));
    group.noise_threshold(0.02);
    group.significance_level(0.01);

    group.bench_function("publish_with_one_slow_subscriber", |b| {
        b.iter_custom(|iters| {
            rt.block_on(async move {
                let bus = Bus::new(BusConfig::new().with_capacity(64)).unwrap();
                let tx = bus.sender();

                // Slow consumer to create pressure — use CPU burn instead of sleep.
                let mut rx = bus.subscribe();
                let slow = tokio::spawn(async move {
                    loop {
                        match rx.recv().await {
                            Ok(Event::Shutdown) => break,
                            Ok(_) => {
                                // ~0.1ms CPU burn; adjust if you want the same wall time as the old sleep.
                                burn_cycles(100_000);
                            }
                            Err(_) => break,
                        }
                    }
                });

                // Measure the publish loop.
                let start = std::time::Instant::now();
                for i in 0..iters {
                    let _ = tx.send(Event::ConfigUpdated { version: i });
                }
                let _ = tx.send(Event::Shutdown);
                let _ = slow.await;
                start.elapsed()
            })
        });
    });

    group.finish();
}

pub fn criterion_benches(c: &mut Criterion) {
    bench_publish_zero_subs(c);
    bench_publish_eight_subs(c);
    bench_publish_with_one_slow_subscriber(c);
}

criterion_group!(benches, criterion_benches);
criterion_main!(benches);

```

### crates/ron-bus/deny.toml
<a id="crates-ron-bus-deny-toml"></a>

```toml
# cargo-deny config (placeholder). See workspace root for canonical policy.

```

### crates/ron-bus/examples/publish_smoke.rs
<a id="crates-ron-bus-examples-publishsmoke-rs"></a>

```rust
//! RO:WHAT — Minimal publish/subscribe smoke example
//! RO:WHY  — Shows intended pattern: one receiver per task, bounded queue, graceful shutdown
//! RO:INTERACTS — Bus, BusConfig, Event
//! RO:INVARIANTS — no background tasks created by the library; host owns subscribers/metrics

use ron_bus::{Bus, BusConfig, Event};

#[tokio::main(flavor = "current_thread")]
async fn main() {
    let bus = Bus::new(BusConfig::new().with_capacity(1024)).expect("bus");
    let tx = bus.sender();

    let mut rx = bus.subscribe();
    let worker = tokio::spawn(async move {
        loop {
            match rx.recv().await {
                Ok(Event::Shutdown) => {
                    println!("worker: shutdown received");
                    break;
                }
                Ok(ev) => {
                    println!("worker: got {:?}", ev);
                }
                Err(e) => {
                    println!("worker: recv error = {:?}", e);
                    break;
                }
            }
        }
    });

    let _ = tx.send(Event::Health {
        service: "svc.a".into(),
        ok: true,
    });
    let _ = tx.send(Event::ConfigUpdated { version: 1 });
    let _ = tx.send(Event::Shutdown);

    let _ = worker.await;
}

```

### crates/ron-bus/rust-toolchain.toml
<a id="crates-ron-bus-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/ron-bus/scripts/smoke_ron_bus.sh
<a id="crates-ron-bus-scripts-smokeronbus-sh"></a>

```bash
#!/usr/bin/env bash
# ron-bus smoke: format (write), lint, test, example, benches (perf-biased)
# Not battery-friendly: uses native CPU flags and longer measurement windows.
# Emits artifacts under artifacts/ron-bus/<timestamp>.

set -euo pipefail

# Resolve repo root (even if invoked from this scripts/ dir)
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$REPO_ROOT"

CRATE="ron-bus"
DATE_TAG="$(date +%Y%m%d-%H%M%S)"
BASELINE="smoke-${DATE_TAG}"
ART_DIR="${REPO_ROOT}/artifacts/ron-bus/${DATE_TAG}"
LOG_DIR="${ART_DIR}/logs"
mkdir -p "${LOG_DIR}"

echo "== ron-bus smoke start @ ${DATE_TAG} =="

echo "== format (write) =="
cargo fmt -p "${CRATE}"

echo "== format (verify) =="
cargo fmt -p "${CRATE}" -- --check

echo "== clippy =="
cargo clippy -p "${CRATE}" --all-targets -- -D warnings | tee "${LOG_DIR}/clippy.txt"

echo "== tests =="
cargo test -p "${CRATE}" | tee "${LOG_DIR}/tests.txt"

echo "== example: publish_smoke =="
cargo run -p "${CRATE}" --example publish_smoke | tee "${LOG_DIR}/publish_smoke.txt"

# Performance-oriented flags: native CPU (not battery-friendly)
export RUSTFLAGS="-C target-cpu=native"

echo "== benches: throughput =="
cargo bench -p "${CRATE}" --bench throughput -- \
  --warm-up-time 2 --measurement-time 5 --sample-size 30 \
  | tee "${LOG_DIR}/bench_throughput.txt"

echo "== benches: latency =="
cargo bench -p "${CRATE}" --bench latency -- \
  --warm-up-time 2 --measurement-time 5 --sample-size 30 \
  | tee "${LOG_DIR}/bench_latency.txt"

echo "== benches: A/B compare =="
cargo bench -p "${CRATE}" --bench ab_compare -- \
  --warm-up-time 3 --measurement-time 10 --sample-size 50 \
  --save-baseline "${BASELINE}" \
  | tee "${LOG_DIR}/bench_ab_compare.txt"

# Copy full Criterion reports
if [ -d "target/criterion" ]; then
  mkdir -p "${ART_DIR}"
  cp -R target/criterion "${ART_DIR}/criterion"
fi

# Quick-and-dirty summary from Criterion files (heuristic)
SUMMARY="${ART_DIR}/ab_compare_summary.txt"
echo "== summarizing ab_compare results =="

AB_DIRS="$(find target/criterion -maxdepth 2 -type d -name 'ab_*' 2>/dev/null || true)"
{
  echo "ron-bus A/B summary (${DATE_TAG})"
  echo "baseline: ${BASELINE}"
  echo
  if [ -n "${AB_DIRS}" ]; then
    # Pull function names + 'time: [' lines from report text files
    grep -RHEn "ab_.*|time:\s+\[" ${AB_DIRS} 2>/dev/null \
      | sed -E 's|^.*/||' \
      | sed -E 's|.*/report.txt:||' || true
  else
    echo "No ab_* groups found under target/criterion."
  fi
} > "${SUMMARY}"

echo "== artifacts =="
echo "Logs:       ${LOG_DIR}"
echo "Criterion:  ${ART_DIR}/criterion"
echo "A/B summary:${SUMMARY}"

echo "== ron-bus smoke done =="

```

### crates/ron-bus/scripts/update_api_snapshot.sh
<a id="crates-ron-bus-scripts-updateapisnapshot-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Placeholder to regenerate public API snapshot into docs/api-history/ron-bus/
echo "Implement public API snapshot generation here."

```

### crates/ron-bus/src/bus.rs
<a id="crates-ron-bus-src-bus-rs"></a>

```rust
//! RO:WHAT — Core Bus type wrapping a bounded Tokio broadcast channel
//! RO:WHY  — Provide monomorphic, bounded, lossy, observable-by-host semantics
//! RO:INTERACTS — config::BusConfig; internal::channel; event::Event
//! RO:INVARIANTS — bounded channel; capacity fixed; no background tasks; host updates metrics
//! RO:TEST — tests/* cover fanout, lag/overflow, cutover

use crate::{config::BusConfig, errors::BusError, event::Event, internal::channel};
use tokio::sync::broadcast::{Receiver, Sender};

/// Bounded in-process broadcast bus (lossy for lagging receivers).
pub struct Bus {
    tx: Sender<Event>,
    capacity: usize,
}

impl Bus {
    /// Construct a new Bus from a config (or default).
    pub fn new(cfg: impl Into<BusConfig>) -> Result<Self, BusError> {
        let cfg = cfg.into();
        cfg.validate().map_err(BusError::Config)?;
        let capacity = cfg.capacity as usize;
        let (tx, _rx) = channel::bounded::<Event>(capacity);
        // Drop the initial receiver; users will call subscribe(). No background tasks here.
        Ok(Self { tx, capacity })
    }

    /// Cloneable sender handle for publishers.
    pub fn sender(&self) -> Sender<Event> {
        self.tx.clone()
    }

    /// Unique receiver for a single subscriber task.
    ///
    /// Pattern: **one receiver per task** to avoid unintended sharing/races.
    pub fn subscribe(&self) -> Receiver<Event> {
        self.tx.subscribe()
    }

    /// The bounded queue capacity (messages).
    pub fn capacity(&self) -> usize {
        self.capacity
    }
}

```

### crates/ron-bus/src/config.rs
<a id="crates-ron-bus-src-config-rs"></a>

```rust
//! RO:WHAT — Host-constructed configuration for Bus
//! RO:WHY  — Capacity & observability knobs are fixed at construction (cutover by rebuild)
//! RO:INTERACTS — Used by Bus::new(cfg); host is responsible for reading env/files/flags
//! RO:INVARIANTS — capacity >= 2 and reasonable upper bound; no runtime mutation
//! RO:TEST — Unit: validate bounds; Integration: capacity_cutover
//! RO:NOTE — Marked #[non_exhaustive] to allow additive evolution without SemVer breaks.
//!           Because of this, external crates must use the builder helpers rather than
//!           struct-literal syntax.

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// Host-facing configuration for constructing a [`Bus`].
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
#[derive(Debug, Clone)]
pub struct BusConfig {
    /// Bounded broadcast buffer size (messages).
    pub capacity: u32,
    /// Host WARN throttling (per minute) for overflow logs; library does not log.
    pub overflow_warn_rate_per_min: u32,
    /// Optional namespace the host may use for metrics; library is metrics-neutral.
    pub metrics_namespace: String,
    /// If true, hosts may attach amnesia={on|off} label to metrics.
    pub emit_amnesia_label: bool,
}

impl Default for BusConfig {
    fn default() -> Self {
        Self {
            capacity: 256,
            overflow_warn_rate_per_min: 60,
            metrics_namespace: "ronbus".to_string(),
            emit_amnesia_label: true,
        }
    }
}

impl BusConfig {
    /// Create with default values (same as `Default::default()`).
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the bounded capacity (messages).
    pub fn with_capacity(mut self, capacity: u32) -> Self {
        self.capacity = capacity;
        self
    }

    /// Set the overflow warn throttle (per minute).
    pub fn with_overflow_warn_rate_per_min(mut self, rate: u32) -> Self {
        self.overflow_warn_rate_per_min = rate;
        self
    }

    /// Set the metrics namespace hint (library remains metrics-neutral).
    pub fn with_metrics_namespace<S: Into<String>>(mut self, ns: S) -> Self {
        self.metrics_namespace = ns.into();
        self
    }

    /// Toggle amnesia label emission hint.
    pub fn with_emit_amnesia_label(mut self, yes: bool) -> Self {
        self.emit_amnesia_label = yes;
        self
    }

    /// Validate bounds & basic invariants.
    pub fn validate(&self) -> Result<(), String> {
        if self.capacity < 2 {
            return Err("capacity must be >= 2".into());
        }
        if self.capacity > (1 << 20) {
            // Keep memory sane; Tokio broadcast alloc is O(capacity)
            return Err("capacity too large; must be <= 1,048,576".into());
        }
        Ok(())
    }
}

```

### crates/ron-bus/src/errors.rs
<a id="crates-ron-bus-src-errors-rs"></a>

```rust
//! RO:WHAT — Local error taxonomy for Bus construction/usage
//! RO:WHY  — Keep external semantics explicit & stable (SemVer)
//! RO:INTERACTS — Returned by Bus::new(); complements tokio::broadcast RecvError at call sites
//! RO:INVARIANTS — small, non_exhaustive; no std::error::Error to avoid error stack bloat
//! RO:TEST — Unit: config errors; Integration: negative patterns

/// Errors constructing or using the Bus surface.
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum BusError {
    /// Invalid configuration: contains a human-readable reason.
    Config(String),
    /// Channel was closed (no subscribers left).
    Closed,
}

```

### crates/ron-bus/src/event.rs
<a id="crates-ron-bus-src-event-rs"></a>

```rust
//! RO:WHAT — Canonical Event enum carried on the bus
//! RO:WHY  — Aligns with kernel public surface; additive-safe growth (#[non_exhaustive])
//! RO:INTERACTS — Consumed by hosts/services; produced by kernel/supervision
//! RO:INVARIANTS — DTO hygiene; keep variants small; no secrets/PII in payloads
//! RO:TEST — Unit: variant roundtrips; Integration: fanout_ok

/// Kernel-aligned, additive-safe event set.
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Event {
    /// Liveness of a named service.
    Health { service: String, ok: bool },
    /// Host config hot-reload emitted version.
    ConfigUpdated { version: u64 },
    /// Supervisor noticed a crash; reason is informational.
    ServiceCrashed { service: String, reason: String },
    /// Coordinated shutdown signal.
    Shutdown,
}

```

### crates/ron-bus/src/internal/channel.rs
<a id="crates-ron-bus-src-internal-channel-rs"></a>

```rust
//! RO:WHAT — Narrow wrapper for creating a bounded Tokio broadcast channel
//! RO:WHY  — Centralize invariants and future tweaks (e.g., debug asserts)
//! RO:INTERACTS — used by Bus::new()
//! RO:INVARIANTS — capacity >= 2; bounded queue; one receiver per task pattern
//! RO:TEST — Indirect via Bus integration tests

use tokio::sync::broadcast;

/// A simple constructor wrapper to emphasize bounded semantics.
pub fn bounded<T: Clone>(capacity: usize) -> (broadcast::Sender<T>, broadcast::Receiver<T>) {
    // Tokio ensures capacity >= 1 produces a bounded channel; we pre-validate in BusConfig.
    broadcast::channel(capacity)
}

```

### crates/ron-bus/src/internal/depth_estimator.rs
<a id="crates-ron-bus-src-internal-depthestimator-rs"></a>

```rust
//! RO:WHAT — Tiny, optional queue depth heuristic for hosts/tests.
//! RO:WHY  — Tokio broadcast does not expose depth/len; we can maintain a
//!           conservative estimate from observed lag and publishes to help
//!           hosts make decisions (e.g., increase capacity, cut over).
//! RO:INTERACTS — Used by host loops/tests; not required by Bus hot path.
//! RO:INVARIANTS — Lock-free from the API perspective; no `.await` here.
//! RO:SECURITY — No secrets/PII; pure counters.
//! RO:TEST — Covered indirectly in integration benches/tests as needed.

use core::sync::atomic::{AtomicU64, Ordering};

/// A conservative queue depth heuristic derived from observed lag/drop.
///
/// This is **purely optional** and **not** wired into the Bus hot path.
/// Hosts may instantiate and update it from their recv loop whenever they
/// observe `RecvError::Lagged(n)` or after batches of publishes.
#[derive(Debug, Default)]
pub struct DepthEstimator {
    /// Count of published messages we tracked (monotonic).
    pub_published: AtomicU64,
    /// Sum of observed lag events (messages skipped by a receiver).
    pub_lagged_sum: AtomicU64,
}

impl DepthEstimator {
    /// Create a new estimator.
    pub const fn new() -> Self {
        Self {
            pub_published: AtomicU64::new(0),
            pub_lagged_sum: AtomicU64::new(0),
        }
    }

    /// Record that `n` messages were published (best effort).
    #[inline]
    pub fn on_published(&self, n: u64) {
        if n != 0 {
            self.pub_published.fetch_add(n, Ordering::Relaxed);
        }
    }

    /// Record that a receiver observed `lagged` dropped messages.
    #[inline]
    pub fn on_lagged(&self, lagged: u64) {
        if lagged != 0 {
            self.pub_lagged_sum.fetch_add(lagged, Ordering::Relaxed);
        }
    }

    /// Snapshot a conservative estimate.
    ///
    /// Not a true queue length — broadcast fanout and differing subscriber
    /// speeds mean there is no single “depth” — but this gives hosts a stable
    /// scalar to alert on (e.g., > X lagged per second).
    #[inline]
    pub fn snapshot(&self) -> DepthSnapshot {
        DepthSnapshot {
            published: self.pub_published.load(Ordering::Relaxed),
            lagged_sum: self.pub_lagged_sum.load(Ordering::Relaxed),
        }
    }

    /// Reset counters (e.g., at the end of a reporting interval).
    #[inline]
    pub fn reset(&self) {
        self.pub_published.store(0, Ordering::Relaxed);
        self.pub_lagged_sum.store(0, Ordering::Relaxed);
    }
}

/// Point-in-time heuristic values.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub struct DepthSnapshot {
    pub published: u64,
    pub lagged_sum: u64,
}

impl DepthSnapshot {
    /// Returns an “estimated pressure” scalar suitable for alerting.
    ///
    /// Right now this is a simple passthrough of `lagged_sum`. Hosts may
    /// choose to apply a moving average or rate conversion externally.
    #[inline]
    pub fn pressure(self) -> u64 {
        self.lagged_sum
    }
}

```

### crates/ron-bus/src/internal/mod.rs
<a id="crates-ron-bus-src-internal-mod-rs"></a>

```rust
//! RO:WHAT — Small internal helpers to keep public files tiny.
//! RO:WHY  — Encapsulate wrappers/heuristics and document invariants once.
//! RO:INTERACTS — `channel` (Tokio broadcast wrapper); optional `depth_estimator`.
//! RO:INVARIANTS — No locks across `.await`; bounded channels only; no bg tasks.

pub mod channel;
pub mod depth_estimator;

pub use channel::bounded as bounded_channel;
pub use depth_estimator::{DepthEstimator, DepthSnapshot};

#[cfg(test)]
mod _doc_pattern {
    use tokio::sync::broadcast;

    // Ensure our wrapper returns the same types we expect from Tokio.
    #[test]
    fn channel_types_match() {
        let (tx, rx): (broadcast::Sender<u8>, broadcast::Receiver<u8>) = super::channel::bounded(8);
        drop((tx, rx));
    }
}

```

### crates/ron-bus/src/lib.rs
<a id="crates-ron-bus-src-lib-rs"></a>

```rust
//! RO:WHAT — Public surface for the in-process broadcast bus (bounded, lossy, observable-by-host)
//! RO:WHY  — Pillar 1 (Kernel & Orchestration); Concerns: RES/PERF (bounded backpressure, no locks across .await)
//! RO:INTERACTS — internal::channel (tokio::broadcast wrapper); public: Bus, BusConfig, Event, BusError
//! RO:INVARIANTS — bounded channel; one receiver per task; no background tasks; no secrets/PII on bus
//! RO:METRICS — none inside crate (host updates counters/gauges in recv loop)
//! RO:CONFIG — capacity fixed at construction; cutover by constructing a new Bus
//! RO:SECURITY — no network/disk I/O; no payload logging; secret-free surface
//! RO:TEST — integration tests in tests/*; loom model optional (cfg(loom))

#![forbid(unsafe_code)]
#![deny(warnings)]

mod bus;
mod config;
mod errors;
mod event;

pub mod metrics;
pub mod prelude;

pub mod internal; // kept small; still non-public APIs within it

pub use bus::Bus;
pub use config::BusConfig;
pub use errors::BusError;
pub use event::Event;

#[cfg(doctest)]
mod _doctests {
    /// Minimal host-side pattern (bounded, one receiver per task).
    ///
    /// ```ignore
    /// use ron_bus::{Bus, BusConfig, Event};
    /// # #[tokio::main(flavor="current_thread")]
    /// # async fn main() {
    /// let bus = Bus::new(BusConfig::default()).unwrap();
    /// let mut rx = bus.subscribe();
    /// tokio::spawn(async move {
    ///     loop {
    ///         match rx.recv().await {
    ///             Ok(_ev) => { /* handle */ }
    ///             Err(tokio::sync::broadcast::error::RecvError::Lagged(n)) => {
    ///                 // host increments metrics here (outside this library)
    ///                 // metrics::bus_overflow_dropped_total().inc_by(n as u64);
    ///             }
    ///             Err(tokio::sync::broadcast::error::RecvError::Closed) => break,
    ///         }
    ///     }
    /// });
    /// bus.sender().send(Event::Shutdown).ok();
    /// # }
    /// ```
    fn _marker() {}
}

```

### crates/ron-bus/src/metrics.rs
<a id="crates-ron-bus-src-metrics-rs"></a>

```rust
//! RO:WHAT — Host-owned metrics facade (no-op default).
//! RO:WHY  — ron-bus does not emit metrics itself; hosts increment counters
//!           in their recv loops. This file provides a tiny trait & a noop
//!           impl for hosts/tests that want a uniform interface.
//! RO:INTERACTS — Referenced by hosts; not used by Bus hot path.
//! RO:INVARIANTS — No global state; zero-alloc; zero-cost if not used.

/// Minimal metrics interface hosts may use around ron-bus operations.
///
/// Intentionally tiny; hosts are free to add richer metrics externally.
pub trait BusMetrics {
    /// Count messages published (best-effort).
    fn inc_published(&self, n: u64);

    /// Count messages received (best-effort).
    fn inc_received(&self, n: u64);

    /// Count messages dropped due to lag (best-effort).
    fn inc_lagged_drop(&self, n: u64);
}

/// A no-op metrics sink (default).
#[derive(Debug, Default, Clone, Copy)]
pub struct NoopMetrics;

impl BusMetrics for NoopMetrics {
    #[inline]
    fn inc_published(&self, _n: u64) {}

    #[inline]
    fn inc_received(&self, _n: u64) {}

    #[inline]
    fn inc_lagged_drop(&self, _n: u64) {}
}

```

### crates/ron-bus/src/prelude.rs
<a id="crates-ron-bus-src-prelude-rs"></a>

```rust
//! RO:WHAT — Convenience prelude for common imports.
//! RO:WHY  — Reduce repetitive `use ron_bus::{...}` in host code/examples.
//! RO:INTERACTS — Re-exports public types only (no macros, no globals).
//! RO:INVARIANTS — Keep small and explicit.

pub use crate::{Bus, BusConfig, BusError, Event};

```

### crates/ron-bus/tests/api_surface.rs
<a id="crates-ron-bus-tests-apisurface-rs"></a>

```rust
// RO:WHAT — API surface smoke tests for ron-bus.
// RO:WHY  — Lock in the basic constructors and methods to catch accidental drift.
// RO:INTERACTS — Bus, BusConfig, Event.
// RO:INVARIANTS — Monomorphic Bus; capacity fixed at construction; one receiver per task.

use ron_bus::{Bus, BusConfig, Event};
use tokio::sync::broadcast::error::RecvError;

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn api_surface_basic() {
    // Default config path
    let bus = Bus::new(BusConfig::new()).expect("bus");
    assert!(bus.capacity() >= 2);

    // Builder path
    let bus = Bus::new(BusConfig::new().with_capacity(512)).expect("bus");
    assert_eq!(bus.capacity(), 512);

    // Sender / subscribe / send / recv
    let tx = bus.sender();
    let mut rx = bus.subscribe();

    tx.send(Event::ConfigUpdated { version: 1 }).unwrap();
    match rx.recv().await {
        Ok(Event::ConfigUpdated { version }) => assert_eq!(version, 1),
        other => panic!("unexpected recv: {:?}", other),
    }

    // Shutdown should be observable by the same receiver.
    tx.send(Event::Shutdown).unwrap();
    match rx.recv().await {
        Ok(Event::Shutdown) => {}
        Err(RecvError::Closed) => panic!("channel unexpectedly closed"),
        other => panic!("unexpected recv: {:?}", other),
    }
}

```

### crates/ron-bus/tests/capacity_cutover.rs
<a id="crates-ron-bus-tests-capacitycutover-rs"></a>

```rust
// RO:WHAT — Capacity cutover test (A -> drop -> B).
// RO:WHY  — Capacity is fixed; resizing is done by constructing a new Bus.
// RO:INTERACTS — Bus, BusConfig, Event.
// RO:INVARIANTS — No background tasks; old bus is dropped before new is created.

use ron_bus::{Bus, BusConfig, Event};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn capacity_cutover_recreate_bus() {
    // Bus A
    let bus_a = Bus::new(BusConfig::new().with_capacity(64)).expect("bus A");
    assert_eq!(bus_a.capacity(), 64);

    // Prove basic send/recv works
    let tx_a = bus_a.sender();
    let mut rx_a = bus_a.subscribe();
    tx_a.send(Event::ConfigUpdated { version: 100 }).unwrap();
    let ev = rx_a.recv().await.unwrap();
    match ev {
        Event::ConfigUpdated { version } => assert_eq!(version, 100),
        _ => panic!("unexpected event on bus A: {:?}", ev),
    }

    // Drop A, construct B with different capacity
    drop(rx_a);
    drop(tx_a);
    drop(bus_a);

    // Bus B
    let bus_b = Bus::new(BusConfig::new().with_capacity(128)).expect("bus B");
    assert_eq!(bus_b.capacity(), 128);

    let tx_b = bus_b.sender();
    let mut rx_b = bus_b.subscribe();
    tx_b.send(Event::Shutdown).unwrap();
    let ev = rx_b.recv().await.unwrap();
    matches!(ev, Event::Shutdown);
}

```

### crates/ron-bus/tests/chaos_amnesia.rs
<a id="crates-ron-bus-tests-chaosamnesia-rs"></a>

```rust
// ignored chaos amnesia test placeholder

```

### crates/ron-bus/tests/fanout_ok.rs
<a id="crates-ron-bus-tests-fanoutok-rs"></a>

```rust
// RO:WHAT — Happy-path fanout: N subscribers receive all events without lag
// RO:WHY  — Proves bounded bus works for steady load; publishers non-blocking
// RO:INTERACTS — Bus, BusConfig, Event
// RO:INVARIANTS — no deadlocks; all receivers get events when not lagging

use ron_bus::{Bus, BusConfig, Event};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn fanout_ok() {
    // Use builder because BusConfig is #[non_exhaustive]
    let cfg = BusConfig::new().with_capacity(256);
    let bus = Bus::new(cfg).unwrap();

    let mut rx1 = bus.subscribe();
    let mut rx2 = bus.subscribe();

    // Publish a couple of events
    let tx = bus.sender();
    tx.send(Event::Health {
        service: "svc.a".into(),
        ok: true,
    })
    .unwrap();
    tx.send(Event::Shutdown).unwrap();

    let a1 = rx1.recv().await.unwrap();
    let a2 = rx1.recv().await.unwrap();
    let b1 = rx2.recv().await.unwrap();
    let b2 = rx2.recv().await.unwrap();

    assert_eq!(
        a1,
        Event::Health {
            service: "svc.a".into(),
            ok: true
        }
    );
    assert_eq!(a2, Event::Shutdown);
    assert_eq!(
        b1,
        Event::Health {
            service: "svc.a".into(),
            ok: true
        }
    );
    assert_eq!(b2, Event::Shutdown);
}

```

### crates/ron-bus/tests/graceful_shutdown.rs
<a id="crates-ron-bus-tests-gracefulshutdown-rs"></a>

```rust
// RO:WHAT — Graceful shutdown convergence test.
// RO:WHY  — Final Shutdown should let receivers exit promptly (no hangs).
// RO:INTERACTS — Bus, BusConfig, Event.
// RO:INVARIANTS — Bounded, no background tasks; receivers exit on Shutdown.

use ron_bus::{Bus, BusConfig, Event};
use tokio::time::{timeout, Duration};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn graceful_shutdown_converges() {
    let bus = Bus::new(BusConfig::new().with_capacity(256)).unwrap();
    let tx = bus.sender();

    let mut rx1 = bus.subscribe();
    let t1 = tokio::spawn(async move {
        loop {
            match rx1.recv().await {
                Ok(Event::Shutdown) | Err(_) => break,
                _ => {}
            }
        }
    });

    let mut rx2 = bus.subscribe();
    let t2 = tokio::spawn(async move {
        loop {
            match rx2.recv().await {
                Ok(Event::Shutdown) | Err(_) => break,
                _ => {}
            }
        }
    });

    // Emit some traffic then Shutdown
    for i in 0..10 {
        let _ = tx.send(Event::ConfigUpdated { version: i });
    }
    let _ = tx.send(Event::Shutdown);

    // Must converge quickly
    timeout(Duration::from_secs(2), async {
        let _ = tokio::join!(t1, t2);
    })
    .await
    .expect("receivers failed to observe Shutdown in time");
}

```

### crates/ron-bus/tests/lagged_overflow_smoke.rs
<a id="crates-ron-bus-tests-laggedoverflowsmoke-rs"></a>

```rust
// RO:WHAT — Force lag on a slow subscriber to observe Lagged(n)
// RO:WHY  — Demonstrate lossy semantics under bounded overflow (host would count metrics)
// RO:INTERACTS — Bus, BusConfig, Event
// RO:INVARIANTS — publisher never blocks; slow consumer gets Lagged(n) and eventually exits on Shutdown
//
// Behavior notes:
// - We intentionally make the consumer slow to trigger RecvError::Lagged(n).
// - We publish Shutdown as the *last* message so that after any lag, the next Ok()
//   should observe Shutdown and break cleanly.

use ron_bus::{Bus, BusConfig, Event};
use std::sync::Arc;
use tokio::sync::broadcast::error::RecvError;
use tokio::sync::Barrier;
use tokio::time::{sleep, timeout, Duration};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn lagged_overflow_smoke() {
    let cap = 8u32; // tiny to trigger lag
    let bus = Bus::new(BusConfig::new().with_capacity(cap)).unwrap();
    let tx = bus.sender();

    let barrier = Arc::new(Barrier::new(2));

    // Slow consumer
    let mut rx_slow = bus.subscribe();
    let slow = {
        let barrier = Arc::clone(&barrier);
        tokio::spawn(async move {
            barrier.wait().await;
            let mut lagged_total = 0u64;
            loop {
                match rx_slow.recv().await {
                    Ok(Event::Shutdown) => break lagged_total,
                    Ok(_ev) => {
                        // Simulate work; large enough to induce lag with small capacity.
                        sleep(Duration::from_millis(2)).await;
                    }
                    Err(RecvError::Lagged(n)) => {
                        lagged_total += n;
                        // host would: metrics::bus_overflow_dropped_total().inc_by(n as u64);
                    }
                    Err(RecvError::Closed) => break lagged_total,
                }
            }
        })
    };

    // Fast publisher loop
    let pubber = {
        let barrier = Arc::clone(&barrier);
        tokio::spawn(async move {
            barrier.wait().await;
            for i in 0..200u32 {
                let _ = tx.send(Event::ConfigUpdated { version: i as u64 });
            }
            // Place Shutdown as the final message so late receivers converge to it.
            let _ = tx.send(Event::Shutdown);
        })
    };

    // Add a timeout safety net so the test never hangs indefinitely.
    let result = timeout(Duration::from_secs(5), async {
        let (_pub_res, lagged_total) = tokio::join!(pubber, slow);
        lagged_total.unwrap()
    })
    .await;

    match result {
        Ok(lagged_total) => {
            assert!(
                lagged_total > 0,
                "expected Lagged(n) to occur for slow consumer"
            );
        }
        Err(_elapsed) => panic!("test timed out waiting for consumer to observe Shutdown"),
    }
}

```

### crates/ron-bus/tests/loom_model.rs
<a id="crates-ron-bus-tests-loommodel-rs"></a>

```rust
// loom model test placeholder

```

### crates/ron-bus/tests/pq_labels_feature.rs
<a id="crates-ron-bus-tests-pqlabelsfeature-rs"></a>

```rust
// pq-labels feature test placeholder

```

### crates/ron-bus/tests/property_bus.rs
<a id="crates-ron-bus-tests-propertybus-rs"></a>

```rust
// property-based tests placeholder

```

### crates/ron-bus/tests/receiver_ownership.rs
<a id="crates-ron-bus-tests-receiverownership-rs"></a>

```rust
// receiver_ownership test placeholder

```



---



# ron-proto

_Source: crates/ron-proto/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:48:14Z -->
# Code Bundle — `ron-proto`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-proto/.github/workflows/ci.yml](#crates-ron-proto--github-workflows-ci-yml)
- [crates/ron-proto/.github/workflows/fuzz.yml](#crates-ron-proto--github-workflows-fuzz-yml)
- [crates/ron-proto/.github/workflows/render-mermaid.yml](#crates-ron-proto--github-workflows-render-mermaid-yml)
- [crates/ron-proto/Cargo.toml](#crates-ron-proto-Cargo-toml)
- [crates/ron-proto/benches/encode_decode_large.rs](#crates-ron-proto-benches-encodedecodelarge-rs)
- [crates/ron-proto/benches/encode_decode_small.rs](#crates-ron-proto-benches-encodedecodesmall-rs)
- [crates/ron-proto/examples/hello_json.rs](#crates-ron-proto-examples-hellojson-rs)
- [crates/ron-proto/fuzz/Cargo.toml](#crates-ron-proto-fuzz-Cargo-toml)
- [crates/ron-proto/fuzz/fuzz_targets/decode_capability.rs](#crates-ron-proto-fuzz-fuzztargets-decodecapability-rs)
- [crates/ron-proto/fuzz/fuzz_targets/decode_manifest.rs](#crates-ron-proto-fuzz-fuzztargets-decodemanifest-rs)
- [crates/ron-proto/fuzz/fuzz_targets/decode_oap_header.rs](#crates-ron-proto-fuzz-fuzztargets-decodeoapheader-rs)
- [crates/ron-proto/fuzz/fuzz_targets/parse_contentid.rs](#crates-ron-proto-fuzz-fuzztargets-parsecontentid-rs)
- [crates/ron-proto/src/cap/caveats.rs](#crates-ron-proto-src-cap-caveats-rs)
- [crates/ron-proto/src/cap/header.rs](#crates-ron-proto-src-cap-header-rs)
- [crates/ron-proto/src/cap/mod.rs](#crates-ron-proto-src-cap-mod-rs)
- [crates/ron-proto/src/config/mod.rs](#crates-ron-proto-src-config-mod-rs)
- [crates/ron-proto/src/config/validate.rs](#crates-ron-proto-src-config-validate-rs)
- [crates/ron-proto/src/econ/mod.rs](#crates-ron-proto-src-econ-mod-rs)
- [crates/ron-proto/src/econ/move_entry.rs](#crates-ron-proto-src-econ-moveentry-rs)
- [crates/ron-proto/src/error/kind.rs](#crates-ron-proto-src-error-kind-rs)
- [crates/ron-proto/src/error/mod.rs](#crates-ron-proto-src-error-mod-rs)
- [crates/ron-proto/src/error/reason.rs](#crates-ron-proto-src-error-reason-rs)
- [crates/ron-proto/src/gov/mod.rs](#crates-ron-proto-src-gov-mod-rs)
- [crates/ron-proto/src/gov/signed_descriptor.rs](#crates-ron-proto-src-gov-signeddescriptor-rs)
- [crates/ron-proto/src/id/content_id.rs](#crates-ron-proto-src-id-contentid-rs)
- [crates/ron-proto/src/id/mod.rs](#crates-ron-proto-src-id-mod-rs)
- [crates/ron-proto/src/id/parse.rs](#crates-ron-proto-src-id-parse-rs)
- [crates/ron-proto/src/lib.rs](#crates-ron-proto-src-lib-rs)
- [crates/ron-proto/src/mailbox/ack.rs](#crates-ron-proto-src-mailbox-ack-rs)
- [crates/ron-proto/src/mailbox/mod.rs](#crates-ron-proto-src-mailbox-mod-rs)
- [crates/ron-proto/src/mailbox/recv.rs](#crates-ron-proto-src-mailbox-recv-rs)
- [crates/ron-proto/src/mailbox/send.rs](#crates-ron-proto-src-mailbox-send-rs)
- [crates/ron-proto/src/manifest/common.rs](#crates-ron-proto-src-manifest-common-rs)
- [crates/ron-proto/src/manifest/mod.rs](#crates-ron-proto-src-manifest-mod-rs)
- [crates/ron-proto/src/manifest/v1.rs](#crates-ron-proto-src-manifest-v1-rs)
- [crates/ron-proto/src/naming.rs](#crates-ron-proto-src-naming-rs)
- [crates/ron-proto/src/oap/data.rs](#crates-ron-proto-src-oap-data-rs)
- [crates/ron-proto/src/oap/end.rs](#crates-ron-proto-src-oap-end-rs)
- [crates/ron-proto/src/oap/error.rs](#crates-ron-proto-src-oap-error-rs)
- [crates/ron-proto/src/oap/hello.rs](#crates-ron-proto-src-oap-hello-rs)
- [crates/ron-proto/src/oap/mod.rs](#crates-ron-proto-src-oap-mod-rs)
- [crates/ron-proto/src/oap/start.rs](#crates-ron-proto-src-oap-start-rs)
- [crates/ron-proto/src/quantum/mod.rs](#crates-ron-proto-src-quantum-mod-rs)
- [crates/ron-proto/src/quantum/pq_tags.rs](#crates-ron-proto-src-quantum-pqtags-rs)
- [crates/ron-proto/src/trace.rs](#crates-ron-proto-src-trace-rs)
- [crates/ron-proto/src/version.rs](#crates-ron-proto-src-version-rs)
- [crates/ron-proto/testing/performance/baselines/ron-proto.json](#crates-ron-proto-testing-performance-baselines-ron-proto-json)
- [crates/ron-proto/tests/content_id.rs](#crates-ron-proto-tests-contentid-rs)
- [crates/ron-proto/tests/cross_version.rs](#crates-ron-proto-tests-crossversion-rs)
- [crates/ron-proto/tests/econ_conservation.rs](#crates-ron-proto-tests-econconservation-rs)
- [crates/ron-proto/tests/golden_vectors.rs](#crates-ron-proto-tests-goldenvectors-rs)
- [crates/ron-proto/tests/hash_truth.rs](#crates-ron-proto-tests-hashtruth-rs)
- [crates/ron-proto/tests/interop_parity.rs](#crates-ron-proto-tests-interopparity-rs)
- [crates/ron-proto/tests/manifest_defaults.rs](#crates-ron-proto-tests-manifestdefaults-rs)
- [crates/ron-proto/tests/oap_roundtrip.rs](#crates-ron-proto-tests-oaproundtrip-rs)
- [crates/ron-proto/tests/validate_helpers.rs](#crates-ron-proto-tests-validatehelpers-rs)
- [crates/ron-proto/tests/vectors/content_id.json](#crates-ron-proto-tests-vectors-contentid-json)
- [crates/ron-proto/tests/vectors/manifest_v1.json](#crates-ron-proto-tests-vectors-manifestv1-json)
- [crates/ron-proto/tests/vectors/oap_data_min.json](#crates-ron-proto-tests-vectors-oapdatamin-json)
- [crates/ron-proto/tests/vectors/oap_error_envelope.json](#crates-ron-proto-tests-vectors-oaperrorenvelope-json)
- [crates/ron-proto/tests/vectors/oap_hello_v1.json](#crates-ron-proto-tests-vectors-oaphellov1-json)

### crates/ron-proto/.github/workflows/ci.yml
<a id="crates-ron-proto--github-workflows-ci-yml"></a>

```yaml

```

### crates/ron-proto/.github/workflows/fuzz.yml
<a id="crates-ron-proto--github-workflows-fuzz-yml"></a>

```yaml

```

### crates/ron-proto/.github/workflows/render-mermaid.yml
<a id="crates-ron-proto--github-workflows-render-mermaid-yml"></a>

```yaml

```

### crates/ron-proto/Cargo.toml
<a id="crates-ron-proto-Cargo-toml"></a>

```toml
[package]
name = "ron-proto"
version = "0.1.0"
edition = "2021"
rust-version = "1.80"
license = "MIT OR Apache-2.0"
description = "RustyOnions canonical DTOs: IDs, OAP/1 envelopes, manifests, mailbox, capability headers, error taxonomy."
repository = "https://example.com/RustyOnions"
readme = "README.md"
categories = ["network-programming", "data-structures"]
keywords = ["dto", "serde", "protocol"]

[lib]
name = "ron_proto"
path = "src/lib.rs"

[features]
# No "serde" feature here—serde is required always.
cbor = ["serde_cbor"]
schemars = ["dep:schemars"]

[dependencies]
bytes = { version = "1.7", default-features = false }
serde = { version = "1.0", features = ["derive"] }
serde_json = { version = "1.0", default-features = true }
serde_bytes = "0.11"
thiserror = "1.0"

# Optional formats / tooling
serde_cbor = { version = "0.11", optional = true }
schemars = { version = "0.8", optional = true, default-features = false, features = ["either", "uuid"] }

[dev-dependencies]
proptest = "1.6"
rand = "0.9"

```

### crates/ron-proto/benches/encode_decode_large.rs
<a id="crates-ron-proto-benches-encodedecodelarge-rs"></a>

```rust


```

### crates/ron-proto/benches/encode_decode_small.rs
<a id="crates-ron-proto-benches-encodedecodesmall-rs"></a>

```rust


```

### crates/ron-proto/examples/hello_json.rs
<a id="crates-ron-proto-examples-hellojson-rs"></a>

```rust
use ron_proto::oap::hello::Hello;
use serde_json as json;

fn main() {
    let hello = Hello::default();
    println!("{}", json::to_string_pretty(&hello).unwrap());
}

```

### crates/ron-proto/fuzz/Cargo.toml
<a id="crates-ron-proto-fuzz-Cargo-toml"></a>

```toml

```

### crates/ron-proto/fuzz/fuzz_targets/decode_capability.rs
<a id="crates-ron-proto-fuzz-fuzztargets-decodecapability-rs"></a>

```rust

```

### crates/ron-proto/fuzz/fuzz_targets/decode_manifest.rs
<a id="crates-ron-proto-fuzz-fuzztargets-decodemanifest-rs"></a>

```rust

```

### crates/ron-proto/fuzz/fuzz_targets/decode_oap_header.rs
<a id="crates-ron-proto-fuzz-fuzztargets-decodeoapheader-rs"></a>

```rust

```

### crates/ron-proto/fuzz/fuzz_targets/parse_contentid.rs
<a id="crates-ron-proto-fuzz-fuzztargets-parsecontentid-rs"></a>

```rust

```

### crates/ron-proto/src/cap/caveats.rs
<a id="crates-ron-proto-src-cap-caveats-rs"></a>

```rust
//! RO:WHAT — Enumerated caveats/flags attached to capability tokens.
//! RO:WHY  — Additive growth via non_exhaustive enum + reserved fields.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "kind", rename_all = "snake_case", deny_unknown_fields)]
#[non_exhaustive]
pub enum Caveat {
    IpAllowlist { cidrs: Vec<String> },
    WriteOnce,
    ContentPrefix { prefix: String }, // e.g., restrict to a subtree/name
}
pub type CaveatKind = Caveat;

```

### crates/ron-proto/src/cap/header.rs
<a id="crates-ron-proto-src-cap-header-rs"></a>

```rust
//! RO:WHAT — `CapTokenHdr` with typed claims (no signatures here).
//! RO:WHY  — Stable header schema for capability enforcement.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct CapTokenHdr {
    pub subject: String, // e.g., user or service id
    pub scope: String,   // e.g., "read", "write-once"
    pub issued_at: u64,  // seconds
    pub expires_at: u64, // seconds (short TTL recommended)
    #[serde(default)]
    pub caveats: Vec<crate::cap::Caveat>,
}

```

### crates/ron-proto/src/cap/mod.rs
<a id="crates-ron-proto-src-cap-mod-rs"></a>

```rust
//! RO:WHAT — Capability token header DTOs (claims/caveats only).
//! RO:WHY  — Typed claims for macaroon-style caps; verification lives in auth services.

pub mod caveats;
pub mod header;

pub use caveats::{Caveat, CaveatKind};
pub use header::CapTokenHdr;

```

### crates/ron-proto/src/config/mod.rs
<a id="crates-ron-proto-src-config-mod-rs"></a>

```rust
//! RO:WHAT — Lightweight, DTO-level validation helpers (no I/O).
//! RO:WHY  — Central place to enforce protocol invariants shared by hosts.
//! RO:INTERACTS — oap::{hello,start,data,end}, version::PROTO_VERSION, error::{ProtoError,Kind}.
//! RO:INVARIANTS — Pure functions; return `ProtoError` with stable reason strings.

use crate::error::{Kind, ProtoError};

/// Validate that the peer speaks our protocol/version.
pub fn validate_hello(h: &crate::oap::hello::Hello) -> Result<(), ProtoError> {
    if h.protocol != "OAP/1" {
        return Err(ProtoError {
            kind: Kind::ProtoMismatch,
            message: format!("unsupported protocol '{}'", h.protocol),
        });
    }
    if h.version != crate::version::PROTO_VERSION {
        return Err(ProtoError {
            kind: Kind::ProtoMismatch,
            message: format!("version {} != {}", h.version, crate::version::PROTO_VERSION),
        });
    }
    Ok(())
}

/// Validate START frame limits against the OAP cap.
pub fn validate_start(s: &crate::oap::start::Start) -> Result<(), ProtoError> {
    if (s.max_frame_bytes as usize) > crate::oap::MAX_FRAME_BYTES {
        return Err(ProtoError {
            kind: Kind::TooLarge,
            message: format!(
                "max_frame_bytes={} exceeds cap {}",
                s.max_frame_bytes,
                crate::oap::MAX_FRAME_BYTES
            ),
        });
    }
    Ok(())
}

/// Validate a DATA frame's payload size against a negotiated bound.
///
/// `negotiated_max` should come from `Start.max_frame_bytes` (after `validate_start`).
pub fn validate_data(d: &crate::oap::data::Data, negotiated_max: u32) -> Result<(), ProtoError> {
    let len = d.bytes.len() as u32;
    if len > negotiated_max {
        return Err(ProtoError {
            kind: Kind::TooLarge,
            message: format!("data bytes={} > negotiated_max={}", len, negotiated_max),
        });
    }
    Ok(())
}

/// Validate monotonic sequence progression (host streams can opt-in).
pub fn validate_seq_progress(prev: u64, next: u64) -> Result<(), ProtoError> {
    if next <= prev {
        return Err(ProtoError {
            kind: Kind::BadRequest,
            message: format!("non-monotonic seq: next={} <= prev={}", next, prev),
        });
    }
    Ok(())
}

// Re-export trait sugar for callers who prefer impl-based validation.
pub mod validate;
pub use validate::{Limits, Validate}; // <— re-export both so users can `use ron_proto::{Validate, Limits};`

```

### crates/ron-proto/src/config/validate.rs
<a id="crates-ron-proto-src-config-validate-rs"></a>

```rust
//! RO:WHAT — Trait-based validation sugar for DTOs.
//! RO:WHY  — Optional ergonomics so hosts can call `x.validate(...)` directly.

use crate::config::{validate_data, validate_hello, validate_start};
use crate::error::ProtoError;

/// Negotiated/host limits needed for validating certain frames.
#[derive(Debug, Clone, Copy)]
pub struct Limits {
    /// Max bytes allowed in a single DATA frame (usually negotiated from START).
    pub max_frame_bytes: u32,
}

impl Default for Limits {
    fn default() -> Self {
        // Be conservative by default; many hosts will set this from START.
        Self {
            max_frame_bytes: crate::oap::MAX_FRAME_BYTES as u32,
        }
    }
}

/// DTOs can opt into trait-based validation.
pub trait Validate {
    fn validate(&self, limits: Limits) -> Result<(), ProtoError>;
}

impl Validate for crate::oap::hello::Hello {
    fn validate(&self, _limits: Limits) -> Result<(), ProtoError> {
        validate_hello(self)
    }
}

impl Validate for crate::oap::start::Start {
    fn validate(&self, _limits: Limits) -> Result<(), ProtoError> {
        validate_start(self)
    }
}

impl Validate for crate::oap::data::Data {
    fn validate(&self, limits: Limits) -> Result<(), ProtoError> {
        validate_data(self, limits.max_frame_bytes)
    }
}

```

### crates/ron-proto/src/econ/mod.rs
<a id="crates-ron-proto-src-econ-mod-rs"></a>

```rust
//! RO:WHAT — ECON-adjacent DTOs used by ledger/rewarder (pure data).
//! RO:WHY  — Keep conservation-friendly shapes; no arithmetic logic here.

pub mod move_entry;

pub use move_entry::MoveEntryV1;

```

### crates/ron-proto/src/econ/move_entry.rs
<a id="crates-ron-proto-src-econ-moveentry-rs"></a>

```rust
//! RO:WHAT — `MoveEntryV1` debit/credit record shape (no arithmetic here).
//! RO:WHY  — Deterministic, signed-friendly DTO for ECON services.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct MoveEntryV1 {
    pub entry_id: String,
    pub account: String,
    /// Positive integer value in minor units (e.g., cents)
    pub amount_minor: u64,
    /// +1 for credit, -1 for debit (host logic enforces consistency)
    pub sign: i8,
    #[serde(default)]
    pub memo: Option<String>,
}

```

### crates/ron-proto/src/error/kind.rs
<a id="crates-ron-proto-src-error-kind-rs"></a>

```rust
//! RO:WHAT — Enumerated error kinds used across DTOs.
//! RO:WHY  — Stable, additive error space for interop & metrics.

use serde::{Deserialize, Serialize};

#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
#[non_exhaustive]
pub enum Kind {
    BadRequest,
    Unauthorized,
    Forbidden,
    NotFound,
    Conflict,
    TooLarge,
    RateLimited,
    Internal,
    Unavailable,
    ProtoMismatch,
}

```

### crates/ron-proto/src/error/mod.rs
<a id="crates-ron-proto-src-error-mod-rs"></a>

```rust
//! RO:WHAT — Typed error taxonomy (`ProtoError`, `Kind`) with stable reasons.
//! RO:WHY  — Deterministic errors for metrics and control flow; immutable reason strings.
//! RO:TEST — Unit tests assert reason strings remain stable across versions.

mod kind;
mod reason;

pub use kind::Kind;
pub use reason::stable_reason;

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct ProtoError {
    pub kind: Kind,
    pub message: String,
}

impl ProtoError {
    pub fn metric_reason(&self) -> &'static str {
        stable_reason(self.kind)
    }
}

```

### crates/ron-proto/src/error/reason.rs
<a id="crates-ron-proto-src-error-reason-rs"></a>

```rust
//! RO:WHAT — Stable mapping from `Kind` to metric reason strings.
//! RO:WHY  — Metric labels must be immutable across versions.

use super::Kind;

pub fn stable_reason(k: Kind) -> &'static str {
    match k {
        Kind::BadRequest => "bad_request",
        Kind::Unauthorized => "unauthorized",
        Kind::Forbidden => "forbidden",
        Kind::NotFound => "not_found",
        Kind::Conflict => "conflict",
        Kind::TooLarge => "too_large",
        Kind::RateLimited => "rate_limited",
        Kind::Internal => "internal",
        Kind::Unavailable => "unavailable",
        Kind::ProtoMismatch => "proto_mismatch",
    }
}

```

### crates/ron-proto/src/gov/mod.rs
<a id="crates-ron-proto-src-gov-mod-rs"></a>

```rust
//! RO:WHAT — Governance DTOs (signable descriptors; no signatures here).
//! RO:WHY  — Typed inputs for policy/registry; PQ-agile via quantum:: tags.

pub mod signed_descriptor;

pub use signed_descriptor::{MultiSigNofM, SignedDescriptorV1};

```

### crates/ron-proto/src/gov/signed_descriptor.rs
<a id="crates-ron-proto-src-gov-signeddescriptor-rs"></a>

```rust
//! RO:WHAT — SignedDescriptorV1 header (detached signature carried elsewhere).
//! RO:WHY  — Replay-safe governance inputs; PQ-agile via quantum tags.
//! RO:INVARIANTS — deny_unknown_fields; deterministic field order.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct MultiSigNofM {
    pub n: u8,
    pub m: u8,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct SignedDescriptorV1 {
    pub descriptor_cid: crate::id::ContentId,
    pub alg: crate::quantum::SignatureAlg,
    pub quorum: MultiSigNofM,
    pub issued_at: u64,
    pub expires_at: u64,
    /// CID of rationale or supplemental evidence
    pub rationale_cid: Option<crate::id::ContentId>,
}

```

### crates/ron-proto/src/id/content_id.rs
<a id="crates-ron-proto-src-id-contentid-rs"></a>

```rust
//! RO:WHAT — `ContentId` newtype ("b3:<hex>") with strict parser/serde.
//! RO:WHY  — Enforce I-1 addressing (BLAKE3) and deterministic casing across SDKs.
//! RO:INTERACTS — oap::Data/End, manifest entries, naming refs.
//! RO:INVARIANTS — hex length=64, lowercase, prefix "b3:"; serde rejects unknown/invalid forms.
//! RO:TEST — proptest for random valid/invalid strings; vector parity tests.

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::{fmt, str::FromStr};

pub const CONTENT_ID_PREFIX: &str = "b3:";
pub const CONTENT_ID_HEX_LEN: usize = 64;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ContentId(String);

impl ContentId {
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Parse with strict validation.
    pub fn parse(s: &str) -> Result<Self, crate::id::ParseContentIdError> {
        crate::id::validate_b3_str(s)?;
        Ok(Self(s.to_string()))
    }
}

impl fmt::Debug for ContentId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Avoid dumping long hex in logs: short preview
        write!(
            f,
            "ContentId({}…)",
            &self.0[..std::cmp::min(self.0.len(), 8)]
        )
    }
}

impl fmt::Display for ContentId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

impl FromStr for ContentId {
    type Err = crate::id::ParseContentIdError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::parse(s)
    }
}

impl Serialize for ContentId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.0)
    }
}

impl<'de> Deserialize<'de> for ContentId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        crate::id::validate_b3_str(&s).map_err(serde::de::Error::custom)?;
        Ok(Self(s))
    }
}

```

### crates/ron-proto/src/id/mod.rs
<a id="crates-ron-proto-src-id-mod-rs"></a>

```rust
//! RO:WHAT — Newtypes and helpers for canonical IDs (content-addresses, names).
//! RO:WHY  — Strong typing for interop; prevent stringly-typed bugs.
//! RO:INTERACTS — Used across OAP envelopes, manifests, mailbox, governance.
//! RO:INVARIANTS — ContentId must be "b3:<64 lowercase hex>"; no hashing performed here.
//! RO:TEST — Round-trip serde tests and parser property tests live in this module.

mod content_id;
mod parse;

pub use content_id::{ContentId, CONTENT_ID_HEX_LEN, CONTENT_ID_PREFIX};
pub use parse::{is_lower_hex64, validate_b3_str, ParseContentIdError};

```

### crates/ron-proto/src/id/parse.rs
<a id="crates-ron-proto-src-id-parse-rs"></a>

```rust
//! RO:WHAT — Strict validators and parse errors for `ContentId`.
//! RO:WHY  — Keep hashing out of ron-proto; only parse/validate.
//! RO:INTERACTS — Used by ContentId serde and FromStr.
//! RO:INVARIANTS — 64 lowercase hex after "b3:" prefix.

use thiserror::Error;

#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum ParseContentIdError {
    #[error("missing 'b3:' prefix")]
    MissingPrefix,
    #[error("hex length must be 64 characters")]
    BadLen,
    #[error("hex must be lowercase [0-9a-f]")]
    BadHex,
}

pub fn validate_b3_str(s: &str) -> Result<(), ParseContentIdError> {
    if !s.starts_with(super::CONTENT_ID_PREFIX) {
        return Err(ParseContentIdError::MissingPrefix);
    }
    let hex = &s[super::CONTENT_ID_PREFIX.len()..];
    if hex.len() != super::CONTENT_ID_HEX_LEN {
        return Err(ParseContentIdError::BadLen);
    }
    if !is_lower_hex64(hex) {
        return Err(ParseContentIdError::BadHex);
    }
    Ok(())
}

pub fn is_lower_hex64(hex: &str) -> bool {
    hex.bytes().all(|b| matches!(b, b'0'..=b'9'|b'a'..=b'f'))
}

```

### crates/ron-proto/src/lib.rs
<a id="crates-ron-proto-src-lib-rs"></a>

```rust
//! RO:WHAT — Flat public facade for RustyOnions canonical DTOs (pure types).
//! RO:WHY  — Pillar 7 (SDK/Interop); Concerns: DX/RES. Deterministic, strict schemas for cross-SDK parity.
//! RO:INTERACTS — oap (frames), id::ContentId, manifest::*, mailbox::*, cap::*, error::*, version::*, naming::*, econ::*, gov::*, quantum::*
//! RO:INVARIANTS — DTO-only (no I/O/crypto); #[serde(deny_unknown_fields)] on externals; OAP max_frame=1MiB; storage chunk≈64KiB.
//! RO:METRICS — N/A (library types only; reason strings stable for host metrics).
//! RO:CONFIG — None (schema helpers only).
//! RO:SECURITY — No secrets/PII; capability types are headers only (no verification).
//! RO:TEST — See tests/ in crate (vectors, cross-version, property tests).

#![forbid(unsafe_code)]
#![deny(warnings)]

pub mod cap;
pub mod config;
pub mod econ;
pub mod error;
pub mod gov;
pub mod id;
pub mod mailbox;
pub mod manifest;
pub mod naming;
pub mod oap;
pub mod quantum;
pub mod trace;
pub mod version; // <— export config helpers/traits

pub use cap::*;
pub use config::{Limits, Validate};
pub use econ::*;
pub use error::*;
pub use gov::*;
pub use id::*;
pub use mailbox::*;
pub use manifest::*;
pub use naming::*;
pub use oap::*;
pub use quantum::*;
pub use trace::*;
pub use version::*; // <— re-export trait + limits for ergonomics

```

### crates/ron-proto/src/mailbox/ack.rs
<a id="crates-ron-proto-src-mailbox-ack-rs"></a>

```rust
//! RO:WHAT — Mailbox Ack DTO.
//! RO:WHY  — Allows hosts to acknowledge processing; no side-effects here.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Ack {
    pub msg_id: String,
    pub ok: bool,
    #[serde(default)]
    pub error: Option<crate::error::ProtoError>,
}

```

### crates/ron-proto/src/mailbox/mod.rs
<a id="crates-ron-proto-src-mailbox-mod-rs"></a>

```rust
//! RO:WHAT — Mailbox DTO entrypoint (Send/Recv/Ack).
//! RO:WHY  — Cross-service message shapes; at-least-once semantics live elsewhere.

pub mod ack;
pub mod recv;
pub mod send;

pub use ack::Ack;
pub use recv::Recv;
pub use send::Send;

```

### crates/ron-proto/src/mailbox/recv.rs
<a id="crates-ron-proto-src-mailbox-recv-rs"></a>

```rust
//! RO:WHAT — Mailbox Recv DTO (deliver to consumer).
//! RO:WHY  — Symmetric with Send; pure data only.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Recv {
    pub msg_id: String,
    pub from: String,
    pub kind: String,
    #[serde(with = "serde_bytes")]
    pub payload: Vec<u8>,
}

```

### crates/ron-proto/src/mailbox/send.rs
<a id="crates-ron-proto-src-mailbox-send-rs"></a>

```rust
//! RO:WHAT — Mailbox Send DTO with idempotency headers.
//! RO:WHY  — Enable at-least-once delivery patterns without logic here.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Send {
    pub msg_id: String,
    pub to: String,
    pub kind: String,
    #[serde(with = "serde_bytes")]
    pub payload: Vec<u8>,
    /// Host-side idempotency key for dedupe
    #[serde(default)]
    pub idempotency_key: Option<String>,
}

```

### crates/ron-proto/src/manifest/common.rs
<a id="crates-ron-proto-src-manifest-common-rs"></a>

```rust
//! RO:WHAT — Shared enums/consts across manifest versions.
//! RO:WHY  — Keep cross-version evolution clean and explicit.
//! RO:INVARIANTS — Deterministic defaults; serde rejects unknown fields where used.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
#[non_exhaustive]
pub enum MediaKind {
    #[default]
    Blob,
    Manifest,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct EntryRef {
    pub id: crate::id::ContentId,
    pub size: u64,
    /// Default to `blob` when omitted for backward compatibility.
    #[serde(default)]
    pub kind: MediaKind,
}

```

### crates/ron-proto/src/manifest/mod.rs
<a id="crates-ron-proto-src-manifest-mod-rs"></a>

```rust
//! RO:WHAT — Versioned manifest DTOs for content graphs.
//! RO:WHY  — Names → manifests → providers; pure data for index/storage.
//! RO:INVARIANTS — Explicit versioning; deterministic ordering (BTreeMap when maps appear).

pub mod common;
pub mod v1;

pub use common::*;
pub use v1::*;

```

### crates/ron-proto/src/manifest/v1.rs
<a id="crates-ron-proto-src-manifest-v1-rs"></a>

```rust
//! RO:WHAT — `ManifestV1` DTO (explicit version field).
//! RO:WHY  — Deterministic, growth-tolerant manifest for CAS graphs.

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct ManifestV1 {
    pub version: u32, // = 1
    pub root: crate::id::ContentId,
    /// Ordered mapping (deterministic) from name → object reference
    pub entries: BTreeMap<String, crate::manifest::EntryRef>,
    #[serde(default)]
    pub meta: BTreeMap<String, String>,
}

impl Default for ManifestV1 {
    fn default() -> Self {
        Self {
            version: 1,
            root: "b3:0000000000000000000000000000000000000000000000000000000000000000"
                .parse()
                .unwrap(),
            entries: BTreeMap::new(),
            meta: BTreeMap::new(),
        }
    }
}

```

### crates/ron-proto/src/naming.rs
<a id="crates-ron-proto-src-naming-rs"></a>

```rust
//! RO:WHAT — Naming/manifest reference types (pure data).
//! RO:WHY  — Provide typed handles for index/gateway layers; resolution lives elsewhere.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct NameRef {
    pub name: String,                           // e.g., "user:stevan/avatar"
    pub expected: Option<crate::id::ContentId>, // optional pin for strong reads
}

```

### crates/ron-proto/src/oap/data.rs
<a id="crates-ron-proto-src-oap-data-rs"></a>

```rust
//! RO:WHAT — OAP DATA frame with object address and payload chunk.
//! RO:WHY  — Carries addressed bytes; readers verify BLAKE3 elsewhere.
//! RO:INVARIANTS — obj is "b3:<hex>"; bytes length must respect max_frame (host-enforced).

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Data {
    pub obj: crate::id::ContentId,
    pub seq: u64,
    #[serde(with = "serde_bytes")]
    pub bytes: Vec<u8>,
}

```

### crates/ron-proto/src/oap/end.rs
<a id="crates-ron-proto-src-oap-end-rs"></a>

```rust
//! RO:WHAT — OAP END frame (finalization status).
//! RO:WHY  — Terminates a flow and conveys integrity/result summary.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct End {
    pub seq_end: u64,
    pub ok: bool,
    #[serde(default)]
    pub error: Option<crate::oap::error::Error>,
}

```

### crates/ron-proto/src/oap/error.rs
<a id="crates-ron-proto-src-oap-error-rs"></a>

```rust
//! RO:WHAT — OAP ERROR envelope (wire-level error details).
//! RO:WHY  — Stable, typed error codes that SDKs can rely on for metrics and control flow.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Error {
    pub code: crate::error::Kind,
    pub message: String,
    #[serde(default)]
    pub detail: Option<String>,
}

```

### crates/ron-proto/src/oap/hello.rs
<a id="crates-ron-proto-src-oap-hello-rs"></a>

```rust
//! RO:WHAT — OAP HELLO frame (protocol/version negotiation).
//! RO:WHY  — Establishes version/features; first contact envelope.
//! RO:INVARIANTS — Strict fields; unknown fields rejected. Use owned `String`
//!                 so JSON deserialization doesn't require a `'static` lifetime.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Hello {
    pub protocol: String, // was &'static str; use String for serde-compat
    pub version: u32,     // mirrors PROTO_VERSION
    #[serde(default)]
    pub features: Vec<String>, // future growth; strings must be stable tokens
}

impl Default for Hello {
    fn default() -> Self {
        Self {
            protocol: "OAP/1".to_string(),
            version: crate::version::PROTO_VERSION,
            features: Vec::new(),
        }
    }
}

```

### crates/ron-proto/src/oap/mod.rs
<a id="crates-ron-proto-src-oap-mod-rs"></a>

```rust
//! RO:WHAT — OAP/1 envelope DTOs (HELLO/START/DATA/END/ERROR).
//! RO:WHY  — Interop contract: frames carry DTOs between services/SDKs.
//! RO:INTERACTS — id::ContentId; version::PROTO_VERSION; error::ProtoError.
//! RO:INVARIANTS — OAP/1 max_frame=1MiB; chunk≈64KiB is a storage guideline (not enforced here). Strict serde.
//! RO:TEST — vectors under tests/vectors; fuzz targets for headers.

use serde::{Deserialize, Serialize};

pub const MAX_FRAME_BYTES: usize = 1024 * 1024; // 1 MiB

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "UPPERCASE")]
#[non_exhaustive]
pub enum OapKind {
    Hello,
    Start,
    Data,
    End,
    Error,
}

pub mod data;
pub mod end;
pub mod error;
pub mod hello;
pub mod start;

```

### crates/ron-proto/src/oap/start.rs
<a id="crates-ron-proto-src-oap-start-rs"></a>

```rust
//! RO:WHAT — OAP START frame (session/stream parameters).
//! RO:WHY  — Sets negotiated limits before DATA frames flow.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct Start {
    pub seq_start: u64,
    pub max_frame_bytes: u32, // must be <= 1MiB; validated by hosts
    #[serde(default)]
    pub meta: Option<String>, // reserved for growth (e.g., codec hints)
}

```

### crates/ron-proto/src/quantum/mod.rs
<a id="crates-ron-proto-src-quantum-mod-rs"></a>

```rust
//! RO:WHAT — PQ-hybrid algorithm tags (enums only; no crypto).
//! RO:WHY  — Keep protocol PQ-agile without dragging crypto deps here.

pub mod pq_tags;

pub use pq_tags::{KemAlg, SignatureAlg};

```

### crates/ron-proto/src/quantum/pq_tags.rs
<a id="crates-ron-proto-src-quantum-pqtags-rs"></a>

```rust
//! RO:WHAT — Enumerations for PQ-capable algorithms referenced by DTOs.
//! RO:WHY  — Wire-stable tokens for hybrid/transition periods (no crypto here).

use serde::{Deserialize, Serialize};

#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
#[non_exhaustive]
pub enum SignatureAlg {
    Ed25519,
    Dilithium3,
    HybridEd25519Dilithium3,
}

#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
#[non_exhaustive]
pub enum KemAlg {
    X25519,
    Kyber768,
    HybridX25519Kyber768,
}

```

### crates/ron-proto/src/trace.rs
<a id="crates-ron-proto-src-trace-rs"></a>

```rust
//! RO:WHAT — Tiny helpers for correlation/trace fields in DTOs.
//! RO:WHY  — Allow hosts to carry correlation IDs without depending on tracing crates.

use serde::{Deserialize, Serialize};

#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Hash, Default)]
#[serde(deny_unknown_fields)]
pub struct CorrId {
    pub id: u64,
}

```

### crates/ron-proto/src/version.rs
<a id="crates-ron-proto-src-version-rs"></a>

```rust
//! RO:WHAT — Protocol version & ABI fingerprint constants.
//! RO:WHY  — Gate breaking changes; SDKs/tests assert these during upgrades.

pub const PROTO_VERSION: u32 = 1;

// NOTE: In CI you can replace this with include_str!("../docs/schema/fingerprint.txt")
// to enforce schema-diff gates. Using a placeholder here to keep the crate self-contained.
pub const PROTO_ABI_FINGERPRINT: &str = "dev-fingerprint";

```

### crates/ron-proto/testing/performance/baselines/ron-proto.json
<a id="crates-ron-proto-testing-performance-baselines-ron-proto-json"></a>

```json

```

### crates/ron-proto/tests/content_id.rs
<a id="crates-ron-proto-tests-contentid-rs"></a>

```rust
use ron_proto::ContentId;

#[test]
fn content_id_parses_and_displays() {
    let s = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    let cid: ContentId = s.parse().unwrap();
    assert_eq!(cid.to_string(), s);
    assert_eq!(cid.as_str(), s);
}

#[test]
fn content_id_rejects_bad_prefix() {
    let s = "b2:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    assert!(s.parse::<ContentId>().is_err());
}

#[test]
fn content_id_rejects_bad_len() {
    let s = "b3:0123456789abcdef"; // too short
    assert!(s.parse::<ContentId>().is_err());
}

#[test]
fn content_id_rejects_uppercase() {
    let s = "b3:0123456789ABCDEF0123456789abcdef0123456789abcdef0123456789abcdef";
    assert!(s.parse::<ContentId>().is_err());
}

```

### crates/ron-proto/tests/cross_version.rs
<a id="crates-ron-proto-tests-crossversion-rs"></a>

```rust


```

### crates/ron-proto/tests/econ_conservation.rs
<a id="crates-ron-proto-tests-econconservation-rs"></a>

```rust


```

### crates/ron-proto/tests/golden_vectors.rs
<a id="crates-ron-proto-tests-goldenvectors-rs"></a>

```rust
use serde_json as json;

#[test]
fn golden_oap_hello_v1_loads() {
    // Embedded golden vector
    const HELLO_JSON: &str = r#"
    {
      "protocol": "OAP/1",
      "version": 1,
      "features": []
    }
    "#;

    let hello: ron_proto::oap::hello::Hello = json::from_str(HELLO_JSON).unwrap();
    assert_eq!(hello.protocol, "OAP/1");
    assert_eq!(hello.version, ron_proto::version::PROTO_VERSION);
}

#[test]
fn golden_oap_data_min_loads() {
    // IMPORTANT: serde_json + serde_bytes represent Vec<u8> as an array of integers
    // (not base64) by default. Use numeric bytes here for portable goldens.
    const DATA_JSON: &str = r#"
    {
      "obj": "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
      "seq": 1,
      "bytes": [104,101,108,108,111]
    }
    "#;

    let data: ron_proto::oap::data::Data = json::from_str(DATA_JSON).unwrap();
    assert_eq!(data.seq, 1);
    assert_eq!(data.bytes, b"hello");
}

```

### crates/ron-proto/tests/hash_truth.rs
<a id="crates-ron-proto-tests-hashtruth-rs"></a>

```rust


```

### crates/ron-proto/tests/interop_parity.rs
<a id="crates-ron-proto-tests-interopparity-rs"></a>

```rust


```

### crates/ron-proto/tests/manifest_defaults.rs
<a id="crates-ron-proto-tests-manifestdefaults-rs"></a>

```rust
use ron_proto::{manifest::EntryRef, ContentId};
use serde_json as json;

#[test]
fn entryref_kind_defaults_to_blob() {
    let cid: ContentId = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
        .parse()
        .unwrap();

    // kind omitted on purpose (should default to "blob")
    let value = json::json!({
        "id": cid.to_string(),
        "size": 1234
    });

    let parsed: EntryRef = json::from_value(value).unwrap();

    // Serialize back and ensure "blob" is present
    let round = json::to_value(&parsed).unwrap();
    assert_eq!(round.get("kind").unwrap().as_str().unwrap(), "blob");
}

```

### crates/ron-proto/tests/oap_roundtrip.rs
<a id="crates-ron-proto-tests-oaproundtrip-rs"></a>

```rust
use ron_proto::ContentId;
use serde_json as json;

#[test]
fn hello_default_roundtrip() {
    let h = ron_proto::oap::hello::Hello::default();
    let s = json::to_string(&h).unwrap();
    let back: ron_proto::oap::hello::Hello = json::from_str(&s).unwrap();
    assert_eq!(h.protocol, back.protocol);
    assert_eq!(h.version, back.version);
}

#[test]
fn data_frame_roundtrip() {
    let cid: ContentId = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
        .parse()
        .unwrap();
    let d = ron_proto::oap::data::Data {
        obj: cid,
        seq: 42,
        bytes: b"hello world".to_vec(),
    };
    let s = json::to_string(&d).unwrap();
    let back: ron_proto::oap::data::Data = json::from_str(&s).unwrap();
    assert_eq!(back.seq, 42);
    assert_eq!(back.bytes, b"hello world");
}

#[test]
fn end_with_error_roundtrip() {
    let e = ron_proto::oap::error::Error {
        code: ron_proto::error::Kind::TooLarge,
        message: "frame exceeds limit".into(),
        detail: Some("max 1MiB".into()),
    };
    let end = ron_proto::oap::end::End {
        seq_end: 99,
        ok: false,
        error: Some(e),
    };
    let s = json::to_string(&end).unwrap();
    let back: ron_proto::oap::end::End = json::from_str(&s).unwrap();
    assert!(!back.ok);
    assert!(matches!(
        back.error.as_ref().unwrap().code,
        ron_proto::error::Kind::TooLarge
    ));
}

#[test]
fn kind_enum_ser_names_match() {
    use ron_proto::oap::OapKind;
    let kinds = [
        OapKind::Hello,
        OapKind::Start,
        OapKind::Data,
        OapKind::End,
        OapKind::Error,
    ];
    let names: Vec<String> = kinds.iter().map(|k| json::to_string(k).unwrap()).collect();
    assert_eq!(
        names,
        vec![
            r#""HELLO""#,
            r#""START""#,
            r#""DATA""#,
            r#""END""#,
            r#""ERROR""#
        ]
    );
}

```

### crates/ron-proto/tests/validate_helpers.rs
<a id="crates-ron-proto-tests-validatehelpers-rs"></a>

```rust
use ron_proto::{oap, ContentId, Limits, Validate};

#[test]
fn hello_and_start_validate() {
    let hello = oap::hello::Hello::default();
    hello.validate(Limits::default()).unwrap();

    let start = oap::start::Start {
        seq_start: 0,
        max_frame_bytes: 1_048_576,
        meta: None,
    };
    start.validate(Limits::default()).unwrap();
}

#[test]
fn data_respects_negotiated_max() {
    let limits = Limits { max_frame_bytes: 8 };

    // Make the type explicit so .parse() knows the target type:
    let cid: ContentId = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
        .parse()
        .unwrap();

    let ok = oap::data::Data {
        obj: cid.clone(),
        seq: 1,
        bytes: b"12345678".to_vec(),
    };
    ok.validate(limits).unwrap();

    let too_big = oap::data::Data {
        obj: cid,
        seq: 2,
        bytes: b"abcdefghi".to_vec(),
    };
    assert!(too_big.validate(limits).is_err());
}

```

### crates/ron-proto/tests/vectors/content_id.json
<a id="crates-ron-proto-tests-vectors-contentid-json"></a>

```json

```

### crates/ron-proto/tests/vectors/manifest_v1.json
<a id="crates-ron-proto-tests-vectors-manifestv1-json"></a>

```json

```

### crates/ron-proto/tests/vectors/oap_data_min.json
<a id="crates-ron-proto-tests-vectors-oapdatamin-json"></a>

```json
{
  "obj": "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
  "seq": 1,
  "bytes": "aGVsbG8="
}

```

### crates/ron-proto/tests/vectors/oap_error_envelope.json
<a id="crates-ron-proto-tests-vectors-oaperrorenvelope-json"></a>

```json

```

### crates/ron-proto/tests/vectors/oap_hello_v1.json
<a id="crates-ron-proto-tests-vectors-oaphellov1-json"></a>

```json
{
  "protocol": "OAP/1",
  "version": 1,
  "features": []
}

```



---



# ron-metrics

_Source: crates/ron-metrics/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:47:02Z -->
# Code Bundle — `ron-metrics`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-metrics/.cargo/config.toml](#crates-ron-metrics--cargo-config-toml)
- [crates/ron-metrics/.github/workflows/ci.yml](#crates-ron-metrics--github-workflows-ci-yml)
- [crates/ron-metrics/.github/workflows/coverage.yml](#crates-ron-metrics--github-workflows-coverage-yml)
- [crates/ron-metrics/.github/workflows/mermaid.yml](#crates-ron-metrics--github-workflows-mermaid-yml)
- [crates/ron-metrics/.github/workflows/perf-smoke.yml](#crates-ron-metrics--github-workflows-perf-smoke-yml)
- [crates/ron-metrics/.github/workflows/public-api.yml](#crates-ron-metrics--github-workflows-public-api-yml)
- [crates/ron-metrics/.github/workflows/sanitizer.yml](#crates-ron-metrics--github-workflows-sanitizer-yml)
- [crates/ron-metrics/Cargo.toml](#crates-ron-metrics-Cargo-toml)
- [crates/ron-metrics/benches/exposer_bench.rs](#crates-ron-metrics-benches-exposerbench-rs)
- [crates/ron-metrics/benches/hotpath_bench.rs](#crates-ron-metrics-benches-hotpathbench-rs)
- [crates/ron-metrics/deny.toml](#crates-ron-metrics-deny-toml)
- [crates/ron-metrics/examples/axum_api.rs](#crates-ron-metrics-examples-axumapi-rs)
- [crates/ron-metrics/examples/exposer.rs](#crates-ron-metrics-examples-exposer-rs)
- [crates/ron-metrics/examples/pump.rs](#crates-ron-metrics-examples-pump-rs)
- [crates/ron-metrics/examples/watch_bus.rs](#crates-ron-metrics-examples-watchbus-rs)
- [crates/ron-metrics/rust-toolchain.toml](#crates-ron-metrics-rust-toolchain-toml)
- [crates/ron-metrics/scripts/check-taxonomy.sh](#crates-ron-metrics-scripts-check-taxonomy-sh)
- [crates/ron-metrics/scripts/render-mermaid.sh](#crates-ron-metrics-scripts-render-mermaid-sh)
- [crates/ron-metrics/src/axum_latency.rs](#crates-ron-metrics-src-axumlatency-rs)
- [crates/ron-metrics/src/axum_status.rs](#crates-ron-metrics-src-axumstatus-rs)
- [crates/ron-metrics/src/build_info.rs](#crates-ron-metrics-src-buildinfo-rs)
- [crates/ron-metrics/src/bus_watcher.rs](#crates-ron-metrics-src-buswatcher-rs)
- [crates/ron-metrics/src/config.rs](#crates-ron-metrics-src-config-rs)
- [crates/ron-metrics/src/errors.rs](#crates-ron-metrics-src-errors-rs)
- [crates/ron-metrics/src/exporters/mod.rs](#crates-ron-metrics-src-exporters-mod-rs)
- [crates/ron-metrics/src/exporters/otel.rs](#crates-ron-metrics-src-exporters-otel-rs)
- [crates/ron-metrics/src/exposer/http.rs](#crates-ron-metrics-src-exposer-http-rs)
- [crates/ron-metrics/src/exposer/middleware.rs](#crates-ron-metrics-src-exposer-middleware-rs)
- [crates/ron-metrics/src/exposer/mod.rs](#crates-ron-metrics-src-exposer-mod-rs)
- [crates/ron-metrics/src/exposer/tls.rs](#crates-ron-metrics-src-exposer-tls-rs)
- [crates/ron-metrics/src/exposer/uds.rs](#crates-ron-metrics-src-exposer-uds-rs)
- [crates/ron-metrics/src/health.rs](#crates-ron-metrics-src-health-rs)
- [crates/ron-metrics/src/labels.rs](#crates-ron-metrics-src-labels-rs)
- [crates/ron-metrics/src/lib.rs](#crates-ron-metrics-src-lib-rs)
- [crates/ron-metrics/src/metrics.rs](#crates-ron-metrics-src-metrics-rs)
- [crates/ron-metrics/src/pq.rs](#crates-ron-metrics-src-pq-rs)
- [crates/ron-metrics/src/readiness.rs](#crates-ron-metrics-src-readiness-rs)
- [crates/ron-metrics/src/registry.rs](#crates-ron-metrics-src-registry-rs)
- [crates/ron-metrics/src/zk.rs](#crates-ron-metrics-src-zk-rs)
- [crates/ron-metrics/tests/bus_watcher.rs](#crates-ron-metrics-tests-buswatcher-rs)
- [crates/ron-metrics/tests/health_ready.rs](#crates-ron-metrics-tests-healthready-rs)
- [crates/ron-metrics/tests/http_endpoints.rs](#crates-ron-metrics-tests-httpendpoints-rs)
- [crates/ron-metrics/tests/http_status_counter.rs](#crates-ron-metrics-tests-httpstatuscounter-rs)
- [crates/ron-metrics/tests/integration_http_endpoints.rs](#crates-ron-metrics-tests-integrationhttpendpoints-rs)
- [crates/ron-metrics/tests/loom_shutdown.rs](#crates-ron-metrics-tests-loomshutdown-rs)
- [crates/ron-metrics/tests/metrics_encode_ok.rs](#crates-ron-metrics-tests-metricsencodeok-rs)
- [crates/ron-metrics/tests/public_api.rs](#crates-ron-metrics-tests-publicapi-rs)
- [crates/ron-metrics/tests/readiness_semantics.rs](#crates-ron-metrics-tests-readinesssemantics-rs)
- [crates/ron-metrics/tests/taxonomy_labels.rs](#crates-ron-metrics-tests-taxonomylabels-rs)
- [crates/ron-metrics/tests/vectors/interop/ron-metrics/readyz-degraded.json](#crates-ron-metrics-tests-vectors-interop-ron-metrics-readyz-degraded-json)
- [crates/ron-metrics/tests/vectors/interop/ron-metrics/readyz-ready.json](#crates-ron-metrics-tests-vectors-interop-ron-metrics-readyz-ready-json)

### crates/ron-metrics/.cargo/config.toml
<a id="crates-ron-metrics--cargo-config-toml"></a>

```toml
# Minimal, portable Cargo config for CI parity
[build]
rustflags = []

[env]
RUSTFLAGS = "-Dwarnings"

```

### crates/ron-metrics/.github/workflows/ci.yml
<a id="crates-ron-metrics--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: rustup toolchain install 1.80.0 --profile minimal --component rustfmt clippy
      - run: cargo fmt --all -- --check
      - run: cargo clippy -p ron-metrics2 -- -D warnings
      - run: cargo test -p ron-metrics2
      - run: cargo deny check

```

### crates/ron-metrics/.github/workflows/coverage.yml
<a id="crates-ron-metrics--github-workflows-coverage-yml"></a>

```yaml
name: coverage
on: [push, pull_request]
jobs:
  cov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: taiki-e/install-action@cargo-llvm-cov
      - run: cargo llvm-cov --workspace --lcov --output-path lcov.info
      - run: cargo llvm-cov report --json | jq -e '.data[0].totals.branches.percent >= 80'

```

### crates/ron-metrics/.github/workflows/mermaid.yml
<a id="crates-ron-metrics--github-workflows-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          mkdir -p docs
          for f in $(git ls-files 'docs/mmd/*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out"
          done

```

### crates/ron-metrics/.github/workflows/perf-smoke.yml
<a id="crates-ron-metrics--github-workflows-perf-smoke-yml"></a>

```yaml
name: perf-smoke
on:
  workflow_dispatch:
jobs:
  bombardier:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "perf smoke placeholder (would hammer /metrics and record p95)"

```

### crates/ron-metrics/.github/workflows/public-api.yml
<a id="crates-ron-metrics--github-workflows-public-api-yml"></a>

```yaml
name: public-api
on: [push, pull_request]
jobs:
  api:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: cargo install cargo-public-api
      # Allow first run to pass before snapshots exist; tighten later.
      - run: cargo public-api --crate ron-metrics2 --deny changed || true

```

### crates/ron-metrics/.github/workflows/sanitizer.yml
<a id="crates-ron-metrics--github-workflows-sanitizer-yml"></a>

```yaml
name: sanitizer
on:
  schedule:
    - cron: "0 4 * * *"
jobs:
  tsan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: rustup toolchain install nightly --profile minimal
      - run: rustup default nightly
      - run: RUSTFLAGS="-Z sanitizer=thread" RUSTDOCFLAGS="-Z sanitizer=thread" cargo test -p ron-metrics2 --target x86_64-unknown-linux-gnu || true

```

### crates/ron-metrics/Cargo.toml
<a id="crates-ron-metrics-Cargo-toml"></a>

```toml
[package]
name = "ron-metrics"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
rust-version = "1.80.0"
description = "RustyOnions observability library (+ tiny HTTP exposer)"

[features]
default = []
bus = ["dep:ron-bus"]                      # bridge ron-bus events -> metrics/health (optional)
otel = ["dep:opentelemetry", "dep:opentelemetry-otlp"]
tls = ["dep:tokio-rustls"]
uds = []

[dependencies]
axum = { version = "0.7.9", default-features = false, features = ["tokio", "http1", "http2", "json"] }
prometheus = "0.14"
tokio = { version = "1.47.1", features = ["rt-multi-thread","macros","net","signal","time","io-util"] }
parking_lot = "0.12"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
once_cell = "1.19"
tracing = "0.1"
http = "1.1"
tower = "0.4"


# optional
tokio-rustls = { version = "0.26.2", optional = true }
opentelemetry = { version = "0.23", optional = true }
opentelemetry-otlp = { version = "0.16", optional = true }
ron-bus = { path = "../ron-bus", optional = true }   # adjust path if your workspace differs

[dev-dependencies]
anyhow = "1.0"
# Hyper core + client
hyper = { version = "1.4", features = ["client", "http1", "http2"] }
hyper-util = { version = "0.1", features = ["client", "http1", "http2", "tokio", "client-legacy"] }
http-body-util = "0.1"
tracing-subscriber = "0.3"
rand = "0.9"
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls"] }

```

### crates/ron-metrics/benches/exposer_bench.rs
<a id="crates-ron-metrics-benches-exposerbench-rs"></a>

```rust
// Criterion bench placeholder for exposition latency across registry sizes.
fn main() {}

```

### crates/ron-metrics/benches/hotpath_bench.rs
<a id="crates-ron-metrics-benches-hotpathbench-rs"></a>

```rust
// Measures counter/histogram hot path (scaffold placeholder).
fn main() {}

```

### crates/ron-metrics/deny.toml
<a id="crates-ron-metrics-deny-toml"></a>

```toml
# cargo-deny baseline (licenses, advisories, bans)
[advisories]
vulnerability = "deny"
yanked = "deny"

[licenses]
confidence-threshold = 0.8
allow = [
  "MIT", "Apache-2.0", "Unicode-DFS-2016", "BSD-3-Clause",
  "ISC", "CC0-1.0", "OpenSSL"
]

```

### crates/ron-metrics/examples/axum_api.rs
<a id="crates-ron-metrics-examples-axumapi-rs"></a>

```rust
//! RO:WHAT — Example Axum API instrumented with ron-metrics middleware (latency + status-class).
//! RO:WHY  — Zero-touch HTTP visibility: /metrics + automatic histograms/counters.
//! Run: RON_METRICS_METRICS_ADDR=127.0.0.1:0 cargo run -p ron-metrics --example axum_api

use axum::{routing::get, Router};
use std::{env, net::SocketAddr, time::Duration};
use tokio::time::sleep;

use ron_metrics::{
    axum_latency, // latency histogram middleware (request_latency_seconds)
    axum_status,  // status-class counter middleware (request_status_total)
    build_info::build_version,
    exposer::http::make_router as make_metrics_router,
    BaseLabels,
    HealthState,
    Metrics,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();

    // Base labels
    let base = BaseLabels {
        service: env::var("RON_SERVICE").unwrap_or_else(|_| "demo-api".into()),
        instance: env::var("RON_INSTANCE").unwrap_or_else(|_| "local-1".into()),
        build_version: build_version(),
        amnesia: env::var("RON_AMNESIA").unwrap_or_else(|_| "off".into()),
    };

    // Health state
    let health = HealthState::new();
    health.set("config_loaded".into(), true);
    health.set("db".into(), true);

    // Metrics
    let metrics = Metrics::new(base, health)?;

    // App routes (business endpoints)
    let app = Router::new()
        .route("/ping", get(|| async { "pong" }))
        .route(
            "/sleep",
            get(|| async {
                // Simulate work
                sleep(Duration::from_millis(12)).await;
                "ok"
            }),
        );

    // Expose /metrics, /healthz, /readyz on same server
    let app = app.merge(make_metrics_router(metrics.clone()));

    // Attach middlewares (order is fine either way; both apply to all routes)
    let app = axum_latency::attach(app, metrics.clone());
    let app = axum_status::attach(app, metrics.clone());

    // Bind & serve
    let bind: SocketAddr = env::var("RON_METRICS_METRICS_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:0".into())
        .parse()?;
    let listener = tokio::net::TcpListener::bind(bind).await?;
    let addr = listener.local_addr()?;
    println!("api     :  http://{}/ping", addr);
    println!("sleep   :  http://{}/sleep", addr);
    println!("metrics :  http://{}/metrics", addr);
    println!("healthz :  http://{}/healthz", addr);
    println!("readyz  :  http://{}/readyz", addr);

    axum::serve(listener, app).await?;
    Ok(())
}

```

### crates/ron-metrics/examples/exposer.rs
<a id="crates-ron-metrics-examples-exposer-rs"></a>

```rust
//! RO:WHAT — Tiny demo: start the exposer and print bound addr.

use ron_metrics::build_info::build_version;
use ron_metrics::{BaseLabels, HealthState, Metrics};
use std::env;
use std::net::SocketAddr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();

    let service = env::var("RON_SERVICE").unwrap_or_else(|_| "demo".into());
    let instance = env::var("RON_INSTANCE").unwrap_or_else(|_| "local-1".into());
    let amnesia = match env::var("RON_AMNESIA").ok().as_deref() {
        Some("on") | Some("1") | Some("true") => "on".to_string(),
        _ => "off".to_string(),
    };

    let base = BaseLabels {
        service,
        instance,
        build_version: build_version(),
        amnesia,
    };

    let health = HealthState::new();
    // Declare one dependency and mark ready
    health.set("config_loaded".to_string(), true);

    let metrics = Metrics::new(base, health)?;
    let bind: SocketAddr = env::var("RON_METRICS_METRICS_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:9100".into())
        .parse()?;

    let (_jh, addr) = metrics.serve(bind).await?;
    println!("metrics:  http://{addr}/metrics");
    println!("healthz:  http://{addr}/healthz");
    println!("readyz :  http://{addr}/readyz");
    tokio::signal::ctrl_c().await?;
    Ok(())
}

```

### crates/ron-metrics/examples/pump.rs
<a id="crates-ron-metrics-examples-pump-rs"></a>

```rust
//! RO:WHAT — Simulate activity against Metrics so /metrics moves live.
//! Run: RON_METRICS_METRICS_ADDR=127.0.0.1:0 cargo run -p ron-metrics --example pump

use rand::{rng, Rng}; // rand 0.9 API
use ron_metrics::{build_info::build_version, BaseLabels, HealthState, Metrics};
use std::{env, net::SocketAddr, time::Duration};
use tokio::time::sleep;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();

    let service = env::var("RON_SERVICE").unwrap_or_else(|_| "demo".into());
    let instance = env::var("RON_INSTANCE").unwrap_or_else(|_| "local-1".into());
    let amnesia = match env::var("RON_AMNESIA").ok().as_deref() {
        Some("on") | Some("1") | Some("true") => "on".to_string(),
        _ => "off".to_string(),
    };

    let base = BaseLabels {
        service,
        instance,
        build_version: build_version(),
        amnesia,
    };

    let health = HealthState::new();
    health.set("config_loaded".to_string(), true);
    health.set("db".to_string(), false);
    health.set("cache".to_string(), false);

    let metrics = Metrics::new(base, health)?;
    let bind: SocketAddr = env::var("RON_METRICS_METRICS_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:0".into())
        .parse()?;

    let (_jh, addr) = metrics.clone().serve(bind).await?;
    println!("metrics:  http://{addr}/metrics");
    println!("healthz:  http://{addr}/healthz");
    println!("readyz :  http://{addr}/readyz");

    // Simulate activity forever
    let mut tick: u64 = 0;
    loop {
        let mut r = rng();

        // Simulate a request with 0.3–20 ms latency
        let lat_ms: f64 = r.random_range(0.3..20.0);
        metrics.observe_request(lat_ms / 1000.0);

        // Pretend a service restarted every ~15s
        if tick % 15 == 0 {
            metrics.inc_service_restart("worker-A");
        }

        // Pretend the bus overwrote some lagged messages sporadically
        if tick % 7 == 0 {
            let overwrites: u64 = r.random_range(1..5);
            metrics.add_bus_lag("kernel", overwrites);
        }

        // Flip readiness of db/cache occasionally to show /readyz truth
        if tick % 9 == 0 {
            let ok = r.random::<bool>();
            metrics.set_ready("db", ok);
        }
        if tick % 11 == 0 {
            let ok = r.random::<bool>();
            metrics.set_ready("cache", ok);
        }

        tick += 1;
        sleep(Duration::from_millis(1000)).await;
    }
}

```

### crates/ron-metrics/examples/watch_bus.rs
<a id="crates-ron-metrics-examples-watchbus-rs"></a>

```rust
//! RO:WHAT — Demo: bridge ron-bus events into ron-metrics endpoints.
//! Run: cargo run -p ron-metrics --features bus --example watch_bus

use ron_metrics::{build_info::build_version, BaseLabels, HealthState, Metrics};
use std::{env, net::SocketAddr, time::Duration};

#[cfg(feature = "bus")]
use {
    ron_bus::{Bus, BusConfig, Event},
    ron_metrics::bus_watcher::start_bus_watcher,
    tokio::time::sleep,
};

/// When `bus` feature is OFF, provide a tiny placeholder main so examples still build under `cargo test`.
#[cfg(not(feature = "bus"))]
fn main() {
    eprintln!("watch_bus example requires `--features bus`");
}

/// Real example when `bus` feature is ON.
#[cfg(feature = "bus")]
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();

    let base = BaseLabels {
        service: env::var("RON_SERVICE").unwrap_or_else(|_| "demo".into()),
        instance: env::var("RON_INSTANCE").unwrap_or_else(|_| "local-1".into()),
        build_version: build_version(),
        amnesia: env::var("RON_AMNESIA").unwrap_or_else(|_| "off".into()),
    };

    let cfg = BusConfig::default().with_capacity(256);
    let bus = Bus::new(cfg).expect("bus");

    let health = HealthState::new();
    health.set("config_loaded".into(), false);

    let metrics = Metrics::new(base, health)?;
    let bind: SocketAddr = env::var("RON_METRICS_METRICS_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:0".into())
        .parse()?;

    let (_jh, addr) = metrics.clone().serve(bind).await?;
    println!("metrics:  http://{addr}/metrics");
    println!("healthz:  http://{addr}/healthz");
    println!("readyz :  http://{addr}/readyz");

    let _watcher = start_bus_watcher(metrics.clone(), &bus, "demo-watcher");

    let tx = bus.sender();
    tx.send(Event::Health {
        service: "config_loaded".into(),
        ok: false,
    })
    .expect("send");
    sleep(Duration::from_millis(250)).await;
    tx.send(Event::Health {
        service: "config_loaded".into(),
        ok: true,
    })
    .expect("send");

    println!("curl the endpoints now. shutting down in ~3s…");
    sleep(Duration::from_secs(3)).await;
    tx.send(Event::Shutdown).expect("send");

    Ok(())
}

```

### crates/ron-metrics/rust-toolchain.toml
<a id="crates-ron-metrics-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/ron-metrics/scripts/check-taxonomy.sh
<a id="crates-ron-metrics-scripts-check-taxonomy-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Placeholder: fetch /metrics and assert suffix and base labels (scaffold).
echo "check-taxonomy: placeholder"

```

### crates/ron-metrics/scripts/render-mermaid.sh
<a id="crates-ron-metrics-scripts-render-mermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Renders all docs/mmd/*.mmd to .svg (requires mmdc).
echo "render-mermaid: placeholder"

```

### crates/ron-metrics/src/axum_latency.rs
<a id="crates-ron-metrics-src-axumlatency-rs"></a>

```rust
//! RO:WHAT — Axum middleware to observe request latency into ron-metrics.
//! RO:WHY  — Zero-touch per-request timing for Axum apps.
//! RO:INVARIANTS — no locks across .await; low overhead.
//! RO:USAGE — let app = axum_latency::attach(router, metrics.clone());

use std::time::Instant;

use crate::Metrics;
use axum::{
    body::Body,
    extract::State,
    http::Request,
    middleware::{self, Next},
    response::Response,
    Router,
};

/// Attach a latency middleware to the given Router that records per-request
/// latency into `request_latency_seconds`.
///
/// ```ignore
/// let router = Router::new()
///     .route("/ping", get(|| async { "pong" }));
/// let router = ron_metrics::axum_latency::attach(router, metrics.clone());
/// ```
pub fn attach(router: Router, metrics: Metrics) -> Router {
    router.layer(middleware::from_fn_with_state(metrics, track_latency))
}

async fn track_latency(State(metrics): State<Metrics>, req: Request<Body>, next: Next) -> Response {
    let started = Instant::now();
    let resp = next.run(req).await;
    metrics.observe_request(started.elapsed().as_secs_f64());
    resp
}

```

### crates/ron-metrics/src/axum_status.rs
<a id="crates-ron-metrics-src-axumstatus-rs"></a>

```rust
//! RO:WHAT — Axum middleware to count responses by status class (1xx..5xx).
//! RO:WHY  — Low-cardinality error-rate signal for SRE/alerts.
//! RO:USAGE — let app = axum_status::attach(router, metrics.clone());

use crate::Metrics;
use axum::{
    body::Body,
    http::Request,
    middleware::{self, Next},
    response::Response,
    Router,
};

pub fn attach(router: Router, metrics: Metrics) -> Router {
    router.layer(middleware::from_fn_with_state(metrics, count_status))
}

async fn count_status(
    axum::extract::State(metrics): axum::extract::State<Metrics>,
    req: Request<Body>,
    next: Next,
) -> Response {
    let resp = next.run(req).await;
    let code = resp.status().as_u16();
    let class = match code {
        100..=199 => "1xx",
        200..=299 => "2xx",
        300..=399 => "3xx",
        400..=499 => "4xx",
        500..=599 => "5xx",
        _ => "other",
    };
    metrics.observe_status_class(class);
    resp
}

```

### crates/ron-metrics/src/build_info.rs
<a id="crates-ron-metrics-src-buildinfo-rs"></a>

```rust
//! RO:WHAT — Build/version helpers for base labels.

pub fn build_version() -> String {
    // Package version + short git if provided by outer build
    let ver = env!("CARGO_PKG_VERSION");
    match option_env!("GIT_SHA_SHORT") {
        Some(sha) if !sha.is_empty() => format!("{ver}+{sha}"),
        _ => ver.to_string(),
    }
}

```

### crates/ron-metrics/src/bus_watcher.rs
<a id="crates-ron-metrics-src-buswatcher-rs"></a>

```rust
//! RO:WHAT — Translate ron-bus events into metrics + health updates.
//! RO:WHY  — Unified observability; keep ron-bus lean, exporter lives here.
//! RO:INTERACTS — ron_bus::{Bus, Event}; Metrics; HealthState.
//! RO:INVARIANTS — single subscriber; bounded; no lock across .await.
//! RO:TODO — If ron-bus later emits lag/overwrite events, extend the match arms here behind the same feature.

#![allow(dead_code)]

#[cfg(feature = "bus")]
mod impls {
    use crate::Metrics;
    use ron_bus::{Bus, Event};
    use tokio::task::JoinHandle;
    use tokio::time::{sleep, Duration};
    use tracing::{info, warn};

    /// Start a watcher that consumes events from the shared bus and updates metrics/health.
    /// We only borrow the `Bus` to create a subscriber; the subscriber is moved into the task.
    pub fn start_bus_watcher(
        metrics: Metrics,
        bus: &Bus,
        watcher_name: &'static str,
    ) -> JoinHandle<()> {
        // Each subscriber has its own cursor by design.
        let mut sub = bus.subscribe();

        tokio::spawn(async move {
            info!(watcher=%watcher_name, "ron-metrics: bus watcher started");
            loop {
                match sub.recv().await {
                    Ok(ev) => match ev {
                        Event::Health { service, ok } => {
                            metrics.set_ready(&service, ok);
                        }
                        Event::Shutdown => {
                            info!(watcher=%watcher_name, "ron-metrics: bus watcher received Shutdown; exiting");
                            break;
                        }
                        // Extend here when new events are added (e.g., ConfigUpdated, BusLag, etc.)
                        _ => {}
                    },
                    Err(e) => {
                        // Channel closed or transient error — back off a hair to avoid hot loop.
                        warn!(watcher=%watcher_name, error=?e, "bus watcher recv error; backing off");
                        sleep(Duration::from_millis(5)).await;
                    }
                }
            }
        })
    }
}

#[cfg(feature = "bus")]
pub use impls::start_bus_watcher;

// If the feature is off, expose a stub so callsites can compile behind cfg.
#[cfg(not(feature = "bus"))]
pub fn start_bus_watcher(_: crate::Metrics, _: (), _: &'static str) -> () {
    ()
}

```

### crates/ron-metrics/src/config.rs
<a id="crates-ron-metrics-src-config-rs"></a>

```rust
// Typed configuration placeholder for ron-metrics2.
// Defines TCP addr vs UDS, timeouts, TLS paths, OTLP endpoint (env-first).
// Implementation intentionally omitted in scaffold.

```

### crates/ron-metrics/src/errors.rs
<a id="crates-ron-metrics-src-errors-rs"></a>

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum MetricsError {
    #[error("prometheus error: {0}")]
    Prometheus(#[from] prometheus::Error),

    #[error("io error: {0}")]
    Io(#[from] std::io::Error),

    #[error("other: {0}")]
    Other(String),
}

```

### crates/ron-metrics/src/exporters/mod.rs
<a id="crates-ron-metrics-src-exporters-mod-rs"></a>

```rust
//! RO:WHAT — Optional exporters (OTLP), feature-gated.

#[cfg(feature = "otel")]
pub mod otel;

```

### crates/ron-metrics/src/exporters/otel.rs
<a id="crates-ron-metrics-src-exporters-otel-rs"></a>

```rust
//! RO:WHAT — Minimal OTLP exporter wiring (feature gated).

#[allow(dead_code)]
pub fn init_otel() -> Result<(), Box<dyn std::error::Error>> {
    // Stub for future: map families to OTLP if desired.
    Ok(())
}

```

### crates/ron-metrics/src/exposer/http.rs
<a id="crates-ron-metrics-src-exposer-http-rs"></a>

```rust
//! RO:WHAT — Axum router + handlers for /metrics, /healthz, /readyz.

use crate::{
    metrics::Metrics,
    readiness::{make_ready_json, ReadyJson, ReadyPolicy},
};
use axum::{
    extract::State,
    http::{header, StatusCode},
    response::{IntoResponse, Response},
    routing::get,
    Json, Router,
};
use prometheus::{Encoder, TextEncoder}; // <-- Encoder trait needed
use std::time::{Instant, SystemTime};

#[derive(Clone)]
pub struct AppState {
    pub metrics: Metrics,
    pub ready_since: SystemTime,
}

pub fn make_router(metrics: Metrics) -> Router {
    let state = AppState {
        metrics,
        ready_since: SystemTime::now(),
    };

    Router::new()
        .route("/metrics", get(get_metrics))
        .route("/healthz", get(get_healthz))
        .route("/readyz", get(get_readyz))
        .with_state(state)
}

async fn get_metrics(State(st): State<AppState>) -> impl IntoResponse {
    let t0 = Instant::now();
    let mf = st.metrics.registry().gather();

    let mut buf = Vec::with_capacity(64 * 1024);
    let enc = TextEncoder::new();

    if let Err(e) = enc.encode(&mf, &mut buf) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("encode failed: {e}"),
        )
            .into_response();
    }

    let secs = t0.elapsed().as_secs_f64();
    st.metrics.observe_exposition(secs, "/metrics");

    Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, enc.format_type())
        .body(axum::body::Body::from(buf))
        .unwrap()
}

async fn get_healthz() -> impl IntoResponse {
    (StatusCode::OK, "ok")
}

async fn get_readyz(State(st): State<AppState>) -> impl IntoResponse {
    let health = st.metrics.health();
    let snap = health.snapshot();
    let all_ready = snap.values().all(|v| *v);
    let missing: Vec<String> = snap
        .into_iter()
        .filter_map(|(svc, ok)| if ok { None } else { Some(svc) })
        .collect();

    let policy: ReadyPolicy = st.metrics.ready_policy();
    let body: ReadyJson = make_ready_json(all_ready, missing, policy, st.ready_since);

    if all_ready {
        (StatusCode::OK, Json(body)).into_response()
    } else {
        let mut resp = (StatusCode::SERVICE_UNAVAILABLE, Json(body)).into_response();
        let retry_after = policy.retry_after_secs.to_string();
        resp.headers_mut()
            .insert(header::RETRY_AFTER, retry_after.parse().unwrap());
        resp
    }
}

```

### crates/ron-metrics/src/exposer/middleware.rs
<a id="crates-ron-metrics-src-exposer-middleware-rs"></a>

```rust
// Middleware placeholder: timeouts, concurrency caps, inflight gauge hooks.

```

### crates/ron-metrics/src/exposer/mod.rs
<a id="crates-ron-metrics-src-exposer-mod-rs"></a>

```rust
//! RO:WHAT — HTTP exposer surface (router + helpers).

pub mod http;
// Future: pub mod tls; pub mod uds;

```

### crates/ron-metrics/src/exposer/tls.rs
<a id="crates-ron-metrics-src-exposer-tls-rs"></a>

```rust
// TLS wiring placeholder (tokio_rustls::rustls::ServerConfig only).

```

### crates/ron-metrics/src/exposer/uds.rs
<a id="crates-ron-metrics-src-exposer-uds-rs"></a>

```rust
// UDS bind placeholder with secure modes (0700 dir / 0600 socket), no symlinks.

```

### crates/ron-metrics/src/health.rs
<a id="crates-ron-metrics-src-health-rs"></a>

```rust
//! RO:WHAT — In-memory readiness map with snapshot semantics.

use parking_lot::RwLock;
use std::{collections::BTreeMap, sync::Arc};

pub type ServiceName = String;

#[derive(Clone)]
pub struct HealthState {
    inner: Arc<RwLock<BTreeMap<ServiceName, bool>>>,
}

impl HealthState {
    pub fn new() -> Self {
        Self {
            inner: Arc::new(RwLock::new(BTreeMap::new())),
        }
    }
    pub fn set(&self, service: ServiceName, ok: bool) {
        let mut w = self.inner.write();
        w.insert(service, ok);
    }
    pub fn snapshot(&self) -> BTreeMap<ServiceName, bool> {
        self.inner.read().clone()
    }
    pub fn all_ready(&self) -> bool {
        self.inner.read().values().all(|v| *v)
    }
}

```

### crates/ron-metrics/src/labels.rs
<a id="crates-ron-metrics-src-labels-rs"></a>

```rust
//! RO:WHAT — Base label helpers (service, instance, build_version, amnesia).

use std::collections::HashMap;

#[derive(Clone, Debug)]
pub struct BaseLabels {
    pub service: String,
    pub instance: String,
    pub build_version: String,
    pub amnesia: String,
}

impl BaseLabels {
    pub fn to_const_labels(&self) -> HashMap<String, String> {
        let mut m = HashMap::with_capacity(4);
        m.insert("service".into(), self.service.clone());
        m.insert("instance".into(), self.instance.clone());
        m.insert("build_version".into(), self.build_version.clone());
        m.insert("amnesia".into(), self.amnesia.clone());
        m
    }
}

```

### crates/ron-metrics/src/lib.rs
<a id="crates-ron-metrics-src-lib-rs"></a>

```rust
//! RO:WHAT — Public façade for ron-metrics: golden families, health/readiness, HTTP exposer.
//! RO:WHY  — Pillar 5 Observability; Concerns: PERF/RES/GOV.
//! RO:INTERACTS — crate::{metrics,registry,labels,health,readiness}, axum; prometheus Registry.
//! RO:INVARIANTS — single registration per process; GET-only; no lock across .await; TLS type=tokio_rustls::rustls::ServerConfig.
//! RO:METRICS — service_restarts_total, bus_lagged_total, request_latency_seconds, exposition_latency_seconds, health_ready{service}.
//! RO:CONFIG — base labels include {service,instance,build_version,amnesia}; amnesia truthful.

#![forbid(unsafe_code)]

pub mod axum_latency;
pub mod axum_status;
pub mod build_info;
pub mod bus_watcher;
mod errors;
pub mod exporters;
pub mod exposer;
mod health;
mod labels;
mod metrics;
mod readiness;
mod registry;

pub use crate::errors::MetricsError;
pub use crate::health::HealthState;
pub use crate::labels::BaseLabels;
pub use crate::metrics::Metrics;
pub use crate::readiness::{ReadyJson, ReadyPolicy};
pub use crate::registry::SafeRegistry;

```

### crates/ron-metrics/src/metrics.rs
<a id="crates-ron-metrics-src-metrics-rs"></a>

```rust
//! RO:WHAT — Metrics facade and registry wiring for ron-metrics.
//! RO:WHY  — Single place to define/own metric families and expose helpers.
//! RO:INVARIANTS — no locks across .await; single registry instance; stable names.

use std::sync::Arc;

use crate::exposer::http::make_router;
use crate::health::HealthState;
use crate::readiness::ReadyPolicy; // <- import ReadyPolicy from the public module
use crate::registry::SafeRegistry;

use prometheus::{Histogram, HistogramOpts, IntCounterVec, IntGaugeVec, Opts};
use tokio::net::TcpListener;
use tokio::task::JoinHandle;

use crate::errors::MetricsError;
use crate::BaseLabels;

#[derive(Clone)]
pub struct Metrics {
    inner: Arc<Inner>,
}

struct Inner {
    registry: SafeRegistry,
    // Golden families
    pub service_restarts_total: IntCounterVec,
    pub bus_lagged_total: IntCounterVec,
    pub request_latency_seconds: Histogram,
    pub exposition_latency_seconds: Histogram,
    pub health_ready: IntGaugeVec,
    pub request_status_total: IntCounterVec,
    // Health state used by /healthz,/readyz
    pub health: HealthState,
}

impl Metrics {
    pub fn new(_base: BaseLabels, health: HealthState) -> Result<Self, MetricsError> {
        // Current SafeRegistry only exposes `new()`
        let registry = SafeRegistry::new();

        // ---- metric families ----
        let service_restarts_total = IntCounterVec::new(
            Opts::new("service_restarts_total", "Total restarts per component"),
            &["component"],
        )?;

        let bus_lagged_total = IntCounterVec::new(
            Opts::new("bus_lagged_total", "Overwrites due to lag/drop on bus"),
            &["bus"],
        )?;

        let request_latency_seconds = Histogram::with_opts(
            HistogramOpts::new("request_latency_seconds", "Request latency")
                .buckets(buckets::pow2_1ms_to_512ms()),
        )?;

        let exposition_latency_seconds = Histogram::with_opts(
            HistogramOpts::new("exposition_latency_seconds", "Latency to expose endpoints")
                .buckets(buckets::pow2_1ms_to_512ms()),
        )?;

        let health_ready =
            IntGaugeVec::new(Opts::new("health_ready", "Readiness (0/1)"), &["check"])?;

        let request_status_total = IntCounterVec::new(
            Opts::new("request_status_total", "Responses by status class"),
            &["status_class"],
        )?;

        // ---- register once with stable names ----
        registry.register("service_restarts_total", |r| {
            r.register(Box::new(service_restarts_total.clone()))
        })?;
        registry.register("bus_lagged_total", |r| {
            r.register(Box::new(bus_lagged_total.clone()))
        })?;
        registry.register("request_latency_seconds", |r| {
            r.register(Box::new(request_latency_seconds.clone()))
        })?;
        registry.register("exposition_latency_seconds", |r| {
            r.register(Box::new(exposition_latency_seconds.clone()))
        })?;
        registry.register("health_ready", |r| {
            r.register(Box::new(health_ready.clone()))
        })?;
        registry.register("request_status_total", |r| {
            r.register(Box::new(request_status_total.clone()))
        })?;

        Ok(Self {
            inner: Arc::new(Inner {
                registry,
                service_restarts_total,
                bus_lagged_total,
                request_latency_seconds,
                exposition_latency_seconds,
                health_ready,
                request_status_total,
                health,
            }),
        })
    }

    /// Exposer uses this to call `.gather()`.
    /// We return the wrapper so `exposer/http.rs` can do: `metrics.registry().gather()`.
    pub fn registry(&self) -> &SafeRegistry {
        &self.inner.registry
    }

    pub fn health(&self) -> &HealthState {
        &self.inner.health
    }

    // ---------- public helpers ----------

    pub fn inc_service_restart(&self, component: &str) {
        let _ = self
            .inner
            .service_restarts_total
            .with_label_values(&[component])
            .inc();
    }

    pub fn add_bus_lag(&self, bus: &str, overwritten: u64) {
        let _ = self
            .inner
            .bus_lagged_total
            .with_label_values(&[bus])
            .inc_by(overwritten);
    }

    pub fn observe_request(&self, seconds: f64) {
        self.inner.request_latency_seconds.observe(seconds);
    }

    /// Record status by class ("2xx", "4xx", ...)
    pub fn observe_status_class(&self, class: &str) {
        let _ = self
            .inner
            .request_status_total
            .with_label_values(&[class])
            .inc();
    }

    pub fn set_ready<S: Into<String>>(&self, check: S, ok: bool) {
        // avoid moving `check` twice
        let check_s: String = check.into();
        let n = if ok { 1 } else { 0 };
        let _ = self
            .inner
            .health_ready
            .with_label_values(&[&check_s])
            .set(n);
        self.inner.health.set(check_s, ok);
    }

    /// Spawn the HTTP server exposing /metrics,/healthz,/readyz
    pub async fn serve(
        self,
        addr: std::net::SocketAddr,
    ) -> Result<(JoinHandle<()>, std::net::SocketAddr), MetricsError> {
        let router = make_router(self.clone());
        let listener = TcpListener::bind(addr).await?;
        let local = listener.local_addr()?;
        let jh = tokio::spawn(async move {
            if let Err(e) = axum::serve(listener, router).await {
                tracing::error!(error=?e, "metrics HTTP server exited");
            }
        });
        Ok((jh, local))
    }

    /// Keep signature compatible with `exposer/http.rs` (it passes endpoint string)
    pub(crate) fn observe_exposition(&self, seconds: f64, _endpoint: &'static str) {
        self.inner.exposition_latency_seconds.observe(seconds);
    }

    /// Exposer expects a ready policy; keep default semantics
    pub fn ready_policy(&self) -> ReadyPolicy {
        ReadyPolicy::default()
    }
}

// Local buckets helper inside this module
pub mod buckets {
    pub fn pow2_1ms_to_512ms() -> Vec<f64> {
        // Explicit, strictly-increasing boundaries (10 buckets)
        // +Inf is implicit in Prometheus.
        [
            0.001, 0.002, 0.004, 0.008, 0.016, 0.032, 0.064, 0.128, 0.256, 0.512,
        ]
        .to_vec()
    }
}

```

### crates/ron-metrics/src/pq.rs
<a id="crates-ron-metrics-src-pq-rs"></a>

```rust
// PQ metrics placeholder (present even if zero): pq_kex_failures_total, etc.

```

### crates/ron-metrics/src/readiness.rs
<a id="crates-ron-metrics-src-readiness-rs"></a>

```rust
//! RO:WHAT — Ready JSON schema + policy helpers.

use serde::{Deserialize, Serialize};
use std::time::{Duration, SystemTime};

#[derive(Clone, Copy)]
pub struct ReadyPolicy {
    pub retry_after_secs: u64,
}
impl Default for ReadyPolicy {
    fn default() -> Self {
        Self {
            retry_after_secs: 5,
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ReadyJson {
    pub degraded: bool,
    #[serde(default)]
    pub missing: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retry_after: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub since: Option<u64>,
}

pub fn make_ready_json(
    all_ready: bool,
    missing: Vec<String>,
    policy: ReadyPolicy,
    since: SystemTime,
) -> ReadyJson {
    let since_secs = since
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    if all_ready {
        ReadyJson {
            degraded: false,
            missing: Vec::new(),
            retry_after: None,
            since: Some(since_secs),
        }
    } else {
        ReadyJson {
            degraded: true,
            missing,
            retry_after: Some(policy.retry_after_secs),
            since: Some(since_secs),
        }
    }
}

```

### crates/ron-metrics/src/registry.rs
<a id="crates-ron-metrics-src-registry-rs"></a>

```rust
//! RO:WHAT — Thin wrapper over prometheus::Registry preventing duplicate names.

use prometheus::{Error as PromError, Registry, Result as PromResult};
use std::collections::HashSet;
use std::sync::{Arc, Mutex};

#[derive(Clone)]
pub struct SafeRegistry {
    inner: Arc<Registry>,
    names: Arc<Mutex<HashSet<String>>>,
}

impl SafeRegistry {
    pub fn new() -> Self {
        Self {
            inner: Arc::new(Registry::new()),
            names: Arc::new(Mutex::new(HashSet::new())),
        }
    }

    pub fn register<F>(&self, family_name: &str, register_fn: F) -> PromResult<()>
    where
        F: FnOnce(&Registry) -> PromResult<()>,
    {
        let mut g = self.names.lock().unwrap();
        if !g.insert(family_name.to_string()) {
            // Return a real prometheus::Error so callers can map it.
            return Err(PromError::Msg(format!("duplicate family: {family_name}")));
        }
        drop(g);
        register_fn(&self.inner)
    }

    pub fn gather(&self) -> Vec<prometheus::proto::MetricFamily> {
        self.inner.gather()
    }

    pub fn raw(&self) -> &Registry {
        &self.inner
    }
}

```

### crates/ron-metrics/src/zk.rs
<a id="crates-ron-metrics-src-zk-rs"></a>

```rust
// ZK metrics placeholder (present even if zero): zk_verify_failures_total, zk_proof_latency_seconds.

```

### crates/ron-metrics/tests/bus_watcher.rs
<a id="crates-ron-metrics-tests-buswatcher-rs"></a>

```rust
#![cfg(feature = "bus")]
use ron_bus::{Bus, BusConfig, Event};
use ron_metrics::build_info::build_version;
use ron_metrics::bus_watcher::start_bus_watcher;
use ron_metrics::{BaseLabels, HealthState, Metrics};

#[tokio::test]
async fn watcher_maps_health_events() {
    let base = BaseLabels {
        service: "svc".into(),
        instance: "t".into(),
        build_version: build_version(),
        amnesia: "off".into(),
    };
    let bus = Bus::new(BusConfig::default().with_capacity(64)).expect("bus");
    let health = HealthState::new();
    let metrics = Metrics::new(base, health).unwrap();
    let _h = start_bus_watcher(metrics.clone(), &bus, "test");

    let tx = bus.sender();
    tx.send(Event::Health {
        service: "db".into(),
        ok: false,
    })
    .unwrap();
    tx.send(Event::Health {
        service: "cache".into(),
        ok: true,
    })
    .unwrap();

    tokio::time::sleep(std::time::Duration::from_millis(50)).await;
    let snap = metrics.health().snapshot();
    assert_eq!(snap.get("db"), Some(&false));
    assert_eq!(snap.get("cache"), Some(&true));

    tx.send(Event::Shutdown).unwrap();
}

```

### crates/ron-metrics/tests/health_ready.rs
<a id="crates-ron-metrics-tests-healthready-rs"></a>

```rust
use ron_metrics::HealthState;

#[test]
fn health_state_roundtrip() {
    let h = HealthState::new();
    h.set("db".to_string(), false);
    h.set("cache".to_string(), true);

    let snap = h.snapshot();
    assert_eq!(snap.get("db"), Some(&false));
    assert_eq!(snap.get("cache"), Some(&true));
    assert!(!h.all_ready());

    h.set("db".to_string(), true);
    assert!(h.all_ready());
}

```

### crates/ron-metrics/tests/http_endpoints.rs
<a id="crates-ron-metrics-tests-httpendpoints-rs"></a>

```rust
use axum::body::Body; // request body type
use ron_metrics::build_info::build_version;
use ron_metrics::{BaseLabels, HealthState, Metrics};

use http_body_util::BodyExt; // for .collect().to_bytes()
use hyper::{Request, StatusCode};
use hyper_util::client::legacy::{connect::HttpConnector, Client};
use hyper_util::rt::TokioExecutor;
use std::net::SocketAddr;

#[tokio::test]
async fn http_endpoints_smoke() {
    let base = BaseLabels {
        service: "test-svc".into(),
        instance: "itest-1".into(),
        build_version: build_version(),
        amnesia: "off".into(),
    };
    let health = HealthState::new();
    health.set("config_loaded".into(), true);
    health.set("db".into(), false);

    let metrics = Metrics::new(base, health).expect("metrics new");

    let (_jh, addr) = metrics
        .clone()
        .serve("127.0.0.1:0".parse::<SocketAddr>().unwrap())
        .await
        .expect("serve");

    // Hyper 1.x client via hyper-util
    let connector = HttpConnector::new();
    let client: Client<_, Body> = Client::builder(TokioExecutor::new()).build(connector);

    // /healthz -> 200
    let resp = client
        .request(
            Request::builder()
                .uri(format!("http://{addr}/healthz"))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    assert_eq!(resp.status(), StatusCode::OK);

    // /readyz -> 503 (db=false) + Retry-After + JSON body
    let resp = client
        .request(
            Request::builder()
                .uri(format!("http://{addr}/readyz"))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    assert_eq!(resp.status(), StatusCode::SERVICE_UNAVAILABLE);
    assert!(resp.headers().get(hyper::header::RETRY_AFTER).is_some());
    let body_bytes = resp
        .into_body()
        .collect()
        .await
        .expect("collect body")
        .to_bytes();
    let v: serde_json::Value = serde_json::from_slice(&body_bytes).unwrap();
    assert!(v.get("degraded").and_then(|b| b.as_bool()).unwrap());

    // flip -> ready
    metrics.set_ready("db", true);
    let resp = client
        .request(
            Request::builder()
                .uri(format!("http://{addr}/readyz"))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    assert_eq!(resp.status(), StatusCode::OK);

    // /metrics -> 200 text/plain
    let resp = client
        .request(
            Request::builder()
                .uri(format!("http://{addr}/metrics"))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
    let ctype = resp
        .headers()
        .get(hyper::header::CONTENT_TYPE)
        .unwrap()
        .to_str()
        .unwrap();
    assert!(ctype.starts_with("text/plain"));
}

```

### crates/ron-metrics/tests/http_status_counter.rs
<a id="crates-ron-metrics-tests-httpstatuscounter-rs"></a>

```rust
//! Ensures request_status_total increments and the latency histogram encodes.

use axum::{routing::get, Router};
use ron_metrics::build_info::build_version;
use ron_metrics::{
    axum_latency, axum_status, exposer::http::make_router, BaseLabels, HealthState, Metrics,
};
use std::net::SocketAddr;
use tokio::time::{sleep, Duration};

#[tokio::test]
async fn status_counter_and_latency_move() {
    let base = BaseLabels {
        service: "test-svc".into(),
        instance: "test-1".into(),
        build_version: build_version(),
        amnesia: "off".into(),
    };
    let health = HealthState::new();
    health.set("config_loaded".into(), true);
    let metrics = Metrics::new(base, health).expect("metrics");

    let app = Router::new()
        .route("/ping", get(|| async { "pong" }))
        .merge(make_router(metrics.clone()));
    let app = axum_latency::attach(app, metrics.clone());
    let app = axum_status::attach(app, metrics.clone());

    let listener = tokio::net::TcpListener::bind(SocketAddr::from(([127, 0, 0, 1], 0)))
        .await
        .unwrap();
    let addr = listener.local_addr().unwrap();

    let jh = tokio::spawn(async move { axum::serve(listener, app).await.unwrap() });

    // exercise endpoints
    let _ = reqwest::get(format!("http://{addr}/ping"))
        .await
        .unwrap()
        .text()
        .await
        .unwrap();
    sleep(Duration::from_millis(10)).await;

    // pull metrics text
    let body = reqwest::get(format!("http://{addr}/metrics"))
        .await
        .unwrap()
        .text()
        .await
        .unwrap();

    // assert status counter moved (2xx)
    assert!(
        body.contains("request_status_total{status_class=\"2xx\"}"),
        "missing 2xx counter"
    );
    // assert latency histogram exported (count present)
    assert!(
        body.contains("request_latency_seconds_count"),
        "missing latency count"
    );

    drop(jh);
}

```

### crates/ron-metrics/tests/integration_http_endpoints.rs
<a id="crates-ron-metrics-tests-integrationhttpendpoints-rs"></a>

```rust
// Ensures /metrics, /healthz, /readyz status/headers/body shapes (scaffold placeholder).
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/loom_shutdown.rs
<a id="crates-ron-metrics-tests-loomshutdown-rs"></a>

```rust
// Loom-gated shutdown sequencing (no locks across .await) — scaffold placeholder.
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/metrics_encode_ok.rs
<a id="crates-ron-metrics-tests-metricsencodeok-rs"></a>

```rust
use prometheus::{Encoder, TextEncoder};
use ron_metrics::build_info::build_version;
use ron_metrics::{BaseLabels, HealthState, Metrics};

#[test]
fn metrics_encode_ok() {
    let base = BaseLabels {
        service: "test-svc".into(),
        instance: "test-1".into(),
        build_version: build_version(),
        amnesia: "off".into(),
    };
    let health = HealthState::new();
    health.set("config_loaded".into(), true);

    let metrics = Metrics::new(base, health).expect("metrics new");
    metrics.inc_service_restart("worker-A");
    metrics.add_bus_lag("kernel", 2);
    metrics.observe_request(0.002);

    let mf = metrics.registry().gather();
    assert!(!mf.is_empty(), "registry should have some families");

    let mut buf = Vec::new();
    let enc = TextEncoder::new();
    enc.encode(&mf, &mut buf).expect("encode");
    assert!(!buf.is_empty(), "prometheus text should be non-empty");
}

```

### crates/ron-metrics/tests/public_api.rs
<a id="crates-ron-metrics-tests-publicapi-rs"></a>

```rust
// Guards public symbol drift via cargo-public-api snapshots (scaffold placeholder).
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/readiness_semantics.rs
<a id="crates-ron-metrics-tests-readinesssemantics-rs"></a>

```rust
// Asserts fail-open reads / fail-closed writes and Retry-After semantics (scaffold placeholder).
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/taxonomy_labels.rs
<a id="crates-ron-metrics-tests-taxonomylabels-rs"></a>

```rust
// Verifies suffix discipline and base labels presence (scaffold placeholder).
#[test]
fn placeholder() {}

```

### crates/ron-metrics/tests/vectors/interop/ron-metrics/readyz-degraded.json
<a id="crates-ron-metrics-tests-vectors-interop-ron-metrics-readyz-degraded-json"></a>

```json
{ "degraded": true, "missing": ["config_loaded","kernel_bus_attached"], "retry_after": 5 }

```

### crates/ron-metrics/tests/vectors/interop/ron-metrics/readyz-ready.json
<a id="crates-ron-metrics-tests-vectors-interop-ron-metrics-readyz-ready-json"></a>

```json
{ "degraded": false, "missing": [], "retry_after": 0 }

```



---



# oap

_Source: crates/oap/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:43:11Z -->
# Code Bundle — `oap`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/oap/.cargo/config.toml](#crates-oap--cargo-config-toml)
- [crates/oap/.github/workflows/ci.yml](#crates-oap--github-workflows-ci-yml)
- [crates/oap/.github/workflows/public-api.yml](#crates-oap--github-workflows-public-api-yml)
- [crates/oap/.github/workflows/render-mermaid.yml](#crates-oap--github-workflows-render-mermaid-yml)
- [crates/oap/Cargo.toml](#crates-oap-Cargo-toml)
- [crates/oap/benches/decode_happy.rs](#crates-oap-benches-decodehappy-rs)
- [crates/oap/benches/decode_pathological.rs](#crates-oap-benches-decodepathological-rs)
- [crates/oap/benches/encode_ack.rs](#crates-oap-benches-encodeack-rs)
- [crates/oap/fuzz/fuzz_targets/ack_fuzz.rs](#crates-oap-fuzz-fuzztargets-ackfuzz-rs)
- [crates/oap/fuzz/fuzz_targets/header_fuzz.rs](#crates-oap-fuzz-fuzztargets-headerfuzz-rs)
- [crates/oap/fuzz/fuzz_targets/parser_fuzz.rs](#crates-oap-fuzz-fuzztargets-parserfuzz-rs)
- [crates/oap/rust-toolchain.toml](#crates-oap-rust-toolchain-toml)
- [crates/oap/scripts/perf_compare.sh](#crates-oap-scripts-perfcompare-sh)
- [crates/oap/src/codec.rs](#crates-oap-src-codec-rs)
- [crates/oap/src/constants.rs](#crates-oap-src-constants-rs)
- [crates/oap/src/envelope.rs](#crates-oap-src-envelope-rs)
- [crates/oap/src/error.rs](#crates-oap-src-error-rs)
- [crates/oap/src/flags.rs](#crates-oap-src-flags-rs)
- [crates/oap/src/frame.rs](#crates-oap-src-frame-rs)
- [crates/oap/src/header.rs](#crates-oap-src-header-rs)
- [crates/oap/src/hello.rs](#crates-oap-src-hello-rs)
- [crates/oap/src/lib.rs](#crates-oap-src-lib-rs)
- [crates/oap/src/metrics.rs](#crates-oap-src-metrics-rs)
- [crates/oap/src/parser/config.rs](#crates-oap-src-parser-config-rs)
- [crates/oap/src/parser/mod.rs](#crates-oap-src-parser-mod-rs)
- [crates/oap/src/parser/state.rs](#crates-oap-src-parser-state-rs)
- [crates/oap/src/prelude.rs](#crates-oap-src-prelude-rs)
- [crates/oap/src/seq.rs](#crates-oap-src-seq-rs)
- [crates/oap/src/writer/config.rs](#crates-oap-src-writer-config-rs)
- [crates/oap/src/writer/mod.rs](#crates-oap-src-writer-mod-rs)
- [crates/oap/tests/ack_algebra.rs](#crates-oap-tests-ackalgebra-rs)
- [crates/oap/tests/config_validation.rs](#crates-oap-tests-configvalidation-rs)
- [crates/oap/tests/conformance.rs](#crates-oap-tests-conformance-rs)
- [crates/oap/tests/envelope_builder.rs](#crates-oap-tests-envelopebuilder-rs)
- [crates/oap/tests/metrics_labels.rs](#crates-oap-tests-metricslabels-rs)
- [crates/oap/tests/metrics_mapping.rs](#crates-oap-tests-metricsmapping-rs)
- [crates/oap/tests/parser_partial_read.rs](#crates-oap-tests-parserpartialread-rs)
- [crates/oap/tests/seq_monotonic.rs](#crates-oap-tests-seqmonotonic-rs)
- [crates/oap/tests/split_need_more.rs](#crates-oap-tests-splitneedmore-rs)
- [crates/oap/tests/vectors.rs](#crates-oap-tests-vectors-rs)
- [crates/oap/tests/writer_roundtrip.rs](#crates-oap-tests-writerroundtrip-rs)

### crates/oap/.cargo/config.toml
<a id="crates-oap--cargo-config-toml"></a>

```toml
[build]
# keep fast and strict in CI
rustflags = []

[target.'cfg(all())']
# You can tighten lints globally in the workspace root; keep crate-local light here.

```

### crates/oap/.github/workflows/ci.yml
<a id="crates-oap--github-workflows-ci-yml"></a>

```yaml
name: ci (oap2)
on: [push, pull_request]
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo fmt --all --check
      - run: cargo clippy -p oap2 -- -D warnings || true
      - run: cargo test -p oap2 --all-features || true
      - run: cargo install cargo-deny || true
      - run: cargo deny check || true

```

### crates/oap/.github/workflows/public-api.yml
<a id="crates-oap--github-workflows-public-api-yml"></a>

```yaml
name: public-api (oap2)
on: [push, pull_request]
jobs:
  api-diff:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo install cargo-public-api || true
      - run: cargo public-api --manifest-path crates/oap2/Cargo.toml || true

```

### crates/oap/.github/workflows/render-mermaid.yml
<a id="crates-oap--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid (oap2)
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          for f in $(git ls-files 'crates/oap2/docs/*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out" || true
          done

```

### crates/oap/Cargo.toml
<a id="crates-oap-Cargo-toml"></a>

```toml
[package]
name = "oap"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Overlay Access Protocol (OAP/1) framing and Tokio codec for RustyOnions"
repository = "https://example.invalid/RustyOnions"
authors = ["RustyOnions contributors"]

[lib]
name = "oap"
path = "src/lib.rs"

[features]
default = []
# Optional bounded decompression for payloads flagged with COMP.
zstd = ["dep:zstd"]

[dependencies]
bytes = "1.6"
tokio-util = { version = "0.7.16", features = ["codec"] }
tokio = { version = "1.47.1", features = ["io-util"] }
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
serde_repr = "0.1"
serde_json = "1.0"
tracing = "0.1"
bitflags = "2.6"
# Only pulled when feature=zstd is on
zstd = { version = "0.13", optional = true }

# Types-only crates (no IO/logic). Keep DTO hygiene.
ron-proto = { path = "../ron-proto", optional = true }

[dev-dependencies]
pretty_assertions = "1.4"

```

### crates/oap/benches/decode_happy.rs
<a id="crates-oap-benches-decodehappy-rs"></a>

```rust
// Criterion bench scaffold (no implementation).
fn main() {}

```

### crates/oap/benches/decode_pathological.rs
<a id="crates-oap-benches-decodepathological-rs"></a>

```rust
fn main() {}

```

### crates/oap/benches/encode_ack.rs
<a id="crates-oap-benches-encodeack-rs"></a>

```rust
fn main() {}

```

### crates/oap/fuzz/fuzz_targets/ack_fuzz.rs
<a id="crates-oap-fuzz-fuzztargets-ackfuzz-rs"></a>

```rust
// libFuzzer target placeholder

```

### crates/oap/fuzz/fuzz_targets/header_fuzz.rs
<a id="crates-oap-fuzz-fuzztargets-headerfuzz-rs"></a>

```rust
// libFuzzer target placeholder

```

### crates/oap/fuzz/fuzz_targets/parser_fuzz.rs
<a id="crates-oap-fuzz-fuzztargets-parserfuzz-rs"></a>

```rust
// libFuzzer target placeholder

```

### crates/oap/rust-toolchain.toml
<a id="crates-oap-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["clippy", "rustfmt"]

```

### crates/oap/scripts/perf_compare.sh
<a id="crates-oap-scripts-perfcompare-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "perf_compare: scaffold placeholder (wire to Criterion JSON once benches exist)"

```

### crates/oap/src/codec.rs
<a id="crates-oap-src-codec-rs"></a>

```rust
//! RO:WHAT — Tokio `Encoder`/`Decoder` for OAP/1 frames (length-prefixed, bounded).
//! RO:WHY — Interop needs a safe, reusable codec with strict limits and optional zstd inflate.
//! RO:INTERACTS — bytes, tokio-util::codec; uses Header/Flags and error taxonomy.
//! RO:INVARIANTS — Enforce MAX_FRAME_BYTES; START-only cap; optional COMP → bounded inflate ≤ 8×.

use bytes::BytesMut;
use tokio_util::codec::{Decoder, Encoder};

use crate::constants::MAX_FRAME_BYTES;
use crate::error::{OapDecodeError as DE, OapEncodeError as EE};
use crate::flags::Flags;
use crate::{Frame, Header};

#[cfg(feature = "zstd")]
use crate::constants::MAX_DECOMPRESS_EXPANSION;
#[cfg(feature = "zstd")]
use bytes::Bytes;

#[derive(Debug, Default)]
pub struct OapDecoder;

#[derive(Debug, Default)]
pub struct OapEncoder;

impl Decoder for OapDecoder {
    type Item = Frame;
    type Error = DE; // must be From<std::io::Error>; satisfied via Io(#[from]).

    fn decode(&mut self, src: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {
        // Need at least the fixed header.
        if src.len() < Header::WIRE_SIZE {
            return Ok(None);
        }

        // Peek a copy for header parsing without moving yet.
        let mut peek = src.clone().freeze();
        let hdr = Header::read_from(&mut peek)?;

        // If we don't have the whole frame yet, wait.
        if src.len() < hdr.len as usize {
            return Ok(None);
        }

        // Split off exactly the frame to work on.
        let mut frame_bytes = src.split_to(hdr.len as usize).freeze();

        // Re-read header from the real slice (advance).
        let _ = Header::read_from(&mut frame_bytes)?; // validated already

        // Cap section
        let cap = if hdr.cap_len > 0 {
            if !hdr.flags.contains(Flags::START) {
                return Err(DE::CapOnNonStart);
            }
            if frame_bytes.len() < hdr.cap_len as usize {
                return Err(DE::CapOutOfBounds);
            }
            Some(frame_bytes.split_to(hdr.cap_len as usize))
        } else {
            None
        };

        // Remaining is payload (may be empty)
        let payload = if frame_bytes.is_empty() {
            None
        } else {
            Some(frame_bytes)
        };

        // Optional bounded decompression when COMP flag set
        #[cfg(feature = "zstd")]
        let mut payload = payload;

        if hdr.flags.contains(Flags::COMP) {
            #[cfg(not(feature = "zstd"))]
            {
                return Err(DE::ZstdFeatureNotEnabled);
            }
            #[cfg(feature = "zstd")]
            {
                if let Some(body) = payload.take() {
                    let max_out = (MAX_FRAME_BYTES * MAX_DECOMPRESS_EXPANSION) as usize;
                    let mut dec = zstd::stream::read::Decoder::new(std::io::Cursor::new(body))
                        .map_err(|e| DE::Zstd(e.to_string()))?;
                    use std::io::Read;
                    let mut out = Vec::new();
                    let mut buf = [0u8; 16 * 1024];
                    loop {
                        let n = dec.read(&mut buf)?;
                        if n == 0 {
                            break;
                        }
                        out.extend_from_slice(&buf[..n]);
                        if out.len() > max_out {
                            return Err(DE::DecompressBoundExceeded);
                        }
                    }
                    payload = Some(Bytes::from(out));
                }
            }
        }

        Ok(Some(Frame {
            header: hdr,
            cap,
            payload,
        }))
    }
}

impl Encoder<Frame> for OapEncoder {
    type Error = EE; // must be From<std::io::Error>; satisfied via Io(#[from]).

    fn encode(&mut self, item: Frame, dst: &mut BytesMut) -> Result<(), Self::Error> {
        // Sanity on lengths vs declared header.len
        let cap_len = item.cap.as_ref().map(|b| b.len()).unwrap_or(0);
        let payload_len = item.payload.as_ref().map(|b| b.len()).unwrap_or(0);
        if cap_len > u16::MAX as usize {
            return Err(EE::CapOutOfBounds);
        }
        let total_len = Header::WIRE_SIZE + cap_len + payload_len;
        if total_len > MAX_FRAME_BYTES as usize {
            return Err(EE::FrameTooLarge {
                len: total_len as u32,
                max: MAX_FRAME_BYTES,
            });
        }

        // Write header (with corrected cap_len & len)
        let mut hdr = item.header;
        hdr.cap_len = cap_len as u16;
        hdr.len = total_len as u32;

        // Reserve and emit
        dst.reserve(total_len);
        hdr.put_to(dst);
        if let Some(cap) = item.cap {
            dst.extend_from_slice(&cap);
        }
        if let Some(payload) = item.payload {
            dst.extend_from_slice(&payload);
        }
        Ok(())
    }
}

```

### crates/oap/src/constants.rs
<a id="crates-oap-src-constants-rs"></a>

```rust
//! RO:WHAT — Canonical OAP/1 constants and limits.
//! RO:WHY — Keep protocol bounds single-sourced and drift-proof (Hardening & Interop blueprints).
//! RO:INTERACTS — Used by header/frame/codec modules and by callers for guardrails.
//! RO:INVARIANTS — max_frame=1MiB; bounded decompress guard ≤ 8× frame cap; chunk hint=64KiB.

/// Maximum allowed OAP frame size in bytes (protocol invariant).
pub const MAX_FRAME_BYTES: u32 = 1024 * 1024; // 1 MiB

/// Recommended streaming chunk size used by storage paths (not a protocol limit).
pub const STREAM_CHUNK_SIZE: usize = 64 * 1024; // 64 KiB

/// Upper bound on decompressed size relative to `MAX_FRAME_BYTES` when COMP flag is set.
/// Per Interop blueprint: bounded inflate (≤ 8× frame cap) → reject with 413 if exceeded.
pub const MAX_DECOMPRESS_EXPANSION: u32 = 8;

/// OAP protocol version.
pub const OAP_VERSION: u16 = 1;

```

### crates/oap/src/envelope.rs
<a id="crates-oap-src-envelope-rs"></a>

```rust
//! RO:WHAT — Ergonomic envelope helpers: capability wrapper and frame builders.
//! RO:WHY  — Reduce boilerplate for callers while enforcing OAP invariants at build time.
//! RO:INTERACTS — Uses Frame/Header/Flags/StatusCode plus HELLO DTOs from `hello.rs`.
//! RO:INVARIANTS — No I/O; the Encoder normalizes `len`/`cap_len`; caps only valid with START.

use bytes::Bytes;

use crate::{
    flags::Flags,
    hello::{Hello, HelloReply},
    Frame, Header, StatusCode, OAP_VERSION,
};

/// Opaque capability bytes carried on `START` frames.
/// Semantics (macaroons, scopes, etc.) live above OAP.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Capability(Bytes);

impl Capability {
    pub fn new(bytes: Bytes) -> Self {
        Self(bytes)
    }
    pub fn as_bytes(&self) -> &Bytes {
        &self.0
    }
    pub fn into_bytes(self) -> Bytes {
        self.0
    }
    /// Size guard for START frames (u16 fit).
    pub fn fits_u16(&self) -> bool {
        self.0.len() <= u16::MAX as usize
    }
}

/// True if a sender requests an ACK.
pub fn wants_ack(flags: Flags) -> bool {
    flags.contains(Flags::ACK_REQ)
}
/// True if a frame marks the logical end of a request/stream.
pub fn is_terminal(flags: Flags) -> bool {
    flags.contains(Flags::END)
}
/// True if a frame is fire-and-forget (EVENT without ACK).
pub fn is_fire_and_forget(flags: Flags) -> bool {
    flags.contains(Flags::EVENT) && !wants_ack(flags)
}

/// Minimal, chainable builder for common envelopes.
/// The encoder will set `len`/`cap_len` on write.
#[derive(Debug, Clone)]
pub struct FrameBuilder {
    header: Header,
    cap: Option<Bytes>,
    payload: Option<Bytes>,
}

impl FrameBuilder {
    /// Begin a request for `app_proto_id`.
    pub fn request(app_proto_id: u16, tenant_id: u128, corr_id: u64) -> Self {
        Self {
            header: Header {
                len: 0,
                ver: OAP_VERSION,
                flags: Flags::REQ,
                code: 0,
                app_proto_id,
                tenant_id,
                cap_len: 0,
                corr_id,
            },
            cap: None,
            payload: None,
        }
    }

    /// Begin a response for `app_proto_id` with a status code.
    pub fn response(app_proto_id: u16, tenant_id: u128, corr_id: u64, code: StatusCode) -> Self {
        Self {
            header: Header {
                len: 0,
                ver: OAP_VERSION,
                flags: Flags::RESP,
                code: code as u16,
                app_proto_id,
                tenant_id,
                cap_len: 0,
                corr_id,
            },
            cap: None,
            payload: None,
        }
    }

    /// Mark as START and attach capability bytes (REQ is set if not already).
    pub fn start_with_cap(mut self, cap: Bytes) -> Self {
        self.header.flags |= Flags::START | Flags::REQ;
        self.cap = Some(cap);
        self
    }

    /// Attach opaque payload.
    pub fn payload(mut self, p: Bytes) -> Self {
        self.payload = Some(p);
        self
    }

    /// Request ACK.
    pub fn want_ack(mut self) -> Self {
        self.header.flags |= Flags::ACK_REQ;
        self
    }

    /// Mark as END.
    pub fn end(mut self) -> Self {
        self.header.flags |= Flags::END;
        self
    }

    /// Build a `Frame`.
    pub fn build(self) -> Frame {
        Frame {
            header: self.header,
            cap: self.cap,
            payload: self.payload,
        }
    }
}

/// Convenience: HELLO request frame (app_proto_id=0).
pub fn hello_request(ua: Option<&str>, tenant_id: u128, corr_id: u64) -> Frame {
    let h = Hello {
        ua: ua.map(str::to_owned),
    };
    h.to_frame(tenant_id, corr_id)
}

/// Convenience: HELLO reply frame (app_proto_id=0), using default server caps.
pub fn hello_reply_default(tenant_id: u128, corr_id: u64) -> Frame {
    HelloReply::default_for_server().to_frame(tenant_id, corr_id)
}

```

### crates/oap/src/error.rs
<a id="crates-oap-src-error-rs"></a>

```rust
//! RO:WHAT — Error taxonomy for OAP codec and helpers.
//! RO:WHY — Stable, typed errors that map to protocol status codes where meaningful.
//! RO:INTERACTS — Used by codec/frame/hello; callers can translate to HTTP or OAP rejects.
//! RO:INVARIANTS — 413 on size violations; 400 family for client misuse; 5xx for internal.

use thiserror::Error;

/// Minimal status code set suitable for mapping OAP outcomes (also maps to HTTP when proxied).
#[derive(
    Copy, Clone, Debug, PartialEq, Eq, serde_repr::Serialize_repr, serde_repr::Deserialize_repr,
)]
#[repr(u16)]
pub enum StatusCode {
    Ok = 200,
    Partial = 206,
    BadRequest = 400,
    Unauthorized = 401,
    Forbidden = 403,
    NotFound = 404,
    PayloadTooLarge = 413,
    TooManyRequests = 429,
    Internal = 500,
    Unavailable = 503,
}

#[derive(Debug, Error)]
pub enum OapDecodeError {
    #[error("truncated header")]
    TruncatedHeader,
    #[error("bad version {0}")]
    BadVersion(u16),
    #[error("bad flags bits {0:#06x}")]
    BadFlags(u16),
    #[error("cap section present but START flag not set")]
    CapOnNonStart,
    #[error("frame too large: {len} > {max}")]
    FrameTooLarge { len: u32, max: u32 },
    #[error("cap length exceeds frame")]
    CapOutOfBounds,
    #[error("payload length exceeds frame")]
    PayloadOutOfBounds,
    #[error("decompression exceeded bound")]
    DecompressBoundExceeded,
    #[error("zstd not enabled")]
    ZstdFeatureNotEnabled,
    #[error("zstd decode error: {0}")]
    Zstd(String),
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
}

#[derive(Debug, Error)]
pub enum OapEncodeError {
    #[error("frame too large: {len} > {max}")]
    FrameTooLarge { len: u32, max: u32 },
    #[error("cap length exceeds frame")]
    CapOutOfBounds,
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
}

#[derive(Debug, Error)]
pub enum OapError {
    #[error(transparent)]
    Decode(#[from] OapDecodeError),
    #[error(transparent)]
    Encode(#[from] OapEncodeError),
}

// Allow `?` on std::io::Error to bubble into OapError (encode path preferred).
impl From<std::io::Error> for OapError {
    fn from(err: std::io::Error) -> Self {
        OapError::Encode(OapEncodeError::Io(err))
    }
}

```

### crates/oap/src/flags.rs
<a id="crates-oap-src-flags-rs"></a>

```rust
//! RO:WHAT — Bitflags for OAP/1 `flags,u16` header field.
//! RO:WHY — Explicit bit meanings for interop; avoids magic numbers.
//! RO:INTERACTS — Used by header/frame/codec; callers set semantics via these bits.
//! RO:INVARIANTS — Bits stable under semver; RESERVED kept for forward-compat.

bitflags::bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    pub struct Flags: u16 {
        const REQ     = 1 << 0;
        const RESP    = 1 << 1;
        const EVENT   = 1 << 2;
        const START   = 1 << 3;
        const END     = 1 << 4;
        const ACK_REQ = 1 << 5;
        const COMP    = 1 << 6; // payload compressed (zstd) with bounded inflate
        const APP_E2E = 1 << 7; // opaque app-layer E2E crypto; platform does not inspect
        // reserve upper bits for future use
    }
}

```

### crates/oap/src/frame.rs
<a id="crates-oap-src-frame-rs"></a>

```rust
//! RO:WHAT — High-level OAP frame value (header + optional cap + payload).
//! RO:WHY — Keep parsing/encoding logic separate from transport loops; safe, owned bytes.
//! RO:INTERACTS — Header/Flags; codec reads/writes `Frame` to/from wire.
//! RO:INVARIANTS — Owned buffers; bounds validated; START carries capability bytes only.

use crate::Header;
use bytes::Bytes;

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Frame {
    pub header: Header,
    pub cap: Option<Bytes>,
    pub payload: Option<Bytes>,
}

impl Frame {
    pub fn new(header: Header, cap: Option<Bytes>, payload: Option<Bytes>) -> Self {
        Self {
            header,
            cap,
            payload,
        }
    }

    pub fn payload_len(&self) -> usize {
        self.payload.as_ref().map(|b| b.len()).unwrap_or(0)
    }

    pub fn cap_len(&self) -> usize {
        self.cap.as_ref().map(|b| b.len()).unwrap_or(0)
    }
}

```

### crates/oap/src/header.rs
<a id="crates-oap-src-header-rs"></a>

```rust
//! RO:WHAT — OAP/1 fixed header (without [cap] and [payload]) and (de)serialization helpers.
//! RO:WHY — Deterministic, endian-stable wire header; validates size/field bounds before alloc.
//! RO:INTERACTS — Flags; codec uses this to parse before reading variable sections.
//! RO:INVARIANTS — Length checked ≤ MAX_FRAME_BYTES; version=1; cap_len for START frames only.

use crate::constants::{MAX_FRAME_BYTES, OAP_VERSION};
use crate::flags::Flags;
use bytes::{Buf, BufMut, BytesMut};

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Header {
    /// Total frame length in bytes (header + cap + payload).
    pub len: u32,
    /// Protocol version (must be 1).
    pub ver: u16,
    /// Bit flags.
    pub flags: Flags,
    /// Status or app code (e.g., 2xx/4xx/5xx or app-defined).
    pub code: u16,
    /// Application protocol id (0 = control/HELLO).
    pub app_proto_id: u16,
    /// Tenant id (128-bit).
    pub tenant_id: u128,
    /// Capability section length in bytes (only valid/allowed with START).
    pub cap_len: u16,
    /// Correlation id (64-bit).
    pub corr_id: u64,
}

impl Header {
    pub const WIRE_SIZE: usize = 4 + 2 + 2 + 2 + 2 + 16 + 2 + 8;

    pub fn validate(&self) -> Result<(), crate::error::OapDecodeError> {
        if self.ver != OAP_VERSION {
            return Err(crate::error::OapDecodeError::BadVersion(self.ver));
        }
        if self.len == 0 || self.len > MAX_FRAME_BYTES {
            return Err(crate::error::OapDecodeError::FrameTooLarge {
                len: self.len,
                max: MAX_FRAME_BYTES,
            });
        }
        if self.cap_len > 0 && !self.flags.contains(Flags::START) {
            return Err(crate::error::OapDecodeError::CapOnNonStart);
        }
        Ok(())
    }

    pub fn put_to(&self, dst: &mut BytesMut) {
        dst.put_u32(self.len);
        dst.put_u16(self.ver);
        dst.put_u16(self.flags.bits());
        dst.put_u16(self.code);
        dst.put_u16(self.app_proto_id);
        dst.put_u128(self.tenant_id);
        dst.put_u16(self.cap_len);
        dst.put_u64(self.corr_id);
    }

    pub fn read_from(src: &mut bytes::Bytes) -> Result<Self, crate::error::OapDecodeError> {
        use crate::error::OapDecodeError as E;
        if src.len() < Self::WIRE_SIZE {
            return Err(E::TruncatedHeader);
        }
        let len = src.get_u32();
        let ver = src.get_u16();
        let flags_bits = src.get_u16();
        let code = src.get_u16();
        let app_proto_id = src.get_u16();
        let tenant_id = src.get_u128();
        let cap_len = src.get_u16();
        let corr_id = src.get_u64();
        let flags = Flags::from_bits(flags_bits).ok_or(E::BadFlags(flags_bits))?;
        let hdr = Header {
            len,
            ver,
            flags,
            code,
            app_proto_id,
            tenant_id,
            cap_len,
            corr_id,
        };
        hdr.validate()?;
        Ok(hdr)
    }
}

```

### crates/oap/src/hello.rs
<a id="crates-oap-src-hello-rs"></a>

```rust
//! RO:WHAT — Small helpers for OAP/1 HELLO (app_proto_id=0) request/response.
//! RO:WHY — Normalize what clients/servers exchange during negotiation.
//! RO:INTERACTS — Flags/Frame/Header; used by SDK and services at connect time.
//! RO:INVARIANTS — ver=1; code=200 on success; returns server caps & versions.

use crate::{constants::*, flags::Flags, Frame, Header};
use bytes::Bytes;
use serde::{Deserialize, Serialize};
use serde_json;

/// Minimal HELLO request (client → server).
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Hello {
    /// Optional user-agent/version string.
    pub ua: Option<String>,
}

/// Minimal HELLO reply (server → client).
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct HelloReply {
    pub max_frame: u32,
    pub max_inflight: u16,
    pub flags_supported: u16,
    pub versions: Vec<u16>,
    pub transports: Vec<String>,
}

impl Hello {
    pub fn to_frame(&self, tenant_id: u128, corr_id: u64) -> Frame {
        let payload = serde_json::to_vec(self).expect("serialize hello");
        let header = Header {
            len: 0, // filled by encoder
            ver: OAP_VERSION,
            flags: Flags::REQ,
            code: 0,
            app_proto_id: 0,
            tenant_id,
            cap_len: 0,
            corr_id,
        };
        Frame {
            header,
            cap: None,
            payload: Some(Bytes::from(payload)),
        }
    }
}

impl HelloReply {
    pub fn default_for_server() -> Self {
        Self {
            max_frame: MAX_FRAME_BYTES,
            max_inflight: 64,
            flags_supported: (Flags::REQ
                | Flags::RESP
                | Flags::EVENT
                | Flags::START
                | Flags::END
                | Flags::ACK_REQ
                | Flags::COMP
                | Flags::APP_E2E)
                .bits(),
            versions: vec![OAP_VERSION],
            transports: vec!["tcp+tls".into()],
        }
    }

    pub fn from_frame(frame: &Frame) -> Result<Self, crate::error::OapDecodeError> {
        let Some(payload) = &frame.payload else {
            return Err(crate::error::OapDecodeError::PayloadOutOfBounds);
        };
        serde_json::from_slice(payload)
            .map_err(|e| crate::error::OapDecodeError::Zstd(e.to_string()))
    }

    pub fn to_frame(&self, tenant_id: u128, corr_id: u64) -> Frame {
        let json = serde_json::to_vec(self).expect("serialize hello reply");
        let header = Header {
            len: 0,
            ver: OAP_VERSION,
            flags: Flags::RESP,
            code: crate::error::StatusCode::Ok as u16,
            app_proto_id: 0,
            tenant_id,
            cap_len: 0,
            corr_id,
        };
        Frame {
            header,
            cap: None,
            payload: Some(Bytes::from(json)),
        }
    }
}

```

### crates/oap/src/lib.rs
<a id="crates-oap-src-lib-rs"></a>

```rust
//! RO:WHAT — OAP/1 constants, flags, header & frame types, and a Tokio codec (Encoder/Decoder).
//! RO:WHY  — Pillar 7 (App BFF & SDK); Concerns: SEC/RES/PERF/DX. Stable envelopes for interop.
//! RO:INTERACTS — bytes, tokio-util::codec; optional ron-proto DTOs; consumed by ron-app-sdk/omnigate.
//! RO:INVARIANTS — OAP/1 max_frame=1MiB; stream chunk≈64KiB (storage); no lock across .await in codec.
//! RO:METRICS — (none here; callers record RED metrics around IO).
//! RO:CONFIG — Bounds are constants; optional zstd with ≤8× expansion guard.
//! RO:SECURITY — No ambient auth; capabilities carried as opaque bytes in START; DTOs deny_unknown_fields upstream.
//! RO:TEST — unit tests in module; golden vectors for HELLO/START/DATA; fuzz hooks to be added in oap-fuzz.

#![forbid(unsafe_code)]

pub mod codec;
pub mod constants;
pub mod error;
pub mod flags;
pub mod frame;
pub mod header;
pub mod hello;

// TODO-aligned modules
pub mod envelope;
pub mod metrics;
pub mod prelude;
pub mod seq;

// Stream helpers (as per TODO folders)
pub mod parser;
pub mod writer;

// Core exports
pub use codec::{OapDecoder, OapEncoder};
pub use constants::*;
pub use error::{OapDecodeError, OapEncodeError, OapError, StatusCode};
pub use flags::Flags;
pub use frame::Frame;
pub use header::Header;
pub use hello::{Hello, HelloReply};

// Ergonomic helpers from TODO modules
pub use envelope::{
    hello_reply_default, hello_request, is_fire_and_forget, is_terminal, wants_ack, Capability,
    FrameBuilder,
};
pub use metrics::{
    is_client_err, is_server_err, is_success, labels_for_outcome, outcome_from_decode,
    outcome_from_status, reason, OutcomeClass,
};
pub use seq::Seq;

// Parser/Writer facades
pub use parser::{ParserConfig, ParserState};
pub use writer::{OapWriter, WriterConfig};

```

### crates/oap/src/metrics.rs
<a id="crates-oap-src-metrics-rs"></a>

```rust
//! RO:WHAT — Status helpers and canonical outcome→label mapping for metrics.
//! RO:WHY  — Keep vocabulary consistent across services; no direct prometheus deps here.
//! RO:INTERACTS — Callers map these to ron-metrics counters/histograms.
//! RO:INVARIANTS — Stable label triplets; conservative defaults.

use crate::error::{OapDecodeError, StatusCode};

/// Human-friendly reason text for a status code (stable subset).
pub fn reason(code: StatusCode) -> &'static str {
    match code {
        StatusCode::Ok => "OK",
        StatusCode::Partial => "Partial Content",
        StatusCode::BadRequest => "Bad Request",
        StatusCode::Unauthorized => "Unauthorized",
        StatusCode::Forbidden => "Forbidden",
        StatusCode::NotFound => "Not Found",
        StatusCode::PayloadTooLarge => "Payload Too Large",
        StatusCode::TooManyRequests => "Too Many Requests",
        StatusCode::Internal => "Internal Server Error",
        StatusCode::Unavailable => "Service Unavailable",
    }
}

/// Quick predicates.
pub fn is_success(code: StatusCode) -> bool {
    (code as u16) / 100 == 2
}
pub fn is_client_err(code: StatusCode) -> bool {
    (code as u16) / 100 == 4
}
pub fn is_server_err(code: StatusCode) -> bool {
    (code as u16) / 100 == 5
}

/// Outcome class for accounting.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum OutcomeClass {
    Success,
    ClientError,
    ServerError,
    DecodeError,
    Oversize,
}

/// Convert a status code into a high-level outcome class.
pub fn outcome_from_status(code: StatusCode) -> OutcomeClass {
    match (code as u16) / 100 {
        2 => OutcomeClass::Success,
        4 => OutcomeClass::ClientError,
        5 => OutcomeClass::ServerError,
        _ => OutcomeClass::ClientError, // default conservative
    }
}

/// Map a decode error to an outcome class (for ingress parse failures).
pub fn outcome_from_decode(err: &OapDecodeError) -> OutcomeClass {
    use OapDecodeError::*;
    match err {
        FrameTooLarge { .. } => OutcomeClass::Oversize,
        BadVersion(_) | BadFlags(_) | CapOnNonStart | CapOutOfBounds | PayloadOutOfBounds => {
            OutcomeClass::DecodeError
        }
        TruncatedHeader | DecompressBoundExceeded | ZstdFeatureNotEnabled | Zstd(_) | Io(_) => {
            OutcomeClass::DecodeError
        }
    }
}

/// Convert outcome into stable label triplet (kind, cause, detail).
/// Keep these short and low-cardinality.
pub fn labels_for_outcome(outcome: OutcomeClass) -> (&'static str, &'static str, &'static str) {
    match outcome {
        OutcomeClass::Success => ("oap", "ok", "2xx"),
        OutcomeClass::ClientError => ("oap", "client", "4xx"),
        OutcomeClass::ServerError => ("oap", "server", "5xx"),
        OutcomeClass::DecodeError => ("oap", "decode", "error"),
        OutcomeClass::Oversize => ("oap", "oversize", "413"),
    }
}

```

### crates/oap/src/parser/config.rs
<a id="crates-oap-src-parser-config-rs"></a>

```rust
//! RO:WHAT — Parser configuration (buffer policy hooks).
//! RO:WHY  — Centralize tunables; allow callers to cap parser memory if desired.
//! RO:INTERACTS — Used by `ParserState`.
//! RO:INVARIANTS — Defaults are conservative and safe.

/// Parser configuration.
/// Currently only exposes a soft maximum buffer size; the OAP decoder still
/// enforces per-frame bounds independently.
#[derive(Clone, Copy, Debug)]
pub struct ParserConfig {
    /// Soft cap for buffered bytes. `None` disables the soft check.
    pub max_buffer_bytes: Option<usize>,
}

impl Default for ParserConfig {
    fn default() -> Self {
        // 4 MiB soft buffer cap is usually sufficient for a few frames in flight.
        Self {
            max_buffer_bytes: Some(4 * 1024 * 1024),
        }
    }
}

```

### crates/oap/src/parser/mod.rs
<a id="crates-oap-src-parser-mod-rs"></a>

```rust
//! RO:WHAT — Incremental OAP frame parser facade.
//! RO:WHY  — Provide a clean API to feed bytes and pull parsed `Frame`s.
//! RO:INTERACTS — Wraps `OapDecoder`; used by gateways/SDKs.
//! RO:INVARIANTS — No blocking; bounded by decoder invariants; zero `unsafe`.

pub mod config;
pub mod state;

pub use config::ParserConfig;
pub use state::ParserState;

```

### crates/oap/src/parser/state.rs
<a id="crates-oap-src-parser-state-rs"></a>

```rust
//! RO:WHAT — Parser state machine: push bytes, pop frames.
//! RO:WHY  — Make partial reads easy without reinventing decoding logic.
//! RO:INTERACTS — `OapDecoder`; returns `Frame`s as they become available.
//! RO:INVARIANTS — No blocking; honors parser config soft cap; zero `unsafe`.

use bytes::BytesMut;
use tokio_util::codec::Decoder; // bring `decode` into scope

use super::ParserConfig;
use crate::{codec::OapDecoder, Frame};

#[derive(Debug)]
pub struct ParserState {
    dec: OapDecoder,
    buf: BytesMut,
    cfg: ParserConfig,
}

impl ParserState {
    pub fn new(cfg: ParserConfig) -> Self {
        Self {
            dec: OapDecoder,
            buf: BytesMut::new(),
            cfg,
        }
    }

    pub fn with_default() -> Self {
        Self::new(ParserConfig::default())
    }

    /// Feed raw bytes into the parser buffer.
    /// Returns `Ok(())` even if no full frame is available yet.
    pub fn push(&mut self, chunk: &[u8]) -> Result<(), crate::OapDecodeError> {
        self.buf.extend_from_slice(chunk);

        // Soft cap (best-effort): callers decide response; decoding still enforces per-frame caps.
        if let Some(max) = self.cfg.max_buffer_bytes {
            if self.buf.len() > max {
                // Return a decode error to signal backpressure to caller (no new variant needed).
                return Err(crate::OapDecodeError::PayloadOutOfBounds);
            }
        }
        Ok(())
    }

    /// Try to decode a single frame if enough data is buffered.
    pub fn try_next(&mut self) -> Result<Option<Frame>, crate::OapDecodeError> {
        self.dec.decode(&mut self.buf)
    }

    /// Drain all currently-available frames.
    pub fn drain(&mut self) -> Result<Vec<Frame>, crate::OapDecodeError> {
        let mut out = Vec::new();
        while let Some(f) = self.dec.decode(&mut self.buf)? {
            out.push(f);
        }
        Ok(out)
    }

    /// Inspect buffered byte count (useful for tests/telemetry).
    pub fn buffered_len(&self) -> usize {
        self.buf.len()
    }
}

```

### crates/oap/src/prelude.rs
<a id="crates-oap-src-prelude-rs"></a>

```rust
//! RO:WHAT — Common imports for ergonomic use of OAP.
//! RO:WHY  — Reduce `use` boilerplate in services and SDKs.
//! RO:INTERACTS — Pure re-exports.

pub use crate::{
    codec::{OapDecoder, OapEncoder},
    constants::{MAX_FRAME_BYTES, OAP_VERSION, STREAM_CHUNK_SIZE},
    envelope::{
        hello_reply_default, hello_request, is_fire_and_forget, is_terminal, wants_ack, Capability,
        FrameBuilder,
    },
    error::{OapDecodeError, OapEncodeError, OapError, StatusCode},
    flags::Flags,
    frame::Frame,
    header::Header,
    metrics::{
        is_client_err, is_server_err, is_success, labels_for_outcome, outcome_from_decode,
        outcome_from_status, reason, OutcomeClass,
    },
    seq::Seq,
};

```

### crates/oap/src/seq.rs
<a id="crates-oap-src-seq-rs"></a>

```rust
//! RO:WHAT — Simple, allocator-free sequence/correlation id generator.
//! RO:WHY  — Provide monotonic ids for `corr_id` without globals/unsafe.
//! RO:INTERACTS — Used by clients/servers to stamp `Header::corr_id`.
//! RO:INVARIANTS — Monotonic per-instance; seed adds time entropy to avoid collisions.

use std::sync::atomic::{AtomicU64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};

/// Monotonic sequence generator (per-instance).
#[derive(Debug)]
pub struct Seq {
    counter: AtomicU64,
}

impl Default for Seq {
    fn default() -> Self {
        // Seed with current nanos (truncated) to diversify instances.
        let seed = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| (d.as_nanos() as u64) ^ 0xA5A5_5A5A_D3C3_3C3D)
            .unwrap_or(0xD00D_F00D_C0FF_EE00);
        Self {
            counter: AtomicU64::new(seed),
        }
    }
}

impl Seq {
    pub fn new() -> Self {
        Self::default()
    }

    /// Fetch-next correlation id.
    #[inline]
    pub fn next(&self) -> u64 {
        self.counter.fetch_add(1, Ordering::Relaxed).wrapping_add(1)
    }
}

```

### crates/oap/src/writer/config.rs
<a id="crates-oap-src-writer-config-rs"></a>

```rust
//! RO:WHAT — Writer configuration.
//! RO:WHY  — Centralize tunables for buffered writes.
//! RO:INTERACTS — Used by `OapWriter`.
//! RO:INVARIANTS — Defaults tuned to typical MTU/page sizes.

use crate::constants::STREAM_CHUNK_SIZE;

/// Writer configuration.
#[derive(Clone, Copy, Debug)]
pub struct WriterConfig {
    /// When internal buffer reaches this size, `write_frame` will flush it automatically.
    pub flush_hint_bytes: usize,
}

impl Default for WriterConfig {
    fn default() -> Self {
        // Use the 64 KiB stream chunk as a reasonable flush hint.
        Self {
            flush_hint_bytes: STREAM_CHUNK_SIZE,
        }
    }
}

```

### crates/oap/src/writer/mod.rs
<a id="crates-oap-src-writer-mod-rs"></a>

```rust
//! RO:WHAT — Buffered OAP frame writer for async sinks.
//! RO:WHY  — Provide a simple way to encode frames and flush to `AsyncWrite`.
//! RO:INTERACTS — `OapEncoder`; tokio `AsyncWrite`.
//! RO:INVARIANTS — No locks across `.await`; zero `unsafe`.

pub mod config;

use bytes::BytesMut;
use tokio::io::{AsyncWrite, AsyncWriteExt};
use tokio_util::codec::Encoder; // bring `encode` into scope

use crate::{codec::OapEncoder, Frame};
pub use config::WriterConfig;

/// Buffered OAP writer: encodes frames into an internal buffer,
/// then writes/flushes to an `AsyncWrite`.
#[derive(Debug)]
pub struct OapWriter {
    enc: OapEncoder,
    buf: BytesMut,
    cfg: WriterConfig,
}

impl OapWriter {
    pub fn new(cfg: WriterConfig) -> Self {
        Self {
            enc: OapEncoder,
            buf: BytesMut::new(),
            cfg,
        }
    }

    pub fn with_default() -> Self {
        Self::new(WriterConfig::default())
    }

    /// Encode a frame into the internal buffer (does not perform I/O).
    pub fn encode_to_buf(&mut self, frame: Frame) -> Result<(), crate::OapEncodeError> {
        self.enc.encode(frame, &mut self.buf)
    }

    /// Take the internal buffer as bytes (leaves buffer empty).
    pub fn take_buf(&mut self) -> bytes::Bytes {
        std::mem::take(&mut self.buf).freeze()
    }

    /// Encode and write a frame to an async sink, flushing if buffer exceeds `flush_hint_bytes`.
    pub async fn write_frame<S: AsyncWrite + Unpin>(
        &mut self,
        sink: &mut S,
        frame: Frame,
    ) -> Result<(), crate::OapError> {
        // Encoding errors -> OapEncodeError -> OapError (From impl)
        self.enc.encode(frame, &mut self.buf)?;

        if self.buf.len() >= self.cfg.flush_hint_bytes {
            // I/O errors -> std::io::Error -> OapError (From impl)
            sink.write_all(&self.buf).await?;
            self.buf.clear();
            sink.flush().await?;
        }
        Ok(())
    }

    /// Force-flush any buffered bytes to the sink.
    pub async fn flush<S: AsyncWrite + Unpin>(
        &mut self,
        sink: &mut S,
    ) -> Result<(), crate::OapError> {
        if !self.buf.is_empty() {
            sink.write_all(&self.buf).await?;
            self.buf.clear();
        }
        sink.flush().await?;
        Ok(())
    }
}

```

### crates/oap/tests/ack_algebra.rs
<a id="crates-oap-tests-ackalgebra-rs"></a>

```rust
//! Exercises ACK/END/EVENT helpers from `envelope`.

use bytes::Bytes;
use oap::{prelude::*, Flags};

#[test]
fn ack_end_event_algebra() {
    // EVENT without ACK → fire-and-forget
    let _ = FrameBuilder::request(1, 0xAB, 1)
        .payload(Bytes::from_static(b"evt"))
        .build();
    let flags = Flags::EVENT;
    assert!(is_fire_and_forget(flags));
    assert!(!wants_ack(flags));
    assert!(!is_terminal(flags));

    // REQUEST with ACK
    let f = FrameBuilder::request(1, 0xAB, 2)
        .payload(Bytes::from_static(b"req"))
        .want_ack()
        .build();
    let flags = f.header.flags | Flags::ACK_REQ;
    assert!(wants_ack(flags));
    assert!(!is_fire_and_forget(flags));

    // RESPONSE terminal
    let f = FrameBuilder::response(1, 0xAB, 3, StatusCode::Ok)
        .payload(Bytes::from_static(b"ok"))
        .end()
        .build();
    let flags = f.header.flags;
    assert!(is_terminal(flags));
}

```

### crates/oap/tests/config_validation.rs
<a id="crates-oap-tests-configvalidation-rs"></a>

```rust
//! Parser config soft-cap behavior and minimal builder sanity.

use bytes::Bytes;
use oap::{parser::ParserConfig, parser::ParserState, prelude::*};

#[test]
fn parser_soft_cap_trips() {
    // Tiny soft cap to trigger error on push.
    let mut p = ParserState::new(ParserConfig {
        max_buffer_bytes: Some(8),
    });
    // Push more than 8 bytes; we expect a decode error (soft-cap signal).
    let err = p.push(&[0u8; 16]).expect_err("should hit soft-cap");
    // We reuse PayloadOutOfBounds to signal backpressure.
    match err {
        oap::OapDecodeError::PayloadOutOfBounds => {}
        e => panic!("unexpected error: {e:?}"),
    }
}

#[test]
fn builder_minimal() {
    // Basic request/response builders compile and set flags.
    let r = FrameBuilder::request(7, 0xCAFE, 1)
        .payload(Bytes::from_static(b"ping"))
        .build();
    assert!(r.header.flags.contains(Flags::REQ));

    let s = FrameBuilder::response(7, 0xCAFE, 1, StatusCode::Ok)
        .payload(Bytes::from_static(b"pong"))
        .build();
    assert!(s.header.flags.contains(Flags::RESP));
}

```

### crates/oap/tests/conformance.rs
<a id="crates-oap-tests-conformance-rs"></a>

```rust
//! Conformance checks against protocol invariants (header size, START+cap rules).

use bytes::BytesMut;
use oap::{flags::Flags, prelude::*};
use tokio_util::codec::Decoder as _;

#[test]
fn header_size_constant() {
    // Defensive: if the header layout ever changes, this test will flag it.
    assert_eq!(Header::WIRE_SIZE, 4 + 2 + 2 + 2 + 2 + 16 + 2 + 8);
}

#[test]
fn cap_requires_start_flag() {
    // Craft a frame with cap_len>0 but without START flag → decoder must reject.
    let hdr = Header {
        len: (Header::WIRE_SIZE + 3) as u32,
        ver: OAP_VERSION,
        flags: Flags::REQ, // no START
        code: 0,
        app_proto_id: 123,
        tenant_id: 0xABCD,
        cap_len: 3,
        corr_id: 99,
    };
    let mut buf = BytesMut::new();
    // Put header, then 3 bytes of "cap".
    hdr.put_to(&mut buf);
    buf.extend_from_slice(b"cap");

    let mut dec = OapDecoder::default();
    let err = dec.decode(&mut buf).expect_err("should fail without START");
    match err {
        oap::OapDecodeError::CapOnNonStart => {}
        e => panic!("unexpected error: {e:?}"),
    }
}

```

### crates/oap/tests/envelope_builder.rs
<a id="crates-oap-tests-envelopebuilder-rs"></a>

```rust
use bytes::Bytes;
use oap::{prelude::*, Flags, StatusCode};

#[test]
fn builder_sets_flags_and_fields() {
    let f = FrameBuilder::request(9, 0xDEAD, 777)
        .start_with_cap(Bytes::from_static(b"macaroon"))
        .payload(Bytes::from_static(b"body"))
        .want_ack()
        .end()
        .build();

    let flags = f.header.flags;
    assert!(flags.contains(Flags::REQ));
    assert!(flags.contains(Flags::START));
    assert!(flags.contains(Flags::ACK_REQ));
    assert!(flags.contains(Flags::END));

    // Response builder sanity.
    let r = FrameBuilder::response(9, 0xDEAD, 777, StatusCode::Ok)
        .payload(Bytes::from_static(b"ok"))
        .build();
    assert!(r.header.flags.contains(Flags::RESP));
    assert_eq!(r.header.code, StatusCode::Ok as u16);
}

```

### crates/oap/tests/metrics_labels.rs
<a id="crates-oap-tests-metricslabels-rs"></a>

```rust
use oap::{metrics::*, StatusCode};

#[test]
fn reason_and_classification() {
    assert_eq!(reason(StatusCode::Ok), "OK");
    assert!(is_success(StatusCode::Ok));
    assert!(is_client_err(StatusCode::BadRequest));
    assert!(is_server_err(StatusCode::Internal));

    assert_eq!(outcome_from_status(StatusCode::Ok), OutcomeClass::Success);
    assert_eq!(
        labels_for_outcome(OutcomeClass::Oversize),
        ("oap", "oversize", "413")
    );
}

```

### crates/oap/tests/metrics_mapping.rs
<a id="crates-oap-tests-metricsmapping-rs"></a>

```rust
//! Outcome classification & labels; decode-error mapping.

use oap::{metrics::*, OapDecodeError, StatusCode};

#[test]
fn status_outcomes_and_labels() {
    assert_eq!(outcome_from_status(StatusCode::Ok), OutcomeClass::Success);
    assert_eq!(
        outcome_from_status(StatusCode::BadRequest),
        OutcomeClass::ClientError
    );
    assert_eq!(
        outcome_from_status(StatusCode::Internal),
        OutcomeClass::ServerError
    );

    assert_eq!(
        labels_for_outcome(OutcomeClass::Success),
        ("oap", "ok", "2xx")
    );
    assert_eq!(
        labels_for_outcome(OutcomeClass::Oversize),
        ("oap", "oversize", "413")
    );
}

#[test]
fn decode_error_to_outcome() {
    let e = OapDecodeError::FrameTooLarge {
        len: 2_000_000,
        max: 1_048_576,
    };
    assert_eq!(outcome_from_decode(&e), OutcomeClass::Oversize);

    let e = OapDecodeError::BadFlags(0xFFFF);
    assert_eq!(outcome_from_decode(&e), OutcomeClass::DecodeError);
}

```

### crates/oap/tests/parser_partial_read.rs
<a id="crates-oap-tests-parserpartialread-rs"></a>

```rust
use bytes::Bytes;
use oap::{codec::OapEncoder, parser::ParserConfig, parser::ParserState, prelude::*};
use tokio_util::codec::Encoder as _;

fn normalize(mut f: Frame) -> Frame {
    let cap_len = f.cap.as_ref().map(|b| b.len()).unwrap_or(0);
    let payload_len = f.payload.as_ref().map(|b| b.len()).unwrap_or(0);
    f.header.cap_len = cap_len as u16;
    f.header.len = (Header::WIRE_SIZE + cap_len + payload_len) as u32;
    f
}

#[test]
fn parses_frames_across_chunks() {
    // Build two frames and encode into one buffer.
    let f1 = FrameBuilder::request(7, 0xA, 1)
        .payload(Bytes::from_static(b"hello"))
        .end()
        .build();
    let f2 = FrameBuilder::response(7, 0xA, 1, StatusCode::Ok)
        .payload(Bytes::from_static(b"world"))
        .build();

    let mut enc = OapEncoder::default();
    let mut buf = bytes::BytesMut::new();
    enc.encode(f1.clone(), &mut buf).unwrap();
    enc.encode(f2.clone(), &mut buf).unwrap();
    let bytes = buf.freeze();

    // Feed in small chunks to the parser.
    let mut p = ParserState::new(ParserConfig::default());
    for chunk in bytes.chunks(3) {
        p.push(chunk).unwrap();
    }

    let frames = p.drain().unwrap();
    assert_eq!(frames.len(), 2);
    assert_eq!(frames[0], normalize(f1));
    assert_eq!(frames[1], normalize(f2));
}

```

### crates/oap/tests/seq_monotonic.rs
<a id="crates-oap-tests-seqmonotonic-rs"></a>

```rust
use oap::Seq;
use std::collections::HashSet;

#[test]
fn seq_is_monotonic_and_unique_across_sample() {
    let s = Seq::new();
    let mut seen = HashSet::new();
    let n = 10_000;
    for _ in 0..n {
        let id = s.next();
        assert!(seen.insert(id), "duplicate id detected");
    }
}

```

### crates/oap/tests/split_need_more.rs
<a id="crates-oap-tests-splitneedmore-rs"></a>

```rust
//! Ensure decoder returns `None` until a full frame is buffered.

use bytes::{Bytes, BytesMut};
use oap::{codec::OapEncoder, prelude::*};
use tokio_util::codec::{Decoder as _, Encoder as _};

fn encode_frame(f: Frame) -> bytes::Bytes {
    let mut enc = OapEncoder::default();
    let mut buf = BytesMut::new();
    enc.encode(f, &mut buf).unwrap();
    buf.freeze()
}

#[test]
fn need_more_before_full_header() {
    let f = FrameBuilder::request(7, 0xAA, 1)
        .payload(Bytes::from_static(b"hello"))
        .build();
    let bytes = encode_frame(f);

    let mut dec = OapDecoder::default();
    let mut buf = BytesMut::new();

    // Feed fewer than the header size — decode must return None.
    buf.extend_from_slice(&bytes[..Header::WIRE_SIZE - 1]);
    assert!(dec.decode(&mut buf).unwrap().is_none());

    // Feed rest — now a frame should be produced.
    buf.extend_from_slice(&bytes[Header::WIRE_SIZE - 1..]);
    let out = dec.decode(&mut buf).unwrap();
    assert!(out.is_some());
}

```

### crates/oap/tests/vectors.rs
<a id="crates-oap-tests-vectors-rs"></a>

```rust
//! RO:WHAT — Golden test vectors for OAP/1: HELLO, START+cap, DATA (with/without COMP).
//! RO:WHY — Guard interop stability; ensure encoder/decoder symmetry and bounds.
//! RO:INVARIANTS — 1MiB bound enforced; START carries cap; COMP requires feature=zstd to decode.

use bytes::{Bytes, BytesMut};
use oap::{
    Flags, Frame, Header, Hello, HelloReply, OapDecoder, OapEncoder, MAX_FRAME_BYTES, OAP_VERSION,
};
// Bring trait methods (encode/decode) into scope:
use tokio_util::codec::{Decoder, Encoder};

/// Compute the canonical on-wire header fields (`len`, `cap_len`) and
/// return a copy of `frame` updated with those values so equality works.
fn normalize(mut frame: Frame) -> Frame {
    let cap_len = frame.cap.as_ref().map(|b| b.len()).unwrap_or(0);
    let payload_len = frame.payload.as_ref().map(|b| b.len()).unwrap_or(0);
    let total_len = Header::WIRE_SIZE + cap_len + payload_len;

    frame.header.cap_len = cap_len as u16;
    frame.header.len = total_len as u32;
    frame
}

fn roundtrip(frame: Frame) {
    let mut enc = OapEncoder::default();
    let mut buf = BytesMut::new();
    enc.encode(frame.clone(), &mut buf).expect("encode");
    let mut dec = OapDecoder::default();
    let out = dec.decode(&mut buf).expect("decode").expect("one frame");

    // Normalize the input to match encoder-corrected header fields.
    let expect = normalize(frame);
    assert_eq!(out, expect);
}

#[test]
fn hello_roundtrip() {
    let h = Hello {
        ua: Some("sdk/0.1".into()),
    };
    let f = h.to_frame(0xAA, 42);
    roundtrip(f);
}

#[test]
fn hello_reply_roundtrip() {
    let hr = HelloReply::default_for_server();
    let f = hr.to_frame(0xBB, 7);
    roundtrip(f);
}

#[test]
fn start_with_cap() {
    let cap = Bytes::from_static(b"macaroon:scope=read:ttl=60s");
    let hdr = Header {
        len: 0,
        ver: OAP_VERSION,
        flags: Flags::START | Flags::REQ,
        code: 0,
        app_proto_id: 100,
        tenant_id: 0xCC,
        cap_len: 0,
        corr_id: 99,
    };
    let frame = Frame {
        header: hdr,
        cap: Some(cap),
        payload: None,
    };
    roundtrip(frame);
}

#[test]
fn data_without_cap() {
    let payload = Bytes::from_static(b"hello world");
    let hdr = Header {
        len: 0,
        ver: OAP_VERSION,
        flags: Flags::RESP,
        code: 200,
        app_proto_id: 200,
        tenant_id: 0xDD,
        cap_len: 0,
        corr_id: 123,
    };
    let frame = Frame {
        header: hdr,
        cap: None,
        payload: Some(payload),
    };
    roundtrip(frame);
}

#[test]
fn rejects_oversize() {
    let payload = vec![0u8; (MAX_FRAME_BYTES as usize) + 1];
    let hdr = Header {
        len: 0,
        ver: OAP_VERSION,
        flags: Flags::RESP,
        code: 200,
        app_proto_id: 1,
        tenant_id: 1,
        cap_len: 0,
        corr_id: 1,
    };
    let mut enc = OapEncoder::default();
    let mut buf = BytesMut::new();
    let res = enc.encode(
        Frame {
            header: hdr,
            cap: None,
            payload: Some(Bytes::from(payload)),
        },
        &mut buf,
    );
    assert!(res.is_err());
}

#[cfg(feature = "zstd")]
#[test]
fn comp_bounded_inflate() {
    // Small payload compressed; ensure decode returns original.
    let raw = vec![42u8; 4096];
    let mut comp = Vec::new();
    {
        let mut enc = zstd::stream::write::Encoder::new(&mut comp, 1).unwrap();
        use std::io::Write;
        enc.write_all(&raw).unwrap();
        enc.finish().unwrap();
    }

    let hdr = Header {
        len: 0,
        ver: OAP_VERSION,
        flags: Flags::RESP | Flags::COMP,
        code: 200,
        app_proto_id: 2,
        tenant_id: 2,
        cap_len: 0,
        corr_id: 2,
    };
    let mut enc = OapEncoder::default();
    let mut buf = BytesMut::new();
    enc.encode(
        Frame {
            header: hdr,
            cap: None,
            payload: Some(Bytes::from(comp)),
        },
        &mut buf,
    )
    .unwrap();

    let mut dec = OapDecoder::default();
    let out = dec.decode(&mut buf).unwrap().unwrap();
    assert_eq!(out.payload.unwrap().len(), raw.len());
}

```

### crates/oap/tests/writer_roundtrip.rs
<a id="crates-oap-tests-writerroundtrip-rs"></a>

```rust
use bytes::Bytes;
use oap::{codec::OapDecoder, prelude::*, writer::OapWriter, writer::WriterConfig};
use tokio_util::codec::Decoder as _;

fn normalize(mut f: Frame) -> Frame {
    let cap_len = f.cap.as_ref().map(|b| b.len()).unwrap_or(0);
    let payload_len = f.payload.as_ref().map(|b| b.len()).unwrap_or(0);
    f.header.cap_len = cap_len as u16;
    f.header.len = (Header::WIRE_SIZE + cap_len + payload_len) as u32;
    f
}

#[test]
fn encode_to_buf_and_decode_back() {
    // Build a START frame with cap + payload.
    let f = FrameBuilder::request(42, 0xCAFE, 99)
        .start_with_cap(Bytes::from_static(b"scope=read"))
        .payload(Bytes::from_static(b"ping"))
        .want_ack()
        .build();

    // Encode using writer (buffered, no async I/O used).
    let mut w = OapWriter::new(WriterConfig::default());
    w.encode_to_buf(f.clone()).unwrap();
    let bytes = w.take_buf();

    // Decode back.
    let mut dec = OapDecoder::default();
    let mut buf: bytes::BytesMut = bytes.clone().into(); // <-- direct From<Bytes>
    let out = dec.decode(&mut buf).unwrap().unwrap();

    assert_eq!(out, normalize(f));
    assert!(buf.is_empty(), "buffer fully consumed");
}

```



---



# ron-transport

_Source: crates/ron-transport/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:42:21Z -->
# Code Bundle — `ron-transport`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-transport/.cargo/config.toml](#crates-ron-transport--cargo-config-toml)
- [crates/ron-transport/.github/workflows/ci.yml](#crates-ron-transport--github-workflows-ci-yml)
- [crates/ron-transport/.github/workflows/perf.yml](#crates-ron-transport--github-workflows-perf-yml)
- [crates/ron-transport/.github/workflows/tla.yml](#crates-ron-transport--github-workflows-tla-yml)
- [crates/ron-transport/Cargo.toml](#crates-ron-transport-Cargo-toml)
- [crates/ron-transport/benches/bench_latency.rs](#crates-ron-transport-benches-benchlatency-rs)
- [crates/ron-transport/benches/bench_throughput.rs](#crates-ron-transport-benches-benchthroughput-rs)
- [crates/ron-transport/examples/bench_echo.rs](#crates-ron-transport-examples-benchecho-rs)
- [crates/ron-transport/examples/http_echo.rs](#crates-ron-transport-examples-httpecho-rs)
- [crates/ron-transport/examples/onion_echo.rs](#crates-ron-transport-examples-onionecho-rs)
- [crates/ron-transport/examples/quic_echo.rs](#crates-ron-transport-examples-quicecho-rs)
- [crates/ron-transport/examples/tcp_echo.rs](#crates-ron-transport-examples-tcpecho-rs)
- [crates/ron-transport/examples/tls_echo.rs](#crates-ron-transport-examples-tlsecho-rs)
- [crates/ron-transport/examples/tls_transport.rs](#crates-ron-transport-examples-tlstransport-rs)
- [crates/ron-transport/fuzz/fuzz_targets/frame_boundaries.rs](#crates-ron-transport-fuzz-fuzztargets-frameboundaries-rs)
- [crates/ron-transport/scripts/ci/env_sanitize.sh](#crates-ron-transport-scripts-ci-envsanitize-sh)
- [crates/ron-transport/scripts/ci/run_tlc.sh](#crates-ron-transport-scripts-ci-runtlc-sh)
- [crates/ron-transport/scripts/local/echo_smoke.sh](#crates-ron-transport-scripts-local-echosmoke-sh)
- [crates/ron-transport/scripts/local/http_echo_smoke.sh](#crates-ron-transport-scripts-local-httpechosmoke-sh)
- [crates/ron-transport/scripts/local/mk_self_signed.sh](#crates-ron-transport-scripts-local-mkselfsigned-sh)
- [crates/ron-transport/scripts/local/perf_repro.sh](#crates-ron-transport-scripts-local-perfrepro-sh)
- [crates/ron-transport/scripts/local/smoke_tls.sh](#crates-ron-transport-scripts-local-smoketls-sh)
- [crates/ron-transport/scripts/local/smoke_transport.sh](#crates-ron-transport-scripts-local-smoketransport-sh)
- [crates/ron-transport/src/arti/client.rs](#crates-ron-transport-src-arti-client-rs)
- [crates/ron-transport/src/arti/mod.rs](#crates-ron-transport-src-arti-mod-rs)
- [crates/ron-transport/src/arti/readiness.rs](#crates-ron-transport-src-arti-readiness-rs)
- [crates/ron-transport/src/arti/service.rs](#crates-ron-transport-src-arti-service-rs)
- [crates/ron-transport/src/config.rs](#crates-ron-transport-src-config-rs)
- [crates/ron-transport/src/conn/backpressure.rs](#crates-ron-transport-src-conn-backpressure-rs)
- [crates/ron-transport/src/conn/mod.rs](#crates-ron-transport-src-conn-mod-rs)
- [crates/ron-transport/src/conn/rate_limit.rs](#crates-ron-transport-src-conn-ratelimit-rs)
- [crates/ron-transport/src/conn/reader.rs](#crates-ron-transport-src-conn-reader-rs)
- [crates/ron-transport/src/conn/writer.rs](#crates-ron-transport-src-conn-writer-rs)
- [crates/ron-transport/src/error.rs](#crates-ron-transport-src-error-rs)
- [crates/ron-transport/src/lib.rs](#crates-ron-transport-src-lib-rs)
- [crates/ron-transport/src/limits.rs](#crates-ron-transport-src-limits-rs)
- [crates/ron-transport/src/metrics.rs](#crates-ron-transport-src-metrics-rs)
- [crates/ron-transport/src/quic/client.rs](#crates-ron-transport-src-quic-client-rs)
- [crates/ron-transport/src/quic/mod.rs](#crates-ron-transport-src-quic-mod-rs)
- [crates/ron-transport/src/quic/server.rs](#crates-ron-transport-src-quic-server-rs)
- [crates/ron-transport/src/readiness.rs](#crates-ron-transport-src-readiness-rs)
- [crates/ron-transport/src/reason.rs](#crates-ron-transport-src-reason-rs)
- [crates/ron-transport/src/tcp/dialer.rs](#crates-ron-transport-src-tcp-dialer-rs)
- [crates/ron-transport/src/tcp/listener.rs](#crates-ron-transport-src-tcp-listener-rs)
- [crates/ron-transport/src/tcp/mod.rs](#crates-ron-transport-src-tcp-mod-rs)
- [crates/ron-transport/src/tls/client.rs](#crates-ron-transport-src-tls-client-rs)
- [crates/ron-transport/src/tls/mod.rs](#crates-ron-transport-src-tls-mod-rs)
- [crates/ron-transport/src/tls/server.rs](#crates-ron-transport-src-tls-server-rs)
- [crates/ron-transport/src/tls_types.rs](#crates-ron-transport-src-tlstypes-rs)
- [crates/ron-transport/src/types.rs](#crates-ron-transport-src-types-rs)
- [crates/ron-transport/src/util/bytes.rs](#crates-ron-transport-src-util-bytes-rs)
- [crates/ron-transport/src/util/cancel.rs](#crates-ron-transport-src-util-cancel-rs)
- [crates/ron-transport/src/util/mod.rs](#crates-ron-transport-src-util-mod-rs)
- [crates/ron-transport/src/util/timeouts.rs](#crates-ron-transport-src-util-timeouts-rs)
- [crates/ron-transport/tests/amnesia/no_disk_touches.rs](#crates-ron-transport-tests-amnesia-nodisktouches-rs)
- [crates/ron-transport/tests/integration/arti_bootstrap_ready.rs](#crates-ron-transport-tests-integration-artibootstrapready-rs)
- [crates/ron-transport/tests/integration/idle_timeout.rs](#crates-ron-transport-tests-integration-idletimeout-rs)
- [crates/ron-transport/tests/integration/mod.rs](#crates-ron-transport-tests-integration-mod-rs)
- [crates/ron-transport/tests/integration/over_capacity.rs](#crates-ron-transport-tests-integration-overcapacity-rs)
- [crates/ron-transport/tests/integration/quic_parity.rs](#crates-ron-transport-tests-integration-quicparity-rs)
- [crates/ron-transport/tests/integration/tls_accept.rs](#crates-ron-transport-tests-integration-tlsaccept-rs)
- [crates/ron-transport/tests/integration/tls_handshake_limits.rs](#crates-ron-transport-tests-integration-tlshandshakelimits-rs)
- [crates/ron-transport/tests/intergration.rs](#crates-ron-transport-tests-intergration-rs)
- [crates/ron-transport/tests/loom/single_writer.rs](#crates-ron-transport-tests-loom-singlewriter-rs)
- [crates/ron-transport/tests/soak/loopback_1MiB.rs](#crates-ron-transport-tests-soak-loopback1MiB-rs)
- [crates/ron-transport/tests/vectors/comp_bounds.json](#crates-ron-transport-tests-vectors-compbounds-json)
- [crates/ron-transport/tests/vectors/oap_hello.json](#crates-ron-transport-tests-vectors-oaphello-json)
- [crates/ron-transport/tests/vectors/pq_hybrid_hello.json](#crates-ron-transport-tests-vectors-pqhybridhello-json)
- [crates/ron-transport/tests/vectors/tor_parity.json](#crates-ron-transport-tests-vectors-torparity-json)

### crates/ron-transport/.cargo/config.toml
<a id="crates-ron-transport--cargo-config-toml"></a>

```toml
[build]
rustflags = ["-Cdebuginfo=1"]

[target.'cfg(unix)']
rustflags = ["-C", "link-arg=-Wl,-O1"]

[term]
verbose = true

```

### crates/ron-transport/.github/workflows/ci.yml
<a id="crates-ron-transport--github-workflows-ci-yml"></a>

```yaml
name: ron-transport2 CI
on:
  push:
  pull_request:
jobs:
  build-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        features: ["", "arti", "quic", "arti,quic"]
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Build
        run: cargo build -p ron-transport2 ${MATRIX:+--features ${{ matrix.features }}}
        env: { MATRIX: ${{ matrix.features }} }
      - name: Test
        run: cargo test -p ron-transport2 ${MATRIX:+--features ${{ matrix.features }}}
        env: { MATRIX: ${{ matrix.features }} }
      - name: Clippy (deny warnings)
        run: cargo clippy -p ron-transport2 ${MATRIX:+--features ${{ matrix.features }}} -- -D warnings
        env: { MATRIX: ${{ matrix.features }} }

```

### crates/ron-transport/.github/workflows/perf.yml
<a id="crates-ron-transport--github-workflows-perf-yml"></a>

```yaml
name: ron-transport2 Perf
on: { workflow_dispatch: {} }
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run benches (placeholder)
        run: cargo bench -p ron-transport2 || true
      - name: Archive Criterion artifacts
        uses: actions/upload-artifact@v4
        with:
          name: bench-artifacts
          path: target/criterion

```

### crates/ron-transport/.github/workflows/tla.yml
<a id="crates-ron-transport--github-workflows-tla-yml"></a>

```yaml
name: ron-transport2 TLA
on:
  push:
  pull_request:
jobs:
  tla:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run TLC (placeholder)
        run: bash crates/ron-transport2/scripts/ci/run_tlc.sh

```

### crates/ron-transport/Cargo.toml
<a id="crates-ron-transport-Cargo-toml"></a>

```toml
[package]
name = "ron-transport"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RustyOnions transport abstraction (TCP/TLS; Tor via arti feature; QUIC optional) for OAP/1 streams."
repository = "https://github.com/yourorg/RustyOnions"
readme = "README.md"

[lib]
name = "ron_transport"
path = "src/lib.rs"

[features]
default = ["tcp", "tls"]
tcp = []
tls = ["dep:tokio-rustls", "dep:rustls-pemfile"]
arti = []            # feature hook; code compiles without pulling arti deps yet
quic = []            # feature hook; add quinn later

[dependencies]
tokio = { version = "1.47.1", features = ["net", "rt-multi-thread", "sync", "time", "io-util", "macros"] }
bytes = "1.6"
futures = "0.3"
thiserror = "2"
anyhow = "1"
parking_lot = "0.12"
tracing = "0.1"
once_cell = "1.20"
rand = "0.9"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
prometheus = "0.14"
tokio-util = { version = "0.7", features = ["codec", "rt"] }  # rt => CancellationToken
pin-project-lite = "0.2"

# TLS (guarded)
tokio-rustls = { version = "0.26.2", optional = true }
rustls-pemfile = { version = "2.2", optional = true }

# Internal crates (kernel re-exports: Bus, HealthState, Metrics)
ron-kernel = { path = "../ron-kernel" }
ron-metrics = { path = "../ron-metrics" }

[dev-dependencies]
tokio = { version = "1.47.1", features = ["rt-multi-thread", "macros", "time", "io-util", "net"] }
criterion = "0.5"
tokio-rustls = { version = "0.26.2" }
rustls-pemfile = { version = "2.2" }

[package.metadata.docs.rs]
features = ["tcp", "tls"]

```

### crates/ron-transport/benches/bench_latency.rs
<a id="crates-ron-transport-benches-benchlatency-rs"></a>

```rust
#![allow(unused)]
fn main() {}
// Placeholder Criterion bench: connect→first-byte latency per backend.

```

### crates/ron-transport/benches/bench_throughput.rs
<a id="crates-ron-transport-benches-benchthroughput-rs"></a>

```rust
#![allow(unused)]
fn main() {}
// Placeholder Criterion bench: 1 MiB frames, ~64 KiB streaming.

```

### crates/ron-transport/examples/bench_echo.rs
<a id="crates-ron-transport-examples-benchecho-rs"></a>

```rust
//! RO:WHAT — Minimal loopback listener smoke.
//! RO:WHY  — Verify spawn_transport() binds and runs without TLS.
//! RO:INTERACTS — TransportConfig, TransportMetrics, HealthState, Bus<TransportEvent>.

use ron_kernel::{Bus, HealthState};
use ron_transport::{
    config::TransportConfig, metrics::TransportMetrics, spawn_transport, types::TransportEvent,
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cfg = TransportConfig::default();
    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());

    // Event bus: we won't consume events here, but the type is now TransportEvent.
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, None).await?;
    println!("ron-transport listening on {}", addr);

    tokio::signal::ctrl_c().await.ok();
    Ok(())
}

```

### crates/ron-transport/examples/http_echo.rs
<a id="crates-ron-transport-examples-httpecho-rs"></a>

```rust
//! Minimal HTTP-ish echo over raw TCP (not using the library).
//! Purpose: easy curl checks that show a visible response.

use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpListener,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let listener = TcpListener::bind(("127.0.0.1", 0)).await?;
    let addr = listener.local_addr()?;
    println!("http-echo listening on {}", addr);

    loop {
        let (mut sock, _peer) = listener.accept().await?;
        tokio::spawn(async move {
            let mut buf = vec![0u8; 16 * 1024];

            // Read once (simple demo) — enough for small requests.
            let n = match sock.read(&mut buf).await {
                Ok(0) => return,
                Ok(m) => m,
                Err(_) => return,
            };

            // Craft a simple 200 OK with echoed body.
            let body = &buf[..n];
            let header = format!(
                "HTTP/1.1 200 OK\r\nContent-Length: {}\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n",
                body.len()
            );

            if sock.write_all(header.as_bytes()).await.is_err() {
                return;
            }
            let _ = sock.write_all(body).await;
            let _ = sock.flush().await;
        });
    }
}

```

### crates/ron-transport/examples/onion_echo.rs
<a id="crates-ron-transport-examples-onionecho-rs"></a>

```rust
fn main() {
    println!("onion_echo (Arti) placeholder");
}

```

### crates/ron-transport/examples/quic_echo.rs
<a id="crates-ron-transport-examples-quicecho-rs"></a>

```rust
fn main() {
    println!("quic_echo placeholder");
}

```

### crates/ron-transport/examples/tcp_echo.rs
<a id="crates-ron-transport-examples-tcpecho-rs"></a>

```rust
//! Minimal TCP echo (for human-visible round-trips with curl/nc).
//! NOTE: This is a standalone echo using Tokio, not the library accept loop.
//! It’s just for smoke-testing with tools that expect a response.

use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpListener,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let listener = TcpListener::bind(("127.0.0.1", 0)).await?;
    let addr = listener.local_addr()?;
    println!("echo listening on {}", addr);

    loop {
        let (mut sock, _peer) = listener.accept().await?;
        tokio::spawn(async move {
            let mut buf = vec![0u8; 4096];
            loop {
                let n = match sock.read(&mut buf).await {
                    Ok(0) => return, // closed
                    Ok(n) => n,
                    Err(_) => return,
                };
                if sock.write_all(&buf[..n]).await.is_err() {
                    return;
                }
            }
        });
    }
}

```

### crates/ron-transport/examples/tls_echo.rs
<a id="crates-ron-transport-examples-tlsecho-rs"></a>

```rust
fn main() {
    println!("tls_echo placeholder");
}

```

### crates/ron-transport/examples/tls_transport.rs
<a id="crates-ron-transport-examples-tlstransport-rs"></a>

```rust
//! TLS listener using the ron-transport library.
//! Loads cert+key, builds rustls::ServerConfig, and passes it to spawn_transport.

#![cfg(feature = "tls")]

use ron_kernel::{Bus, HealthState};
use ron_transport::{
    config::TransportConfig,
    metrics::TransportMetrics,
    spawn_transport,
    types::TransportEvent,
    TlsServerConfig, // re-export
};
use std::{fs::File, io::BufReader, path::Path, sync::Arc};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cert_path = std::env::args()
        .nth(1)
        .unwrap_or_else(|| "crates/ron-transport/scripts/local/certs/cert.pem".into());
    let key_path = std::env::args()
        .nth(2)
        .unwrap_or_else(|| "crates/ron-transport/scripts/local/certs/key.pem".into());

    let tls_cfg = Arc::new(load_rustls_server(&cert_path, &key_path)?);

    let mut cfg = TransportConfig::default();
    cfg.name = "tls";
    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, Some(tls_cfg)).await?;
    println!("tls-transport listening on {}", addr);
    tokio::signal::ctrl_c().await.ok();
    Ok(())
}

#[cfg(feature = "tls")]
fn load_rustls_server(cert_path: &str, key_path: &str) -> anyhow::Result<TlsServerConfig> {
    use rustls_pemfile::{certs, pkcs8_private_keys, rsa_private_keys};
    use tokio_rustls::rustls::{
        pki_types::{CertificateDer, PrivateKeyDer, PrivatePkcs1KeyDer, PrivatePkcs8KeyDer},
        ServerConfig,
    };

    // Load cert chain
    let cert_file = File::open(Path::new(cert_path))?;
    let mut cert_rd = BufReader::new(cert_file);
    let certs: Vec<CertificateDer<'static>> = certs(&mut cert_rd).collect::<Result<_, _>>()?;

    // Load first available private key (PKCS#8 preferred, fall back to PKCS#1/RSA)
    let key: PrivateKeyDer<'static> = {
        // Try PKCS#8
        let key_file = File::open(Path::new(key_path))?;
        let mut key_rd = BufReader::new(key_file);
        let mut pkcs8: Vec<PrivateKeyDer<'static>> = pkcs8_private_keys(&mut key_rd)
            .map(|res: std::io::Result<PrivatePkcs8KeyDer<'static>>| res.map(Into::into))
            .collect::<Result<_, _>>()?;
        if let Some(k) = pkcs8.pop() {
            k
        } else {
            // Try PKCS#1 (RSA)
            let key_file = File::open(Path::new(key_path))?;
            let mut key_rd = BufReader::new(key_file);
            let mut rsa: Vec<PrivateKeyDer<'static>> = rsa_private_keys(&mut key_rd)
                .map(|res: std::io::Result<PrivatePkcs1KeyDer<'static>>| res.map(Into::into))
                .collect::<Result<_, _>>()?;
            rsa.pop()
                .ok_or_else(|| anyhow::anyhow!("no private key found in {}", key_path))?
        }
    };

    // rustls 0.22 API
    let cfg = ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)?;

    Ok(cfg)
}

```

### crates/ron-transport/fuzz/fuzz_targets/frame_boundaries.rs
<a id="crates-ron-transport-fuzz-fuzztargets-frameboundaries-rs"></a>

```rust
#![no_main]
// Placeholder fuzz target for frame boundaries.

```

### crates/ron-transport/scripts/ci/env_sanitize.sh
<a id="crates-ron-transport-scripts-ci-envsanitize-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — sanitize env for hermetic CI runs
set -euo pipefail
unset RUST_LOG || true
unset RUST_BACKTRACE || true

```

### crates/ron-transport/scripts/ci/run_tlc.sh
<a id="crates-ron-transport-scripts-ci-runtlc-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — placeholder TLA+ runner (specs compile later)
set -euo pipefail
echo "TLA+ specs not enabled yet for ron-transport MVP."

```

### crates/ron-transport/scripts/local/echo_smoke.sh
<a id="crates-ron-transport-scripts-local-echosmoke-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

LOG_FILE="$(mktemp -t ron_transport_echo.XXXXXX.log)"
RUST_LOG=info cargo run -q -p ron-transport --example tcp_echo >"$LOG_FILE" 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true; rm -f "$LOG_FILE"' EXIT

# Wait for "echo listening on ..."
for _ in {1..50}; do
  if grep -q "echo listening on" "$LOG_FILE"; then break; fi
  sleep 0.1
done

line="$(grep "echo listening on" "$LOG_FILE" | tail -n1)"
PORT="$(awk -F: '{print $NF}' <<<"$line" | tr -d '[:space:]')"
HOST="$(sed -E 's/.* on ([0-9\.]+):[0-9]+/\1/' <<<"$line")"

echo "[ OK ] echo server: ${HOST}:${PORT}"

# 1) curl round-trip allowing HTTP/0.9 (raw TCP echo)
if command -v curl >/dev/null 2>&1; then
  printf 'hello RON\n' | curl --http0.9 --no-progress-meter --data-binary @- "http://${HOST}:${PORT}/" || true
else
  echo "[WARN] curl not found; skipping curl test"
fi

# 2) nc round-trip
if command -v nc >/dev/null 2>&1; then
  printf 'hello RON\n' | nc -w 1 "${HOST}" "${PORT}" || true
else
  echo "[WARN] nc not found; skipping nc test"
fi

echo "[ OK ] probes done"

```

### crates/ron-transport/scripts/local/http_echo_smoke.sh
<a id="crates-ron-transport-scripts-local-httpechosmoke-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

LOG_FILE="$(mktemp -t ron_transport_http_echo.XXXXXX.log)"
RUST_LOG=info cargo run -q -p ron-transport --example http_echo >"$LOG_FILE" 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true; rm -f "$LOG_FILE"' EXIT

for _ in {1..50}; do
  if grep -q "http-echo listening on" "$LOG_FILE"; then break; fi
  sleep 0.1
done

line="$(grep "http-echo listening on" "$LOG_FILE" | tail -n1)"
PORT="$(awk -F: '{print $NF}' <<<"$line" | tr -d '[:space:]')"
HOST="$(sed -E 's/.* on ([0-9\.]+):[0-9]+/\1/' <<<"$line")"

echo "[ OK ] http-echo server: ${HOST}:${PORT}"
printf 'Hello via curl 🧪\n' | curl --no-progress-meter --data-binary @- "http://${HOST}:${PORT}/" || true
echo
echo "[ OK ] done"

```

### crates/ron-transport/scripts/local/mk_self_signed.sh
<a id="crates-ron-transport-scripts-local-mkselfsigned-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Generate a quick self-signed cert/key for local TLS smoke.
set -euo pipefail

DIR="${1:-crates/ron-transport/scripts/local/certs}"
mkdir -p "$DIR"

CERT="$DIR/cert.pem"
KEY="$DIR/key.pem"

# 365-day self-signed; CN=localhost
openssl req -x509 -newkey rsa:2048 -nodes -sha256 -days 365 \
  -subj "/CN=localhost" \
  -keyout "$KEY" -out "$CERT" >/dev/null 2>&1

echo "[ OK ] wrote $CERT and $KEY"

```

### crates/ron-transport/scripts/local/perf_repro.sh
<a id="crates-ron-transport-scripts-local-perfrepro-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — local loopback perf smoke (placeholder)
set -euo pipefail
RUST_LOG=${RUST_LOG:-info} cargo run -p ron-transport --example bench_echo || true

```

### crates/ron-transport/scripts/local/smoke_tls.sh
<a id="crates-ron-transport-scripts-local-smoketls-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Build (--features tls), start tls_transport, and probe with openssl.
set -euo pipefail

# Ensure certs exist
bash crates/ron-transport/scripts/local/mk_self_signed.sh >/dev/null

CERT="crates/ron-transport/scripts/local/certs/cert.pem"
KEY="crates/ron-transport/scripts/local/certs/key.pem"

# Build with TLS
cargo build -q -p ron-transport --features tls

# Run tls_transport example
LOG_FILE="$(mktemp -t ron_transport_tls.XXXXXX.log)"
RUST_LOG=info cargo run -q -p ron-transport --features tls --example tls_transport -- "$CERT" "$KEY" >"$LOG_FILE" 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true; rm -f "$LOG_FILE"' EXIT

# Wait for it to start
for _ in {1..50}; do
  if grep -q "tls-transport listening on" "$LOG_FILE"; then break; fi
  sleep 0.1
done

line="$(grep "tls-transport listening on" "$LOG_FILE" | tail -n1)"
PORT="$(awk -F: '{print $NF}' <<<"$line" | tr -d '[:space:]')"
HOST="$(sed -E 's/.* on ([0-9\.]+):[0-9]+/\1/' <<<"$line")"
echo "[ OK ] tls server: ${HOST}:${PORT}"

# Probe with openssl s_client (TLS 1.3), send a line, and exit.
# Expect no HTTP response — this proves handshake success.
printf 'hello over TLS\n' | openssl s_client -quiet -connect "${HOST}:${PORT}" -tls1_3 -servername localhost >/dev/null 2>&1 || true
echo "[ OK ] openssl s_client connected + wrote bytes (no response expected)"

```

### crates/ron-transport/scripts/local/smoke_transport.sh
<a id="crates-ron-transport-scripts-local-smoketransport-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT  — End-to-end smoke for ron-transport loopback (robust macOS/Linux).
# RO:NOTE  — Uses Python socket send first (non-blocking), falls back to nc with safe flags.

set -euo pipefail

HOST_DEFAULT="127.0.0.1"
HOST="${HOST:-$HOST_DEFAULT}"
PORT="${PORT:-}"
LOG_FILE="$(mktemp -t ron_transport_smoke.XXXXXX.log)"
SERVER_PID=""
CLEANUP_DONE=0

cleanup() {
  if [[ $CLEANUP_DONE -eq 1 ]]; then return; fi
  CLEANUP_DONE=1
  if [[ -n "${SERVER_PID}" ]]; then
    kill "${SERVER_PID}" >/dev/null 2>&1 || true
    wait "${SERVER_PID}" >/dev/null 2>&1 || true
  fi
  rm -f "$LOG_FILE" || true
}
trap cleanup EXIT INT TERM

info()  { printf "[INFO] %s\n" "$*"; }
ok()    { printf "[ OK ] %s\n" "$*"; }
warn()  { printf "[WARN] %s\n" "$*"; }
fail()  { printf "[FAIL] %s\n" "$*"; }

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || { fail "missing '$1' in PATH"; exit 1; }
}

spawn_server_if_needed() {
  if [[ -n "${PORT}" ]]; then
    info "Using provided PORT=${PORT}, HOST=${HOST}; will not spawn server."
    return
  fi

  info "Starting bench_echo to auto-discover port (HOST=${HOST})…"
  RUST_LOG=info cargo run -q -p ron-transport --example bench_echo >"$LOG_FILE" 2>&1 &
  SERVER_PID=$!

  # Wait until it prints the listening line (timeout ~5s).
  for _ in {1..50}; do
    if grep -q "ron-transport listening on" "$LOG_FILE"; then
      break
    fi
    sleep 0.1
  done
  if ! grep -q "ron-transport listening on" "$LOG_FILE"; then
    warn "Could not detect listener line; recent log:"
    tail -n +1 "$LOG_FILE" || true
    fail "Server failed to start or log was not captured."
    exit 1
  fi

  local line
  line="$(grep "ron-transport listening on" "$LOG_FILE" | tail -n1)"
  PORT="$(awk -F: '{print $NF}' <<<"$line" | tr -d '[:space:]')"
  HOST="$(sed -E 's/.* on ([0-9\.]+):[0-9]+/\1/' <<<"$line")"
  ok "Server is up: ${HOST}:${PORT} (pid ${SERVER_PID})"
}

nc_support_flags() {
  # Detect safe close flag for this nc variant.
  local help; help="$( (nc -h 2>&1 || true) )"
  if grep -q -- " -N" <<<"$help"; then
    echo "-N"           # OpenBSD/macOS: close on stdin EOF
  elif grep -q -- " -q " <<<"$help"; then
    echo "-q 1"         # GNU netcat: quit 1s after EOF on stdin
  else
    echo ""             # Unknown; we’ll guard with timeout anyway
  fi
}

run_probes() {
  # 1) Quick TCP connect check with nc -vz (non-blocking)
  info "Probing with nc (TCP connect)…"
  if command -v nc >/dev/null 2>&1; then
    if nc -vz -w 2 "${HOST}" "${PORT}" >/dev/null 2>&1; then
      ok "nc connect succeeded"
    else
      warn "nc connect failed (continuing)"
    fi
  else
    warn "nc not found; skipping"
  fi

  # 2) Send bytes via Python socket (preferred, never hangs)
  info "Python one-liner send…"
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<PY || warn "python send failed (continuing)"
import socket
s=socket.create_connection(("${HOST}", int("${PORT}")), 2)
s.sendall(b"hello\\n")
s.close()
PY
    ok "python send completed"
  else
    warn "python3 not found; skipping python send"
  fi

  # 3) Optional: nc one-shot send with safe close (guarded)
  if command -v nc >/dev/null 2>&1; then
    local CLOSE_FLAGS; CLOSE_FLAGS="$(nc_support_flags)"
    info "Sending bytes via nc (one-shot, flags: ${CLOSE_FLAGS:-none})…"
    # Run nc in the background with a hard kill after 3s as a final guard.
    ( printf 'hello ron-transport\n' | nc ${CLOSE_FLAGS} -w 2 "${HOST}" "${PORT}" ) >/dev/null 2>&1 & 
    local nc_pid=$!
    # Hard timeout guard:
    ( sleep 3; kill "$nc_pid" >/dev/null 2>&1 || true ) &
    wait "$nc_pid" >/dev/null 2>&1 || true
    ok "sent bytes with nc (no response expected)"
  fi

  # 4) curl proof (expect timeout; add connect-timeout)
  info "curl smoke (expect timeout, proves non-HTTP raw TCP)…"
  if command -v curl >/dev/null 2>&1; then
    if echo -n 'hello' | curl --no-progress-meter --data-binary @- \
         --connect-timeout 1 --max-time 2 "http://${HOST}:${PORT}/" >/dev/null; then
      warn "curl returned success (unexpected for raw TCP), continuing"
    else
      ok "curl timed out as expected (raw TCP, no HTTP)"
    fi
  else
    warn "curl not found; skipping"
  fi

  info "All probes done."
}

main() {
  require_cmd cargo
  spawn_server_if_needed
  run_probes
}

main

```

### crates/ron-transport/src/arti/client.rs
<a id="crates-ron-transport-src-arti-client-rs"></a>

```rust
//! Arti outbound (placeholder).
pub struct ArtiClient;

```

### crates/ron-transport/src/arti/mod.rs
<a id="crates-ron-transport-src-arti-mod-rs"></a>

```rust
pub mod client;
pub mod readiness;
pub mod service;

```

### crates/ron-transport/src/arti/readiness.rs
<a id="crates-ron-transport-src-arti-readiness-rs"></a>

```rust
//! Arti readiness glue (placeholder).
pub struct ArtiReadiness;

```

### crates/ron-transport/src/arti/service.rs
<a id="crates-ron-transport-src-arti-service-rs"></a>

```rust
//! Arti onion service (placeholder).
pub struct ArtiService;

```

### crates/ron-transport/src/config.rs
<a id="crates-ron-transport-src-config-rs"></a>

```rust
//! RO:WHAT — Transport configuration (bind, ceilings, timeouts).
//! RO:WHY  — Hard caps & deadlines enforce SEC/RES.
//! RO:INTERACTS — limits, tcp::listener/dialer, tls::{server,client}.
//! RO:INVARIANTS — immutable at runtime; values bounded; amnesia-safe.
//! RO:CONFIG — From env or files (upstream); this struct is runtime snapshot.

use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
use std::time::Duration;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TransportConfig {
    /// Bind address for the listener (e.g., "127.0.0.1:9400").
    pub addr: SocketAddr,
    /// Human-readable transport name (for metrics labels).
    pub name: &'static str,
    /// Maximum concurrent connections allowed.
    pub max_conns: usize,
    /// Read timeout per I/O op.
    pub read_timeout: Duration,
    /// Write timeout per I/O op.
    pub write_timeout: Duration,
    /// Idle timeout (no traffic).
    pub idle_timeout: Duration,
}

impl Default for TransportConfig {
    fn default() -> Self {
        Self {
            addr: "127.0.0.1:0".parse().unwrap(),
            name: "tcp",
            max_conns: 1024,
            read_timeout: Duration::from_secs(5),
            write_timeout: Duration::from_secs(5),
            idle_timeout: Duration::from_secs(15),
        }
    }
}

```

### crates/ron-transport/src/conn/backpressure.rs
<a id="crates-ron-transport-src-conn-backpressure-rs"></a>

```rust
//! RO:WHAT — Simple per-conn inflight limiter (MVP).
use crate::limits::MAX_INFLIGHT_FRAMES;
use std::sync::atomic::{AtomicUsize, Ordering};

#[derive(Default)]
pub struct Inflight {
    n: AtomicUsize,
}
impl Inflight {
    pub fn new() -> Self {
        Self {
            n: AtomicUsize::new(0),
        }
    }
    pub fn try_inc(&self) -> bool {
        let cur = self.n.load(Ordering::Relaxed);
        if cur >= MAX_INFLIGHT_FRAMES {
            return false;
        }
        self.n.fetch_add(1, Ordering::Relaxed);
        true
    }
    pub fn dec(&self) {
        self.n.fetch_sub(1, Ordering::Relaxed);
    }
}

```

### crates/ron-transport/src/conn/mod.rs
<a id="crates-ron-transport-src-conn-mod-rs"></a>

```rust
//! RO:WHAT — Connection primitives (backpressure, reader, writer, rate limits).
//! RO:INVARIANTS — single-writer discipline; bounded inflight.

pub mod backpressure;
pub mod rate_limit;
pub mod reader;
pub mod writer;

```

### crates/ron-transport/src/conn/rate_limit.rs
<a id="crates-ron-transport-src-conn-ratelimit-rs"></a>

```rust
//! RO:WHAT — Placeholder for per-conn rate limiting (tokens).
#[derive(Clone, Default)]
pub struct RateLimit;
impl RateLimit {
    pub fn allow(&self, _bytes: usize) -> bool {
        true
    }
}

```

### crates/ron-transport/src/conn/reader.rs
<a id="crates-ron-transport-src-conn-reader-rs"></a>

```rust
//! RO:WHAT — Per-connection reader task (frame-capped, timed).
//! RO:INVARIANTS — cap before alloc; owned bytes; cancel-safe; idle/read timeouts.
//! RO:DESIGN — Generic over any AsyncRead, so it supports TcpStream and TlsStream.

use bytes::BytesMut;
use tokio::io::{AsyncRead, AsyncReadExt};
use tokio::time::{timeout, Duration, Instant};

use crate::limits::MAX_FRAME_BYTES;

#[derive(Debug, Default, Clone)]
pub struct ReaderStats {
    pub bytes_in: u64,
}

pub async fn run<R>(
    mut rd: R,
    read_timeout: Duration,
    idle_timeout: Duration,
) -> std::io::Result<ReaderStats>
where
    R: AsyncRead + Unpin,
{
    let mut buf = BytesMut::with_capacity(8 * 1024);
    let mut stats = ReaderStats::default();
    let mut last = Instant::now();

    loop {
        // Per-op read timeout.
        let n = match timeout(read_timeout, rd.read_buf(&mut buf)).await {
            Ok(Ok(0)) => return Ok(stats), // peer closed
            Ok(Ok(n)) => n,
            Ok(Err(e)) => return Err(e),
            Err(_elapsed) => {
                // If we've been entirely idle longer than idle_timeout, close.
                if last.elapsed() > idle_timeout {
                    return Ok(stats);
                }
                continue; // allow another attempt until idle threshold trips
            }
        };

        last = Instant::now();
        stats.bytes_in += n as u64;

        if buf.len() > MAX_FRAME_BYTES {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "frame too large",
            ));
        }

        // MVP: drain; upper layers will parse OAP frames.
        if !buf.is_empty() {
            buf.clear();
        }
    }
}

```

### crates/ron-transport/src/conn/writer.rs
<a id="crates-ron-transport-src-conn-writer-rs"></a>

```rust
//! RO:WHAT — Per-connection single-writer task with backpressure.
//! RO:WHY  — Enforce single-writer discipline; count bytes_out; await I/O for backpressure.
//! RO:DESIGN — Generic over any AsyncWrite so it works for TcpStream and TlsStream.

use bytes::Bytes;
use tokio::{
    io::AsyncWrite,
    io::AsyncWriteExt,
    sync::mpsc::{self, error::SendError, Sender},
};

/// Handle to enqueue bytes for the connection's writer task.
#[derive(Clone)]
pub struct WriterHandle {
    tx: Sender<Bytes>,
}

impl WriterHandle {
    pub async fn send(&self, b: Bytes) -> Result<(), SendError<Bytes>> {
        self.tx.send(b).await
    }
}

/// Spawn a writer task for any AsyncWrite (TcpStream, TlsStream, ...).
/// Returns a handle for sending bytes and the writer task JoinHandle.
///
/// The writer task:
/// - writes each chunk fully (`write_all`)
/// - flushes periodically (on every message in MVP)
/// - increments `bytes_out` metrics
/// - exits cleanly when channel closes
pub fn spawn_writer<W>(
    mut w: W,
    name: &'static str,
    metrics: crate::metrics::TransportMetrics,
) -> (WriterHandle, tokio::task::JoinHandle<()>)
where
    W: AsyncWrite + Unpin + Send + 'static,
{
    // Bounded queue prevents unbounded memory under slow receivers.
    let (tx, mut rx) = mpsc::channel::<Bytes>(64);
    let jh = tokio::spawn(async move {
        while let Some(chunk) = rx.recv().await {
            if chunk.is_empty() {
                continue;
            }
            if let Err(e) = w.write_all(&chunk).await {
                tracing::debug!(error=%e, "writer: write_all failed");
                break;
            }
            // Count bytes_out
            metrics
                .bytes_out
                .with_label_values(&[name])
                .inc_by(chunk.len() as u64);

            // Flush to minimize tail latency (can batch/tune later).
            if let Err(e) = w.flush().await {
                tracing::debug!(error=%e, "writer: flush failed");
                break;
            }
        }

        // Attempt graceful shutdown for protocols that support it (e.g., TLS close_notify).
        let _ = w.shutdown().await;
    });

    (WriterHandle { tx }, jh)
}

```

### crates/ron-transport/src/error.rs
<a id="crates-ron-transport-src-error-rs"></a>

```rust
//! RO:WHAT — Error types for ron-transport.
//! RO:WHY  — Stable taxonomy for callers (deterministic).
//! RO:INTERACTS — reason::RejectReason.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum TransportError {
    #[error("bind error: {0}")]
    Bind(std::io::Error),
    #[error("accept loop failed: {0}")]
    Accept(std::io::Error),
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
    #[error("limit exceeded: {0}")]
    Limit(&'static str),
    #[error("timeout")]
    Timeout,
    #[error("tls error")]
    Tls,
    #[error("closed")]
    Closed,
}

```

### crates/ron-transport/src/lib.rs
<a id="crates-ron-transport-src-lib-rs"></a>

```rust
//! RO:WHAT — Public entry for ron-transport: config/types and spawn helpers.
//! RO:WHY  — Pillar 10 transport; Concerns: SEC/RES/PERF.
//! RO:INTERACTS — tcp::{listener,dialer}, tls::{server,client}, limits, metrics; kernel Bus/Health.
//! RO:INVARIANTS — single writer per conn; no locks across .await; OAP max_frame=1MiB; chunk≈64KiB.

#![forbid(unsafe_code)]

#[cfg(feature = "arti")]
pub mod arti;
pub mod config;
pub mod conn;
pub mod error;
pub mod limits;
pub mod metrics;
#[cfg(feature = "quic")]
pub mod quic;
pub mod readiness;
pub mod reason;
pub mod tcp;
#[cfg(feature = "tls")]
pub mod tls;
pub mod types;
pub mod util;

// Always-present TLS type alias wrapper (feature-safe).
mod tls_types;
pub use tls_types::TlsServerConfig;

use crate::config::TransportConfig;
use crate::metrics::TransportMetrics;
use crate::readiness::ReadyGate;
use crate::types::TransportEvent;
use crate::util::cancel::Cancel;
use ron_kernel::{Bus, HealthState};
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::task::JoinHandle;

/// Public handle for a running transport listener.
pub struct TransportHandle {
    /// The accept-loop task.
    pub task: JoinHandle<()>,
    /// The bound socket address.
    pub addr: SocketAddr,
    /// Cancellation token — request graceful shutdown.
    pub cancel: Cancel,
}

/// Spawn a TCP (optionally TLS) listener and per-connection tasks, returning a shutdown handle.
///
/// Backward-compatible, high-level entry.
pub async fn spawn_transport_with_cancel(
    cfg: TransportConfig,
    metrics: TransportMetrics,
    health: Arc<HealthState>,
    _bus: Bus<TransportEvent>, // reserved; will publish Connected/Disconnected when Bus API is confirmed
    tls: Option<Arc<TlsServerConfig>>,
) -> anyhow::Result<TransportHandle> {
    let gate = ReadyGate::new();
    let cancel = Cancel::new();
    let (task, addr) = tcp::listener::spawn_listener_with_cancel(
        cfg,
        metrics,
        health,
        gate.clone(),
        tls,
        cancel.clone(),
    )
    .await?;
    gate.set_listeners_bound(true);
    Ok(TransportHandle { task, addr, cancel })
}

/// Legacy wrapper that preserves the original return type.
/// Use `spawn_transport_with_cancel` if you want a shutdown handle.
pub async fn spawn_transport(
    cfg: TransportConfig,
    metrics: TransportMetrics,
    health: Arc<HealthState>,
    bus: Bus<TransportEvent>,
    tls: Option<Arc<TlsServerConfig>>,
) -> anyhow::Result<(JoinHandle<()>, SocketAddr)> {
    let handle = spawn_transport_with_cancel(cfg, metrics, health, bus, tls).await?;
    Ok((handle.task, handle.addr))
}

```

### crates/ron-transport/src/limits.rs
<a id="crates-ron-transport-src-limits-rs"></a>

```rust
//! RO:WHAT — Hard transport limits aligned to OAP/1 & Hardening v2.
//! RO:WHY  — Prevent DoS/compression bombs; deterministic errors.
//! RO:INTERACTS — conn::{reader,writer}, reason::RejectReason.

/// OAP/1 protocol frame max (bytes).
pub const MAX_FRAME_BYTES: usize = 1 * 1024 * 1024; // 1 MiB

/// Typical streaming chunk size (~storage path guidance).
pub const STREAM_CHUNK_BYTES: usize = 64 * 1024; // 64 KiB

/// Maximum decompressed size multiplier (defense-in-depth).
pub const MAX_DECOMP_RATIO: u32 = 10;

/// Inflight per-connection frame bound (defensive default).
pub const MAX_INFLIGHT_FRAMES: usize = 64;

```

### crates/ron-transport/src/metrics.rs
<a id="crates-ron-transport-src-metrics-rs"></a>

```rust
//! RO:WHAT — Prometheus counters/histograms for transport.
//! RO:WHY  — Golden metrics surface; avoid duplicate registers.

use prometheus::{HistogramOpts, HistogramVec, IntCounterVec, Opts, Registry};

#[derive(Clone)]
pub struct TransportMetrics {
    pub registry: Registry,
    pub connections: IntCounterVec,
    pub bytes_in: IntCounterVec,
    pub bytes_out: IntCounterVec,
    pub rejected_total: IntCounterVec,
    pub latency_seconds: HistogramVec,
}

impl TransportMetrics {
    pub fn new(namespace: &str) -> Self {
        let registry = Registry::new();
        let connections = IntCounterVec::new(
            Opts::new("transport_connections_total", "Accepted connections").namespace(namespace),
            &["name"],
        )
        .unwrap();
        let bytes_in = IntCounterVec::new(
            Opts::new("transport_bytes_in_total", "Bytes received").namespace(namespace),
            &["name"],
        )
        .unwrap();
        let bytes_out = IntCounterVec::new(
            Opts::new("transport_bytes_out_total", "Bytes sent").namespace(namespace),
            &["name"],
        )
        .unwrap();
        let rejected_total = IntCounterVec::new(
            Opts::new("transport_rejected_total", "Rejected connections/frames")
                .namespace(namespace),
            &["name", "reason"],
        )
        .unwrap();
        let latency_seconds = HistogramVec::new(
            HistogramOpts::new("transport_latency_seconds", "End-to-end per-conn lifetime")
                .namespace(namespace),
            &["name"],
        )
        .unwrap();

        registry.register(Box::new(connections.clone())).ok();
        registry.register(Box::new(bytes_in.clone())).ok();
        registry.register(Box::new(bytes_out.clone())).ok();
        registry.register(Box::new(rejected_total.clone())).ok();
        registry.register(Box::new(latency_seconds.clone())).ok();

        Self {
            registry,
            connections,
            bytes_in,
            bytes_out,
            rejected_total,
            latency_seconds,
        }
    }
}

```

### crates/ron-transport/src/quic/client.rs
<a id="crates-ron-transport-src-quic-client-rs"></a>

```rust
//! QUIC client (placeholder).
pub struct QuicClient;

```

### crates/ron-transport/src/quic/mod.rs
<a id="crates-ron-transport-src-quic-mod-rs"></a>

```rust
pub mod client;
pub mod server;

```

### crates/ron-transport/src/quic/server.rs
<a id="crates-ron-transport-src-quic-server-rs"></a>

```rust
//! QUIC server (placeholder).
pub struct QuicServer;

```

### crates/ron-transport/src/readiness.rs
<a id="crates-ron-transport-src-readiness-rs"></a>

```rust
//! RO:WHAT — Minimal readiness gate for listeners.
//! RO:WHY  — Truthful /readyz for services consuming transport.

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

#[derive(Clone)]
pub struct ReadyGate {
    listeners_bound: Arc<AtomicBool>,
}

impl ReadyGate {
    pub fn new() -> Self {
        Self {
            listeners_bound: Arc::new(AtomicBool::new(false)),
        }
    }
    pub fn set_listeners_bound(&self, v: bool) {
        self.listeners_bound.store(v, Ordering::SeqCst);
    }
    pub fn listeners_bound(&self) -> bool {
        self.listeners_bound.load(Ordering::SeqCst)
    }
}

```

### crates/ron-transport/src/reason.rs
<a id="crates-ron-transport-src-reason-rs"></a>

```rust
//! RO:WHAT — Canonical reject reasons (metrics label-safe).
//! RO:WHY  — Consistent observability & tests.

#[derive(Debug, Clone, Copy)]
pub enum RejectReason {
    OverCapacity,
    BadFrame,
    TooLarge,
    Timeout,
    Io,
    Tls,
}

impl RejectReason {
    pub fn as_str(self) -> &'static str {
        match self {
            Self::OverCapacity => "over_capacity",
            Self::BadFrame => "bad_frame",
            Self::TooLarge => "too_large",
            Self::Timeout => "timeout",
            Self::Io => "io",
            Self::Tls => "tls",
        }
    }
}

```

### crates/ron-transport/src/tcp/dialer.rs
<a id="crates-ron-transport-src-tcp-dialer-rs"></a>

```rust
//! RO:WHAT — TCP dialer (MVP).
use std::net::SocketAddr;
use tokio::net::TcpStream;

pub async fn dial(addr: SocketAddr) -> std::io::Result<TcpStream> {
    TcpStream::connect(addr).await
}

```

### crates/ron-transport/src/tcp/listener.rs
<a id="crates-ron-transport-src-tcp-listener-rs"></a>

```rust
//! RO:WHAT — TCP accept loop with optional TLS, limits, metrics, cancel.
//! RO:INVARIANTS — readiness flips when bound; single writer; deadlines enforced.

use crate::config::TransportConfig;
use crate::conn::reader::{self, ReaderStats};
use crate::conn::writer;
use crate::metrics::TransportMetrics;
use crate::readiness::ReadyGate;
use crate::reason::RejectReason;
use crate::util::cancel::Cancel;
use crate::TlsServerConfig;

use std::net::SocketAddr;
use std::sync::Arc;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::{OwnedSemaphorePermit, Semaphore};
use tokio::task::JoinHandle;
use tokio::time::{sleep, Duration, Instant};

/// Back-compat API (no shutdown handle). Internally creates a cancel token and drops it.
pub async fn spawn_listener(
    cfg: TransportConfig,
    metrics: TransportMetrics,
    health: Arc<ron_kernel::HealthState>,
    gate: ReadyGate,
    tls: Option<Arc<TlsServerConfig>>,
) -> anyhow::Result<(JoinHandle<()>, SocketAddr)> {
    let cancel = Cancel::new();
    spawn_listener_with_cancel(cfg, metrics, health, gate, tls, cancel).await
}

/// New API that takes a `Cancel` token so callers can trigger graceful shutdown.
pub async fn spawn_listener_with_cancel(
    cfg: TransportConfig,
    metrics: TransportMetrics,
    _health: Arc<ron_kernel::HealthState>,
    _gate: ReadyGate,
    tls: Option<Arc<TlsServerConfig>>,
    cancel: Cancel,
) -> anyhow::Result<(JoinHandle<()>, SocketAddr)> {
    let listener = TcpListener::bind(cfg.addr)
        .await
        .map_err(crate::error::TransportError::Bind)?;
    let addr = listener.local_addr().unwrap();
    let permits = Arc::new(Semaphore::new(cfg.max_conns));

    let jh = tokio::spawn(async move {
        tracing::info!(%addr, name=%cfg.name, "ron-transport listener bound");
        loop {
            tokio::select! {
                _ = cancel.cancelled() => {
                    tracing::info!(%addr, "listener shutdown requested");
                    break;
                }
                res = listener.accept() => {
                    match res {
                        Ok((stream, peer)) => {
                            let cfgc = cfg.clone();
                            let m = metrics.clone();
                            let tls_cfg = tls.clone();

                            // Connection limit: clone Arc before try_acquire_owned (it consumes its Arc).
                            match permits.clone().try_acquire_owned() {
                                Ok(permit) => {
                                    m.connections.with_label_values(&[cfg.name]).inc();
                                    tokio::spawn(handle_conn(stream, peer, cfgc, m, permit, tls_cfg));
                                }
                                Err(_) => {
                                    m.rejected_total
                                        .with_label_values(&[cfg.name, RejectReason::OverCapacity.as_str()])
                                        .inc();
                                    drop(stream);
                                }
                            }
                        }
                        Err(e) => {
                            metrics
                                .rejected_total
                                .with_label_values(&[cfg.name, RejectReason::Io.as_str()])
                                .inc();
                            tracing::warn!(error=%e, "accept failed; backing off");
                            sleep(Duration::from_millis(100)).await;
                        }
                    }
                }
            }
        }
        tracing::info!(%addr, "listener exited");
    });

    Ok((jh, addr))
}

async fn handle_conn(
    stream: TcpStream,
    peer: SocketAddr,
    cfg: TransportConfig,
    metrics: TransportMetrics,
    _permit: OwnedSemaphorePermit, // holds a slot until this task ends
    tls: Option<Arc<TlsServerConfig>>,
) {
    tracing::debug!(%peer, "accepted");
    let started = Instant::now();

    let result = match maybe_tls(stream, tls).await {
        Ok(IoUpgraded::Plain(s)) => run_plain(s, &cfg, &metrics).await,
        #[cfg(feature = "tls")]
        Ok(IoUpgraded::Tls(s)) => run_tls(s, &cfg, &metrics).await,
        Err(e) => Err(e),
    };
    let elapsed = started.elapsed().as_secs_f64();

    match result {
        Ok(stats) => {
            metrics
                .bytes_in
                .with_label_values(&[cfg.name])
                .inc_by(stats.bytes_in as u64);
            metrics
                .latency_seconds
                .with_label_values(&[cfg.name])
                .observe(elapsed);
            tracing::debug!(%peer, bytes_in=%stats.bytes_in, dur=%elapsed, "closed ok");
        }
        Err(e) => {
            metrics
                .rejected_total
                .with_label_values(&[cfg.name, RejectReason::Io.as_str()])
                .inc();
            tracing::debug!(%peer, error=%e, "closed with error");
        }
    }
}

async fn run_plain(
    stream: TcpStream,
    cfg: &TransportConfig,
    metrics: &TransportMetrics,
) -> std::io::Result<ReaderStats> {
    use tokio::io::split;
    let (rd, wr) = split(stream);

    // Spawn writer (currently unused by upper layers; metrics ready).
    let (_wh, writer_task) = writer::spawn_writer(wr, cfg.name, metrics.clone());

    // Run reader until EOF/timeout/error.
    let stats = reader::run(rd, cfg.read_timeout, cfg.idle_timeout).await;

    // Drop handle, await the task to flush+shutdown (sends FIN).
    drop(_wh);
    let _ = writer_task.await;

    stats
}

#[cfg(feature = "tls")]
async fn run_tls(
    stream: tokio_rustls::server::TlsStream<TcpStream>,
    cfg: &TransportConfig,
    metrics: &TransportMetrics,
) -> std::io::Result<ReaderStats> {
    use tokio::io::split;
    let (rd, wr) = split(stream);

    // Spawn writer (TLS): will send close_notify during shutdown().
    let (_wh, writer_task) = writer::spawn_writer(wr, cfg.name, metrics.clone());

    // Reader loop (generic over AsyncRead).
    let stats = reader::run(rd, cfg.read_timeout, cfg.idle_timeout).await;

    // Drop handle and wait for close_notify.
    drop(_wh);
    let _ = writer_task.await;

    stats
}

/// Unified return type for maybe_tls()
enum IoUpgraded {
    Plain(TcpStream),
    #[cfg(feature = "tls")]
    Tls(tokio_rustls::server::TlsStream<TcpStream>),
}

// Feature-safe TLS accept wrapper: if TLS feature disabled or None provided, pass-through.
async fn maybe_tls(
    stream: TcpStream,
    tls: Option<Arc<TlsServerConfig>>,
) -> std::io::Result<IoUpgraded> {
    match tls {
        #[cfg(feature = "tls")]
        Some(cfg) => {
            use tokio_rustls::TlsAcceptor;
            let acceptor = TlsAcceptor::from(cfg);
            let tls_stream = acceptor.accept(stream).await?;
            Ok(IoUpgraded::Tls(tls_stream))
        }
        _ => Ok(IoUpgraded::Plain(stream)),
    }
}

```

### crates/ron-transport/src/tcp/mod.rs
<a id="crates-ron-transport-src-tcp-mod-rs"></a>

```rust
//! RO:WHAT — TCP transport modules (listener/dialer).
pub mod dialer;
pub mod listener;

```

### crates/ron-transport/src/tls/client.rs
<a id="crates-ron-transport-src-tls-client-rs"></a>

```rust
//! RO:WHAT — TLS dial wrapper (placeholder).
#![cfg(feature = "tls")]
pub struct TlsClientConfig; // placeholder

```

### crates/ron-transport/src/tls/mod.rs
<a id="crates-ron-transport-src-tls-mod-rs"></a>

```rust
//! RO:WHAT — TLS wrappers (server/client) behind rustls.
//! RO:INVARIANTS — ServerConfig type = tokio_rustls::rustls::ServerConfig.
pub mod client;
pub mod server;

```

### crates/ron-transport/src/tls/server.rs
<a id="crates-ron-transport-src-tls-server-rs"></a>

```rust
//! RO:WHAT — TLS accept wrapper (placeholder).
#![cfg(feature = "tls")]
use tokio_rustls::rustls::ServerConfig;

pub type TlsServerConfig = ServerConfig;
// Integration will wrap TcpStream with TlsAcceptor::from(Arc<ServerConfig>) later.

```

### crates/ron-transport/src/tls_types.rs
<a id="crates-ron-transport-src-tlstypes-rs"></a>

```rust
//! RO:WHAT — Feature-safe TLS ServerConfig alias.
//! This lets the rest of the crate reference `TlsServerConfig` regardless of
//! whether `feature = "tls"` is enabled.

#[cfg(feature = "tls")]
pub type TlsServerConfig = tokio_rustls::rustls::ServerConfig;

#[cfg(not(feature = "tls"))]
pub struct TlsServerConfig;

```

### crates/ron-transport/src/types.rs
<a id="crates-ron-transport-src-types-rs"></a>

```rust
//! RO:WHAT — Common types/aliases for transport.
//! RO:WHY  — Keep the public surface small & stable; define bus events.

use bytes::Bytes;
use std::net::SocketAddr;

/// Owned frame bytes on hot paths (upper layers decode OAP/1).
pub type FrameBytes = Bytes;

/// Event type emitted on the kernel bus for observability/supervision.
#[derive(Debug, Clone)]
pub enum TransportEvent {
    Connected {
        peer: SocketAddr,
        name: &'static str,
    },
    Disconnected {
        peer: SocketAddr,
        name: &'static str,
        reason: Option<String>,
    },
}

```

### crates/ron-transport/src/util/bytes.rs
<a id="crates-ron-transport-src-util-bytes-rs"></a>

```rust
//! RO:WHAT — Byte helpers (cap checks).
//! RO:INVARIANTS — enforce MAX_FRAME_BYTES before alloc.

use bytes::BytesMut;

pub fn reserve_capped(buf: &mut BytesMut, want: usize, cap: usize) -> Result<(), &'static str> {
    if want > cap {
        return Err("cap_exceeded");
    }
    buf.reserve(want);
    Ok(())
}

```

### crates/ron-transport/src/util/cancel.rs
<a id="crates-ron-transport-src-util-cancel-rs"></a>

```rust
//! RO:WHAT — Cancel tokens & helpers (async-drop friendly).
//! RO:WHY  — Crash-only supervision + graceful shutdown.

use tokio_util::sync::CancellationToken;

#[derive(Clone)]
pub struct Cancel {
    token: CancellationToken,
}
impl Cancel {
    pub fn new() -> Self {
        Self {
            token: CancellationToken::new(),
        }
    }
    pub fn child(&self) -> Self {
        Self {
            token: self.token.child_token(),
        }
    }
    pub fn cancel(&self) {
        self.token.cancel();
    }
    pub async fn cancelled(&self) {
        self.token.cancelled().await;
    }
}

```

### crates/ron-transport/src/util/mod.rs
<a id="crates-ron-transport-src-util-mod-rs"></a>

```rust
pub mod bytes;
pub mod cancel;
pub mod timeouts;

```

### crates/ron-transport/src/util/timeouts.rs
<a id="crates-ron-transport-src-util-timeouts-rs"></a>

```rust
//! RO:WHAT — Timeout helpers (read/write/idle).
use std::time::Duration;
use tokio::time::{timeout, Instant};

pub async fn with_timeout<F, T>(dur: Duration, f: F) -> Result<T, tokio::time::error::Elapsed>
where
    F: std::future::Future<Output = T>,
{
    timeout(dur, f).await
}

pub struct IdleGuard {
    last: Instant,
    idle: Duration,
}
impl IdleGuard {
    pub fn new(idle: Duration) -> Self {
        Self {
            last: Instant::now(),
            idle,
        }
    }
    pub fn bump(&mut self) {
        self.last = Instant::now();
    }
    pub fn expired(&self) -> bool {
        self.last.elapsed() > self.idle
    }
}

```

### crates/ron-transport/tests/amnesia/no_disk_touches.rs
<a id="crates-ron-transport-tests-amnesia-nodisktouches-rs"></a>

```rust
#[test]
fn no_disk_touches_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/integration/arti_bootstrap_ready.rs
<a id="crates-ron-transport-tests-integration-artibootstrapready-rs"></a>

```rust
#[test]
fn arti_bootstrap_ready_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/integration/idle_timeout.rs
<a id="crates-ron-transport-tests-integration-idletimeout-rs"></a>

```rust
use ron_kernel::{Bus, HealthState};
use ron_transport::{
    config::TransportConfig, metrics::TransportMetrics, spawn_transport, types::TransportEvent,
};
use std::{io::Write, net::TcpStream as StdTcp, sync::Arc, time::Duration};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn idle_timeout_closes() -> anyhow::Result<()> {
    let mut cfg = TransportConfig::default();
    cfg.read_timeout = Duration::from_millis(50);
    cfg.idle_timeout = Duration::from_millis(100);
    cfg.name = "test";

    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, None).await?;

    // Connect and stay idle; server should close within ~idle_timeout.
    let mut s = StdTcp::connect(addr)?;
    tokio::time::sleep(Duration::from_millis(200)).await; // cross idle timeout

    // Poll for closure up to a small budget to avoid race with FIN propagation.
    let deadline = std::time::Instant::now() + Duration::from_millis(600);
    loop {
        match s.write(&[1, 2, 3]) {
            Ok(_) => {
                if std::time::Instant::now() >= deadline {
                    anyhow::bail!(
                        "expected write to fail after idle timeout (connection still open)"
                    );
                }
                // FIN may not have arrived yet; wait and retry.
                tokio::time::sleep(Duration::from_millis(50)).await;
            }
            Err(e) => {
                use std::io::ErrorKind::*;
                assert!(
                    matches!(
                        e.kind(),
                        BrokenPipe | ConnectionReset | NotConnected | UnexpectedEof
                    ),
                    "unexpected error kind: {e}"
                );
                break;
            }
        }
    }
    Ok(())
}

```

### crates/ron-transport/tests/integration/mod.rs
<a id="crates-ron-transport-tests-integration-mod-rs"></a>

```rust
mod idle_timeout;
mod over_capacity;
#[cfg(feature = "tls")]
mod tls_accept;

```

### crates/ron-transport/tests/integration/over_capacity.rs
<a id="crates-ron-transport-tests-integration-overcapacity-rs"></a>

```rust
use ron_kernel::{Bus, HealthState};
use ron_transport::{
    config::TransportConfig, metrics::TransportMetrics, spawn_transport, types::TransportEvent,
};
use std::{io::Write, net::TcpStream as StdTcp, sync::Arc, time::Duration};

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn over_capacity_second_conn_dropped() -> anyhow::Result<()> {
    let mut cfg = TransportConfig::default();
    cfg.max_conns = 1;
    cfg.read_timeout = Duration::from_millis(200);
    cfg.idle_timeout = Duration::from_millis(500);
    cfg.name = "test";

    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, None).await?;

    // First connection holds the single permit.
    let _first = StdTcp::connect(addr)?;

    // Second connection should be dropped immediately by policy.
    let mut second = StdTcp::connect(addr)?;
    match second.write(&[9, 9, 9]) {
        Ok(_) => {
            tokio::time::sleep(Duration::from_millis(100)).await;
            match second.write(&[9, 9, 9]) {
                Ok(_) => anyhow::bail!("expected second connection to be dropped"),
                Err(_) => Ok(()),
            }
        }
        Err(_) => Ok(()),
    }
}

```

### crates/ron-transport/tests/integration/quic_parity.rs
<a id="crates-ron-transport-tests-integration-quicparity-rs"></a>

```rust
#[test]
fn quic_parity_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/integration/tls_accept.rs
<a id="crates-ron-transport-tests-integration-tlsaccept-rs"></a>

```rust
#![cfg(feature = "tls")]

use ron_kernel::{Bus, HealthState};
use ron_transport::{
    config::TransportConfig, metrics::TransportMetrics, spawn_transport, types::TransportEvent,
    TlsServerConfig,
};
use rustls_pemfile::{certs, pkcs8_private_keys, rsa_private_keys};
use std::{fs::File, io::BufReader, path::Path, sync::Arc};
use tokio::net::TcpStream;
use tokio_rustls::rustls::{
    pki_types::{CertificateDer, PrivatePkcs1KeyDer, PrivatePkcs8KeyDer, ServerName},
    ClientConfig, RootCertStore,
};
use tokio_rustls::TlsConnector;

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn tls_accepts_handshake() -> anyhow::Result<()> {
    let cert_path = "crates/ron-transport/scripts/local/certs/cert.pem";
    let key_path = "crates/ron-transport/scripts/local/certs/key.pem";
    if !(Path::new(cert_path).exists() && Path::new(key_path).exists()) {
        eprintln!("(skipping tls_accepts_handshake: local certs not found)");
        return Ok(());
    }

    let server_cfg = Arc::new(load_rustls_server(cert_path, key_path)?);

    let mut cfg = TransportConfig::default();
    cfg.name = "tls-test";
    let metrics = TransportMetrics::new("ron");
    let health = Arc::new(HealthState::new());
    let bus: Bus<TransportEvent> = Bus::new();

    let (_jh, addr) = spawn_transport(cfg, metrics, health, bus, Some(server_cfg)).await?;

    let mut roots = RootCertStore::empty();
    let cert_file = File::open(Path::new(cert_path))?;
    let mut cert_rd = BufReader::new(cert_file);
    let certs: Vec<CertificateDer<'static>> = certs(&mut cert_rd).collect::<Result<_, _>>()?;
    for c in certs.into_iter() {
        roots.add(c)?;
    }

    let client = ClientConfig::builder()
        .with_root_certificates(roots)
        .with_no_client_auth();
    let connector = TlsConnector::from(Arc::new(client));
    let tcp = TcpStream::connect(addr).await?;
    let _tls = connector
        .connect(ServerName::try_from("localhost")?, tcp)
        .await?;
    Ok(())
}

fn load_rustls_server(cert_path: &str, key_path: &str) -> anyhow::Result<TlsServerConfig> {
    use tokio_rustls::rustls::{
        pki_types::{CertificateDer, PrivateKeyDer},
        ServerConfig,
    };

    let cert_file = File::open(Path::new(cert_path))?;
    let mut cert_rd = BufReader::new(cert_file);
    let certs: Vec<CertificateDer<'static>> = certs(&mut cert_rd).collect::<Result<_, _>>()?;

    let key: PrivateKeyDer<'static> = {
        let key_file = File::open(Path::new(key_path))?;
        let mut key_rd = BufReader::new(key_file);
        let mut pkcs8: Vec<PrivateKeyDer<'static>> = pkcs8_private_keys(&mut key_rd)
            .map(|res: std::io::Result<PrivatePkcs8KeyDer<'static>>| res.map(Into::into))
            .collect::<Result<_, _>>()?;
        if let Some(k) = pkcs8.pop() {
            k
        } else {
            let key_file = File::open(Path::new(key_path))?;
            let mut key_rd = BufReader::new(key_file);
            let mut rsa: Vec<PrivateKeyDer<'static>> = rsa_private_keys(&mut key_rd)
                .map(|res: std::io::Result<PrivatePkcs1KeyDer<'static>>| res.map(Into::into))
                .collect::<Result<_, _>>()?;
            rsa.pop()
                .ok_or_else(|| anyhow::anyhow!("no private key found in {}", key_path))?
        }
    };

    let cfg = ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)?;
    Ok(cfg)
}

```

### crates/ron-transport/tests/integration/tls_handshake_limits.rs
<a id="crates-ron-transport-tests-integration-tlshandshakelimits-rs"></a>

```rust
#[test]
fn tls_handshake_limits_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/intergration.rs
<a id="crates-ron-transport-tests-intergration-rs"></a>

```rust
mod integration;

```

### crates/ron-transport/tests/loom/single_writer.rs
<a id="crates-ron-transport-tests-loom-singlewriter-rs"></a>

```rust
#[test]
fn single_writer_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/soak/loopback_1MiB.rs
<a id="crates-ron-transport-tests-soak-loopback1MiB-rs"></a>

```rust
#[test]
fn soak_loopback_placeholder() { assert!(true); }

```

### crates/ron-transport/tests/vectors/comp_bounds.json
<a id="crates-ron-transport-tests-vectors-compbounds-json"></a>

```json
{ "max_frame_bytes": 1048576, "inflate_cap": "8x", "notes": "placeholder" }

```

### crates/ron-transport/tests/vectors/oap_hello.json
<a id="crates-ron-transport-tests-vectors-oaphello-json"></a>

```json
{ "name": "oap_hello", "version": 1, "notes": "placeholder vector" }

```

### crates/ron-transport/tests/vectors/pq_hybrid_hello.json
<a id="crates-ron-transport-tests-vectors-pqhybridhello-json"></a>

```json
{ "kex": "hybrid_x25519_mlkem768", "sig": "ed25519", "notes": "placeholder" }

```

### crates/ron-transport/tests/vectors/tor_parity.json
<a id="crates-ron-transport-tests-vectors-torparity-json"></a>

```json
{ "backend": "arti", "parity": true, "notes": "placeholder" }

```



---



# ryker

_Source: crates/ryker/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:55:36Z -->
# Code Bundle — `ryker`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ryker/.clippy.toml](#crates-ryker--clippy-toml)
- [crates/ryker/Cargo.toml](#crates-ryker-Cargo-toml)
- [crates/ryker/benches/batch.rs](#crates-ryker-benches-batch-rs)
- [crates/ryker/benches/dequeue.rs](#crates-ryker-benches-dequeue-rs)
- [crates/ryker/benches/enqueue.rs](#crates-ryker-benches-enqueue-rs)
- [crates/ryker/criterion.toml](#crates-ryker-criterion-toml)
- [crates/ryker/examples/actor_loop.rs](#crates-ryker-examples-actorloop-rs)
- [crates/ryker/examples/config_dump.rs](#crates-ryker-examples-configdump-rs)
- [crates/ryker/fuzz/fuzz_targets/fuzz_mailbox_ops.rs](#crates-ryker-fuzz-fuzztargets-fuzzmailboxops-rs)
- [crates/ryker/fuzz/fuzz_targets/fuzz_parse_config_json.rs](#crates-ryker-fuzz-fuzztargets-fuzzparseconfigjson-rs)
- [crates/ryker/fuzz/fuzz_targets/fuzz_parse_config_toml.rs](#crates-ryker-fuzz-fuzztargets-fuzzparseconfigtoml-rs)
- [crates/ryker/rust-toolchain.toml](#crates-ryker-rust-toolchain-toml)
- [crates/ryker/ryker.example.toml](#crates-ryker-ryker-example-toml)
- [crates/ryker/scripts/public_api_snapshot.sh](#crates-ryker-scripts-publicapisnapshot-sh)
- [crates/ryker/scripts/render-mermaid.sh](#crates-ryker-scripts-render-mermaid-sh)
- [crates/ryker/src/config/loader.rs](#crates-ryker-src-config-loader-rs)
- [crates/ryker/src/config/mod.rs](#crates-ryker-src-config-mod-rs)
- [crates/ryker/src/config/model.rs](#crates-ryker-src-config-model-rs)
- [crates/ryker/src/config/reload.rs](#crates-ryker-src-config-reload-rs)
- [crates/ryker/src/errors.rs](#crates-ryker-src-errors-rs)
- [crates/ryker/src/lib.rs](#crates-ryker-src-lib-rs)
- [crates/ryker/src/mailbox/builder.rs](#crates-ryker-src-mailbox-builder-rs)
- [crates/ryker/src/mailbox/error.rs](#crates-ryker-src-mailbox-error-rs)
- [crates/ryker/src/mailbox/mod.rs](#crates-ryker-src-mailbox-mod-rs)
- [crates/ryker/src/mailbox/observer.rs](#crates-ryker-src-mailbox-observer-rs)
- [crates/ryker/src/mailbox/queue.rs](#crates-ryker-src-mailbox-queue-rs)
- [crates/ryker/src/observe/metrics.rs](#crates-ryker-src-observe-metrics-rs)
- [crates/ryker/src/observe/mod.rs](#crates-ryker-src-observe-mod-rs)
- [crates/ryker/src/observe/trace.rs](#crates-ryker-src-observe-trace-rs)
- [crates/ryker/src/prelude.rs](#crates-ryker-src-prelude-rs)
- [crates/ryker/src/runtime/mod.rs](#crates-ryker-src-runtime-mod-rs)
- [crates/ryker/src/runtime/runtime.rs](#crates-ryker-src-runtime-runtime-rs)
- [crates/ryker/src/supervisor/backoff.rs](#crates-ryker-src-supervisor-backoff-rs)
- [crates/ryker/src/supervisor/mod.rs](#crates-ryker-src-supervisor-mod-rs)
- [crates/ryker/src/supervisor/supervisor.rs](#crates-ryker-src-supervisor-supervisor-rs)
- [crates/ryker/tests/feature_matrix.rs](#crates-ryker-tests-featurematrix-rs)
- [crates/ryker/tests/integration/amnesia.rs](#crates-ryker-tests-integration-amnesia-rs)
- [crates/ryker/tests/integration/backpressure.rs](#crates-ryker-tests-integration-backpressure-rs)
- [crates/ryker/tests/integration/config_env_snapshot.rs](#crates-ryker-tests-integration-configenvsnapshot-rs)
- [crates/ryker/tests/integration/deadline.rs](#crates-ryker-tests-integration-deadline-rs)
- [crates/ryker/tests/integration/metrics_contract.rs](#crates-ryker-tests-integration-metricscontract-rs)
- [crates/ryker/tests/integration/reload_hot_cold.rs](#crates-ryker-tests-integration-reloadhotcold-rs)
- [crates/ryker/tests/integration/supervisor_backoff.rs](#crates-ryker-tests-integration-supervisorbackoff-rs)
- [crates/ryker/tests/loom/loom_backpressure.rs](#crates-ryker-tests-loom-loombackpressure-rs)
- [crates/ryker/tests/loom/loom_mailbox_basic.rs](#crates-ryker-tests-loom-loommailboxbasic-rs)
- [crates/ryker/tests/loom/loom_shutdown.rs](#crates-ryker-tests-loom-loomshutdown-rs)
- [crates/ryker/tests/vectors/snapshots/config_snapshot.json](#crates-ryker-tests-vectors-snapshots-configsnapshot-json)
- [crates/ryker/tests/vectors/snapshots/config_snapshot.toml](#crates-ryker-tests-vectors-snapshots-configsnapshot-toml)

### crates/ryker/.clippy.toml
<a id="crates-ryker--clippy-toml"></a>

```toml
# Minimal, stable-friendly Clippy config for ryker
msrv = "1.80"

```

### crates/ryker/Cargo.toml
<a id="crates-ryker-Cargo-toml"></a>

```toml
[package]
name = "ryker"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Embedded actor & bounded mailbox runtime for RustyOnions"
readme = "README.MD"
rust-version = "1.80"

[features]
default = ["metrics", "tracing", "amnesia"]
metrics = []
tracing = ["dep:tracing"]
amnesia = []
loom = []
dev-cli = []
# Enables a non-intrusive "tap" for benches to clone a receiver; off in prod.
bench_support = []

[dependencies]
tokio = { version = "1.47", features = ["macros", "rt", "time", "sync"] }
parking_lot = "0.12"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
serde_with = "3.9"
humantime = "2.1"
humantime-serde = "1.1"
once_cell = "1.19"
rand = "0.9"
anyhow = "1.0"
serde_json = "1.0"

# Optional tracing; enabled via feature above
tracing = { version = "0.1", optional = true, default-features = false, features = ["std"] }

[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports", "async_tokio"] }
serde_json = "1.0"
anyhow = "1.0"

[[bench]]
name = "enqueue"
harness = false

[[bench]]
name = "dequeue"
harness = false

[[bench]]
name = "batch"
harness = false

[lib]
doctest = false
```

### crates/ryker/benches/batch.rs
<a id="crates-ryker-benches-batch-rs"></a>

```rust
//! RO:WHAT — Criterion bench: batched dequeue throughput.
//! RO:INVAR — Prefill with send(); drop TX; drain RX in batches until N or Closed.

use criterion::{criterion_group, criterion_main, Criterion};
use ryker::prelude::*;
use std::time::Duration;
use tokio::runtime::{Builder as TokioBuilder, Runtime as TokioRt};

const CAP: usize = 2048;
const N_MSGS: usize = CAP;
const BATCH: usize = 64;

fn tokio_rt() -> TokioRt {
    TokioBuilder::new_current_thread()
        .enable_time()
        .build()
        .expect("tokio rt")
}

fn bench_batch(c: &mut Criterion) {
    let rt = tokio_rt();
    c.bench_function("ryker_batch_pull", |b| {
        b.to_async(&rt).iter(|| async {
            let cfg = ryker::config::from_env_validated().unwrap();
            let ry = Runtime::new(cfg);

            let mb = ry
                .mailbox::<u64>("bench.batch")
                .capacity(CAP)
                .deadline(Duration::from_millis(10))
                .build();

            let (tx, mut rx) = mb.split();

            for i in 0..N_MSGS as u64 {
                tx.send(i).await.expect("prefill");
            }
            drop(tx);

            let mut n = 0usize;
            while n < N_MSGS {
                let mut got = 0usize;
                while got < BATCH {
                    match rx.pull().await {
                        Ok(_m) => {
                            got += 1;
                            n += 1;
                            if n >= N_MSGS {
                                break;
                            }
                        }
                        Err(ryker::mailbox::MailboxError::Closed) => break,
                        Err(ryker::mailbox::MailboxError::Timeout) => break,
                        Err(e) => panic!("unexpected: {e}"),
                    }
                }
                tokio::task::yield_now().await;
            }
        });
    });
}

criterion_group!(benches, bench_batch);
criterion_main!(benches);

```

### crates/ryker/benches/dequeue.rs
<a id="crates-ryker-benches-dequeue-rs"></a>

```rust
//! RO:WHAT — Criterion bench: dequeue throughput.
//! RO:INVAR — Prefill with send(); drop TX; drain RX until N or Closed.

use criterion::{criterion_group, criterion_main, Criterion};
use ryker::prelude::*;
use std::time::Duration;
use tokio::runtime::{Builder as TokioBuilder, Runtime as TokioRt};

const CAP: usize = 1024;
const N_MSGS: usize = CAP;

fn tokio_rt() -> TokioRt {
    TokioBuilder::new_current_thread()
        .enable_time()
        .build()
        .expect("tokio rt")
}

fn bench_dequeue(c: &mut Criterion) {
    let rt = tokio_rt();
    c.bench_function("ryker_dequeue_pull", |b| {
        b.to_async(&rt).iter(|| async {
            let cfg = ryker::config::from_env_validated().unwrap();
            let ry = Runtime::new(cfg);

            let mb = ry
                .mailbox::<u64>("bench.dequeue")
                .capacity(CAP)
                .deadline(Duration::from_millis(10))
                .build();

            let (tx, mut rx) = mb.split();

            for i in 0..N_MSGS as u64 {
                tx.send(i).await.expect("prefill");
            }
            drop(tx); // important: close the channel

            let mut n = 0usize;
            loop {
                match rx.pull().await {
                    Ok(_m) => {
                        n += 1;
                        if n >= N_MSGS {
                            break;
                        }
                    }
                    Err(ryker::mailbox::MailboxError::Closed) => break,
                    Err(ryker::mailbox::MailboxError::Timeout) => break,
                    Err(e) => panic!("unexpected: {e}"),
                }
                tokio::task::yield_now().await;
            }
        });
    });
}

criterion_group!(benches, bench_dequeue);
criterion_main!(benches);

```

### crates/ryker/benches/enqueue.rs
<a id="crates-ryker-benches-enqueue-rs"></a>

```rust
//! RO:WHAT — Criterion bench: enqueue throughput (producer side).
//! RO:INVAR — try_send burst, ignore Busy (we measure producer cost, not success rate).

use criterion::{criterion_group, criterion_main, Criterion};
use ryker::prelude::*;
use std::time::Duration;
use tokio::runtime::{Builder as TokioBuilder, Runtime as TokioRt};

const CAP: usize = 2048;
const N_TRIES: usize = CAP * 2; // intentionally over capacity

fn tokio_rt() -> TokioRt {
    TokioBuilder::new_current_thread()
        .enable_time()
        .build()
        .expect("tokio rt")
}

fn bench_enqueue(c: &mut Criterion) {
    let rt = tokio_rt();
    c.bench_function("ryker_enqueue_try_send", |b| {
        b.to_async(&rt).iter(|| async {
            let cfg = ryker::config::from_env_validated().unwrap();
            let ry = Runtime::new(cfg);

            let mb = ry
                .mailbox::<u64>("bench.enqueue")
                .capacity(CAP)
                .deadline(Duration::from_millis(5))
                .build();

            let (tx, _rx) = mb.split();

            for i in 0..N_TRIES as u64 {
                let _ = tx.try_send(i);
            }
        });
    });
}

criterion_group!(benches, bench_enqueue);
criterion_main!(benches);

```

### crates/ryker/criterion.toml
<a id="crates-ryker-criterion-toml"></a>

```toml
warm_up_time = "0.5 s"
measurement_time = "2.0 s"
sample_size = 30
confidence_level = 0.90
noise_threshold = 0.02
nresamples = 10_000
plotting_backend = "disabled"

```

### crates/ryker/examples/actor_loop.rs
<a id="crates-ryker-examples-actorloop-rs"></a>

```rust
// RO:WHAT  — Minimal actor loop using Runtime + Mailbox + Supervisor.
// RO:HOW   — cargo run -p ryker --example actor_loop

use ryker::prelude::*;
use std::time::Duration;

#[derive(Debug, Clone)]
struct Msg(&'static str);

#[tokio::main(flavor = "current_thread")]
async fn main() -> anyhow::Result<()> {
    let cfg = ryker::config::from_env_validated()?;
    let rt = Runtime::new(cfg);

    // Build a small mailbox to demo Busy behavior.
    let mb: ryker::mailbox::Mailbox<Msg> = rt
        .mailbox("demo-actor")
        .capacity(4)
        .deadline(Duration::from_millis(250))
        .build();

    // Enqueue a few messages; you should see Busy when capacity is exceeded.
    for i in 0..8 {
        match mb.try_send(Msg("hello")) {
            Ok(_) => println!("[main] enqueued i={i}"),
            Err(ryker::mailbox::MailboxError::Busy) => {
                println!("[main] queue Busy at i={i} (reject-new)")
            }
            Err(e) => println!("[main] enqueue error at i={i}: {e}"),
        }
    }

    // Hand-off ownership of the mailbox to the supervised actor exactly once.
    // The FnMut factory can be called multiple times by Supervisor after failures;
    // we use Option.take() so only the first call consumes the mailbox.
    let mut rx_opt = Some(mb);
    let sup = Supervisor::new(rt.config());
    let _handle = sup.spawn(move || {
        // Take the mailbox on the first invocation; None thereafter (no restart).
        let rx_taken = rx_opt.take();
        async move {
            if let Some(mut rx) = rx_taken {
                loop {
                    match rx.pull().await {
                        Ok(Msg(s)) => println!("[actor] handled: {s}"),
                        Err(ryker::mailbox::MailboxError::Timeout) => {
                            println!("[actor] idle timeout");
                        }
                        Err(ryker::mailbox::MailboxError::Closed) => break,
                        Err(e) => eprintln!("[actor] error: {e}"),
                    }
                }
            }
            Ok::<(), anyhow::Error>(())
        }
    });

    tokio::time::sleep(Duration::from_secs(1)).await;
    Ok(())
}

```

### crates/ryker/examples/config_dump.rs
<a id="crates-ryker-examples-configdump-rs"></a>

```rust
// RO:WHAT — Print the effective RykerConfig as JSON.
// RO:HOW  — cargo run -p ryker --example config_dump

use serde_json::json;

fn main() -> anyhow::Result<()> {
    let cfg = ryker::config::from_env_validated()?;
    let d = &cfg.defaults;
    let f = &cfg.fairness;
    let s = &cfg.supervisor;

    let out = json!({
        "defaults": {
            "mailbox_capacity": d.mailbox_capacity,
            "max_msg_bytes": d.max_msg_bytes,
            "deadline_ms": d.deadline.as_millis(),
        },
        "fairness": {
            "batch_messages": f.batch_messages,
            "yield_every_n_msgs": f.yield_every_n_msgs,
        },
        "supervisor": {
            "backoff_base_ms": s.backoff_base_ms,
            "backoff_cap_ms": s.backoff_cap_ms,
            "decorrelated_jitter": s.decorrelated_jitter,
        },
        "amnesia": cfg.amnesia,
        "observe": {
            "queue_depth_sampling": cfg.observe.queue_depth_sampling,
        }
    });

    println!("{}", serde_json::to_string_pretty(&out)?);
    Ok(())
}

```

### crates/ryker/fuzz/fuzz_targets/fuzz_mailbox_ops.rs
<a id="crates-ryker-fuzz-fuzztargets-fuzzmailboxops-rs"></a>

```rust
#![no_main]
// cargo-fuzz target (stub): randomized mailbox ops.

```

### crates/ryker/fuzz/fuzz_targets/fuzz_parse_config_json.rs
<a id="crates-ryker-fuzz-fuzztargets-fuzzparseconfigjson-rs"></a>

```rust
#![no_main]
// cargo-fuzz target (stub): parse JSON config.

```

### crates/ryker/fuzz/fuzz_targets/fuzz_parse_config_toml.rs
<a id="crates-ryker-fuzz-fuzztargets-fuzzparseconfigtoml-rs"></a>

```rust
#![no_main]
// cargo-fuzz target (stub): parse TOML config.

```

### crates/ryker/rust-toolchain.toml
<a id="crates-ryker-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/ryker/ryker.example.toml
<a id="crates-ryker-ryker-example-toml"></a>

```toml
# Example config — validated via RykerConfig::from_env_validated()
[mailbox]
capacity = 256
max_msg_bytes = "64KiB"
default_deadline_ms = 1000

[fairness]
batch_messages = 32
yield_every_n = 64

[supervisor]
backoff_base_ms = 100
backoff_cap_ms  = 5000

[observe]
metrics = true
queue_depth_sampling = true

[amnesia]
enabled = false


```

### crates/ryker/scripts/public_api_snapshot.sh
<a id="crates-ryker-scripts-publicapisnapshot-sh"></a>

```bash
#!/usr/bin/env bash
# Takes a public API snapshot for the `ryker` crate and optionally diffs it.
# Requirements:
#   - cargo-public-api  (install: cargo install cargo-public-api)
# Usage:
#   scripts/public_api_snapshot.sh save <name>        # save snapshot to target/public-api/<name>.txt
#   scripts/public_api_snapshot.sh diff <old> <new>   # show diff between two saved snapshots
#   scripts/public_api_snapshot.sh now                # print current API (no file)
# Env:
#   CARGO_FEATURES="..."   # e.g. "--features bench_support"

set -euo pipefail

# Find workspace root by walking upward until Cargo.toml is found.
find_workspace_root() {
  local d="$1"
  for _ in {1..6}; do
    if [[ -f "$d/Cargo.toml" ]]; then
      echo "$d"
      return 0
    fi
    d="$(dirname "$d")"
  done
  return 1
}

here="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
start_dir="$here"
repo="$(find_workspace_root "$start_dir" || true)"
if [[ -z "${repo:-}" ]]; then
  echo "Could not find workspace Cargo.toml by walking up from: $start_dir"
  echo "Hint: run this script from within the workspace, or set REPO_ROOT env var."
  exit 1
fi
cd "$repo"

if ! command -v cargo-public-api >/dev/null 2>&1; then
  echo "cargo-public-api not found. install it first:"
  echo "cargo install cargo-public-api"
  exit 1
fi

outdir="target/public-api"
mkdir -p "$outdir"

features="${CARGO_FEATURES:-}"

case "${1:-}" in
  save)
    name="${2:-ryker-$(date +%Y%m%d-%H%M%S)}"
    out="$outdir/$name.txt"
    cargo public-api -p ryker $features --simplified \
      --omit blanket-impls --omit auto-trait-impls > "$out"
    echo "Saved: $out"
    ;;
  diff)
    old="$outdir/${2:?old snapshot name}.txt"
    new="$outdir/${3:?new snapshot name}.txt"
    if [[ ! -f "$old" || ! -f "$new" ]]; then
      echo "Missing files: $old or $new"
      exit 2
    fi
    diff -u "$old" "$new" || true
    ;;
  now)
    cargo public-api -p ryker $features --simplified \
      --omit blanket-impls --omit auto-trait-impls
    ;;
  *)
    echo "Usage:"
    echo "  $0 save <name>"
    echo "  $0 diff <old> <new>"
    echo "  $0 now"
    exit 64
    ;;
esac

```

### crates/ryker/scripts/render-mermaid.sh
<a id="crates-ryker-scripts-render-mermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Renders docs/*.mmd to SVG using mermaid-cli if available.
ROOT=${1:-"./crates"}
cd "./crates/ryker"
if ! command -v mmdc >/dev/null 2>&1; then
  echo "mmdc not found. Install: npm i -g @mermaid-js/mermaid-cli"
  exit 1
fi
for f in docs/*.mmd; do
  [ -e "$f" ] || continue
  out=${f%.mmd}.svg
  mmdc -i "$f" -o "$out"
  echo "rendered: $out"
done


```

### crates/ryker/src/config/loader.rs
<a id="crates-ryker-src-config-loader-rs"></a>

```rust
//! RO:WHAT — Builder + environment merge for `RykerConfig` (file optional).
//! RO:WHY  — Enforce builder > env > file > defaults; prod guards.
//! RO:INTERACTS — model (schema), reload (hooks), runtime creates snapshot.
//! RO:INVARIANTS — `RYKER_CONFIG_PATH` ignored in prod unless explicitly allowed.

use super::model::RykerConfig;
use crate::errors::{ConfigError, Result};
use once_cell::sync::Lazy;
use std::env;

static IS_PROD: Lazy<bool> = Lazy::new(|| {
    let app = env::var("APP_ENV").ok();
    let rust = env::var("RUST_ENV").ok();
    matches!(app.or(rust), Some(s) if s == "production")
});

#[derive(Default)]
pub struct RykerConfigBuilder {
    inner: RykerConfig,
}

impl RykerConfigBuilder {
    pub fn new() -> Self {
        Self {
            inner: RykerConfig::default(),
        }
    }
    pub fn build(mut self) -> Result<RykerConfig> {
        merge_env(&mut self.inner)?;
        self.inner.validate()?;
        Ok(self.inner)
    }
}

pub fn from_env_validated() -> Result<RykerConfig> {
    let mut cfg = RykerConfig::default();

    if let Ok(path) = env::var("RYKER_CONFIG_PATH") {
        if *IS_PROD && env::var("RYKER_ALLOW_CONFIG_PATH").as_deref() != Ok("1") {
            return Err(
                ConfigError::ProdGuard("RYKER_CONFIG_PATH rejected in production".into()).into(),
            );
        }
        tracing_log!("dev-cli path provided (host should load file): {}", path);
    }

    merge_env(&mut cfg)?;
    cfg.validate()?;
    Ok(cfg)
}

fn merge_env(cfg: &mut RykerConfig) -> Result<()> {
    let get = |k: &str| env::var(k).ok();

    if let Some(v) = get("RYKER_DEFAULT_MAILBOX_CAPACITY") {
        cfg.defaults.mailbox_capacity = v.parse().map_err(|_| {
            ConfigError::Invalid("RYKER_DEFAULT_MAILBOX_CAPACITY must be int".into())
        })?;
    }
    if let Some(v) = get("RYKER_DEFAULT_MAX_MSG_BYTES") {
        cfg.defaults.max_msg_bytes = parse_size(&v)?;
    }
    if let Some(v) = get("RYKER_DEFAULT_DEADLINE") {
        cfg.defaults.deadline = humantime::parse_duration(&v)
            .map_err(|_| ConfigError::Invalid("bad deadline".into()))?;
    }
    if let Some(v) = get("RYKER_BACKOFF_BASE_MS") {
        cfg.supervisor.backoff_base_ms = v
            .parse()
            .map_err(|_| ConfigError::Invalid("bad backoff_base_ms".into()))?;
    }
    if let Some(v) = get("RYKER_BACKOFF_CAP_MS") {
        cfg.supervisor.backoff_cap_ms = v
            .parse()
            .map_err(|_| ConfigError::Invalid("bad backoff_cap_ms".into()))?;
    }
    if let Some(v) = get("RYKER_BATCH_MESSAGES") {
        cfg.fairness.batch_messages = v
            .parse()
            .map_err(|_| ConfigError::Invalid("bad batch_messages".into()))?;
    }
    if let Some(v) = get("RYKER_YIELD_EVERY_N") {
        cfg.fairness.yield_every_n_msgs = v
            .parse()
            .map_err(|_| ConfigError::Invalid("bad yield_every_n".into()))?;
    }
    if let Some(v) = get("RYKER_ENABLE_METRICS") {
        cfg.observe.queue_depth_sampling = matches!(v.as_str(), "1" | "true" | "TRUE");
    }
    if let Some(v) = get("RYKER_AMNESIA") {
        cfg.amnesia = matches!(v.as_str(), "1" | "true" | "TRUE");
    }
    Ok(())
}

fn parse_size(s: &str) -> Result<usize> {
    let s = s.trim();
    if let Some(n) = s.strip_suffix("KiB") {
        let v: usize = n
            .trim()
            .parse()
            .map_err(|_| ConfigError::Invalid("size".into()))?;
        return Ok(v * 1024);
    }
    if let Some(n) = s.strip_suffix("MiB") {
        let v: usize = n
            .trim()
            .parse()
            .map_err(|_| ConfigError::Invalid("size".into()))?;
        return Ok(v * 1024 * 1024);
    }
    let v: usize = s.parse().map_err(|_| ConfigError::Invalid("size".into()))?;
    Ok(v)
}

// Tiny local macro to avoid requiring tracing at call site when feature disabled
#[inline]
fn tracing_log_(lvl: &str, msg: &str) {
    #[cfg(feature = "tracing")]
    match lvl {
        "info" => tracing::info!("{}", msg),
        _ => tracing::debug!("{}", msg),
    }
}

macro_rules! tracing_log {
    ($($tt:tt)*) => {
        #[allow(unused)]
        {
            let s = format!($($tt)*);
            super::loader::tracing_log_("debug", &s);
        }
    };
}
pub(crate) use tracing_log;

```

### crates/ryker/src/config/mod.rs
<a id="crates-ryker-src-config-mod-rs"></a>

```rust
//! RO:WHAT — Public entry for configuration types and loader.
//! RO:WHY  — Keep builder/env/file precedence & validation together.
//! RO:INTERACTS — model (schema), loader (env/file), reload (hooks).
//! RO:INVARIANTS — builder > env > file > defaults; deny invalid combos; amnesia honored.

mod loader;
mod model;
mod reload;

pub use loader::{from_env_validated, RykerConfigBuilder};
pub use model::{FairnessCfg, RykerConfig, SupervisionCfg};
pub use reload::{ReloadCounters, RykerReloadHook};

```

### crates/ryker/src/config/model.rs
<a id="crates-ryker-src-config-model-rs"></a>

```rust
//! RO:WHAT — Typed configuration schema for ryker.
//! RO:WHY  — Deterministic defaults + strict validation (docs-aligned).
//! RO:INTERACTS — loader merges sources; runtime/mailbox read snapshots.
//! RO:INVARIANTS — capacity>0; 0 < deadline ≤ 60s; max_msg_bytes ≤ 1MiB; yield_every_n ≥ batch.

use crate::errors::{ConfigError, Result};
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RykerConfig {
    pub defaults: Defaults,
    pub fairness: FairnessCfg,
    pub supervisor: SupervisionCfg,
    pub amnesia: bool,
    pub observe: ObserveCfg,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Defaults {
    pub mailbox_capacity: usize,
    pub max_msg_bytes: usize,
    #[serde(with = "humantime_serde")]
    pub deadline: Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FairnessCfg {
    pub batch_messages: usize,
    pub yield_every_n_msgs: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupervisionCfg {
    pub backoff_base_ms: u64,
    pub backoff_cap_ms: u64,
    pub decorrelated_jitter: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ObserveCfg {
    /// If true, ryker may sample queue depths via observer hooks.
    pub queue_depth_sampling: bool,
}

impl Default for RykerConfig {
    fn default() -> Self {
        Self {
            defaults: Defaults {
                mailbox_capacity: 256,
                max_msg_bytes: 64 * 1024,
                deadline: Duration::from_secs(1),
            },
            fairness: FairnessCfg {
                batch_messages: 32,
                yield_every_n_msgs: 64,
            },
            supervisor: SupervisionCfg {
                backoff_base_ms: 100,
                backoff_cap_ms: 5_000,
                decorrelated_jitter: true,
            },
            amnesia: false,
            observe: ObserveCfg {
                queue_depth_sampling: true,
            },
        }
    }
}

impl RykerConfig {
    pub fn validate(&self) -> Result<()> {
        // mailbox must have capacity
        if self.defaults.mailbox_capacity == 0 {
            return Err(ConfigError::Invalid("mailbox_capacity=0".into()).into());
        }

        // Upper bound aligns with crate docs (≤ 1 MiB)
        const MIB: usize = 1024 * 1024;
        if self.defaults.max_msg_bytes > MIB {
            return Err(ConfigError::Invalid("max_msg_bytes > 1MiB".into()).into());
        }

        // 1 ms ..= 60 s recommended bounds
        if self.defaults.deadline < Duration::from_millis(1)
            || self.defaults.deadline > Duration::from_secs(60)
        {
            return Err(ConfigError::Invalid("deadline out of [1ms, 60s]".into()).into());
        }

        // yield_every_n must be ≥ batch size
        if self.fairness.yield_every_n_msgs < self.fairness.batch_messages {
            return Err(ConfigError::Invalid("yield_every_n_msgs < batch_messages".into()).into());
        }

        // backoff base/cap relationship must be coherent and non-zero
        if self.supervisor.backoff_base_ms == 0
            || self.supervisor.backoff_cap_ms == 0
            || self.supervisor.backoff_base_ms > self.supervisor.backoff_cap_ms
        {
            return Err(
                ConfigError::Invalid("invalid backoff base/cap relationship".into()).into(),
            );
        }
        Ok(())
    }

    /// Apply in-process overrides (builder-like) then revalidate.
    pub fn with_overrides<F: FnOnce(&mut RykerConfig)>(mut self, f: F) -> Result<RykerConfig> {
        f(&mut self);
        self.validate()?;
        Ok(self)
    }
}

```

### crates/ryker/src/config/reload.rs
<a id="crates-ryker-src-config-reload-rs"></a>

```rust
//! RO:WHAT — Config reload hook trait and counters.
//! RO:WHY  — Hosts may hot-apply fairness/deadline; capacity is cold-only.
//! RO:INTERACTS — runtime applies hooks; observe increments counters.
//! RO:INVARIANTS — reloads are atomic snapshot swaps; diffs are redacted.

use std::sync::atomic::AtomicU64;

#[derive(Default)]
pub struct ReloadCounters {
    pub total: AtomicU64,
    pub errors: AtomicU64,
}

pub trait RykerReloadHook: Send + Sync + 'static {
    /// Apply a new effective snapshot. Implementations must be fast and panic-free.
    fn apply(&self);
}

```

### crates/ryker/src/errors.rs
<a id="crates-ryker-src-errors-rs"></a>

```rust
//! RO:WHAT — Typed error taxonomy for ryker (mailbox/runtime/config).
//! RO:WHY  — Deterministic mapping for hosts; Concerns: RES/DX.
//! RO:INTERACTS — mailbox (Busy/TooLarge/Closed/Timeout), config loader.
//! RO:INVARIANTS — errors stable across minors; strings are non-sensitive.

use thiserror::Error;

pub type Result<T, E = Error> = std::result::Result<T, E>;

#[derive(Debug, Error)]
pub enum Error {
    #[error("mailbox at capacity (Busy)")]
    Busy,
    #[error("message too large (max {max} bytes)")]
    TooLarge { max: usize },
    #[error("mailbox closed")]
    Closed,
    #[error("deadline exceeded")]
    Timeout,
    #[error("configuration error: {0}")]
    Config(ConfigError),
}

#[derive(Debug, Error)]
pub enum ConfigError {
    #[error("invalid value: {0}")]
    Invalid(String),
    #[error("unsupported in production: {0}")]
    ProdGuard(String),
}

// Allow `?` on ConfigError to bubble as Error::Config
impl From<ConfigError> for Error {
    fn from(e: ConfigError) -> Self {
        Error::Config(e)
    }
}

```

### crates/ryker/src/lib.rs
<a id="crates-ryker-src-lib-rs"></a>

```rust
//! RO:WHAT — Crate facade for ryker (actor & bounded mailbox runtime).
//! RO:WHY  — Pillar 1 (Kernel & Orchestration); Concerns: RES/PERF.
//! RO:INTERACTS — modules: config, runtime, mailbox, supervisor, observe, errors.
//! RO:INVARIANTS — bounded mailboxes (reject-new Busy); deadlines enforced; no locks across .await.
//! RO:METRICS — via observe::MailboxObserver callbacks (host integrates Prometheus).
//! RO:CONFIG — env `RYKER_*` honored; builder > env > file > defaults precedence.
//! RO:SECURITY — library-only; no sockets/TLS/PII; amnesia feature zeroizes on drop (host-verified).
//! RO:TEST — unit/integration/loom per docs; property tests optional (proptest).

#![forbid(unsafe_code)]
#![doc = include_str!("../README.md")]

pub mod config;
pub mod errors;
pub mod mailbox;
pub mod observe;
pub mod runtime;
pub mod supervisor;

pub mod prelude;

```

### crates/ryker/src/mailbox/builder.rs
<a id="crates-ryker-src-mailbox-builder-rs"></a>

```rust
//! RO:WHAT — Per-actor mailbox builder with overrides.
//! RO:WHY  — Ergonomics; mirrors README examples; preserves snapshot defaults.
//! RO:INTERACTS — queue::Mailbox, observer hooks, config snapshot.
//! RO:INVARIANTS — capacity>0; max_msg_bytes≤1MiB; deadline bounds; reject-new policy.

#![forbid(unsafe_code)]

use super::observer::{NoopObserver, Observer};
use super::queue::Mailbox;
use crate::config::RykerConfig;
use std::sync::Arc;
use std::time::Duration;

pub struct MailboxBuilder<T> {
    actor_name: String,
    cfg: Arc<RykerConfig>,
    capacity: Option<usize>,
    max_msg_bytes: Option<usize>,
    deadline: Option<Duration>,
    observer: Option<Observer>,
    _phantom: std::marker::PhantomData<T>,
}

impl<T> MailboxBuilder<T> {
    pub(crate) fn new(actor_name: String, cfg: Arc<RykerConfig>) -> Self {
        Self {
            actor_name,
            cfg,
            capacity: None,
            max_msg_bytes: None,
            deadline: None,
            observer: None,
            _phantom: std::marker::PhantomData,
        }
    }

    pub fn capacity(mut self, cap: usize) -> Self {
        self.capacity = Some(cap);
        self
    }

    pub fn max_msg_bytes(mut self, max: usize) -> Self {
        self.max_msg_bytes = Some(max);
        self
    }

    pub fn deadline(mut self, d: Duration) -> Self {
        self.deadline = Some(d);
        self
    }

    /// Convenience for ms-based examples/doc parity.
    pub fn deadline_ms(mut self, ms: u64) -> Self {
        self.deadline = Some(Duration::from_millis(ms));
        self
    }

    pub fn observer(mut self, obs: Observer) -> Self {
        self.observer = Some(obs);
        self
    }

    pub fn build(self) -> Mailbox<T> {
        let cap = self.capacity.unwrap_or(self.cfg.defaults.mailbox_capacity);
        let max = self
            .max_msg_bytes
            .unwrap_or(self.cfg.defaults.max_msg_bytes);
        let dl = self.deadline.unwrap_or(self.cfg.defaults.deadline);
        let obs = self.observer.unwrap_or_else(|| Arc::new(NoopObserver));

        Mailbox::new(self.actor_name, cap, max, dl, obs)
    }
}

```

### crates/ryker/src/mailbox/error.rs
<a id="crates-ryker-src-mailbox-error-rs"></a>

```rust
//! RO:WHAT — Mailbox-local error facade and Result alias.
//! RO:WHY  — Keep mailbox concerns self-contained while mapping 1:1 to crate errors.
//! RO:INTERACTS — Used by `queue.rs` and `builder.rs`; re-exports for callers via `mailbox::`.
//! RO:INVARIANTS — Mirrors `crate::errors::Error`; stable across minor versions.

#![forbid(unsafe_code)]

pub type MailboxResult<T, E = MailboxError> = std::result::Result<T, E>;

/// Thin alias to the crate-wide error so users can import `mailbox::MailboxError`
/// without reaching into `crate::errors`.
#[derive(Debug, thiserror::Error)]
pub enum MailboxError {
    #[error("mailbox at capacity (Busy)")]
    Busy,
    #[error("message too large (max {max} bytes)")]
    TooLarge { max: usize },
    #[error("mailbox closed")]
    Closed,
    #[error("deadline exceeded")]
    Timeout,
}

impl From<crate::errors::Error> for MailboxError {
    fn from(e: crate::errors::Error) -> Self {
        match e {
            crate::errors::Error::Busy => MailboxError::Busy,
            crate::errors::Error::TooLarge { max } => MailboxError::TooLarge { max },
            crate::errors::Error::Closed => MailboxError::Closed,
            crate::errors::Error::Timeout => MailboxError::Timeout,
            crate::errors::Error::Config(_) => {
                // Mailbox never bubbles config errors; map conservatively.
                MailboxError::Closed
            }
        }
    }
}

impl From<MailboxError> for crate::errors::Error {
    fn from(e: MailboxError) -> Self {
        match e {
            MailboxError::Busy => crate::errors::Error::Busy,
            MailboxError::TooLarge { max } => crate::errors::Error::TooLarge { max },
            MailboxError::Closed => crate::errors::Error::Closed,
            MailboxError::Timeout => crate::errors::Error::Timeout,
        }
    }
}

```

### crates/ryker/src/mailbox/mod.rs
<a id="crates-ryker-src-mailbox-mod-rs"></a>

```rust
//! RO:WHAT — Public mailbox types: builder and queue facade.
//! RO:WHY  — Bounded single-consumer mailbox; Busy on overflow.
//! RO:INTERACTS — queue (tokio mpsc), observer hooks, errors.
//! RO:INVARIANTS — FIFO per-mailbox; reject-new; deadlines enforced via timeout.

mod builder;
mod error;
pub mod observer;
mod queue;

pub use builder::MailboxBuilder;
pub use error::{MailboxError, MailboxResult};
pub use queue::Mailbox;

// Convenience re-exports so users can `use ryker::mailbox::*;`
pub use observer::{DropReason, MailboxObserver, NoopObserver, Observer};

```

### crates/ryker/src/mailbox/observer.rs
<a id="crates-ryker-src-mailbox-observer-rs"></a>

```rust
/*! MailboxObserver hooks (stub). Forward to metrics facade without exporter lock-in. */

//! RO:WHAT — Mailbox-local observer trait re-exports and helpers.
//! RO:WHY  — Give callers a single `mailbox::observer` import surface.
//! RO:INTERACTS — Wraps `observe::metrics` to avoid leaking crate internals.
//! RO:INVARIANTS — Non-blocking hooks only; never hold locks across `.await`.

#![forbid(unsafe_code)]

pub use crate::observe::metrics::{DropReason, MailboxObserver, NoopObserver, Observer};

```

### crates/ryker/src/mailbox/queue.rs
<a id="crates-ryker-src-mailbox-queue-rs"></a>

```rust
//! RO:WHAT — Mailbox<T>: bounded queue facade around tokio mpsc, with split().
//! RO:WHY  — Single-consumer FIFO; Busy on overflow; per-message deadlines; explicit close via drop.
//! RO:INTERACTS — mailbox::observer hooks, errors.
//! RO:INVARIANTS — try_send rejects when full; pull uses timeout(deadline). No PII logged.

#![forbid(unsafe_code)]

use super::error::{MailboxError, MailboxResult};
use super::observer::{DropReason, Observer};
use crate::observe::trace;
use std::time::Duration;
use tokio::sync::mpsc;
use tokio::sync::mpsc::error::{SendError, TrySendError};

/// Factory wrapper that owns both ends until you call split().
pub struct Mailbox<T> {
    actor: String,
    tx: mpsc::Sender<T>,
    rx: mpsc::Receiver<T>,
    capacity: usize,
    max_msg_bytes: usize,
    deadline: Duration,
    observer: Observer,
}

impl<T> Mailbox<T> {
    pub(crate) fn new(
        actor: String,
        capacity: usize,
        max_msg_bytes: usize,
        deadline: Duration,
        observer: Observer,
    ) -> Self {
        let (tx, rx) = mpsc::channel(capacity);
        Self {
            actor,
            tx,
            rx,
            capacity,
            max_msg_bytes,
            deadline,
            observer,
        }
    }

    /// Non-blocking enqueue; returns Busy when full.
    pub fn try_send(&self, msg: T) -> MailboxResult<()> {
        match self.tx.try_send(msg) {
            Ok(()) => {
                // Depth is not exposed by tokio mpsc; still notify enqueue for hooks.
                self.observer.on_enqueue(&self.actor, 0);
                trace::span_enqueue(&self.actor, 0);
                Ok(())
            }
            Err(TrySendError::Full(_msg)) => {
                self.observer.on_drop(&self.actor, DropReason::Capacity);
                Err(MailboxError::Busy)
            }
            Err(TrySendError::Closed(_msg)) => Err(MailboxError::Closed),
        }
    }

    /// Blocking send with the mailbox’s per-message deadline (timeout).
    pub async fn send(&self, msg: T) -> MailboxResult<()> {
        tokio::select! {
            biased;
            _ = tokio::time::sleep(self.deadline) => {
                self.observer.on_timeout(&self.actor);
                trace::span_handle(&self.actor, "timeout", self.deadline.as_millis() as u64);
                Err(MailboxError::Timeout)
            }
            res = self.tx.send(msg) => {
                match res {
                    Ok(()) => Ok(()),
                    Err(SendError(_msg)) => Err(MailboxError::Closed),
                }
            }
        }
    }

    /// Pull one message, honoring the deadline as a receive timeout.
    pub async fn pull(&mut self) -> MailboxResult<T> {
        match tokio::time::timeout(self.deadline, self.rx.recv()).await {
            Ok(Some(m)) => Ok(m),
            Ok(None) => Err(MailboxError::Closed),
            Err(_) => {
                self.observer.on_timeout(&self.actor);
                trace::span_handle(&self.actor, "timeout", self.deadline.as_millis() as u64);
                Err(MailboxError::Timeout)
            }
        }
    }

    /// Configured bounded capacity.
    pub fn capacity(&self) -> usize {
        self.capacity
    }

    /// Deadline getter.
    pub fn deadline(&self) -> Duration {
        self.deadline
    }

    /// Split into a producer (tx) and consumer (rx). Dropping tx will *close*
    /// the channel, ensuring drains can terminate (recv => None).
    pub fn split(self) -> (MailboxTx<T>, MailboxRx<T>) {
        let Mailbox {
            actor,
            tx,
            rx,
            capacity: _,
            max_msg_bytes: _,
            deadline,
            observer,
        } = self;
        (
            MailboxTx {
                actor: actor.clone(),
                tx,
                observer: observer.clone(),
            },
            MailboxRx {
                actor,
                rx,
                deadline,
                observer,
            },
        )
    }
}

/// Send half of a mailbox.
pub struct MailboxTx<T> {
    actor: String,
    tx: mpsc::Sender<T>,
    observer: Observer,
}

impl<T> MailboxTx<T> {
    pub fn try_send(&self, msg: T) -> MailboxResult<()> {
        match self.tx.try_send(msg) {
            Ok(()) => {
                self.observer.on_enqueue(&self.actor, 0);
                trace::span_enqueue(&self.actor, 0);
                Ok(())
            }
            Err(TrySendError::Full(_msg)) => {
                self.observer.on_drop(&self.actor, DropReason::Capacity);
                Err(MailboxError::Busy)
            }
            Err(TrySendError::Closed(_msg)) => Err(MailboxError::Closed),
        }
    }

    pub async fn send(&self, msg: T) -> MailboxResult<()> {
        match self.tx.send(msg).await {
            Ok(()) => Ok(()),
            Err(SendError(_msg)) => Err(MailboxError::Closed),
        }
    }
}

/// Receive half of a mailbox.
pub struct MailboxRx<T> {
    actor: String,
    rx: mpsc::Receiver<T>,
    deadline: Duration,
    observer: Observer,
}

impl<T> MailboxRx<T> {
    pub async fn pull(&mut self) -> MailboxResult<T> {
        match tokio::time::timeout(self.deadline, self.rx.recv()).await {
            Ok(Some(m)) => Ok(m),
            Ok(None) => Err(MailboxError::Closed),
            Err(_) => {
                self.observer.on_timeout(&self.actor);
                trace::span_handle(&self.actor, "timeout", self.deadline.as_millis() as u64);
                Err(MailboxError::Timeout)
            }
        }
    }

    pub fn deadline(&self) -> Duration {
        self.deadline
    }
}

```

### crates/ryker/src/observe/metrics.rs
<a id="crates-ryker-src-observe-metrics-rs"></a>

```rust
//! RO:WHAT — Observer trait for mailbox lifecycle signals.
//! RO:WHY  — Allow hosts to increment counters/gauges without pulling prometheus here.
//! RO:INTERACTS — mailbox queue calls hooks on enqueue/drop/timeout/drain.
//! RO:INVARIANTS — must be non-blocking; cheap; thread-safe.

use std::sync::Arc;

#[derive(Clone)]
pub struct NoopObserver;

impl MailboxObserver for NoopObserver {
    fn on_enqueue(&self, _actor: &str, _depth: usize) {}
    fn on_drop(&self, _actor: &str, _reason: DropReason) {}
    fn on_timeout(&self, _actor: &str) {}
    fn on_restart(&self, _actor: &str) {}
}

#[derive(Clone, Copy, Debug)]
pub enum DropReason {
    Capacity,
    Closed,
}

pub trait MailboxObserver: Send + Sync + 'static {
    fn on_enqueue(&self, actor: &str, depth: usize);
    fn on_drop(&self, actor: &str, reason: DropReason);
    fn on_timeout(&self, actor: &str);
    fn on_restart(&self, actor: &str);
}

pub type Observer = Arc<dyn MailboxObserver>;

```

### crates/ryker/src/observe/mod.rs
<a id="crates-ryker-src-observe-mod-rs"></a>

```rust
//! RO:WHAT — Lightweight observability hooks (metrics/tracing integration points).
//! RO:WHY  — Keep ryker decoupled from metrics exporters; host wires Prometheus/OTEL.
//! RO:INTERACTS — mailbox builder/queue calls observer methods; tracing spans are optional.
//! RO:INVARIANTS — no heavy work in hooks; sampling controlled by config.

pub mod metrics;
pub mod trace;

pub use metrics::{MailboxObserver, NoopObserver};

```

### crates/ryker/src/observe/trace.rs
<a id="crates-ryker-src-observe-trace-rs"></a>

```rust
//! RO:WHAT — Optional tracing helpers (no-op without `tracing` feature).
//! RO:WHY  — Keep span names stable per docs; host chooses exporter.
//! RO:INVARIANTS — never log message bodies/PII.

#[inline]
pub fn span_enqueue(actor: &str, depth: usize) {
    #[cfg(feature = "tracing")]
    tracing::trace!(target="ryker", actor=%actor, queue_depth=%depth, "ryker.mailbox.enqueue");
}

#[inline]
pub fn span_handle(actor: &str, outcome: &str, deadline_ms: u64) {
    #[cfg(feature = "tracing")]
    tracing::trace!(target="ryker", actor=%actor, outcome=%outcome, deadline_ms=%deadline_ms, "ryker.actor.handle");
}

#[inline]
pub fn span_config_reload() {
    #[cfg(feature = "tracing")]
    tracing::info!(target = "ryker", "ryker.config.reload");
}

```

### crates/ryker/src/prelude.rs
<a id="crates-ryker-src-prelude-rs"></a>

```rust
//! RO:WHAT — Ergonomic re-exports for common ryker types.
//! RO:WHY  — DX; fewer deep module paths for apps embedding ryker.
//! RO:INTERACTS — re-exports from config, runtime, mailbox, supervisor.
//! RO:INVARIANTS — re-export only stable, documented surface.

pub use crate::config::RykerConfig;
pub use crate::errors::{Error, Result};
pub use crate::mailbox::{Mailbox, MailboxBuilder};
pub use crate::runtime::Runtime;
pub use crate::supervisor::Supervisor;

```

### crates/ryker/src/runtime/mod.rs
<a id="crates-ryker-src-runtime-mod-rs"></a>

```rust
//! RO:WHAT — Runtime facade holding the effective config snapshot.
//! RO:WHY  — Central factory for MailboxBuilder; no global executors.
//! RO:INTERACTS — mailbox builder/queue, observe hooks, config snapshot.
//! RO:INVARIANTS — snapshot immutable via Arc; hosts own task lifetimes.
#![allow(clippy::module_inception)]

mod runtime;

pub use runtime::Runtime;

```

### crates/ryker/src/runtime/runtime.rs
<a id="crates-ryker-src-runtime-runtime-rs"></a>

```rust
//! RO:WHAT — Runtime implementation and mailbox factory methods.
//! RO:WHY  — Host-owned container to spawn mailboxes with per-actor overrides.
//! RO:INTERACTS — config::RykerConfig, mailbox::{Mailbox, MailboxBuilder}.
//! RO:INVARIANTS — never allocates unbounded queues; respects defaults & overrides.

use crate::config::RykerConfig;
use crate::mailbox::{Mailbox, MailboxBuilder};
use std::sync::Arc;

#[derive(Clone)]
pub struct Runtime {
    cfg: Arc<RykerConfig>,
}

impl Runtime {
    pub fn new(cfg: RykerConfig) -> Self {
        Self { cfg: Arc::new(cfg) }
    }

    pub fn mailbox<T>(&self, actor_name: impl Into<String>) -> MailboxBuilder<T> {
        MailboxBuilder::new(actor_name.into(), self.cfg.clone())
    }

    /// Build a mailbox immediately with defaults (no overrides).
    pub fn mailbox_default<T>(&self, actor_name: impl Into<String>) -> Mailbox<T> {
        self.mailbox(actor_name).build()
    }

    /// Access the effective config snapshot.
    pub fn config(&self) -> Arc<RykerConfig> {
        self.cfg.clone()
    }
}

```

### crates/ryker/src/supervisor/backoff.rs
<a id="crates-ryker-src-supervisor-backoff-rs"></a>

```rust
//! RO:WHAT — Decorrelated jitter backoff calculator.
//! RO:WHY  — Avoid lockstep thundering herds; Concerns: RES.
//! RO:INVARIANTS — cap respected; base>0; deterministic bounds.

use rand::{rngs::StdRng, Rng, SeedableRng};

pub fn decorrelated_jitter(base_ms: u64, cap_ms: u64, prev_ms: u64, seed: u64) -> u64 {
    let mut rng = StdRng::seed_from_u64(seed ^ prev_ms);
    let next = (base_ms as f64).max((prev_ms as f64 * 3.0).min(cap_ms as f64));
    let jitter = rng.random_range(base_ms..=next as u64);
    jitter.min(cap_ms)
}

```

### crates/ryker/src/supervisor/mod.rs
<a id="crates-ryker-src-supervisor-mod-rs"></a>

```rust
//! RO:WHAT — Crash-only supervision with jittered backoff.
//! RO:WHY  — Resilience; restarts counted by host metrics via observe hooks.
//! RO:INTERACTS — backoff calc; host spawns async tasks; no global runtime.
//! RO:INVARIANTS — decorrelated jitter; bounded backoff; cancel-safe.
#![allow(clippy::module_inception)]

mod backoff;
mod supervisor;

pub use backoff::decorrelated_jitter;
pub use supervisor::Supervisor;

```

### crates/ryker/src/supervisor/supervisor.rs
<a id="crates-ryker-src-supervisor-supervisor-rs"></a>

```rust
//! RO:WHAT — Supervisor wrapper that restarts an async actor on failure.
//! RO:WHY  — Crash-only philosophy; Concerns: RES; host observes restarts.
//! RO:INTERACTS — config::SupervisionCfg (base/cap/jitter); tracing (optional).
//! RO:INVARIANTS — backoff grows to cap; cancellation cooperative.

use crate::config::RykerConfig;
use crate::supervisor::decorrelated_jitter;
use std::future::Future;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::task::JoinHandle;

pub struct Supervisor {
    cfg: Arc<RykerConfig>,
}

impl Supervisor {
    pub fn new(cfg: Arc<RykerConfig>) -> Self {
        Self { cfg }
    }

    /// Spawn an actor future; if it returns Err or panics, it will be restarted
    /// with decorrelated jitter until cancel() is observed by the actor.
    pub fn spawn<F, Fut>(&self, mut make_actor: F) -> JoinHandle<()>
    where
        F: FnMut() -> Fut + Send + 'static,
        Fut: Future<Output = anyhow::Result<()>> + Send + 'static,
    {
        let cfg = self.cfg.clone();
        tokio::spawn(async move {
            let mut backoff = cfg.supervisor.backoff_base_ms;
            let mut last_fail = Instant::now();
            loop {
                let res = make_actor().await;
                if res.is_ok() {
                    // Normal exit—do not restart.
                    break;
                }
                #[cfg(feature = "tracing")]
                tracing::warn!(target = "ryker", "actor failed; restarting");

                // Compute next delay with decorrelated jitter.
                let seed = last_fail.elapsed().as_millis() as u64;
                backoff = decorrelated_jitter(
                    cfg.supervisor.backoff_base_ms,
                    cfg.supervisor.backoff_cap_ms,
                    backoff,
                    seed,
                );
                tokio::time::sleep(Duration::from_millis(backoff)).await;
                last_fail = Instant::now();
            }
        })
    }
}

```

### crates/ryker/tests/feature_matrix.rs
<a id="crates-ryker-tests-featurematrix-rs"></a>

```rust
/*! Compile-only feature matrix checks (stub). Ensures public surface builds across combos. */

```

### crates/ryker/tests/integration/amnesia.rs
<a id="crates-ryker-tests-integration-amnesia-rs"></a>

```rust
/*! Gate: amnesia zeroize behavior on/off (stub test). */

```

### crates/ryker/tests/integration/backpressure.rs
<a id="crates-ryker-tests-integration-backpressure-rs"></a>

```rust
/*! Gate: full queue -> Busy + dropped_total{reason=capacity} (stub test). */

```

### crates/ryker/tests/integration/config_env_snapshot.rs
<a id="crates-ryker-tests-integration-configenvsnapshot-rs"></a>

```rust
/*! Gate: config precedence & validation (stub test). */

```

### crates/ryker/tests/integration/deadline.rs
<a id="crates-ryker-tests-integration-deadline-rs"></a>

```rust
/*! Gate: deadline -> outcome=timeout in histogram (stub test). */

```

### crates/ryker/tests/integration/metrics_contract.rs
<a id="crates-ryker-tests-integration-metricscontract-rs"></a>

```rust
/*! Gate: metrics contract golden test (stub). Compare to vectors/snapshots/metrics_contract.txt. */

```

### crates/ryker/tests/integration/reload_hot_cold.rs
<a id="crates-ryker-tests-integration-reloadhotcold-rs"></a>

```rust
/*! Gate: hot(deadline/fairness) vs cold(capacity/size) reload semantics (stub test). */

```

### crates/ryker/tests/integration/supervisor_backoff.rs
<a id="crates-ryker-tests-integration-supervisorbackoff-rs"></a>

```rust
/*! Gate: decorrelated jitter bounds + rapid-fail ceiling (stub test). */

```

### crates/ryker/tests/loom/loom_backpressure.rs
<a id="crates-ryker-tests-loom-loombackpressure-rs"></a>

```rust
/*! Loom: deterministic Busy under contention (stub). */

```

### crates/ryker/tests/loom/loom_mailbox_basic.rs
<a id="crates-ryker-tests-loom-loommailboxbasic-rs"></a>

```rust
/*! Loom: N producers -> 1 consumer; no deadlocks; FIFO per mailbox (stub). */

```

### crates/ryker/tests/loom/loom_shutdown.rs
<a id="crates-ryker-tests-loom-loomshutdown-rs"></a>

```rust
/*! Loom: graceful shutdown; cancel-safe; no double-drop (stub). */

```

### crates/ryker/tests/vectors/snapshots/config_snapshot.json
<a id="crates-ryker-tests-vectors-snapshots-configsnapshot-json"></a>

```json
{ "snapshot": true }

```

### crates/ryker/tests/vectors/snapshots/config_snapshot.toml
<a id="crates-ryker-tests-vectors-snapshots-configsnapshot-toml"></a>

```toml
# snapshot placeholder

```



---



# svc-overlay

_Source: crates/svc-overlay/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:44:10Z -->
# Code Bundle — `svc-overlay`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-overlay/.devcontainer/devcontainer.json](#crates-svc-overlay--devcontainer-devcontainer-json)
- [crates/svc-overlay/.github/workflows/ci.yml](#crates-svc-overlay--github-workflows-ci-yml)
- [crates/svc-overlay/.github/workflows/concurrency-guardrails.yml](#crates-svc-overlay--github-workflows-concurrency-guardrails-yml)
- [crates/svc-overlay/.github/workflows/contract-apis.yml](#crates-svc-overlay--github-workflows-contract-apis-yml)
- [crates/svc-overlay/.github/workflows/render-mermaid.yml](#crates-svc-overlay--github-workflows-render-mermaid-yml)
- [crates/svc-overlay/Cargo.toml](#crates-svc-overlay-Cargo-toml)
- [crates/svc-overlay/benches/handshake.rs](#crates-svc-overlay-benches-handshake-rs)
- [crates/svc-overlay/benches/oap_codec.rs](#crates-svc-overlay-benches-oapcodec-rs)
- [crates/svc-overlay/build.rs](#crates-svc-overlay-build-rs)
- [crates/svc-overlay/examples/libapi_embed.rs](#crates-svc-overlay-examples-libapiembed-rs)
- [crates/svc-overlay/examples/oap_client.rs](#crates-svc-overlay-examples-oapclient-rs)
- [crates/svc-overlay/examples/pq_embed.rs](#crates-svc-overlay-examples-pqembed-rs)
- [crates/svc-overlay/fuzz/fuzz_targets/gossip_lane.rs](#crates-svc-overlay-fuzz-fuzztargets-gossiplane-rs)
- [crates/svc-overlay/fuzz/fuzz_targets/oap_frame_parse.rs](#crates-svc-overlay-fuzz-fuzztargets-oapframeparse-rs)
- [crates/svc-overlay/scripts/roundtrip_overlay.sh](#crates-svc-overlay-scripts-roundtripoverlay-sh)
- [crates/svc-overlay/scripts/smoke_overlay.sh](#crates-svc-overlay-scripts-smokeoverlay-sh)
- [crates/svc-overlay/scripts/soak_overlay.sh](#crates-svc-overlay-scripts-soakoverlay-sh)
- [crates/svc-overlay/src/admin/health.rs](#crates-svc-overlay-src-admin-health-rs)
- [crates/svc-overlay/src/admin/metrics.rs](#crates-svc-overlay-src-admin-metrics-rs)
- [crates/svc-overlay/src/admin/mod.rs](#crates-svc-overlay-src-admin-mod-rs)
- [crates/svc-overlay/src/admin/ready.rs](#crates-svc-overlay-src-admin-ready-rs)
- [crates/svc-overlay/src/admin/version.rs](#crates-svc-overlay-src-admin-version-rs)
- [crates/svc-overlay/src/api/mod.rs](#crates-svc-overlay-src-api-mod-rs)
- [crates/svc-overlay/src/auth/macaroon.rs](#crates-svc-overlay-src-auth-macaroon-rs)
- [crates/svc-overlay/src/auth/mod.rs](#crates-svc-overlay-src-auth-mod-rs)
- [crates/svc-overlay/src/bootstrap.rs](#crates-svc-overlay-src-bootstrap-rs)
- [crates/svc-overlay/src/cli.rs](#crates-svc-overlay-src-cli-rs)
- [crates/svc-overlay/src/config.rs](#crates-svc-overlay-src-config-rs)
- [crates/svc-overlay/src/conn/error.rs](#crates-svc-overlay-src-conn-error-rs)
- [crates/svc-overlay/src/conn/mod.rs](#crates-svc-overlay-src-conn-mod-rs)
- [crates/svc-overlay/src/conn/reader.rs](#crates-svc-overlay-src-conn-reader-rs)
- [crates/svc-overlay/src/conn/supervisor.rs](#crates-svc-overlay-src-conn-supervisor-rs)
- [crates/svc-overlay/src/conn/tx.rs](#crates-svc-overlay-src-conn-tx-rs)
- [crates/svc-overlay/src/conn/writer.rs](#crates-svc-overlay-src-conn-writer-rs)
- [crates/svc-overlay/src/errors.rs](#crates-svc-overlay-src-errors-rs)
- [crates/svc-overlay/src/gossip/engine.rs](#crates-svc-overlay-src-gossip-engine-rs)
- [crates/svc-overlay/src/gossip/mod.rs](#crates-svc-overlay-src-gossip-mod-rs)
- [crates/svc-overlay/src/gossip/types.rs](#crates-svc-overlay-src-gossip-types-rs)
- [crates/svc-overlay/src/lib.rs](#crates-svc-overlay-src-lib-rs)
- [crates/svc-overlay/src/limits.rs](#crates-svc-overlay-src-limits-rs)
- [crates/svc-overlay/src/listener/mod.rs](#crates-svc-overlay-src-listener-mod-rs)
- [crates/svc-overlay/src/listener/plain.rs](#crates-svc-overlay-src-listener-plain-rs)
- [crates/svc-overlay/src/listener/ron.rs](#crates-svc-overlay-src-listener-ron-rs)
- [crates/svc-overlay/src/main.rs](#crates-svc-overlay-src-main-rs)
- [crates/svc-overlay/src/observe.rs](#crates-svc-overlay-src-observe-rs)
- [crates/svc-overlay/src/pq/mod.rs](#crates-svc-overlay-src-pq-mod-rs)
- [crates/svc-overlay/src/pq/negotiate.rs](#crates-svc-overlay-src-pq-negotiate-rs)
- [crates/svc-overlay/src/protocol/cbor.rs](#crates-svc-overlay-src-protocol-cbor-rs)
- [crates/svc-overlay/src/protocol/error.rs](#crates-svc-overlay-src-protocol-error-rs)
- [crates/svc-overlay/src/protocol/flags.rs](#crates-svc-overlay-src-protocol-flags-rs)
- [crates/svc-overlay/src/protocol/handshake.rs](#crates-svc-overlay-src-protocol-handshake-rs)
- [crates/svc-overlay/src/protocol/mod.rs](#crates-svc-overlay-src-protocol-mod-rs)
- [crates/svc-overlay/src/protocol/oap.rs](#crates-svc-overlay-src-protocol-oap-rs)
- [crates/svc-overlay/src/readiness/mod.rs](#crates-svc-overlay-src-readiness-mod-rs)
- [crates/svc-overlay/src/readiness/sampler.rs](#crates-svc-overlay-src-readiness-sampler-rs)
- [crates/svc-overlay/src/shutdown.rs](#crates-svc-overlay-src-shutdown-rs)
- [crates/svc-overlay/src/supervisor.rs](#crates-svc-overlay-src-supervisor-rs)
- [crates/svc-overlay/src/transport/mod.rs](#crates-svc-overlay-src-transport-mod-rs)
- [crates/svc-overlay/src/transport/quic.rs](#crates-svc-overlay-src-transport-quic-rs)
- [crates/svc-overlay/src/transport/tls.rs](#crates-svc-overlay-src-transport-tls-rs)
- [crates/svc-overlay/src/transport/tor.rs](#crates-svc-overlay-src-transport-tor-rs)
- [crates/svc-overlay/src/tuning.rs](#crates-svc-overlay-src-tuning-rs)
- [crates/svc-overlay/src/types.rs](#crates-svc-overlay-src-types-rs)
- [crates/svc-overlay/tests/http_contract.rs](#crates-svc-overlay-tests-httpcontract-rs)
- [crates/svc-overlay/tests/integration/oap_session_handshake.rs](#crates-svc-overlay-tests-integration-oapsessionhandshake-rs)
- [crates/svc-overlay/tests/integration/overlay_admin_roundtrip.rs](#crates-svc-overlay-tests-integration-overlayadminroundtrip-rs)
- [crates/svc-overlay/tests/integration/overlay_oap_streaming.rs](#crates-svc-overlay-tests-integration-overlayoapstreaming-rs)
- [crates/svc-overlay/tests/interop_vectors.rs](#crates-svc-overlay-tests-interopvectors-rs)
- [crates/svc-overlay/tests/loom/loom_overlay.rs](#crates-svc-overlay-tests-loom-loomoverlay-rs)
- [crates/svc-overlay/tests/metrics_schema.rs](#crates-svc-overlay-tests-metricsschema-rs)
- [crates/svc-overlay/tests/pq_negotiation.rs](#crates-svc-overlay-tests-pqnegotiation-rs)
- [crates/svc-overlay/tests/readiness_under_pressure.rs](#crates-svc-overlay-tests-readinessunderpressure-rs)

### crates/svc-overlay/.devcontainer/devcontainer.json
<a id="crates-svc-overlay--devcontainer-devcontainer-json"></a>

```json
{
  "name": "svc-overlay",
  "image": "mcr.microsoft.com/devcontainers/rust:1-1.80-bookworm",
  "features": {},
  "customizations": {
    "vscode": {
      "extensions": ["rust-lang.rust-analyzer", "serayuzgur.crates"]
    }
  },
  "postCreateCommand": "cargo fetch"
}

```

### crates/svc-overlay/.github/workflows/ci.yml
<a id="crates-svc-overlay--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy,rustfmt
      - name: Build
        run: cargo build -p svc-overlay
      - name: Clippy (deny warnings)
        run: cargo clippy -p svc-overlay -- -D warnings
      - name: Test
        run: cargo test -p svc-overlay --all-features
      - name: Doc tests
        run: cargo test -p svc-overlay --doc
      - name: Cargo deny
        run: cargo deny check
      - name: Cargo audit
        run: cargo install cargo-audit || true
      - name: Audit vulnerabilities
        run: cargo audit
      - name: Coverage (floor 85%)
        run: echo "(hook up your coverage tool here and fail below 85%)"

```

### crates/svc-overlay/.github/workflows/concurrency-guardrails.yml
<a id="crates-svc-overlay--github-workflows-concurrency-guardrails-yml"></a>

```yaml
name: concurrency-guardrails
on: [push, pull_request]
jobs:
  loom:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Loom interleavings
        run: RUSTFLAGS='--cfg loom' cargo test -p svc-overlay --test loom_overlay

```

### crates/svc-overlay/.github/workflows/contract-apis.yml
<a id="crates-svc-overlay--github-workflows-contract-apis-yml"></a>

```yaml
name: contract-apis
on: [push, pull_request]
jobs:
  public-api-and-schemas:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Cargo public-api
        run: |
          cargo install cargo-public-api || true
          cargo public-api -p svc-overlay > public-api.txt || true
      - name: Diff api-history snapshots
        run: echo "(compare against docs/api-history/svc-overlay/*)" 

```

### crates/svc-overlay/.github/workflows/render-mermaid.yml
<a id="crates-svc-overlay--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          mkdir -p docs
          for f in $(git ls-files '*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out"
          done

```

### crates/svc-overlay/Cargo.toml
<a id="crates-svc-overlay-Cargo-toml"></a>

```toml
[package]
name = "svc-overlay"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false
description = "RustyOnions overlay service: sessions & gossip (no DHT)"
readme = "README.md"

[features]
libapi = []
tls = ["dep:tokio-rustls"]   # enable TLS wiring when we hook it up
pq  = []                     # placeholder for future PQ handshake toggle
quic = []                    # placeholder for future QUIC
# Flip this to use the ron-transport adapter path (default build = plain TCP)
use_ron_transport = ["dep:ron-transport"]

[dependencies]
anyhow = "1.0.86"
thiserror = "1.0.63"
tokio = { version = "1.47.1", features = ["rt-multi-thread","macros","signal","time","sync","io-util"] }
tracing = "0.1.40"
tracing-subscriber = { version = "0.3.18", features = ["env-filter","fmt","json"] }
axum = { version = "0.7.9", features = ["http1","http2","json"] }   # no "tokio" feature here
hyper = "1.4.1"
prometheus = "0.14.0"
serde = { version = "1.0.214", features = ["derive"] }
serde_json = "1.0.132"
bytes = "1.7.1"
base64 = "0.22.1"
hex = "0.4.3"
sha2 = "0.10.8"
parking_lot = "0.12.3"
tokio-rustls = { version = "0.26.2", optional = true }
futures = "0.3.31"
bitflags = "2.6.0"

# Observability used by src/observe.rs
metrics = "0.24.1"
metrics-exporter-prometheus = "0.15.3"
once_cell = "1.19.0"

# Local workspace crates
ron-metrics   = { path = "../ron-metrics" }
ron-proto     = { path = "../ron-proto" }
ron-kernel    = { path = "../ron-kernel" }

# Optional transport (enabled by feature `use_ron_transport`)
ron-transport = { path = "../ron-transport", optional = true }

[dev-dependencies]
tokio = { version = "1.47.1", features = ["rt","macros","time"] }

```

### crates/svc-overlay/benches/handshake.rs
<a id="crates-svc-overlay-benches-handshake-rs"></a>

```rust
/*! handshake.rs — microbench placeholders
- Control-plane handshake latency; PQ-hybrid delta vs classic.
*/

```

### crates/svc-overlay/benches/oap_codec.rs
<a id="crates-svc-overlay-benches-oapcodec-rs"></a>

```rust
/*! oap_codec.rs — microbench placeholders
- Benchmarks for frame encode/decode at 1 KiB / 64 KiB / 1 MiB.
*/

```

### crates/svc-overlay/build.rs
<a id="crates-svc-overlay-build-rs"></a>

```rust
// RO:WHAT
//   Inject GIT_SHA and BUILD_TS envs for /version.
// RO:WHY
//   Make /version useful in dev and CI without runtime shelling.

use std::process::Command;

fn main() {
    // Best-effort short SHA
    if let Ok(out) = Command::new("git")
        .args(["rev-parse", "--short=12", "HEAD"])
        .output()
    {
        if out.status.success() {
            if let Ok(sha) = String::from_utf8(out.stdout) {
                println!("cargo:rustc-env=GIT_SHA={}", sha.trim());
            }
        }
    }
    // UTC-ish timestamp using std
    use std::time::{SystemTime, UNIX_EPOCH};
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    println!("cargo:rustc-env=BUILD_TS=unix:{now}");

    // Re-run on HEAD changes
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs");
}

```

### crates/svc-overlay/examples/libapi_embed.rs
<a id="crates-svc-overlay-examples-libapiembed-rs"></a>

```rust
//! Minimal client: dial localhost, do OAP/1 hello, send one DATA frame, read echo.
//! Run with: cargo run -p svc-overlay --example libapi_embed

use anyhow::Result;
use bytes::{Bytes, BytesMut};
use std::time::Duration;
use tokio::io::AsyncReadExt;
use tokio::net::TcpStream;

use svc_overlay::conn::writer::write_frame;
use svc_overlay::protocol::flags::Caps;
use svc_overlay::protocol::handshake::handshake;
use svc_overlay::protocol::oap::{try_parse_frame, Frame, FrameKind};

#[tokio::main]
async fn main() -> Result<()> {
    // Quick logger
    if std::env::var_os("RUST_LOG").is_none() {
        std::env::set_var("RUST_LOG", "info");
    }
    tracing_subscriber::fmt::init();

    // 1) Connect to the overlay's temporary listener.
    let addr = "127.0.0.1:9700";
    tracing::info!("dialing {addr}");
    let mut sock = TcpStream::connect(addr).await?;
    tracing::info!("connected; performing OAP/1 handshake");

    // 2) Symmetric OAP/1 hello.
    let caps = Caps::GOSSIP_V1;
    let neg = handshake(&mut sock, caps, Duration::from_secs(3)).await?;
    tracing::info!("negotiated: ver={}, caps={:?}", neg.version, neg.caps);

    // 3) Send a single DATA frame.
    let payload = Bytes::from_static(b"hello, overlay!");
    let frame = Frame {
        kind: FrameKind::Data,
        payload: payload.clone(),
    };
    let mut scratch = BytesMut::with_capacity(1024);
    write_frame(&mut sock, &frame, &mut scratch).await?;
    tracing::info!("sent one DATA frame; waiting for echo");

    // 4) Read back echo and print.
    let mut inbuf = BytesMut::with_capacity(4096);
    loop {
        // Try parse any buffered frames first.
        if let Some(f) = try_parse_frame(&mut inbuf)? {
            if let FrameKind::Data = f.kind {
                let text = String::from_utf8_lossy(&f.payload);
                println!("echo from overlay: {}", text);
                break;
            }
        }
        // Need more bytes.
        let n = sock.read_buf(&mut inbuf).await?;
        if n == 0 {
            anyhow::bail!("server closed before echo");
        }
    }

    Ok(())
}

```

### crates/svc-overlay/examples/oap_client.rs
<a id="crates-svc-overlay-examples-oapclient-rs"></a>

```rust
use anyhow::{anyhow, Result};
use bytes::BytesMut;
use std::net::SocketAddr;
use std::time::Duration;
use tokio::io::AsyncReadExt;
use tokio::net::TcpStream;

use svc_overlay::conn::writer::write_frame;
use svc_overlay::protocol::flags::Caps;
use svc_overlay::protocol::handshake::handshake;
use svc_overlay::protocol::oap::{try_parse_frame, Frame, FrameKind};

#[tokio::main]
async fn main() -> Result<()> {
    let addr: SocketAddr = std::env::var("OVERLAY_ADDR")
        .unwrap_or_else(|_| "127.0.0.1:9700".into())
        .parse()?;

    eprintln!("[client] connecting to {}", addr);
    let mut sock = TcpStream::connect(addr).await?;

    // Handshake to match server
    let caps = Caps::GOSSIP_V1;
    let neg = handshake(&mut sock, caps, Duration::from_secs(3)).await?;
    eprintln!(
        "[client] negotiated version={} caps={:?}",
        neg.version, neg.caps
    );

    // Send one Data frame and verify echo
    let mut outbuf = BytesMut::with_capacity(1024);
    let mut inbuf = BytesMut::with_capacity(1024);

    let payload = b"hello-overlay";
    let frame = Frame {
        kind: FrameKind::Data,
        payload: payload.as_slice().into(),
    };
    write_frame(&mut sock, &frame, &mut outbuf).await?;

    loop {
        while let Some(f) = try_parse_frame(&mut inbuf)? {
            if let FrameKind::Data = f.kind {
                if f.payload.as_ref() == payload {
                    eprintln!("[client] got echo OK");
                    return Ok(());
                } else {
                    return Err(anyhow!("unexpected payload {:?}", f.payload));
                }
            }
        }
        let n = sock.read_buf(&mut inbuf).await?;
        if n == 0 {
            return Err(anyhow!("server closed before echo"));
        }
    }
}

```

### crates/svc-overlay/examples/pq_embed.rs
<a id="crates-svc-overlay-examples-pqembed-rs"></a>

```rust
/*! pq_embed.rs — example placeholder
Demonstrates enabling transport-level PQ hybrid posture via feature flags.
*/

```

### crates/svc-overlay/fuzz/fuzz_targets/gossip_lane.rs
<a id="crates-svc-overlay-fuzz-fuzztargets-gossiplane-rs"></a>

```rust
// fuzz target placeholder: gossip lane scheduler/backpressure\n
```

### crates/svc-overlay/fuzz/fuzz_targets/oap_frame_parse.rs
<a id="crates-svc-overlay-fuzz-fuzztargets-oapframeparse-rs"></a>

```rust
// fuzz target placeholder: OAP envelope parsing edge cases\n
```

### crates/svc-overlay/scripts/roundtrip_overlay.sh
<a id="crates-svc-overlay-scripts-roundtripoverlay-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT
#   Launch svc-overlay, run the OAP client N times, scrape metrics, teardown.
# RO:USAGE
#   chmod +x crates/svc-overlay/scripts/roundtrip_overlay.sh
#   crates/svc-overlay/scripts/roundtrip_overlay.sh 3

set -euo pipefail

RUNS="${1:-3}"
ADMIN_ADDR="${ADMIN_ADDR:-127.0.0.1:9600}"
OVERLAY_ADDR="${OVERLAY_ADDR:-127.0.0.1:9700}"
RUST_LOG="${RUST_LOG:-svc_overlay=info}"

log(){ printf '[roundtrip] %s\n' "$*" >&2; }

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

log "fmt + clippy"
cargo fmt -p svc-overlay
cargo clippy -p svc-overlay --no-deps -- -D warnings

log "building server + oap_client example (only)"
cargo build -p svc-overlay --example oap_client

RUN_LOG="target/svc-overlay.roundtrip.log"
: > "$RUN_LOG"
log "launching svc-overlay (logs → $RUN_LOG)"
RUST_LOG="$RUST_LOG" cargo run -p svc-overlay >"$RUN_LOG" 2>&1 &
SVC_PID=$!

cleanup(){
  set +e
  if kill -0 "$SVC_PID" >/dev/null 2>&1; then
    log "stopping svc-overlay (pid $SVC_PID)"
    kill "$SVC_PID" || true
    sleep 0.3
    kill -9 "$SVC_PID" 2>/dev/null || true
  fi
}
trap cleanup EXIT INT TERM

log "waiting for admin @ http://$ADMIN_ADDR/healthz"
for i in {1..60}; do
  curl -sf "http://$ADMIN_ADDR/healthz" >/dev/null && break
  sleep 0.2
  [[ $i -eq 60 ]] && { log "timeout waiting for admin"; tail -n 120 "$RUN_LOG" || true; exit 1; }
done

# Also wait for TCP port to accept (macOS-friendly: use nc -z)
HOST="${OVERLAY_ADDR%:*}"
PORT="${OVERLAY_ADDR##*:}"
log "waiting for overlay TCP ${HOST}:${PORT}"
for i in {1..60}; do
  if nc -z "$HOST" "$PORT" >/dev/null 2>&1; then
    break
  fi
  sleep 0.2
  [[ $i -eq 60 ]] && { log "timeout waiting for overlay TCP"; tail -n 120 "$RUN_LOG" || true; exit 1; }
done

show_metrics(){
  curl -sSf "http://$ADMIN_ADDR/metrics" \
    | grep -E 'overlay_build_info|overlay_sessions_active|overlay_(accept_latency_seconds|frames_in_total|frames_out_total|bytes_in_total|bytes_out_total)' \
    || true
}

log "baseline metrics"
show_metrics

for n in $(seq 1 "$RUNS"); do
  log "client run $n/$RUNS"
  OVERLAY_ADDR="$OVERLAY_ADDR" cargo run -q -p svc-overlay --example oap_client || {
    log "client failed on run $n"
    tail -n 120 "$RUN_LOG" || true
    exit 1
  }
done

log "post-runs metrics"
show_metrics

log "recent server logs:"
tail -n 120 "$RUN_LOG" || true

log "done"

```

### crates/svc-overlay/scripts/smoke_overlay.sh
<a id="crates-svc-overlay-scripts-smokeoverlay-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT
#   One-button smoke test for svc-overlay:
#     - fmt + clippy
#     - launch svc-overlay (background)
#     - wait for admin /healthz
#     - open a few test sockets (nc)
#     - scrape metrics (gauge + histogram)
#     - clean shutdown
#
# RO:USAGE
#   chmod +x crates/svc-overlay/scripts/smoke_overlay.sh
#   crates/svc-overlay/scripts/smoke_overlay.sh
#
# RO:CONFIG
#   ADMIN_ADDR:  admin HTTP bind (default 127.0.0.1:9600)
#   OVERLAY_ADDR: overlay TCP bind (default 127.0.0.1:9700)
#   RUST_LOG: set logging for the run (default svc_overlay=info)

set -euo pipefail

ADMIN_ADDR="${ADMIN_ADDR:-127.0.0.1:9600}"
OVERLAY_ADDR="${OVERLAY_ADDR:-127.0.0.1:9700}"
RUST_LOG="${RUST_LOG:-svc_overlay=info}"

log() { printf '[smoke] %s\n' "$*" >&2; }

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT_DIR"

log "fmt + clippy"
cargo fmt -p svc-overlay
cargo clippy -p svc-overlay --no-deps -- -D warnings

RUN_LOG="target/svc-overlay.smoke.log"
: > "$RUN_LOG"

log "launching svc-overlay (logs → $RUN_LOG)"
RUST_LOG="$RUST_LOG" cargo run -p svc-overlay >"$RUN_LOG" 2>&1 &
SVC_PID=$!

cleanup() {
  set +e
  if kill -0 "$SVC_PID" >/dev/null 2>&1; then
    log "stopping svc-overlay (pid $SVC_PID)"
    kill "$SVC_PID" || true
    sleep 0.5
    kill -9 "$SVC_PID" 2>/dev/null || true
  fi
}
trap cleanup EXIT INT TERM

# Wait for /healthz
log "waiting for admin to be up at http://$ADMIN_ADDR/healthz"
for i in {1..60}; do
  if curl -sf "http://$ADMIN_ADDR/healthz" >/dev/null; then
    log "admin is up"
    break
  fi
  sleep 0.25
  if ! kill -0 "$SVC_PID" >/dev/null 2>&1; then
    log "svc-overlay terminated unexpectedly"
    tail -n 200 "$RUN_LOG" >&2 || true
    exit 1
  fi
  if [[ $i -eq 60 ]]; then
    log "timeout waiting for admin"
    tail -n 200 "$RUN_LOG" >&2 || true
    exit 1
  fi
done

# Helper to show key metrics
show_metrics() {
  curl -sSf "http://$ADMIN_ADDR/metrics" \
  | grep -E 'overlay_build_info|overlay_sessions_active|overlay_accept_latency_seconds_(count|sum)' \
  || true
}

log "initial metrics snapshot"
show_metrics

# Function to open a short-lived socket (which will handshake-timeout in ~3s)
short_socket() {
  # Use a subshell so we can background it cleanly
  (
    # macOS/BSD nc: -w <secs> is a write timeout; best effort: just sleep then exit
    # We want the server to see an accept and then a timeout/close
    exec nc "$(cut -d: -f1 <<<"$OVERLAY_ADDR")" "$(cut -d: -f2 <<<"$OVERLAY_ADDR")"
  ) &
  NC_PID=$!
  sleep 3.2
  kill -INT "$NC_PID" 2>/dev/null || true
  wait "$NC_PID" 2>/dev/null || true
}

# Function to open a long socket so we can watch the gauge at 1
long_socket_open() {
  (
    exec nc "$(cut -d: -f1 <<<"$OVERLAY_ADDR")" "$(cut -d: -f2 <<<"$OVERLAY_ADDR")"
  ) &
  echo $!
}

log "opening one long-lived socket to demonstrate overlay_sessions_active=1"
LONG_PID="$(long_socket_open)"
sleep 0.2
show_metrics

log "closing long-lived socket"
kill -INT "$LONG_PID" 2>/dev/null || true
wait "$LONG_PID" 2>/dev/null || true
sleep 0.2
show_metrics

log "opening two short-lived sockets to tick the latency histogram"
short_socket
show_metrics
short_socket
show_metrics

log "final metrics snapshot"
show_metrics

log "tail of runtime logs:"
tail -n 40 "$RUN_LOG" || true

log "done"

```

### crates/svc-overlay/scripts/soak_overlay.sh
<a id="crates-svc-overlay-scripts-soakoverlay-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# RO:WHAT  — Lightweight soak/chaos for svc-overlay echo path.
# RO:USAGE — ./crates/svc-overlay/scripts/soak_overlay.sh [seconds] [concurrency]
#            Defaults: 30s, 16 clients
# RO:NOTE  — Uses the existing oap_client example via the roundtrip driver.

DURATION="${1:-30}"
CONCURRENCY="${2:-16}"

echo "[soak] duration=${DURATION}s concurrency=${CONCURRENCY}"
echo "[soak] RON_OVERLAY_TX_WATERMARK=${RON_OVERLAY_TX_WATERMARK:-<default>} RON_OVERLAY_HANDSHAKE_MS=${RON_OVERLAY_HANDSHAKE_MS:-<default>}"

# Ensure server is up
if ! curl -fsS http://127.0.0.1:9600/healthz >/dev/null ; then
  echo "[soak] server not up on 127.0.0.1:9600 — start it first (e.g., cargo run -p svc-overlay)"
  exit 1
fi

# Warm baseline metrics
echo "[soak] baseline overlay_* sample:"
curl -fsS http://127.0.0.1:9600/metrics | rg '^overlay_' | head -n 20 || true

echo "[soak] kicking off clients…"
end=$(( SECONDS + DURATION ))
i=0
fails=0

run_client() {
  # Same client path the roundtrip script uses
  target/debug/examples/oap_client 127.0.0.1:9700 >/dev/null 2>&1 || return 1
  return 0
}

# Fire-and-forget workers
while [ $SECONDS -lt $end ]; do
  for _ in $(seq 1 "$CONCURRENCY"); do
    run_client & pid=$!
    pids+=("$pid")
  done
  # Reap in batches
  for p in "${pids[@]:-}"; do
    if ! wait "$p"; then
      fails=$((fails+1))
    fi
  done
  unset pids
  i=$((i+CONCURRENCY))
done

echo "[soak] completed launches: ${i}, failures: ${fails}"

echo "[soak] post-run overlay_* sample:"
curl -fsS http://127.0.0.1:9600/metrics | rg '^overlay_' | head -n 50 || true

echo "[soak] readiness snapshot:"
curl -fsS http://127.0.0.1:9600/readyz | jq .

```

### crates/svc-overlay/src/admin/health.rs
<a id="crates-svc-overlay-src-admin-health-rs"></a>

```rust
//! /healthz — liveness only (process loop tick).

use axum::{response::IntoResponse, Json};
use serde::Serialize;

#[derive(Serialize)]
struct Health {
    alive: bool,
}

pub async fn healthz() -> impl IntoResponse {
    Json(Health { alive: true })
}

```

### crates/svc-overlay/src/admin/metrics.rs
<a id="crates-svc-overlay-src-admin-metrics-rs"></a>

```rust
//! RO:WHAT
//!   Prometheus exporter for /metrics backed by the default registry.
//!
//! RO:WHY
//!   Self-initialize overlay metrics and build_info so the endpoint is never empty.
//!
//! RO:INTERACTS
//!   - Other modules bump overlay metrics via `overlay_metrics::*`.
//!
//! RO:INVARIANTS
//!   - Single global registry; encode errors return 500; no panics.

use axum::{
    http::{header, StatusCode},
    response::IntoResponse,
};
use once_cell::sync::Lazy;
use prometheus::{
    Encoder, Histogram, HistogramOpts, IntCounterVec, IntGauge, IntGaugeVec, Opts, Registry,
    TextEncoder,
};
use tracing::warn;

static GLOBAL_REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);

fn ensure_registered() {
    let _ = &*OVERLAY_SESSIONS_ACTIVE;
    let _ = &*OVERLAY_ACCEPT_LATENCY_SECONDS;
    let _ = &*BUILD_INFO;
    let _ = &*OVERLAY_HANDSHAKE_FAIL_TOTAL;
    let _ = &*OVERLAY_PEER_TX_DROPPED_TOTAL;
    let _ = &*OVERLAY_PEER_TX_DEPTH;
    let _ = &*OVERLAY_CONN_LIFETIME_SECONDS;
}

static OVERLAY_SESSIONS_ACTIVE: Lazy<IntGauge> = Lazy::new(|| {
    let g = IntGauge::with_opts(Opts::new(
        "overlay_sessions_active",
        "Current number of active overlay sessions",
    ))
    .expect("gauge");
    GLOBAL_REGISTRY
        .register(Box::new(g.clone()))
        .expect("register overlay_sessions_active");
    g
});

static OVERLAY_ACCEPT_LATENCY_SECONDS: Lazy<Histogram> = Lazy::new(|| {
    let h = Histogram::with_opts(
        HistogramOpts::new(
            "overlay_accept_latency_seconds",
            "Time from accept to handshake start",
        )
        .buckets(vec![
            0.00005, 0.0001, 0.0002, 0.0005, 0.001, 0.002, 0.005, 0.01,
        ]),
    )
    .expect("histogram");
    GLOBAL_REGISTRY
        .register(Box::new(h.clone()))
        .expect("register overlay_accept_latency_seconds");
    h
});

static OVERLAY_CONN_LIFETIME_SECONDS: Lazy<Histogram> = Lazy::new(|| {
    let h = Histogram::with_opts(HistogramOpts::new(
        "overlay_conn_lifetime_seconds",
        "Lifetime of a connection (from handshake ok to close)",
    ))
    .expect("histogram");
    GLOBAL_REGISTRY
        .register(Box::new(h.clone()))
        .expect("register overlay_conn_lifetime_seconds");
    h
});

static OVERLAY_HANDSHAKE_FAIL_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    let c = IntCounterVec::new(
        Opts::new(
            "overlay_handshake_fail_total",
            "Handshake failures by reason",
        ),
        &["reason"],
    )
    .expect("counter");
    GLOBAL_REGISTRY
        .register(Box::new(c.clone()))
        .expect("register overlay_handshake_fail_total");
    c
});

static OVERLAY_PEER_TX_DROPPED_TOTAL: Lazy<IntGauge> = Lazy::new(|| {
    let g = IntGauge::with_opts(Opts::new(
        "overlay_peer_dropped_total",
        "Total frames dropped due to full per-peer TX queue (process lifetime)",
    ))
    .expect("gauge");
    GLOBAL_REGISTRY
        .register(Box::new(g.clone()))
        .expect("register overlay_peer_dropped_total");
    g
});

static OVERLAY_PEER_TX_DEPTH: Lazy<IntGauge> = Lazy::new(|| {
    let g = IntGauge::with_opts(Opts::new(
        "overlay_peer_queue_depth",
        "Current per-peer TX queue depth (most recent writer task)",
    ))
    .expect("gauge");
    GLOBAL_REGISTRY
        .register(Box::new(g.clone()))
        .expect("register overlay_peer_queue_depth");
    g
});

static BUILD_INFO: Lazy<IntGaugeVec> = Lazy::new(|| {
    let v = IntGaugeVec::new(
        Opts::new(
            "overlay_build_info",
            "Build info for svc-overlay (value is always 1)",
        ),
        &["version", "git"],
    )
    .expect("gauge vec");
    GLOBAL_REGISTRY
        .register(Box::new(v.clone()))
        .expect("register overlay_build_info");
    v
});

pub mod overlay_metrics {
    use super::*;
    pub fn ensure() {
        super::ensure_registered();
    }
    pub fn inc_sessions_active() {
        OVERLAY_SESSIONS_ACTIVE.inc();
    }
    pub fn dec_sessions_active() {
        OVERLAY_SESSIONS_ACTIVE.dec();
    }
    pub fn accept_latency_seconds(v: f64) {
        OVERLAY_ACCEPT_LATENCY_SECONDS.observe(v);
    }
    pub fn conn_lifetime_seconds(v: f64) {
        OVERLAY_CONN_LIFETIME_SECONDS.observe(v);
    }
    pub fn handshake_fail(reason: &'static str) {
        OVERLAY_HANDSHAKE_FAIL_TOTAL
            .with_label_values(&[reason])
            .inc();
    }
    pub fn set_build_info(version: &'static str, git: &'static str) {
        BUILD_INFO.with_label_values(&[version, git]).set(1);
    }
    pub fn set_peer_tx_depth(depth: usize) {
        OVERLAY_PEER_TX_DEPTH.set(depth as i64);
    }
    pub fn inc_peer_tx_dropped() {
        OVERLAY_PEER_TX_DROPPED_TOTAL.inc();
    }

    // NEW: lightweight getters for the sampler.
    pub fn get_peer_tx_depth() -> i64 {
        OVERLAY_PEER_TX_DEPTH.get()
    }
    pub fn get_sessions_active() -> i64 {
        OVERLAY_SESSIONS_ACTIVE.get()
    }
}

/// GET /metrics — Prometheus exposition format
pub async fn handle_metrics() -> impl IntoResponse {
    ensure_registered();

    let mut buf = Vec::with_capacity(64 * 1024);
    let encoder = TextEncoder::new();
    let metrics = prometheus::gather();
    if let Err(e) = encoder.encode(&metrics, &mut buf) {
        warn!(error=?e, "failed to encode prometheus metrics");
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            [("content-type", "text/plain")],
            "encode failed",
        )
            .into_response();
    }

    (
        StatusCode::OK,
        [(header::CONTENT_TYPE.as_str(), encoder.format_type())],
        buf,
    )
        .into_response()
}

```

### crates/svc-overlay/src/admin/mod.rs
<a id="crates-svc-overlay-src-admin-mod-rs"></a>

```rust
//! RO:WHAT
//!   Admin plane: router(), ReadyProbe gates, /healthz, /readyz, /version, /metrics.
//! RO:WHY
//!   Matches bootstrap’s expected API (router(probe, ver), ReadyProbe::set(..)).
//! RO:INVARIANTS
//!   - Truthful readiness: 200 only when all gates are satisfied.
//!   - Cheap atomics; /readyz lists missing gates when not ready.

use axum::{extract::State, response::IntoResponse, routing::get, Json, Router};
use serde::Serialize;
use std::net::SocketAddr;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

pub mod metrics;
pub use metrics::handle_metrics;

pub mod version;
pub use version::{current_build_info, BuildInfo};

/// Readiness gates container (Arc so we can clone into tasks).
#[derive(Clone)]
pub struct ReadyProbe(Arc<ReadyInner>);

struct ReadyInner {
    listeners_bound: AtomicBool,
    metrics_bound: AtomicBool,
    cfg_loaded: AtomicBool,
    queues_ok: AtomicBool,
    shed_rate_ok: AtomicBool,
    fd_headroom: AtomicBool,
}

/// Mutable view used by `ReadyProbe::set` to emulate your original closure API.
#[derive(Default)]
pub struct ReadyState {
    pub listeners_bound: bool,
    pub metrics_bound: bool,
    pub cfg_loaded: bool,
    pub queues_ok: bool,
    pub shed_rate_ok: bool,
    pub fd_headroom: bool,
}

impl Default for ReadyProbe {
    fn default() -> Self {
        Self::new()
    }
}

impl ReadyProbe {
    pub fn new() -> Self {
        Self(Arc::new(ReadyInner {
            listeners_bound: AtomicBool::new(false),
            metrics_bound: AtomicBool::new(false),
            cfg_loaded: AtomicBool::new(false),
            queues_ok: AtomicBool::new(true),
            shed_rate_ok: AtomicBool::new(true),
            fd_headroom: AtomicBool::new(true),
        }))
    }

    #[inline]
    pub fn set_listeners_bound(&self, v: bool) {
        self.0.listeners_bound.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_metrics_bound(&self, v: bool) {
        self.0.metrics_bound.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_cfg_loaded(&self, v: bool) {
        self.0.cfg_loaded.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_queues_ok(&self, v: bool) {
        self.0.queues_ok.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_shed_rate_ok(&self, v: bool) {
        self.0.shed_rate_ok.store(v, Ordering::Relaxed);
    }
    #[inline]
    pub fn set_fd_headroom(&self, v: bool) {
        self.0.fd_headroom.store(v, Ordering::Relaxed);
    }

    /// API compatibility shim for prior `probe.set(|s| s.<gate> = ..).await` usage.
    /// This is `async` to match call sites; it performs stores immediately.
    pub async fn set<F>(&self, f: F)
    where
        F: FnOnce(&mut ReadyState),
    {
        // snapshot
        let mut st = ReadyState {
            listeners_bound: self.0.listeners_bound.load(Ordering::Relaxed),
            metrics_bound: self.0.metrics_bound.load(Ordering::Relaxed),
            cfg_loaded: self.0.cfg_loaded.load(Ordering::Relaxed),
            queues_ok: self.0.queues_ok.load(Ordering::Relaxed),
            shed_rate_ok: self.0.shed_rate_ok.load(Ordering::Relaxed),
            fd_headroom: self.0.fd_headroom.load(Ordering::Relaxed),
        };
        // mutate
        f(&mut st);
        // store
        self.0
            .listeners_bound
            .store(st.listeners_bound, Ordering::Relaxed);
        self.0
            .metrics_bound
            .store(st.metrics_bound, Ordering::Relaxed);
        self.0.cfg_loaded.store(st.cfg_loaded, Ordering::Relaxed);
        self.0.queues_ok.store(st.queues_ok, Ordering::Relaxed);
        self.0
            .shed_rate_ok
            .store(st.shed_rate_ok, Ordering::Relaxed);
        self.0.fd_headroom.store(st.fd_headroom, Ordering::Relaxed);
    }

    fn snapshot(&self) -> Gates {
        Gates {
            listeners_bound: self.0.listeners_bound.load(Ordering::Relaxed),
            metrics_bound: self.0.metrics_bound.load(Ordering::Relaxed),
            cfg_loaded: self.0.cfg_loaded.load(Ordering::Relaxed),
            queues_ok: self.0.queues_ok.load(Ordering::Relaxed),
            shed_rate_ok: self.0.shed_rate_ok.load(Ordering::Relaxed),
            fd_headroom: self.0.fd_headroom.load(Ordering::Relaxed),
        }
    }
}

#[derive(Clone)]
pub struct AdminState {
    pub probe: ReadyProbe,
    pub build: BuildInfo,
}

#[derive(Serialize)]
struct Health {
    alive: bool,
}

async fn handle_healthz() -> Json<Health> {
    Json(Health { alive: true })
}

#[derive(Serialize)]
struct ReadyBody<'a> {
    ready: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    missing: Option<&'a [&'a str]>,
}

#[derive(Default)]
struct Gates {
    listeners_bound: bool,
    metrics_bound: bool,
    cfg_loaded: bool,
    queues_ok: bool,
    shed_rate_ok: bool,
    fd_headroom: bool,
}

impl Gates {
    fn all_ready(&self) -> bool {
        self.listeners_bound
            && self.metrics_bound
            && self.cfg_loaded
            && self.queues_ok
            && self.shed_rate_ok
            && self.fd_headroom
    }
    fn missing(&self) -> Vec<&'static str> {
        let mut v = Vec::with_capacity(6);
        if !self.listeners_bound {
            v.push("listeners_bound");
        }
        if !self.metrics_bound {
            v.push("metrics_bound");
        }
        if !self.cfg_loaded {
            v.push("cfg_loaded");
        }
        if !self.queues_ok {
            v.push("queues_ok");
        }
        if !self.shed_rate_ok {
            v.push("shed_rate_ok");
        }
        if !self.fd_headroom {
            v.push("fd_headroom");
        }
        v
    }
}

async fn handle_readyz(State(state): State<AdminState>) -> impl IntoResponse {
    use axum::http::StatusCode;
    let snap = state.probe.snapshot();
    if snap.all_ready() {
        (
            StatusCode::OK,
            Json(ReadyBody {
                ready: true,
                missing: None,
            }),
        )
            .into_response()
    } else {
        let miss = snap.missing();
        (
            StatusCode::SERVICE_UNAVAILABLE,
            Json(ReadyBody {
                ready: false,
                missing: Some(&miss),
            }),
        )
            .into_response()
    }
}

/// Build the admin router with state and handlers (what bootstrap expects).
pub fn router(probe: ReadyProbe, build: BuildInfo) -> Router {
    let state = AdminState { probe, build };
    Router::new()
        .route("/healthz", get(handle_healthz))
        .route("/readyz", get(handle_readyz))
        .route("/version", get(version::handle_version))
        .route("/metrics", get(metrics::handle_metrics))
        .with_state(state)
}

/// Helper to run the admin plane on an address.
pub async fn serve_admin(
    bind: SocketAddr,
    probe: ReadyProbe,
    build: BuildInfo,
) -> anyhow::Result<()> {
    let app = router(probe, build);
    let listener = tokio::net::TcpListener::bind(bind).await?;
    tracing::info!(addr=?bind, "admin server listening");
    axum::serve(listener, app).await?;
    Ok(())
}

```

### crates/svc-overlay/src/admin/ready.rs
<a id="crates-svc-overlay-src-admin-ready-rs"></a>

```rust
//! /readyz — truthful readiness gate. JSON schema kept stable.

use axum::{extract::State, response::IntoResponse, Json};
use serde::Serialize;
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Clone, Default)]
pub struct ReadyProbe(Arc<RwLock<ReadyState>>);

#[derive(Default, Clone)]
pub struct ReadyState {
    pub listeners_bound: bool,
    pub metrics_bound: bool,
    pub cfg_loaded: bool,
    pub queues_ok: bool,
    pub shed_rate_ok: bool,
    pub fd_headroom: bool,
    pub pq_ready: Option<bool>,
    pub tor_bootstrap: Option<bool>,
}

impl ReadyProbe {
    pub fn new() -> Self {
        Self::default()
    }

    pub async fn set<F: FnOnce(&mut ReadyState)>(&self, f: F) {
        let mut g = self.0.write().await;
        f(&mut g);
    }

    pub async fn snapshot(&self) -> ReadyState {
        self.0.read().await.clone()
    }
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct ReadyResp {
    ready: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    degraded: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    missing: Option<Vec<&'static str>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    retry_after: Option<u64>,
}

#[inline]
fn need(flag: bool, name: &'static str, out: &mut Vec<&'static str>) {
    if !flag {
        out.push(name);
    }
}

/// Axum handler for `/readyz`.
pub async fn readyz(State(probe): State<ReadyProbe>) -> impl IntoResponse {
    let s = probe.snapshot().await;
    let mut missing = Vec::new();

    need(s.listeners_bound, "listeners_bound", &mut missing);
    need(s.metrics_bound, "metrics_bound", &mut missing);
    need(s.cfg_loaded, "cfg_loaded", &mut missing);
    need(s.queues_ok, "queues_ok", &mut missing);
    need(s.shed_rate_ok, "shed_rate_ok", &mut missing);
    need(s.fd_headroom, "fd_headroom", &mut missing);
    if let Some(false) = s.pq_ready {
        missing.push("pq_ready");
    }
    if let Some(false) = s.tor_bootstrap {
        missing.push("tor_bootstrap");
    }

    if missing.is_empty() {
        (
            axum::http::StatusCode::OK,
            Json(ReadyResp {
                ready: true,
                degraded: None,
                missing: None,
                retry_after: None,
            }),
        )
    } else {
        (
            axum::http::StatusCode::SERVICE_UNAVAILABLE,
            Json(ReadyResp {
                ready: false,
                degraded: Some(true),
                missing: Some(missing),
                retry_after: Some(5),
            }),
        )
    }
}

```

### crates/svc-overlay/src/admin/version.rs
<a id="crates-svc-overlay-src-admin-version-rs"></a>

```rust
//! RO:WHAT
//!   Build metadata surface (type + handler) for /version.
//! RO:WHY
//!   Bootstrap expects `BuildInfo` and `admin::router(probe, ver)`.
//! RO:INVARIANTS
//!   - Safe if git/build envs are missing (fall back to "unknown").

use axum::{extract::State, response::IntoResponse, Json};
use serde::Serialize;

/// Static build metadata carried in admin state.
#[derive(Clone, Copy, Serialize)]
pub struct BuildInfo {
    pub version: &'static str,
    pub git: &'static str,
    pub build: &'static str,
    pub features: &'static [&'static str],
}

/// Construct BuildInfo from compile-time env (fallbacks allowed).
pub fn current_build_info() -> BuildInfo {
    BuildInfo {
        version: env!("CARGO_PKG_VERSION"),
        git: option_env!("GIT_SHA").unwrap_or("unknown"),
        build: option_env!("BUILD_TS").unwrap_or("unknown"),
        features: &[
            // e.g., "tls", "quic", "pq", "amnesia"
        ],
    }
}

/// GET /version — returns the build info from AdminState.
pub async fn handle_version(State(state): State<crate::admin::AdminState>) -> impl IntoResponse {
    Json(state.build)
}

```

### crates/svc-overlay/src/api/mod.rs
<a id="crates-svc-overlay-src-api-mod-rs"></a>

```rust
//! RO:WHAT — Minimal lib API surface (feature `libapi`)
#![allow(dead_code)]
use anyhow::Result;
use crate::{config::Config, readiness::HealthGate, bootstrap::start_runtime};

#[cfg(feature = "libapi")]
pub struct OverlayHandle(pub(crate) crate::supervisor::OverlayRuntime);

#[cfg(feature = "libapi")]
pub async fn spawn(cfg: Config) -> Result<OverlayHandle> {
    let hg = HealthGate::new();
    let rt = start_runtime(cfg, hg).await?;
    Ok(OverlayHandle(rt))
}

#[cfg(feature = "libapi")]
impl OverlayHandle {
    pub async fn shutdown(self) -> Result<()> { self.0.shutdown().await }
}

```

### crates/svc-overlay/src/auth/macaroon.rs
<a id="crates-svc-overlay-src-auth-macaroon-rs"></a>

```rust
//! RO:WHAT — Macaroon-based capability checks (stub)
#![allow(dead_code)]
pub fn verify_capability(_cap: &str) -> bool {
    true
}

```

### crates/svc-overlay/src/auth/mod.rs
<a id="crates-svc-overlay-src-auth-mod-rs"></a>

```rust
//! RO:WHAT — AuthN/Z surface
pub mod macaroon;

```

### crates/svc-overlay/src/bootstrap.rs
<a id="crates-svc-overlay-src-bootstrap-rs"></a>

```rust
//! Boot wiring for tracing + admin server.

use crate::admin::version::BuildInfo;
use crate::admin::{self, ReadyProbe};
use axum::Router;
use std::net::SocketAddr;
use tokio::net::TcpListener;
use tracing::{info, Level};
use tracing_subscriber::{fmt, EnvFilter};

pub struct AdminServer {
    pub addr: SocketAddr,
    handle: tokio::task::JoinHandle<anyhow::Result<()>>,
}

impl AdminServer {
    pub async fn spawn(
        bind: SocketAddr,
        probe: ReadyProbe,
        ver: BuildInfo,
    ) -> anyhow::Result<Self> {
        let app: Router = admin::router(probe, ver);
        let listener = TcpListener::bind(bind).await?;
        let addr = listener.local_addr()?;
        let handle = tokio::spawn(async move {
            axum::serve(listener, app).await?;
            Ok::<_, anyhow::Error>(())
        });
        info!("admin server listening on {}", addr);
        Ok(Self { addr, handle })
    }

    pub async fn join(self) -> anyhow::Result<()> {
        self.handle.await??;
        Ok(())
    }
}

/// Install JSON tracing with an env-filter override.
/// Example: `RUST_LOG=svc-overlay=debug,axum=warn`
pub fn init_tracing(default_level: &str) {
    let filter =
        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(default_level));
    fmt()
        .with_max_level(Level::INFO)
        .with_env_filter(filter)
        .json()
        .with_current_span(true)
        .with_span_list(true)
        .flatten_event(true)
        .init();
}

/// Start the minimal gossip engine and register the global publish hook.
/// Returns the spawned worker task so supervisors can hold/join it.
pub fn start_gossip_engine(capacity: usize) -> tokio::task::JoinHandle<()> {
    let (gossip, task) = crate::gossip::GossipEngine::start(capacity);
    gossip.install_global();
    info!("gossip engine online (cap={})", capacity);
    task
}

```

### crates/svc-overlay/src/cli.rs
<a id="crates-svc-overlay-src-cli-rs"></a>

```rust
//! RO:WHAT — CLI surface (env-first, minimal flags placeholder)
#![allow(dead_code)]
pub struct Cli {}
impl Cli {
    pub fn parse() -> Self {
        Self {}
    }
}

```

### crates/svc-overlay/src/config.rs
<a id="crates-svc-overlay-src-config-rs"></a>

```rust
//! RO:WHAT — Config loader/validator
use anyhow::{anyhow, bail, Result};
use std::{net::SocketAddr, time::Duration};

#[derive(Clone, Debug)]
pub struct Admin {
    pub http_addr: SocketAddr,
    pub metrics_addr: SocketAddr,
}

#[derive(Clone, Debug)]
pub struct TransportCfg {
    pub addr: SocketAddr,
    pub name: &'static str,
    pub read_timeout: Duration,
    pub idle_timeout: Duration,
    pub max_conns: usize,
    // TLS/QUIC/Tor knobs can be added here and mapped to ron-transport features
}

#[derive(Clone, Debug)]
pub struct Config {
    pub admin: Admin,
    pub transport: TransportCfg,
    pub oap_max_frame: usize,
    pub send_window_frames: u32,
    pub recv_window_frames: u32,
    pub amnesia: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            admin: Admin {
                http_addr: "127.0.0.1:9600".parse().unwrap(),
                metrics_addr: "127.0.0.1:9601".parse().unwrap(),
            },
            transport: TransportCfg {
                addr: "127.0.0.1:9700".parse().unwrap(),
                name: "svc-overlay",
                read_timeout: Duration::from_secs(5),
                idle_timeout: Duration::from_secs(30),
                max_conns: 1024,
            },
            oap_max_frame: 1 << 20,
            send_window_frames: 16,
            recv_window_frames: 16,
            amnesia: false,
        }
    }
}

impl Config {
    /// Minimal env loader; expand per your CONFIG.MD later.
    pub fn from_env_and_cli() -> Result<Self> {
        let mut c = Self::default();
        if let Ok(addr) = std::env::var("SVC_OVERLAY_HTTP_ADDR") {
            c.admin.http_addr = addr.parse().map_err(|e| anyhow!("bad http addr: {e}"))?;
        }
        if let Ok(addr) = std::env::var("SVC_OVERLAY_METRICS_ADDR") {
            c.admin.metrics_addr = addr.parse().map_err(|e| anyhow!("bad metrics addr: {e}"))?;
        }
        if let Ok(addr) = std::env::var("SVC_OVERLAY_LISTEN_ADDR") {
            c.transport.addr = addr.parse().map_err(|e| anyhow!("bad listen addr: {e}"))?;
        }
        if let Ok(n) = std::env::var("SVC_OVERLAY_MAX_CONNS") {
            c.transport.max_conns = n.parse().map_err(|e| anyhow!("bad max conns: {e}"))?;
        }
        c.validate()?;
        Ok(c)
    }

    pub fn validate(&self) -> Result<()> {
        if self.oap_max_frame == 0 || self.oap_max_frame > (1 << 20) {
            bail!("oap_max_frame must be 1..=1MiB");
        }
        if self.transport.max_conns == 0 {
            bail!("transport.max_conns must be > 0");
        }
        Ok(())
    }
}

```

### crates/svc-overlay/src/conn/error.rs
<a id="crates-svc-overlay-src-conn-error-rs"></a>

```rust
//! RO:WHAT — Connection-level errors.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum ConnError {
    #[error("io: {0}")]
    Io(#[from] std::io::Error),

    #[error(transparent)]
    Proto(#[from] crate::protocol::error::ProtoError),
}

pub type ConnResult<T> = Result<T, ConnError>;

```

### crates/svc-overlay/src/conn/mod.rs
<a id="crates-svc-overlay-src-conn-mod-rs"></a>

```rust
//! RO:WHAT — Connection tasks (reader/writer queues and supervision)

pub mod error;
pub mod reader;
pub mod supervisor;
pub mod tx;
pub mod writer;

```

### crates/svc-overlay/src/conn/reader.rs
<a id="crates-svc-overlay-src-conn-reader-rs"></a>

```rust
//! RO:WHAT — Read loop: accumulates bytes, decodes OAP frames.

use bytes::BytesMut;
use tokio::io::{AsyncRead, AsyncReadExt};
use tracing::{debug, trace};

use super::error::ConnResult;
use crate::protocol::oap::{try_parse_frame, FrameKind}; // <- keep only ConnResult

/// Blocking-ish read loop that parses frames and logs; returns on EOF or error.
/// Transport-agnostic: any AsyncRead works (TCP/TLS/QUIC streams that implement it).
pub async fn run_reader<R>(mut rd: R) -> ConnResult<()>
where
    R: AsyncRead + Unpin,
{
    let mut buf = BytesMut::with_capacity(8 * 1024);

    loop {
        // Try parse any already-buffered frames first.
        while let Some(frame) = try_parse_frame(&mut buf)? {
            match frame.kind {
                FrameKind::Data => {
                    debug!(len = frame.payload.len(), "oap/data frame");
                }
                FrameKind::Ctrl => {
                    debug!(len = frame.payload.len(), "oap/ctrl frame");
                }
            }
            trace!(buf_len = buf.len(), "post-parse buffer");
        }

        // Refill buffer. read_buf appends into BytesMut.
        let n = rd.read_buf(&mut buf).await?;
        if n == 0 {
            // EOF
            return Ok(());
        }
        trace!(read = n, buf_len = buf.len(), "read bytes");
    }
}

```

### crates/svc-overlay/src/conn/supervisor.rs
<a id="crates-svc-overlay-src-conn-supervisor-rs"></a>

```rust
//! RO:WHAT — Per-connection supervisor (stub)
#![allow(dead_code)]

```

### crates/svc-overlay/src/conn/tx.rs
<a id="crates-svc-overlay-src-conn-tx-rs"></a>

```rust
//! RO:WHAT — Bounded per-connection TX queue with single-writer task.
//! RO:WHY  — Enforces single-writer discipline and exposes queue depth/drops.
//! RO:INTERACTS — conn::writer::write_frame, admin::metrics::overlay_metrics
//! RO:INVARIANTS — one writer per connection; bounded mpsc; no locks across .await
//! RO:METRICS — overlay_peer_queue_depth, overlay_peer_dropped_total
//! RO:TEST — covered indirectly by roundtrip; unit tests can enqueue/close

use bytes::BytesMut;
use tokio::io::AsyncWrite;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;
use tracing::{debug, warn};

use crate::admin::metrics::overlay_metrics;
use crate::protocol::oap::Frame;

/// Message to the writer task.
pub enum TxMsg {
    Frame(Frame),
    Close,
}

/// Handle to enqueue frames for a single connection.
#[derive(Clone)]
pub struct TxSender {
    tx: mpsc::Sender<TxMsg>,
}

impl TxSender {
    pub fn capacity(&self) -> usize {
        self.tx.capacity()
    }

    pub fn try_send(&self, frame: Frame) -> Result<(), Frame> {
        match self.tx.try_send(TxMsg::Frame(frame)) {
            Ok(_) => {
                overlay_metrics::set_peer_tx_depth(self.tx.max_capacity() - self.tx.capacity());
                Ok(())
            }
            Err(mpsc::error::TrySendError::Full(TxMsg::Frame(f))) => {
                overlay_metrics::inc_peer_tx_dropped();
                Err(f)
            }
            Err(mpsc::error::TrySendError::Closed(TxMsg::Frame(f))) => Err(f),
            Err(_) => unreachable!("only Frame variants used here"),
        }
    }

    pub async fn send(&self, frame: Frame) -> Result<(), Frame> {
        // Avoid use-after-move by staging in an Option.
        let mut slot = Some(frame);
        match self.tx.send(TxMsg::Frame(slot.take().unwrap())).await {
            Ok(_) => {
                overlay_metrics::set_peer_tx_depth(self.tx.max_capacity() - self.tx.capacity());
                Ok(())
            }
            Err(mpsc::error::SendError(TxMsg::Frame(f))) => Err(f),
            Err(_) => unreachable!("only Frame variants used here"),
        }
    }
}

/// Spawn a writer task which OWNS the AsyncWrite half (single-writer discipline).
pub fn spawn_writer<W>(mut wr: W, bound: usize) -> (TxSender, JoinHandle<()>)
where
    W: AsyncWrite + Unpin + Send + 'static,
{
    let (tx, mut rx) = mpsc::channel::<TxMsg>(bound);
    let handle = tokio::spawn(async move {
        let mut scratch = BytesMut::with_capacity(8 * 1024);
        while let Some(msg) = rx.recv().await {
            match msg {
                TxMsg::Frame(frame) => {
                    if let Err(e) =
                        crate::conn::writer::write_frame(&mut wr, &frame, &mut scratch).await
                    {
                        warn!(error=?e, "writer: write failed — closing");
                        break;
                    }
                    overlay_metrics::set_peer_tx_depth(rx.max_capacity() - rx.capacity());
                }
                TxMsg::Close => {
                    debug!("writer: close requested");
                    break;
                }
            }
        }
    });
    (TxSender { tx }, handle)
}

```

### crates/svc-overlay/src/conn/writer.rs
<a id="crates-svc-overlay-src-conn-writer-rs"></a>

```rust
//! RO:WHAT — Writer helpers: encode frames and flush.

use bytes::BytesMut;
use tokio::io::{AsyncWrite, AsyncWriteExt};

use super::error::ConnResult;
use crate::protocol::oap::Frame; // <- keep only ConnResult

/// Encode a frame into a scratch buffer and write it out atomically.
pub async fn write_frame<W>(wr: &mut W, frame: &Frame, scratch: &mut BytesMut) -> ConnResult<()>
where
    W: AsyncWrite + Unpin,
{
    scratch.clear();
    frame.encode_to(scratch)?;
    wr.write_all(scratch).await?;
    wr.flush().await?;
    Ok(())
}

```

### crates/svc-overlay/src/errors.rs
<a id="crates-svc-overlay-src-errors-rs"></a>

```rust
//! RO:WHAT — Error taxonomy
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("protocol: {0}")]
    Protocol(String),
}

```

### crates/svc-overlay/src/gossip/engine.rs
<a id="crates-svc-overlay-src-gossip-engine-rs"></a>

```rust
//! RO:WHAT — Minimal gossip engine: bounded ingress queue + background worker.
//! RO:WHY  — Provide a place to route/process `Data` frames beyond the echo demo.
//! RO:INVARIANTS — Non-blocking publish; backpressure via bounded channel; best-effort drop on full.

use bytes::Bytes;
use once_cell::sync::OnceCell;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;
use tracing::{debug, warn};

/// Global publishing hook (optional). Listener can publish without holding an Engine instance.
static GLOBAL_TX: OnceCell<mpsc::Sender<Bytes>> = OnceCell::new();

#[derive(Clone)]
pub struct GossipEngine {
    tx: mpsc::Sender<Bytes>,
}

impl GossipEngine {
    /// Start the engine with bounded capacity and spawn the worker task.
    pub fn start(capacity: usize) -> (Self, JoinHandle<()>) {
        let (tx, mut rx) = mpsc::channel::<Bytes>(capacity);
        let me = Self { tx: tx.clone() };

        let task = tokio::spawn(async move {
            // Minimal worker: log and count. Later: route, dedupe, fanout.
            while let Some(msg) = rx.recv().await {
                debug!(len = msg.len(), "gossip: received message");
                metrics::counter!("gossip_ingress_total").increment(1);
                metrics::counter!("gossip_ingress_bytes_total").increment(msg.len() as u64);
                // TODO: plumb to per-topic queues or peers.
            }
            // Channel closed → shutdown path.
            warn!("gossip: worker exiting (channel closed)");
        });

        (me, task)
    }

    /// Install this engine as the global publisher target.
    pub fn install_global(&self) {
        let _ = GLOBAL_TX.set(self.tx.clone());
    }

    /// Try to publish a message (drops if queue is full).
    pub fn try_publish(&self, msg: Bytes) -> bool {
        match self.tx.try_send(msg) {
            Ok(()) => true,
            Err(mpsc::error::TrySendError::Full(_)) => {
                metrics::counter!("gossip_dropped_total", "reason" => "full").increment(1);
                false
            }
            Err(mpsc::error::TrySendError::Closed(_)) => {
                metrics::counter!("gossip_dropped_total", "reason" => "closed").increment(1);
                false
            }
        }
    }
}

/// Publish through the global hook (if installed).
pub fn publish(msg: Bytes) -> bool {
    if let Some(tx) = GLOBAL_TX.get() {
        match tx.try_send(msg) {
            Ok(()) => {
                metrics::counter!("gossip_ingress_total").increment(1);
                true
            }
            Err(mpsc::error::TrySendError::Full(_)) => {
                metrics::counter!("gossip_dropped_total", "reason" => "full").increment(1);
                false
            }
            Err(mpsc::error::TrySendError::Closed(_)) => {
                metrics::counter!("gossip_dropped_total", "reason" => "closed").increment(1);
                false
            }
        }
    } else {
        metrics::counter!("gossip_dropped_total", "reason" => "unset").increment(1);
        false
    }
}

```

### crates/svc-overlay/src/gossip/mod.rs
<a id="crates-svc-overlay-src-gossip-mod-rs"></a>

```rust
//! RO:WHAT — Gossip module
pub mod engine;
pub use engine::{publish, GossipEngine};
pub mod types;

```

### crates/svc-overlay/src/gossip/types.rs
<a id="crates-svc-overlay-src-gossip-types-rs"></a>

```rust
//! RO:WHAT — Gossip types
#![allow(dead_code)]
use bytes::Bytes;
pub type GossipMsg = Bytes;

```

### crates/svc-overlay/src/lib.rs
<a id="crates-svc-overlay-src-lib-rs"></a>

```rust
//! RO:WHAT — Library entry for svc-overlay
#![forbid(unsafe_code)]

pub mod admin;
pub mod auth;
pub mod bootstrap;
pub mod cli;
pub mod config;
pub mod conn;
pub mod errors;
pub mod gossip;
pub mod limits;
pub mod listener;
pub mod observe;
pub mod pq;
pub mod protocol;
pub mod readiness;
pub mod shutdown;
pub mod supervisor;
pub mod transport;
pub mod tuning;
pub mod types;

use tracing_subscriber::{fmt, EnvFilter};

pub fn init_tracing() {
    let filter = EnvFilter::from_default_env().add_directive(
        "svc_overlay=info"
            .parse()
            .unwrap_or_else(|_| "info".parse().unwrap()),
    );
    let _ = fmt()
        .with_env_filter(filter)
        .json()
        .flatten_event(true)
        .try_init();
}

```

### crates/svc-overlay/src/limits.rs
<a id="crates-svc-overlay-src-limits-rs"></a>

```rust
//! RO:WHAT — Service limits (constants)
pub const MAX_FRAME_BYTES: usize = 1 << 20; // 1 MiB

```

### crates/svc-overlay/src/listener/mod.rs
<a id="crates-svc-overlay-src-listener-mod-rs"></a>

```rust
//! RO:WHAT — Listener module entry.
//! RO:WHY  — Keep a single listener implementation in `plain.rs` that delegates
//!           transport concerns to `crate::transport` (facade).
//! RO:CFG  — No cfgs here. The `use_ron_transport` feature is implemented in
//!           the transport facade, not at the listener boundary.

pub mod plain;

// Re-export the public API expected by bootstrap.
pub use plain::{spawn_listener, ListenerHandle};

```

### crates/svc-overlay/src/listener/plain.rs
<a id="crates-svc-overlay-src-listener-plain-rs"></a>

```rust
//! RO:WHAT — Overlay listener using transport facade + metrics.
//! RO:NEXT — When `transport` facade switches to ron-transport, no changes needed here.
//! RO:INVARIANTS — one writer per connection; bounded queue; no locks across .await

use crate::admin::metrics::overlay_metrics;
use crate::admin::ReadyProbe;
use crate::config::Config;
use crate::conn::tx::spawn_writer;
use crate::gossip::publish;
use crate::protocol::flags::Caps;
use crate::protocol::handshake::handshake;
use crate::protocol::oap::{try_parse_frame, Frame, FrameKind};
use crate::transport::{bind_listener, TransportStream};
use crate::tuning; // <— NEW

use anyhow::Result;
use bytes::BytesMut;
use std::net::SocketAddr;
use std::time::Instant;
use tokio::io::AsyncReadExt;
use tokio::net::tcp::OwnedReadHalf;
use tokio::task::JoinHandle;
use tokio::time::Duration;
use tracing::{error, info, trace, warn, Instrument};

pub struct ListenerHandle {
    addr: SocketAddr,
    task: JoinHandle<()>,
}

impl ListenerHandle {
    pub fn addr(&self) -> SocketAddr {
        self.addr
    }
    pub async fn shutdown(self) -> Result<()> {
        self.task.abort();
        Ok(())
    }
}

/// Observe "accept → handshake start" latency even if early-return happens.
struct AcceptTimer {
    start: Instant,
    observed: bool,
}
impl AcceptTimer {
    fn start() -> Self {
        Self {
            start: Instant::now(),
            observed: false,
        }
    }
    fn observe_once(&mut self) {
        if !self.observed {
            overlay_metrics::accept_latency_seconds(self.start.elapsed().as_secs_f64());
            self.observed = true;
        }
    }
}
impl Drop for AcceptTimer {
    fn drop(&mut self) {
        self.observe_once();
    }
}

pub async fn spawn_listener(cfg: &Config, probe: &ReadyProbe) -> Result<ListenerHandle> {
    let (listener, addr) = bind_listener(cfg.transport.addr).await?;
    info!(%addr, "overlay listener bound");
    probe.set(|s| s.listeners_bound = true).await;

    // Readiness sampler — flips `queues_ok` based on TX queue depth.
    let probe_clone = probe.clone();
    tokio::spawn(async move {
        loop {
            let depth = overlay_metrics::get_peer_tx_depth();
            let active = overlay_metrics::get_sessions_active();
            let watermark = tuning::tx_queue_watermark(); // <— NEW
            let ok = if active > 0 { depth < watermark } else { true };
            probe_clone.set(|s| s.queues_ok = ok).await;
            tokio::time::sleep(Duration::from_millis(200)).await;
        }
    });

    let task = tokio::spawn(async move {
        loop {
            match listener.accept().await {
                Ok((stream, peer)) => {
                    metrics::counter!("overlay_connections_total").increment(1);
                    overlay_metrics::inc_sessions_active();
                    tokio::spawn(handle_conn(peer, stream).in_current_span());
                }
                Err(e) => {
                    warn!(error=?e, "accept failed");
                    tokio::time::sleep(Duration::from_millis(50)).await;
                }
            }
        }
    });

    Ok(ListenerHandle { addr, task })
}

async fn handle_conn(peer: SocketAddr, mut stream: TransportStream) {
    let mut accept_timer = AcceptTimer::start();

    // Handshake on the unified stream first (before splitting).
    {
        use tokio::io::{AsyncRead, AsyncWrite};

        trait HandshakeBorrow {
            type Dyn: AsyncRead + AsyncWrite + Unpin;
            fn as_io_mut(&mut self) -> &mut Self::Dyn;
        }
        impl HandshakeBorrow for TransportStream {
            type Dyn = tokio::net::TcpStream;
            fn as_io_mut(&mut self) -> &mut Self::Dyn {
                &mut self.inner
            }
        }

        let caps = Caps::GOSSIP_V1;
        let tmo = tuning::handshake_timeout(); // <— NEW
        let _neg = match tokio::time::timeout(
            tmo,
            handshake(
                <TransportStream as HandshakeBorrow>::as_io_mut(&mut stream),
                caps,
                tmo,
            ),
        )
        .await
        {
            Ok(Ok(n)) => {
                accept_timer.observe_once();
                info!(%peer, ver = n.version, caps = ?n.caps, "conn: negotiated");
                n
            }
            Ok(Err(_e)) => {
                overlay_metrics::handshake_fail("io");
                warn!(%peer, "conn: handshake failed");
                overlay_metrics::dec_sessions_active();
                return;
            }
            Err(_elapsed) => {
                overlay_metrics::handshake_fail("timeout");
                warn!(%peer, "conn: handshake timeout");
                overlay_metrics::dec_sessions_active();
                return;
            }
        };
    }

    // Split into owned halves; writer task owns the write half.
    let (mut rd, wr) = stream.into_split();
    let (tx, _writer_task) = spawn_writer(wr, 128);

    // Reader loop: parse frames; echo Data via bounded TX; publish demo gossip.
    let mut inbuf = BytesMut::with_capacity(8 * 1024);
    let start_ok = Instant::now();

    async fn read_more(rd: &mut OwnedReadHalf, buf: &mut BytesMut) -> std::io::Result<usize> {
        rd.read_buf(buf).await
    }

    loop {
        // Drain any complete frames already in the buffer.
        while let Some(frame) = match try_parse_frame(&mut inbuf) {
            Ok(f) => f,
            Err(e) => {
                warn!(%peer, error=?e, "conn: frame parse error");
                overlay_metrics::dec_sessions_active();
                return;
            }
        } {
            match frame.kind {
                FrameKind::Data => {
                    publish(frame.payload.clone());
                    let echo = Frame {
                        kind: FrameKind::Data,
                        payload: frame.payload,
                    };
                    // On backpressure, drop and record.
                    if tx.try_send(echo).is_err() {
                        overlay_metrics::inc_peer_tx_dropped();
                    }
                }
                FrameKind::Ctrl => {
                    // TODO: handle control frames when defined
                }
            }
        }

        // Refill buffer from reader
        match read_more(&mut rd, &mut inbuf).await {
            Ok(0) => {
                let secs = start_ok.elapsed().as_secs_f64();
                overlay_metrics::conn_lifetime_seconds(secs);
                info!(%peer, dt_ms = (secs * 1000.0) as u64, "conn: closed");
                overlay_metrics::dec_sessions_active();
                return;
            }
            Ok(n) => {
                trace!(%peer, read = n, buf_len = inbuf.len(), "read bytes");
            }
            Err(e) => {
                error!(%peer, error=?e, "conn: read error");
                overlay_metrics::dec_sessions_active();
                return;
            }
        }
    }
}

```

### crates/svc-overlay/src/listener/ron.rs
<a id="crates-svc-overlay-src-listener-ron-rs"></a>

```rust
//! RO:WHAT — ron-transport listener (placeholder).
//! RO:NEXT — Replace delegation with real spawn using ron-transport once stream handoff API is set.

use crate::admin::ReadyProbe;
use crate::config::Config;
use anyhow::Result;

// For now, delegate to plain listener so enabling the feature doesn't break runtime.
// We keep the same public surface (spawn_listener, ListenerHandle).
pub(super) use super::plain::{spawn_listener, ListenerHandle};

```

### crates/svc-overlay/src/main.rs
<a id="crates-svc-overlay-src-main-rs"></a>

```rust
//! Binary entry: parse config, init tracing, run admin + overlay runtime.

use svc_overlay::admin::version::BuildInfo;
use svc_overlay::admin::ReadyProbe;
use svc_overlay::bootstrap;
use svc_overlay::config::Config;
use svc_overlay::supervisor::OverlayRuntime;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1) Config
    let cfg = Config::from_env_and_cli()?;
    cfg.validate()?;

    // 2) Tracing
    bootstrap::init_tracing("info");

    // 3) Admin server
    let probe = ReadyProbe::new();
    // Early boot truth; listener flips listeners_bound later.
    probe
        .set(|s| {
            s.metrics_bound = true; // Keep true: exporter can be added later
            s.cfg_loaded = true;
            s.listeners_bound = false;
            s.queues_ok = true;
            s.shed_rate_ok = true;
            s.fd_headroom = true;
        })
        .await;

    let build = BuildInfo {
        version: env!("CARGO_PKG_VERSION"),
        git: option_env!("GIT_SHA").unwrap_or("unknown"),
        build: option_env!("BUILD_TS").unwrap_or("unknown"),
        features: &[],
    };

    let admin = bootstrap::AdminServer::spawn(cfg.admin.http_addr, probe.clone(), build).await?;

    // 4) Overlay runtime (bind temporary TCP listener -> flips /readyz green)
    let overlay = OverlayRuntime::start(cfg.clone(), probe.clone()).await?;

    // 5) Wait until admin server exits (CTRL-C or test harness)
    admin.join().await?;

    // 6) Shutdown overlay
    overlay.shutdown().await?;

    Ok(())
}

```

### crates/svc-overlay/src/observe.rs
<a id="crates-svc-overlay-src-observe-rs"></a>

```rust
//! Observability bootstrap + metric helpers.
//! Contract: Prometheus exposition via /metrics with stable names/buckets.
//! See docs/OBSERVABILITY.md and API.MD for the golden set.
//
// NOTE: We intentionally avoid calling `metrics::*` macros here because the
// workspace currently pulls in two different `metrics` versions via
// `metrics-exporter-prometheus`, which causes type/trait conflicts.
// The `emit` helpers are kept as no-ops so call sites compile. Once we unify
// on a single `metrics` version across the workspace, we can flip these back
// on without changing call sites.

use metrics_exporter_prometheus::{Matcher, PrometheusBuilder, PrometheusHandle};
use once_cell::sync::OnceCell;
use std::net::SocketAddr;
use tracing::info;

// Global handle used by /metrics handler to render a scrape.
static PROM_HANDLE: OnceCell<PrometheusHandle> = OnceCell::new();

/// Install a Prometheus recorder and store a handle for /metrics scraping.
/// Returns the configured bind address (HTTP listener is owned by the exporter).
pub fn init_metrics(addr: SocketAddr) -> anyhow::Result<SocketAddr> {
    // Buckets aligned with docs: latency 5ms..5s, frame sizes up to 1MiB.
    let builder = PrometheusBuilder::new()
        .with_http_listener(addr)
        // metrics-exporter-prometheus 0.15 uses (Matcher, &[f64]) — set each metric separately.
        .set_buckets_for_metric(
            Matcher::Full("request_latency_seconds".into()),
            &[0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0],
        )?
        .set_buckets_for_metric(
            Matcher::Full("overlay_frame_size_bytes".into()),
            &[
                512.0,
                1024.0,
                4096.0,
                16384.0,
                65536.0,
                262_144.0,
                524_288.0,
                1_048_576.0,
            ],
        )?;

    // Start exporter + install recorder.
    let handle = builder.install_recorder()?;

    // Touch to ensure recorder is live (silence unused warnings).
    let _ = handle.render().len();

    // Store global handle for /metrics endpoint.
    let _ = PROM_HANDLE.set(handle);

    info!("metrics recorder installed on {}", addr);
    Ok(addr)
}

/// Render Prometheus metrics as text/plain; used by the HTTP handler.
pub fn render_prometheus() -> String {
    PROM_HANDLE
        .get()
        .map(|h| h.render())
        .unwrap_or_else(|| "# no recorder".to_string())
}

/// Canonical metric helpers (names stabilized here).
/// Currently NO-OPs to avoid `metrics` crate version conflicts.
/// Re-enable by replacing bodies with `metrics::*` macros once the workspace
/// is on a single `metrics` version.
pub mod emit {
    #[inline]
    pub fn http_req_total(_route: &'static str, _method: &'static str, _status: u16) {
        // NO-OP (see module docs)
    }

    #[inline]
    pub fn http_latency(_route: &'static str, _method: &'static str, _secs: f64) {
        // NO-OP (see module docs)
    }

    #[inline]
    pub fn ready_state(_val: i64) {
        // NO-OP (see module docs)
    }
}

```

### crates/svc-overlay/src/pq/mod.rs
<a id="crates-svc-overlay-src-pq-mod-rs"></a>

```rust
//! RO:WHAT — Post-quantum negotiation
pub mod negotiate;

```

### crates/svc-overlay/src/pq/negotiate.rs
<a id="crates-svc-overlay-src-pq-negotiate-rs"></a>

```rust
//! RO:WHAT — PQ negotiation stub
#![allow(dead_code)]
pub async fn negotiate() -> bool {
    true
}

```

### crates/svc-overlay/src/protocol/cbor.rs
<a id="crates-svc-overlay-src-protocol-cbor-rs"></a>

```rust
//! RO:WHAT — CBOR helpers for OAP (placeholder)
#![allow(dead_code)]

```

### crates/svc-overlay/src/protocol/error.rs
<a id="crates-svc-overlay-src-protocol-error-rs"></a>

```rust
//! RO:WHAT — Protocol-level errors (OAP/1 framing & handshake).
//! RO:INVARIANTS — No allocation bombs; errors are structured and non-panicking.

use thiserror::Error;

#[derive(Debug, Error)]
pub enum ProtoError {
    #[error("frame too large: {got} > {max} bytes")]
    FrameTooLarge { got: usize, max: usize },

    #[error("incomplete frame")]
    Incomplete,

    #[error("bad magic/version: got {got:?}")]
    BadPreamble { got: [u8; 5] },

    #[error("io: {0}")]
    Io(#[from] std::io::Error),

    #[error("handshake timeout")]
    HandshakeTimeout,

    #[error("capability mismatch")]
    CapabilityMismatch,
}

pub type ProtoResult<T> = Result<T, ProtoError>;

```

### crates/svc-overlay/src/protocol/flags.rs
<a id="crates-svc-overlay-src-protocol-flags-rs"></a>

```rust
//! RO:WHAT — OAP/1 capability flags used during handshake.
//! RO:WHY  — Keep overlay features discoverable and future-proof.

bitflags::bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct Caps: u32 {
        const NONE        = 0;
        const GOSSIP_V1   = 1 << 0;
        const RESERVED_1  = 1 << 1;
        // Future: const PQ_HYBRID = 1 << 8;  // negotiated at overlay level; transport does TLS/PQ.
    }
}

impl Default for Caps {
    fn default() -> Self {
        Caps::GOSSIP_V1
    }
}

```

### crates/svc-overlay/src/protocol/handshake.rs
<a id="crates-svc-overlay-src-protocol-handshake-rs"></a>

```rust
//! RO:WHAT — Minimal OAP/1 handshake over any AsyncRead/Write stream.
//! RO:WHY  — Establish version & capability agreement before frames.
//! RO:INVARIANTS — Fixed-size preamble; bounded IO; timeout guarded.

use crate::protocol::error::{ProtoError, ProtoResult};
use crate::protocol::flags::Caps;
use tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};
use tokio::time::{timeout, Duration};

const MAGIC: &[u8; 4] = b"OAP1";
const WIRE_HELLO_LEN: usize = 4 /*MAGIC*/ + 1 /*ver*/ + 4 /*caps*/;
pub const VERSION: u8 = 1;

#[derive(Debug, Clone, Copy)]
pub struct Negotiated {
    pub version: u8,
    pub caps: Caps,
}

fn encode_hello(buf: &mut [u8; WIRE_HELLO_LEN], ver: u8, caps: Caps) {
    buf[0..4].copy_from_slice(MAGIC);
    buf[4] = ver;
    buf[5..9].copy_from_slice(&(caps.bits()).to_be_bytes());
}

fn decode_hello(buf: &[u8; WIRE_HELLO_LEN]) -> ProtoResult<(u8, Caps)> {
    if &buf[0..4] != MAGIC {
        return Err(ProtoError::BadPreamble {
            got: [buf[0], buf[1], buf[2], buf[3], buf[4]],
        });
    }
    let ver = buf[4];
    let mut caps_b = [0u8; 4];
    caps_b.copy_from_slice(&buf[5..9]);
    let caps = u32::from_be_bytes(caps_b);
    Ok((ver, Caps::from_bits_truncate(caps)))
}

/// Perform a 1-RTT symmetric hello exchange with a timeout.
pub async fn handshake<IO>(io: &mut IO, ours: Caps, dur: Duration) -> ProtoResult<Negotiated>
where
    IO: AsyncRead + AsyncWrite + Unpin,
{
    let mut buf_out = [0u8; WIRE_HELLO_LEN];
    let mut buf_in = [0u8; WIRE_HELLO_LEN];

    encode_hello(&mut buf_out, VERSION, ours);

    let fut = async {
        // Write our hello, then flush
        io.write_all(&buf_out).await?;
        io.flush().await?;

        // Read peer hello (exact len)
        io.read_exact(&mut buf_in).await?;
        ProtoResult::Ok(())
    };

    timeout(dur, fut)
        .await
        .map_err(|_| ProtoError::HandshakeTimeout)??;

    let (peer_ver, peer_caps) = decode_hello(&buf_in)?;
    if peer_ver != VERSION {
        return Err(ProtoError::BadPreamble {
            got: [buf_in[0], buf_in[1], buf_in[2], buf_in[3], buf_in[4]],
        });
    }

    // Minimal check: both must support GOSSIP_V1 for now.
    let needed = Caps::GOSSIP_V1;
    if !peer_caps.contains(needed) || !ours.contains(needed) {
        return Err(ProtoError::CapabilityMismatch);
    }

    Ok(Negotiated {
        version: peer_ver,
        caps: peer_caps & ours,
    })
}

```

### crates/svc-overlay/src/protocol/mod.rs
<a id="crates-svc-overlay-src-protocol-mod-rs"></a>

```rust
//! RO:WHAT — Protocol (OAP-1) framing/handshake surface
pub mod cbor;
pub mod error;
pub mod flags;
pub mod handshake;
pub mod oap;

```

### crates/svc-overlay/src/protocol/oap.rs
<a id="crates-svc-overlay-src-protocol-oap-rs"></a>

```rust
//! RO:WHAT — OAP/1 framing: length-prefixed frames with a kind byte.
//! RO:WHY  — Provide message boundaries over byte-stream transports.
//! RO:INVARIANTS — Max frame size is sourced from ron-proto; parsing is incremental & non-panicking.

use crate::protocol::error::{ProtoError, ProtoResult};
use bytes::{Buf, BufMut, Bytes, BytesMut};

/// Canonical limit from `ron-proto`.
const MAX_FRAME_BYTES: usize = ron_proto::oap::MAX_FRAME_BYTES;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum FrameKind {
    /// Application/gossip data frame (payload = opaque).
    Data = 0x01,
    /// Control/handshake or control acks (payload = small).
    Ctrl = 0x02,
}

impl FrameKind {
    fn from_byte(b: u8) -> Option<Self> {
        match b {
            0x01 => Some(FrameKind::Data),
            0x02 => Some(FrameKind::Ctrl),
            _ => None,
        }
    }
}

#[derive(Debug, Clone)]
pub struct Frame {
    pub kind: FrameKind,
    pub payload: Bytes,
}

impl Frame {
    /// Encode: 4-byte BE length (kind + payload), then 1-byte kind, then payload.
    pub fn encode_to(&self, out: &mut BytesMut) -> ProtoResult<()> {
        let len = 1usize + self.payload.len();
        if len > MAX_FRAME_BYTES {
            return Err(ProtoError::FrameTooLarge {
                got: len,
                max: MAX_FRAME_BYTES,
            });
        }
        out.reserve(4 + len);
        out.put_u32(len as u32);
        out.put_u8(self.kind as u8);
        out.extend_from_slice(&self.payload);
        Ok(())
    }
}

/// Try to parse a single frame from the buffer; leaves remaining bytes in `buf`.
pub fn try_parse_frame(buf: &mut BytesMut) -> ProtoResult<Option<Frame>> {
    const HDR: usize = 4; // BE length
    if buf.len() < HDR {
        return Ok(None);
    }
    let mut len_bytes = &buf[..HDR];
    let len = len_bytes.get_u32() as usize;

    if len > MAX_FRAME_BYTES {
        return Err(ProtoError::FrameTooLarge {
            got: len,
            max: MAX_FRAME_BYTES,
        });
    }

    if buf.len() < HDR + len {
        // Not enough yet
        return Ok(None);
    }

    buf.advance(HDR);
    let kind_b = buf.get_u8();
    let Some(kind) = FrameKind::from_byte(kind_b) else {
        // Treat as control error; drop this frame safely by consuming payload.
        buf.advance(len - 1);
        return Err(ProtoError::BadPreamble {
            got: [b'F', b'K', kind_b, 0, 0],
        });
    };

    let payload_len = len - 1;
    let payload = buf.split_to(payload_len).freeze();

    Ok(Some(Frame { kind, payload }))
}

```

### crates/svc-overlay/src/readiness/mod.rs
<a id="crates-svc-overlay-src-readiness-mod-rs"></a>

```rust
//! RO:WHAT — Readiness/health gate
use parking_lot::RwLock;
use std::sync::Arc;

#[derive(Clone)]
pub struct HealthGate(Arc<RwLock<State>>);

#[derive(Default)]
struct State {
    pub listeners_bound: bool,
    pub metrics_bound: bool,
    pub cfg_loaded: bool,
    pub queues_ok: bool,
    pub shed_rate_ok: bool,
    pub fd_headroom: bool,
}

impl HealthGate {
    #[must_use]
    pub fn new() -> Self {
        Self(Arc::new(RwLock::new(State::default())))
    }

    pub fn set_listeners_bound(&self, v: bool) {
        self.0.write().listeners_bound = v;
    }
    pub fn set_metrics_bound(&self, v: bool) {
        self.0.write().metrics_bound = v;
    }
    pub fn set_cfg_loaded(&self, v: bool) {
        self.0.write().cfg_loaded = v;
    }
    pub fn set_queues_ok(&self, v: bool) {
        self.0.write().queues_ok = v;
    }
    pub fn set_shed_rate_ok(&self, v: bool) {
        self.0.write().shed_rate_ok = v;
    }
    pub fn set_fd_headroom(&self, v: bool) {
        self.0.write().fd_headroom = v;
    }

    pub fn readyz_state(&self) -> (u16, serde_json::Value) {
        let s = self.0.read();
        let ok = s.listeners_bound
            && s.metrics_bound
            && s.cfg_loaded
            && s.queues_ok
            && s.shed_rate_ok
            && s.fd_headroom;

        if ok {
            (200, serde_json::json!({"ready": true}))
        } else {
            let mut missing = vec![];
            if !s.listeners_bound {
                missing.push("listeners_bound");
            }
            if !s.metrics_bound {
                missing.push("metrics_bound");
            }
            if !s.cfg_loaded {
                missing.push("cfg_loaded");
            }
            if !s.queues_ok {
                missing.push("queues_ok");
            }
            if !s.shed_rate_ok {
                missing.push("shed_rate_ok");
            }
            if !s.fd_headroom {
                missing.push("fd_headroom");
            }

            (
                503,
                serde_json::json!({
                    "ready": false,
                    "degraded": true,
                    "missing": missing,
                    "retry_after": 5
                }),
            )
        }
    }

    pub fn healthz(&self) -> (u16, serde_json::Value) {
        (200, serde_json::json!({"ok": true}))
    }
}

// ✅ Satisfy clippy: `new_without_default`
impl Default for HealthGate {
    fn default() -> Self {
        Self::new()
    }
}

```

### crates/svc-overlay/src/readiness/sampler.rs
<a id="crates-svc-overlay-src-readiness-sampler-rs"></a>

```rust
//! RO:WHAT — Readiness sampler (periodic checks). Placeholder.
#![allow(dead_code)]

```

### crates/svc-overlay/src/shutdown.rs
<a id="crates-svc-overlay-src-shutdown-rs"></a>

```rust
//! RO:WHAT — Shutdown coordination
pub async fn wait_for_shutdown() {
    let _ = tokio::signal::ctrl_c().await;
}

```

### crates/svc-overlay/src/supervisor.rs
<a id="crates-svc-overlay-src-supervisor-rs"></a>

```rust
//! RO:WHAT — Runtime supervisor for overlay loops
use crate::{admin::ReadyProbe, config::Config, listener};
use anyhow::Result;
use tokio::task::JoinHandle;
use tracing::{info, warn};

pub struct OverlayRuntime {
    join: JoinHandle<()>,
    stop: tokio::sync::oneshot::Sender<()>,
    listener: Option<listener::ListenerHandle>,
}

impl OverlayRuntime {
    pub async fn start(cfg: Config, probe: ReadyProbe) -> Result<Self> {
        // Bind listener first; flips /readyz to green when successful.
        let lh = listener::spawn_listener(&cfg, &probe).await?;

        let (stop_tx, mut stop_rx) = tokio::sync::oneshot::channel::<()>();
        let join = tokio::spawn(async move {
            info!("overlay supervisor running");
            loop {
                tokio::select! {
                    _ = &mut stop_rx => {
                        info!("overlay supervisor stopping");
                        break;
                    }
                    _ = tokio::time::sleep(std::time::Duration::from_millis(250)) => {
                        // place periodic tasks here (samplers, house-keeping)
                    }
                }
            }
        });

        Ok(Self {
            join,
            stop: stop_tx,
            listener: Some(lh),
        })
    }

    pub async fn shutdown(mut self) -> Result<()> {
        if let Some(lh) = self.listener.take() {
            lh.shutdown().await?;
        }
        let _ = self.stop.send(());
        if let Err(e) = self.join.await {
            warn!(error=?e, "overlay supervisor join error");
        }
        Ok(())
    }
}

```

### crates/svc-overlay/src/transport/mod.rs
<a id="crates-svc-overlay-src-transport-mod-rs"></a>

```rust
//! RO:WHAT — Transport facade for svc-overlay.
//! RO:WHY  — Allow swapping plain TCP for `ron-transport` without touching call-sites.
//! RO:NOTE — For now, BOTH feature paths use Tokio TCP. When we align with the real
//!           `ron-transport` API, only this file needs changes.

use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};

pub struct Listener {
    inner: TcpListener,
}

pub struct TransportStream {
    pub inner: TcpStream,
}

impl TransportStream {
    pub fn into_split(
        self,
    ) -> (
        tokio::net::tcp::OwnedReadHalf,
        tokio::net::tcp::OwnedWriteHalf,
    ) {
        self.inner.into_split()
    }
}

pub async fn bind_listener(addr: SocketAddr) -> std::io::Result<(Listener, SocketAddr)> {
    let inner = TcpListener::bind(addr).await?;
    let local = inner.local_addr()?;
    Ok((Listener { inner }, local))
}

impl Listener {
    pub async fn accept(&self) -> std::io::Result<(TransportStream, SocketAddr)> {
        let (sock, peer) = self.inner.accept().await?;
        Ok((TransportStream { inner: sock }, peer))
    }
}

```

### crates/svc-overlay/src/transport/quic.rs
<a id="crates-svc-overlay-src-transport-quic-rs"></a>

```rust
//! RO:WHAT — QUIC transport (stub)
#![allow(dead_code)]

```

### crates/svc-overlay/src/transport/tls.rs
<a id="crates-svc-overlay-src-transport-tls-rs"></a>

```rust
//! RO:WHAT — TLS transport (stub)
#![allow(dead_code)]

```

### crates/svc-overlay/src/transport/tor.rs
<a id="crates-svc-overlay-src-transport-tor-rs"></a>

```rust
//! RO:WHAT — Tor transport (stub)
#![allow(dead_code)]

```

### crates/svc-overlay/src/tuning.rs
<a id="crates-svc-overlay-src-tuning-rs"></a>

```rust
//! RO:WHAT — Small runtime “tuning knobs” for svc-overlay.
//! RO:WHY  — Allow ops/tests to tune without rebuilds until full Config plumbing lands.
//!
//! Env vars (optional):
//! - RON_OVERLAY_TX_WATERMARK : i64   — default 96 (of 128-slot TX queue)
//! - RON_OVERLAY_HANDSHAKE_MS : u64   — default 2000 (ms)
//!
//! Invariants:
//! - Clamped to safe ranges; parsing failures fall back to defaults.
//! - Values are read on each call; cheap enough for infrequent reads in our usage.

use std::time::Duration;

const DEF_WATERMARK: i64 = 96;
const DEF_HSHAKE_MS: u64 = 2_000;

pub fn tx_queue_watermark() -> i64 {
    match std::env::var("RON_OVERLAY_TX_WATERMARK") {
        Ok(v) => v
            .parse::<i64>()
            .ok()
            .map(|n| n.clamp(1, 127))
            .unwrap_or(DEF_WATERMARK),
        Err(_) => DEF_WATERMARK,
    }
}

pub fn handshake_timeout() -> Duration {
    let ms = match std::env::var("RON_OVERLAY_HANDSHAKE_MS") {
        Ok(v) => v
            .parse::<u64>()
            .ok()
            .map(|ms| ms.clamp(100, 30_000))
            .unwrap_or(DEF_HSHAKE_MS),
        Err(_) => DEF_HSHAKE_MS,
    };
    Duration::from_millis(ms)
}

```

### crates/svc-overlay/src/types.rs
<a id="crates-svc-overlay-src-types-rs"></a>

```rust
//! RO:WHAT — Common types
#![allow(dead_code)]
use std::net::SocketAddr;
pub type PeerAddr = SocketAddr;

```

### crates/svc-overlay/tests/http_contract.rs
<a id="crates-svc-overlay-tests-httpcontract-rs"></a>

```rust
// http_contract.rs — placeholder
// Validates /healthz, /readyz semantics and /metrics scrape shape.

```

### crates/svc-overlay/tests/integration/oap_session_handshake.rs
<a id="crates-svc-overlay-tests-integration-oapsessionhandshake-rs"></a>

```rust
// oap_session_handshake.rs — placeholder
// Drives session establishment over the real stack (hello/ack paths).

```

### crates/svc-overlay/tests/integration/overlay_admin_roundtrip.rs
<a id="crates-svc-overlay-tests-integration-overlayadminroundtrip-rs"></a>

```rust
// overlay_admin_roundtrip.rs — placeholder
// Spins admin plane (healthz/readyz/metrics) and asserts end-to-end contracts.

```

### crates/svc-overlay/tests/integration/overlay_oap_streaming.rs
<a id="crates-svc-overlay-tests-integration-overlayoapstreaming-rs"></a>

```rust
// overlay_oap_streaming.rs — placeholder
// Streaming happy-path with bounded backpressure and latency assertions.

```

### crates/svc-overlay/tests/interop_vectors.rs
<a id="crates-svc-overlay-tests-interopvectors-rs"></a>

```rust
// interop_vectors.rs — placeholder
// Golden vectors for hello/ack, oversize/ratio rejects (OAP invariants).

```

### crates/svc-overlay/tests/loom/loom_overlay.rs
<a id="crates-svc-overlay-tests-loom-loomoverlay-rs"></a>

```rust
// loom_overlay.rs — placeholder
// Interleavings for one-writer invariant, bounded queues, orderly shutdown.

```

### crates/svc-overlay/tests/metrics_schema.rs
<a id="crates-svc-overlay-tests-metricsschema-rs"></a>

```rust
// metrics_schema.rs — placeholder
// Emits sample metrics and asserts names/labels match docs/api-history.

```

### crates/svc-overlay/tests/pq_negotiation.rs
<a id="crates-svc-overlay-tests-pqnegotiation-rs"></a>

```rust
// pq_negotiation.rs — placeholder
// Matrix tests: off<->off, hybrid<->hybrid, hybrid<->off refusal cases.

```

### crates/svc-overlay/tests/readiness_under_pressure.rs
<a id="crates-svc-overlay-tests-readinessunderpressure-rs"></a>

```rust
// readiness_under_pressure.rs — placeholder
// Induces saturation; expects early degrade and recovery.

```



---



# svc-dht

_Source: crates/svc-dht/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:54:58Z -->
# Code Bundle — `svc-dht`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-dht/.cargo/config.toml](#crates-svc-dht--cargo-config-toml)
- [crates/svc-dht/.github/workflows/ci.yml](#crates-svc-dht--github-workflows-ci-yml)
- [crates/svc-dht/.github/workflows/fuzz.yml](#crates-svc-dht--github-workflows-fuzz-yml)
- [crates/svc-dht/.github/workflows/mermaid.yml](#crates-svc-dht--github-workflows-mermaid-yml)
- [crates/svc-dht/.github/workflows/perf.yml](#crates-svc-dht--github-workflows-perf-yml)
- [crates/svc-dht/.rustfmt.toml](#crates-svc-dht--rustfmt-toml)
- [crates/svc-dht/Cargo.toml](#crates-svc-dht-Cargo-toml)
- [crates/svc-dht/benches/lookup_bench.rs](#crates-svc-dht-benches-lookupbench-rs)
- [crates/svc-dht/build.rs](#crates-svc-dht-build-rs)
- [crates/svc-dht/clippy.toml](#crates-svc-dht-clippy-toml)
- [crates/svc-dht/examples/find_providers.rs](#crates-svc-dht-examples-findproviders-rs)
- [crates/svc-dht/examples/provide.rs](#crates-svc-dht-examples-provide-rs)
- [crates/svc-dht/fuzz/fuzz_targets/kad_packet_decode.rs](#crates-svc-dht-fuzz-fuzztargets-kadpacketdecode-rs)
- [crates/svc-dht/fuzz/fuzz_targets/msg_frame_decode.rs](#crates-svc-dht-fuzz-fuzztargets-msgframedecode-rs)
- [crates/svc-dht/loom/loom_hedge.rs](#crates-svc-dht-loom-loomhedge-rs)
- [crates/svc-dht/loom/loom_kbucket.rs](#crates-svc-dht-loom-loomkbucket-rs)
- [crates/svc-dht/rust-toolchain.toml](#crates-svc-dht-rust-toolchain-toml)
- [crates/svc-dht/scripts/chaos/netem.sh](#crates-svc-dht-scripts-chaos-netem-sh)
- [crates/svc-dht/scripts/chaos/partition.sh](#crates-svc-dht-scripts-chaos-partition-sh)
- [crates/svc-dht/scripts/provide-and-check.sh](#crates-svc-dht-scripts-provide-and-check-sh)
- [crates/svc-dht/scripts/render-mermaid.sh](#crates-svc-dht-scripts-render-mermaid-sh)
- [crates/svc-dht/scripts/run-local.sh](#crates-svc-dht-scripts-run-local-sh)
- [crates/svc-dht/scripts/smoke_svc_dht.sh](#crates-svc-dht-scripts-smokesvcdht-sh)
- [crates/svc-dht/scripts/ttl-demo.sh](#crates-svc-dht-scripts-ttl-demo-sh)
- [crates/svc-dht/scripts/two-node-local.sh](#crates-svc-dht-scripts-two-node-local-sh)
- [crates/svc-dht/src/bootstrap.rs](#crates-svc-dht-src-bootstrap-rs)
- [crates/svc-dht/src/cache/memory.rs](#crates-svc-dht-src-cache-memory-rs)
- [crates/svc-dht/src/cache/mod.rs](#crates-svc-dht-src-cache-mod-rs)
- [crates/svc-dht/src/cache/sled_cache.rs](#crates-svc-dht-src-cache-sledcache-rs)
- [crates/svc-dht/src/codec/decode.rs](#crates-svc-dht-src-codec-decode-rs)
- [crates/svc-dht/src/codec/encode.rs](#crates-svc-dht-src-codec-encode-rs)
- [crates/svc-dht/src/codec/frame.rs](#crates-svc-dht-src-codec-frame-rs)
- [crates/svc-dht/src/codec/limits.rs](#crates-svc-dht-src-codec-limits-rs)
- [crates/svc-dht/src/codec/mod.rs](#crates-svc-dht-src-codec-mod-rs)
- [crates/svc-dht/src/config.rs](#crates-svc-dht-src-config-rs)
- [crates/svc-dht/src/errors.rs](#crates-svc-dht-src-errors-rs)
- [crates/svc-dht/src/health.rs](#crates-svc-dht-src-health-rs)
- [crates/svc-dht/src/invariants.rs](#crates-svc-dht-src-invariants-rs)
- [crates/svc-dht/src/lib.rs](#crates-svc-dht-src-lib-rs)
- [crates/svc-dht/src/main.rs](#crates-svc-dht-src-main-rs)
- [crates/svc-dht/src/metrics.rs](#crates-svc-dht-src-metrics-rs)
- [crates/svc-dht/src/peer/bucket.rs](#crates-svc-dht-src-peer-bucket-rs)
- [crates/svc-dht/src/peer/id.rs](#crates-svc-dht-src-peer-id-rs)
- [crates/svc-dht/src/peer/mod.rs](#crates-svc-dht-src-peer-mod-rs)
- [crates/svc-dht/src/peer/selector.rs](#crates-svc-dht-src-peer-selector-rs)
- [crates/svc-dht/src/peer/table.rs](#crates-svc-dht-src-peer-table-rs)
- [crates/svc-dht/src/pipeline/asn_guard.rs](#crates-svc-dht-src-pipeline-asnguard-rs)
- [crates/svc-dht/src/pipeline/deadlines.rs](#crates-svc-dht-src-pipeline-deadlines-rs)
- [crates/svc-dht/src/pipeline/hedging.rs](#crates-svc-dht-src-pipeline-hedging-rs)
- [crates/svc-dht/src/pipeline/lookup.rs](#crates-svc-dht-src-pipeline-lookup-rs)
- [crates/svc-dht/src/pipeline/mod.rs](#crates-svc-dht-src-pipeline-mod-rs)
- [crates/svc-dht/src/pipeline/provide.rs](#crates-svc-dht-src-pipeline-provide-rs)
- [crates/svc-dht/src/pipeline/rate_limit.rs](#crates-svc-dht-src-pipeline-ratelimit-rs)
- [crates/svc-dht/src/pq/algo.rs](#crates-svc-dht-src-pq-algo-rs)
- [crates/svc-dht/src/pq/gating.rs](#crates-svc-dht-src-pq-gating-rs)
- [crates/svc-dht/src/pq/mod.rs](#crates-svc-dht-src-pq-mod-rs)
- [crates/svc-dht/src/pq/verify.rs](#crates-svc-dht-src-pq-verify-rs)
- [crates/svc-dht/src/provider/mod.rs](#crates-svc-dht-src-provider-mod-rs)
- [crates/svc-dht/src/provider/record.rs](#crates-svc-dht-src-provider-record-rs)
- [crates/svc-dht/src/provider/republish.rs](#crates-svc-dht-src-provider-republish-rs)
- [crates/svc-dht/src/provider/store.rs](#crates-svc-dht-src-provider-store-rs)
- [crates/svc-dht/src/provider/ttl.rs](#crates-svc-dht-src-provider-ttl-rs)
- [crates/svc-dht/src/readiness.rs](#crates-svc-dht-src-readiness-rs)
- [crates/svc-dht/src/rpc/bus.rs](#crates-svc-dht-src-rpc-bus-rs)
- [crates/svc-dht/src/rpc/discv5.rs](#crates-svc-dht-src-rpc-discv5-rs)
- [crates/svc-dht/src/rpc/http.rs](#crates-svc-dht-src-rpc-http-rs)
- [crates/svc-dht/src/rpc/kad.rs](#crates-svc-dht-src-rpc-kad-rs)
- [crates/svc-dht/src/rpc/mod.rs](#crates-svc-dht-src-rpc-mod-rs)
- [crates/svc-dht/src/supervision/backoff.rs](#crates-svc-dht-src-supervision-backoff-rs)
- [crates/svc-dht/src/supervision/mod.rs](#crates-svc-dht-src-supervision-mod-rs)
- [crates/svc-dht/src/supervision/signals.rs](#crates-svc-dht-src-supervision-signals-rs)
- [crates/svc-dht/src/supervision/supervisor.rs](#crates-svc-dht-src-supervision-supervisor-rs)
- [crates/svc-dht/src/tracing.rs](#crates-svc-dht-src-tracing-rs)
- [crates/svc-dht/src/transport/clients.rs](#crates-svc-dht-src-transport-clients-rs)
- [crates/svc-dht/src/transport/mod.rs](#crates-svc-dht-src-transport-mod-rs)
- [crates/svc-dht/src/transport/tor.rs](#crates-svc-dht-src-transport-tor-rs)
- [crates/svc-dht/src/types.rs](#crates-svc-dht-src-types-rs)
- [crates/svc-dht/tests/api_smoke.rs](#crates-svc-dht-tests-apismoke-rs)
- [crates/svc-dht/tests/asn_diversity.rs](#crates-svc-dht-tests-asndiversity-rs)
- [crates/svc-dht/tests/chaos/netem.rs](#crates-svc-dht-tests-chaos-netem-rs)
- [crates/svc-dht/tests/chaos/partition.rs](#crates-svc-dht-tests-chaos-partition-rs)
- [crates/svc-dht/tests/chaos/soak_churn.rs](#crates-svc-dht-tests-chaos-soakchurn-rs)
- [crates/svc-dht/tests/deadline_hedge.rs](#crates-svc-dht-tests-deadlinehedge-rs)
- [crates/svc-dht/tests/kbucket_props.rs](#crates-svc-dht-tests-kbucketprops-rs)
- [crates/svc-dht/tests/nodeid_and_store.rs](#crates-svc-dht-tests-nodeidandstore-rs)
- [crates/svc-dht/tests/provider_roundtrip.rs](#crates-svc-dht-tests-providerroundtrip-rs)
- [crates/svc-dht/tests/readiness_bootstrap.rs](#crates-svc-dht-tests-readinessbootstrap-rs)

### crates/svc-dht/.cargo/config.toml
<a id="crates-svc-dht--cargo-config-toml"></a>

```toml
[alias]
fmt = "fmt --all"
clippy = "clippy --all-targets -- -D warnings"
test-all = "test --all-features"

```

### crates/svc-dht/.github/workflows/ci.yml
<a id="crates-svc-dht--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'placeholder CI (fmt/clippy/tests/deny/coverage/mutation)'

```

### crates/svc-dht/.github/workflows/fuzz.yml
<a id="crates-svc-dht--github-workflows-fuzz-yml"></a>

```yaml
name: fuzz
on:
  schedule: [{cron: "0 3 * * *"}]
jobs:
  fuzz:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'placeholder fuzz workflow'

```

### crates/svc-dht/.github/workflows/mermaid.yml
<a id="crates-svc-dht--github-workflows-mermaid-yml"></a>

```yaml
name: mermaid
on: [push, pull_request]
jobs:
  render:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'placeholder mermaid render'

```

### crates/svc-dht/.github/workflows/perf.yml
<a id="crates-svc-dht--github-workflows-perf-yml"></a>

```yaml
name: perf
on:
  workflow_dispatch:
  schedule: [{cron: "0 6 * * *"}]
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'placeholder perf SLO regression check'

```

### crates/svc-dht/.rustfmt.toml
<a id="crates-svc-dht--rustfmt-toml"></a>

```toml
max_width = 100
use_small_heuristics = "Max"


```

### crates/svc-dht/Cargo.toml
<a id="crates-svc-dht-Cargo-toml"></a>

```toml
[package]
name = "svc-dht"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
authors = ["RustyOnions"]
description = "RustyOnions DHT service (Kademlia/Discv5)—discovery & providers"
repository = "https://github.com/RustyOnions/RustyOnions"
rust-version = "1.80.0"
build = "build.rs"

[features]
default = ["tls"]
tls = []
arti = []            # Tor/Arti via ron-transport
sled-cache = []      # optional sled-backed cache layer

[dependencies]
tokio = { version = "1.47.0", features = ["rt-multi-thread","macros","signal","time","sync","io-util","net"] }
axum = { version = "0.7.9", features = ["tokio","http1","http2","json"] }
hyper = "1.4"
http = "1.1"
tower = "0.5"
tower-http = { version = "0.6.6", features = ["trace","cors","timeout"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter","fmt","json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "2.0"
anyhow = "1.0"
bytes = "1.6"
prometheus = "0.14"
once_cell = "1.19"
rand = "0.9"
blake3 = "1.5"
base64 = "0.22"
hex = "0.4"
arc-swap = "1.7"
parking_lot = "0.12"

# RON crates via relative paths (works whether or not workspace.dependencies exists)
ron-kernel    = { path = "../ron-kernel" }
ron-metrics   = { path = "../ron-metrics" }
ron-transport = { path = "../ron-transport" }
ron-proto     = { path = "../ron-proto" }
oap           = { path = "../oap" }

# Optional sled cache
sled = { version = "0.34", optional = true }

[dev-dependencies]
tokio = { version = "1.47.0", features = ["rt-multi-thread","macros","time","sync"] }
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls-native-roots","json"] }
criterion = { version = "0.5", features = ["async_tokio"] }

[[bench]]
name = "lookup_bench"
harness = false

[build-dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock"] }

```

### crates/svc-dht/benches/lookup_bench.rs
<a id="crates-svc-dht-benches-lookupbench-rs"></a>

```rust
//! Criterion + custom stats: lookup baseline and optional hedge tail-rescue sim.
//! RO:WHAT — (1) Baseline lookup path with β sweep and zero stagger (fast).
//!           (2) Optional tail-rescue sim showing P50/P95/P99 (env-gated).
//! RO:RUN  — Fast baseline only (default):
//!            cargo bench -p svc-dht --bench lookup_bench
//!           Include tail-rescue sim (tunable):
//!            DHT_SIM=1 DHT_TRIALS=600 DHT_PSLOW=0.05 DHT_STAGGER_MS=2 cargo bench -p svc-dht --bench lookup_bench

use std::sync::{
    atomic::{AtomicU64, Ordering},
    Arc,
};
use std::time::{Duration, Instant};

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};
use svc_dht::pipeline::hedging::race_hedged;
use svc_dht::pipeline::lookup::{LookupCtx, LookupRequest};
use svc_dht::provider::Store;

// ---------- tiny helpers ----------
fn percentiles(mut xs: Vec<f64>) -> (f64, f64, f64) {
    if xs.is_empty() {
        return (0.0, 0.0, 0.0);
    }
    xs.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let idx = |p: f64| -> usize {
        let n = xs.len() as f64;
        let k = (p * (n - 1.0)).round() as usize;
        k.min(xs.len() - 1)
    };
    (xs[idx(0.50)], xs[idx(0.95)], xs[idx(0.99)])
}

// SplitMix-like deterministic mixer (no non-Send RNG).
#[inline]
fn mix64(mut x: u64) -> u64 {
    x = x.wrapping_add(0x9E3779B97F4A7C15);
    let mut z = x;
    z = (z ^ (z >> 30)).wrapping_mul(0xBF58476D1CE4E5B9);
    z = (z ^ (z >> 27)).wrapping_mul(0x94D049BB133111EB);
    z ^ (z >> 31)
}
#[inline]
fn mix_range_inc(x: u64, min: u64, max: u64) -> u64 {
    let span = max.saturating_sub(min) + 1;
    min + (mix64(x) % span)
}

// ---------- optional tail-rescue sim (env-gated) ----------
fn maybe_print_hedge_tail_rescue(rt: &tokio::runtime::Runtime) {
    let sim = std::env::var("DHT_SIM").ok().and_then(|s| s.parse::<u8>().ok()).unwrap_or(0);
    if sim == 0 {
        // Keep benches fast unless explicitly enabled.
        return;
    }

    let trials: usize =
        std::env::var("DHT_TRIALS").ok().and_then(|s| s.parse().ok()).unwrap_or(400);
    let p_slow: f64 = std::env::var("DHT_PSLOW").ok().and_then(|s| s.parse().ok()).unwrap_or(0.05);
    let hedge_stagger_ms: u64 =
        std::env::var("DHT_STAGGER_MS").ok().and_then(|s| s.parse().ok()).unwrap_or(2);
    let slow_min: u64 =
        std::env::var("DHT_SLOW_MIN_MS").ok().and_then(|s| s.parse().ok()).unwrap_or(80);
    let slow_max: u64 =
        std::env::var("DHT_SLOW_MAX_MS").ok().and_then(|s| s.parse().ok()).unwrap_or(120);
    let fast_min: u64 =
        std::env::var("DHT_FAST_MIN_MS").ok().and_then(|s| s.parse().ok()).unwrap_or(1);
    let fast_max: u64 =
        std::env::var("DHT_FAST_MAX_MS").ok().and_then(|s| s.parse().ok()).unwrap_or(2);
    let leg_budget_ms: u64 =
        std::env::var("DHT_LEG_BUDGET_MS").ok().and_then(|s| s.parse().ok()).unwrap_or(150);

    let leg_budget = Duration::from_millis(leg_budget_ms);
    let ctr = Arc::new(AtomicU64::new(1));

    let run_beta = |beta: usize| -> Vec<f64> {
        let mut out = Vec::with_capacity(trials);
        rt.block_on(async {
            for _ in 0..trials {
                let t0 = Instant::now();
                let _ = race_hedged::<_, _, (), ()>(
                    beta,
                    Duration::from_millis(hedge_stagger_ms),
                    leg_budget,
                    {
                        let ctr = ctr.clone();
                        move |leg_idx| {
                            let seed =
                                ctr.fetch_add(1, Ordering::Relaxed).wrapping_add(leg_idx as u64);
                            async move {
                                // primary slow with prob p_slow; hedges fast
                                let slow_roll = (mix64(seed) as f64) / (u64::MAX as f64);
                                let is_slow_primary = leg_idx == 0 && slow_roll < p_slow;
                                let delay_ms = if is_slow_primary {
                                    mix_range_inc(seed ^ 0xA5A5, slow_min, slow_max)
                                } else {
                                    mix_range_inc(seed ^ 0x5A5A, fast_min, fast_max)
                                };
                                tokio::time::sleep(Duration::from_millis(delay_ms)).await;
                                Ok(())
                            }
                        }
                    },
                )
                .await;
                out.push(t0.elapsed().as_secs_f64() * 1_000.0);
            }
        });
        out
    };

    let b0 = run_beta(0);
    let b1 = run_beta(1);
    let b2 = run_beta(2);
    let b3 = run_beta(3);
    let (b0_p50, b0_p95, b0_p99) = percentiles(b0);
    let (b1_p50, b1_p95, b1_p99) = percentiles(b1);
    let (b2_p50, b2_p95, b2_p99) = percentiles(b2);
    let (b3_p50, b3_p95, b3_p99) = percentiles(b3);

    println!(
        "\n=== Hedge Tail Rescue (trials={} p_slow={:.1}% stagger={}ms budget={}ms) ===",
        trials,
        p_slow * 100.0,
        hedge_stagger_ms,
        leg_budget_ms
    );
    println!("β=0  P50={:.2}ms  P95={:.2}ms  P99={:.2}ms", b0_p50, b0_p95, b0_p99);
    println!("β=1  P50={:.2}ms  P95={:.2}ms  P99={:.2}ms", b1_p50, b1_p95, b1_p99);
    println!("β=2  P50={:.2}ms  P95={:.2}ms  P99={:.2}ms", b2_p50, b2_p95, b2_p99);
    println!("β=3  P50={:.2}ms  P95={:.2}ms  P99={:.2}ms", b3_p50, b3_p95, b3_p99);
    println!("(sim is env-gated; default bench does not run it)");
}

// ---------- (1) Baseline: lookup over in-memory store (no stagger) ----------
fn bench_lookup_baseline(c: &mut Criterion) {
    let store = Arc::new(Store::new(Duration::from_secs(60)));
    let cid = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef".to_string();

    // Warm providers so the lookup path returns immediately.
    for i in 0..8 {
        store.add(cid.clone(), format!("local://node{i}"), Some(Duration::from_secs(60)));
    }
    let ctx = LookupCtx::new(store, 64);

    // Current-thread RT for stable measurements.
    let rt = tokio::runtime::Builder::new_current_thread().enable_time().build().expect("rt");

    // Print the optional tail simulation (fast baseline remains unaffected if DHT_SIM=0).
    maybe_print_hedge_tail_rescue(&rt);

    let mut group = c.benchmark_group("lookup_baseline");
    for beta in [0usize, 1, 2, 3] {
        group.bench_with_input(BenchmarkId::new("beta", beta), &beta, |b, &bval| {
            b.iter(|| {
                rt.block_on(async {
                    let req = LookupRequest {
                        cid: cid.clone(),
                        alpha: 1,
                        beta: bval,
                        hop_budget: 6,
                        deadline: Duration::from_millis(200),
                        hedge_stagger: Duration::from_millis(0), // ← zero to measure orchestration
                        min_leg_budget: Duration::from_millis(5),
                    };
                    // Don’t panic in benches; rare timing hiccups shouldn’t fail the run.
                    let _ = ctx.run(req).await;
                });
            });
        });
    }
    group.finish();
}

criterion_group!(benches, bench_lookup_baseline);
criterion_main!(benches);

```

### crates/svc-dht/build.rs
<a id="crates-svc-dht-build-rs"></a>

```rust
use std::process::Command;

fn main() {
    // Best-effort short git SHA
    let sha = Command::new("git")
        .args(["rev-parse", "--short", "HEAD"])
        .output()
        .ok()
        .and_then(|o| {
            if o.status.success() {
                Some(String::from_utf8_lossy(&o.stdout).trim().to_string())
            } else {
                None
            }
        })
        .unwrap_or_else(|| "unknown".to_string());

    // Build timestamp (UTC, RFC3339)
    let ts = chrono::Utc::now().to_rfc3339();

    println!("cargo:rustc-env=BUILD_GIT_SHA={}", sha);
    println!("cargo:rustc-env=BUILD_TS={}", ts);
}

```

### crates/svc-dht/clippy.toml
<a id="crates-svc-dht-clippy-toml"></a>

```toml
warn-on-all-wildcard-imports = true

```

### crates/svc-dht/examples/find_providers.rs
<a id="crates-svc-dht-examples-findproviders-rs"></a>

```rust
//! Example: GET /dht/find_providers/:cid from a running svc-dht.
//! Run the service in another terminal: `cargo run -p svc-dht`
//! Then: `cargo run -p svc-dht --example find_providers -- b3:deadbeef`

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cid = std::env::args().nth(1).unwrap_or_else(|| "b3:deadbeef".into());
    let addr = std::env::var("DHT_ADDR").unwrap_or_else(|_| "127.0.0.1:5301".into());
    let url = format!("http://{addr}/dht/find_providers/{cid}");
    let txt = reqwest::get(url).await?.text().await?;
    println!("{txt}");
    Ok(())
}

```

### crates/svc-dht/examples/provide.rs
<a id="crates-svc-dht-examples-provide-rs"></a>

```rust
//! Example: POST /dht/provide to a running svc-dht.
//! Run the service in another terminal: `cargo run -p svc-dht`
//! Then: `cargo run -p svc-dht --example provide -- b3:deadbeef local://nodeA 60`

use std::time::Duration;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let mut args = std::env::args().skip(1);
    let cid = args.next().unwrap_or_else(|| "b3:deadbeef".to_string());
    let node = args.next().unwrap_or_else(|| "local://nodeA".to_string());
    let ttl = args.next().and_then(|s| s.parse::<u64>().ok()).unwrap_or(60);
    let addr = std::env::var("DHT_ADDR").unwrap_or_else(|_| "127.0.0.1:5301".into());

    let url = format!("http://{addr}/dht/provide");
    let body = serde_json::json!({ "cid": cid, "node": node, "ttl_secs": ttl });
    let cli = reqwest::Client::builder().timeout(Duration::from_secs(5)).build()?;
    let res = cli.post(url).json(&body).send().await?.text().await?;
    println!("{res}");
    Ok(())
}

```

### crates/svc-dht/fuzz/fuzz_targets/kad_packet_decode.rs
<a id="crates-svc-dht-fuzz-fuzztargets-kadpacketdecode-rs"></a>

```rust
// fuzz: kad_packet_decode (placeholder).

```

### crates/svc-dht/fuzz/fuzz_targets/msg_frame_decode.rs
<a id="crates-svc-dht-fuzz-fuzztargets-msgframedecode-rs"></a>

```rust
// fuzz: msg_frame_decode (placeholder).

```

### crates/svc-dht/loom/loom_hedge.rs
<a id="crates-svc-dht-loom-loomhedge-rs"></a>

```rust
// loom: hedged fan-out invariants (placeholder).

```

### crates/svc-dht/loom/loom_kbucket.rs
<a id="crates-svc-dht-loom-loomkbucket-rs"></a>

```rust
// loom: k-bucket invariants (placeholder).

```

### crates/svc-dht/rust-toolchain.toml
<a id="crates-svc-dht-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["clippy", "rustfmt"]

```

### crates/svc-dht/scripts/chaos/netem.sh
<a id="crates-svc-dht-scripts-chaos-netem-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Apply/remove tc netem profiles (placeholder).

```

### crates/svc-dht/scripts/chaos/partition.sh
<a id="crates-svc-dht-scripts-chaos-partition-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Simulate network partition topology locally (placeholder).

```

### crates/svc-dht/scripts/provide-and-check.sh
<a id="crates-svc-dht-scripts-provide-and-check-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
CID="${1:-b3:deadbeef}"
NODE="${2:-local://nodeA}"
TTL="${3:-60}"
ADDR="${4:-127.0.0.1:5301}"

curl -s -X POST "http://${ADDR}/dht/provide" \
  -H "content-type: application/json" \
  -d "{\"cid\":\"${CID}\",\"node\":\"${NODE}\",\"ttl_secs\":${TTL}}" | jq

curl -s "http://${ADDR}/dht/find_providers/${CID}" | jq
curl -s "http://${ADDR}/metrics" | grep -E "dht_lookup_latency_seconds_count|dht_lookup_hops|dht_lookups_total" || true

```

### crates/svc-dht/scripts/render-mermaid.sh
<a id="crates-svc-dht-scripts-render-mermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# Render docs/*.mmd to SVG (placeholder).

```

### crates/svc-dht/scripts/run-local.sh
<a id="crates-svc-dht-scripts-run-local-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
# run-local.sh — local smoke: readyz → provide → find → metrics

ADDR="${1:-127.0.0.1:5301}"
CID="${2:-b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef}"
NODE="${3:-local://nodeA}"
TTL="${4:-60}"

echo ">>> Waiting for readyz at http://${ADDR}/readyz ..."
for i in $(seq 1 100); do
  code=$(curl -s -o /dev/null -w "%{http_code}" "http://${ADDR}/readyz" || true)
  [ "$code" = "200" ] && echo "ready" && break
  sleep 0.1
done

echo ">>> Version:"
curl -s "http://${ADDR}/version" | jq -r '.'

echo ">>> Provide:"
curl -s -X POST "http://${ADDR}/dht/provide" \
  -H "content-type: application/json" \
  -d "{\"cid\":\"${CID}\",\"node\":\"${NODE}\",\"ttl_secs\":${TTL}}" | jq -r '.'

echo ">>> Find:"
curl -s "http://${ADDR}/dht/find_providers/${CID}" | jq -r '.'

echo ">>> Metrics (grep dht_*):"
curl -s "http://${ADDR}/metrics" | grep -E "dht_lookup_|dht_lookups_total|dht_provides_total" || true

echo "done"

```

### crates/svc-dht/scripts/smoke_svc_dht.sh
<a id="crates-svc-dht-scripts-smokesvcdht-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

echo "== svc-dht smoke start =="
echo "== format + clippy =="
cargo fmt -p svc-dht
cargo clippy -p svc-dht --no-deps -- -D warnings

echo "== unit/integration tests =="
cargo test -p svc-dht -- --nocapture

echo "== bench (short) =="
cargo bench -p svc-dht --bench lookup_bench -- --measurement-time 2 --warm-up-time 1 || true

echo "== local E2E (provide/find/metrics) =="
# runs against a locally started svc-dht (in another terminal)
crates/svc-dht/scripts/run-local.sh || true

echo "== done =="

```

### crates/svc-dht/scripts/ttl-demo.sh
<a id="crates-svc-dht-scripts-ttl-demo-sh"></a>

```bash
#!/usr/bin/env bash
# ttl-demo.sh — local provide → find_providers → TTL expiry demo for svc-dht
# Supports auto-spawn of the service.
#
# Usage:
#   ./ttl-demo.sh [--spawn] [--cid b3:short] [--node local://tmp] [--ttl 2] [--addr 127.0.0.1:5301] [--timeout 30]
#
# Notes:
# - If --spawn is provided, this script will run `cargo run -p svc-dht` in the background,
#   wait for /readyz, perform the demo, and then terminate the service.
# - Requires: curl; jq (optional for pretty JSON)
#
#
# EXAMPLE RUN: 
# TERMINAL A: cargo run -p svc-dht
# TERMINAL B: crates/svc-dht/scripts/ttl-demo.sh --spawn --ttl 2
#

set -euo pipefail

CID="b3:short"
NODE="local://tmp"
TTL=2
ADDR="127.0.0.1:5301"
TIMEOUT=30
SPAWN=0
CARGO_CMD="cargo run -p svc-dht"
LOGFILE="/tmp/svc-dht.demo.log"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --cid)      CID="$2"; shift 2 ;;
    --node)     NODE="$2"; shift 2 ;;
    --ttl)      TTL="$2"; shift 2 ;;
    --addr)     ADDR="$2"; shift 2 ;;
    --timeout)  TIMEOUT="$2"; shift 2 ;;
    --spawn)    SPAWN=1; shift ;;
    -h|--help)
      echo "Usage: $0 [--spawn] [--cid b3:short] [--node local://tmp] [--ttl 2] [--addr 127.0.0.1:5301] [--timeout 30]"
      exit 0
      ;;
    *)
      echo "Unknown arg: $1"
      exit 1
      ;;
  esac
done

has_jq() { command -v jq >/dev/null 2>&1; }
json_pretty() { if has_jq; then jq; else python3 -m json.tool 2>/dev/null || cat; fi; }
get() { curl -sS "http://$ADDR$1"; }
post_json() { curl -sS -H "content-type: application/json" -d "$2" "http://$ADDR$1"; }

PROC_PGID=""
cleanup() {
  if [[ "$SPAWN" -eq 1 && -n "${PROC_PGID:-}" ]]; then
    echo
    echo ">>> Stopping spawned svc-dht (pgid=$PROC_PGID)"
    kill -TERM "-$PROC_PGID" >/dev/null 2>&1 || true
    sleep 1
    kill -KILL "-$PROC_PGID" >/dev/null 2>&1 || true
  fi
}
trap cleanup EXIT

if [[ "$SPAWN" -eq 1 ]]; then
  echo ">>> Spawning svc-dht and logging to $LOGFILE"
  # Start in its own process group so we can kill the whole tree cleanly later.
  bash -c "set -m; $CARGO_CMD &> '$LOGFILE' & echo \$! > '$LOGFILE.pid'; disown" &
  # Wait for pid file
  for _ in $(seq 1 50); do
    [[ -f "$LOGFILE.pid" ]] && break
    sleep 0.1
  done
  if [[ ! -f "$LOGFILE.pid" ]]; then
    echo "Failed to obtain svc-dht PID (check $LOGFILE)."
    exit 1
  fi
  PID="$(cat "$LOGFILE.pid")"
  # Get the process group id (pgid == pid for group leader)
  PROC_PGID="$(ps -o pgid= -p "$PID" 2>/dev/null | tr -d ' ')"
  if [[ -z "$PROC_PGID" ]]; then
    echo "Could not determine process group; PID=$PID. Proceeding without kill group."
  fi
fi

echo ">>> Waiting for readiness at http://$ADDR/readyz (timeout ${TIMEOUT}s)..."
deadline=$(( $(date +%s) + TIMEOUT ))
while :; do
  # Capture both curl status and http code
  HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$ADDR/readyz" || echo 000)
  if [[ "$HTTP_CODE" == "200" ]]; then
    echo "Ready."
    break
  fi
  if (( $(date +%s) >= deadline )); then
    echo "Service not ready (HTTP $HTTP_CODE) before timeout."
    if [[ "$SPAWN" -eq 1 ]]; then
      echo "Last 50 lines from $LOGFILE:"
      tail -n 50 "$LOGFILE" || true
    fi
    exit 1
  fi
  sleep 0.2
done

echo
echo ">>> Version:"
get "/version" | json_pretty

echo
echo ">>> Posting provide (cid=$CID, node=$NODE, ttl=$TTL s)"
RESP=$(post_json "/dht/provide" "$(printf '{"cid":"%s","node":"%s","ttl_secs":%s}' "$CID" "$NODE" "$TTL")")
echo "$RESP" | json_pretty

echo
echo ">>> Immediate find_providers:"
get "/dht/find_providers/$CID" | json_pretty

echo
echo ">>> Debug snapshot (with seconds remaining):"
get "/dht/_debug/list" | json_pretty

echo
echo ">>> Metrics (before sleep):"
get "/metrics" | grep -E "dht_provides_total|dht_lookups_total" || true

echo
echo ">>> Sleeping ${TTL}s + 1 to allow TTL to expire..."
sleep $((TTL + 1))

echo
echo ">>> find_providers after expiry (should be empty):"
get "/dht/find_providers/$CID" | json_pretty

echo
echo ">>> Metrics (after):"
get "/metrics" | grep -E "dht_provides_total|dht_lookups_total" || true

if [[ "$SPAWN" -eq 1 ]]; then
  echo
  echo ">>> svc-dht logs (tail):"
  tail -n 50 "$LOGFILE" || true
fi

echo
echo "Done."

```

### crates/svc-dht/scripts/two-node-local.sh
<a id="crates-svc-dht-scripts-two-node-local-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# RO:WHAT — Launch two svc-dht nodes on different admin ports, seed them, prove cross-node lookup.
# RO:RUN
#   chmod +x crates/svc-dht/scripts/two-node-local.sh
#   crates/svc-dht/scripts/two-node-local.sh

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
BIN="target/debug/svc-dht"

if ! command -v jq >/dev/null 2>&1; then
  echo "jq required"; exit 1
fi

echo "== build =="
cargo build -p svc-dht >/dev/null

CID="b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

killall -q svc-dht || true
sleep 0.2

echo "== start node A (5301) =="
RON_DHT_ADMIN_ADDR=127.0.0.1:5301 \
RON_DHT_SEEDS="" \
RON_DHT_NODE_URI="local://nodeA" \
"${BIN}" >/tmp/svc-dht-A.log 2>&1 &

echo "== start node B (5302) =="
RON_DHT_ADMIN_ADDR=127.0.0.1:5302 \
RON_DHT_SEEDS="http://127.0.0.1:5301" \
RON_DHT_NODE_URI="local://nodeB" \
"${BIN}" >/tmp/svc-dht-B.log 2>&1 &

ready() { curl -fsS "$1/readyz" >/dev/null 2>&1; }

echo "== wait ready =="
for i in {1..50}; do
  ready http://127.0.0.1:5301 && ready http://127.0.0.1:5302 && break
  sleep 0.1
done

echo "== provide on node A =="
curl -fsS -X POST http://127.0.0.1:5301/provide \
  -H 'content-type: application/json' \
  -d "{\"cid\":\"${CID}\",\"node\":\"local://nodeA\",\"ttl_secs\":60}" | jq .

echo "== find from node B (should discover A) =="
curl -fsS "http://127.0.0.1:5302/find/${CID}" | jq .

echo "== metrics B (grep dht_) =="
curl -fsS http://127.0.0.1:5302/metrics | grep -E '^dht_' || true

echo "== tail logs (A/B hints) =="
echo "-- A --"; tail -n 3 /tmp/svc-dht-A.log || true
echo "-- B --"; tail -n 3 /tmp/svc-dht-B.log || true

echo "== done =="

```

### crates/svc-dht/src/bootstrap.rs
<a id="crates-svc-dht-src-bootstrap-rs"></a>

```rust
//! RO:WHAT — Seed dialing + min-fill readiness gate
//! RO:WHY — Bring table to life before accepting work; Concerns: RES/PERF
//! RO:INTERACTS — peer::table, metrics, readiness, transport
//! RO:INVARIANTS — backoff with jitter; no locks across .await
//! RO:TEST — readiness_bootstrap.rs

use crate::{config::Config, metrics::DhtMetrics, readiness::ReadyGate};
use rand::{rng, Rng};
use ron_kernel::HealthState;
use std::sync::Arc;
use tokio::time::{sleep, Duration};
use tracing::{info, warn};

pub struct Supervisor {
    shutdown_tx: Option<tokio::sync::oneshot::Sender<()>>,
    handle: tokio::task::JoinHandle<()>,
}

impl Supervisor {
    pub async fn shutdown(mut self) {
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(());
        }
        let _ = self.handle.await;
    }
}

pub async fn spawn_bootstrap_supervisor(
    cfg: Config,
    _health: Arc<HealthState>,
    ready: Arc<ReadyGate>,
    _metrics: Arc<DhtMetrics>,
) -> anyhow::Result<Supervisor> {
    let (tx, mut rx) = tokio::sync::oneshot::channel::<()>();

    let handle = tokio::spawn(async move {
        // Single pass for MVP; in Phase 2 we'll loop with backoff until quorum/min-fill.
        tokio::select! {
            _ = &mut rx => {
                info!("bootstrap supervisor: shutdown");
            }
            _ = do_once(&cfg) => {
                ready.set_ready();
                info!("bootstrap: min-fill reached; ready gate opened");
            }
        }
    });

    Ok(Supervisor { shutdown_tx: Some(tx), handle })
}

async fn do_once(cfg: &Config) {
    // TODO Phase 2: dial seeds via ron-transport; refresh k-buckets by distance
    if cfg.seeds.is_empty() {
        warn!("no seeds configured; table will rely on inbound discovery");
        sleep(Duration::from_millis(300)).await;
    } else {
        for s in &cfg.seeds {
            let _ = s; // simulate dial
            let jitter = rng().random_range(10..60);
            sleep(Duration::from_millis(jitter)).await;
        }
    }
}

```

### crates/svc-dht/src/cache/memory.rs
<a id="crates-svc-dht-src-cache-memory-rs"></a>

```rust
// cache::memory - RAM cache (placeholder).

```

### crates/svc-dht/src/cache/mod.rs
<a id="crates-svc-dht-src-cache-mod-rs"></a>

```rust
//! RO:WHAT — Cache facade (RAM default; sled optional)
//! RO:WHY — Micronode amnesia by default; Concerns: PERF/SEC
pub mod memory; // TODO phase 2
#[cfg(feature = "sled-cache")]
pub mod sled_cache; // TODO phase 2

```

### crates/svc-dht/src/cache/sled_cache.rs
<a id="crates-svc-dht-src-cache-sledcache-rs"></a>

```rust
// cache::sled_cache - sled-backed cache (placeholder).

```

### crates/svc-dht/src/codec/decode.rs
<a id="crates-svc-dht-src-codec-decode-rs"></a>

```rust
// codec::decode - parsers (placeholder).

```

### crates/svc-dht/src/codec/encode.rs
<a id="crates-svc-dht-src-codec-encode-rs"></a>

```rust
// codec::encode - serializers (placeholder).

```

### crates/svc-dht/src/codec/frame.rs
<a id="crates-svc-dht-src-codec-frame-rs"></a>

```rust
// codec::frame - OAP/1 frame constants (placeholder).

```

### crates/svc-dht/src/codec/limits.rs
<a id="crates-svc-dht-src-codec-limits-rs"></a>

```rust
//! RO:WHAT — Central protocol size/time limits (OAP guidance mirrored)
//! RO:WHY — Hardening; Concerns: SEC
pub const MAX_FRAME_BYTES: usize = 1_048_576; // 1 MiB
pub const CHUNK_BYTES: usize = 64 * 1024; // 64 KiB (storage stream knob)

```

### crates/svc-dht/src/codec/mod.rs
<a id="crates-svc-dht-src-codec-mod-rs"></a>

```rust
//! RO:WHAT — Codec module (frame/encode/decode/limits)
//! RO:WHY — Isolate parser logic for fuzzing; Concerns: SEC/RES
pub mod decode; // TODO phase 2
pub mod encode;
pub mod frame; // TODO phase 2
pub mod limits; // TODO phase 2

```

### crates/svc-dht/src/config.rs
<a id="crates-svc-dht-src-config-rs"></a>

```rust
//! RO:WHAT — svc-dht configuration (binds, α/β, k, seeds, timeouts, amnesia)
//! RO:WHY — Centralized knobs; Concerns: GOV/RES/PERF; hot-reload-friendly shape
//! RO:INTERACTS — bootstrap, peer::table, rpc/http handlers, transport
//! RO:INVARIANTS — values bounded; α ≤ k; β ≤ α; timeouts sane; amnesia honored
//! RO:TEST — config parse unit tests; trybuild for compile-fail when invalid

use serde::{Deserialize, Serialize};
use std::{
    env,
    net::{IpAddr, Ipv4Addr, SocketAddr},
    time::Duration,
};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Config {
    pub admin_bind: SocketAddr,
    pub alpha: usize,
    pub beta: usize,
    pub k: usize,
    pub hop_budget: usize,
    pub dial_timeout_ms: u64,
    pub idle_timeout_ms: u64,
    pub seeds: Vec<String>,
    pub amnesia: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            admin_bind: SocketAddr::from((IpAddr::V4(Ipv4Addr::LOCALHOST), 5301)),
            alpha: 3,
            beta: 1,
            k: 20,
            hop_budget: 6,
            dial_timeout_ms: 1_500,
            idle_timeout_ms: 5_000,
            seeds: vec![],
            amnesia: true,
        }
    }
}

impl Config {
    pub fn from_env() -> anyhow::Result<Self> {
        let mut cfg = Self::default();
        if let Ok(s) = env::var("DHT_ADMIN_BIND") {
            cfg.admin_bind = s.parse()?;
        }
        if let Ok(v) = env::var("DHT_ALPHA") {
            cfg.alpha = v.parse()?;
        }
        if let Ok(v) = env::var("DHT_BETA") {
            cfg.beta = v.parse()?;
        }
        if let Ok(v) = env::var("DHT_K") {
            cfg.k = v.parse()?;
        }
        if let Ok(v) = env::var("DHT_HOP_BUDGET") {
            cfg.hop_budget = v.parse()?;
        }
        if let Ok(v) = env::var("DHT_DIAL_TIMEOUT_MS") {
            cfg.dial_timeout_ms = v.parse()?;
        }
        if let Ok(v) = env::var("DHT_IDLE_TIMEOUT_MS") {
            cfg.idle_timeout_ms = v.parse()?;
        }
        if let Ok(v) = env::var("DHT_SEEDS") {
            cfg.seeds =
                v.split(',').map(|s| s.trim().to_string()).filter(|s| !s.is_empty()).collect();
        }
        if let Ok(v) = env::var("RON_AMNESIA") {
            cfg.amnesia = matches!(v.as_str(), "1") || v.eq_ignore_ascii_case("true");
        }
        cfg.validate()?;
        Ok(cfg)
    }

    pub fn validate(&self) -> anyhow::Result<()> {
        use anyhow::bail;
        if self.alpha == 0 || self.k == 0 {
            bail!("alpha and k must be > 0");
        }
        if self.beta > self.alpha {
            bail!("beta must be <= alpha");
        }
        if self.k < self.alpha {
            bail!("k (bucket size) should be >= alpha");
        }
        if self.hop_budget == 0 {
            bail!("hop budget must be > 0");
        }
        if self.dial_timeout_ms < 100 || self.idle_timeout_ms < 500 {
            bail!("timeouts too small");
        }
        if self.seeds.iter().any(|s| s.len() > 255) {
            bail!("seed too long");
        }
        Ok(())
    }

    pub fn dial_timeout(&self) -> Duration {
        Duration::from_millis(self.dial_timeout_ms)
    }
    pub fn idle_timeout(&self) -> Duration {
        Duration::from_millis(self.idle_timeout_ms)
    }
}

```

### crates/svc-dht/src/errors.rs
<a id="crates-svc-dht-src-errors-rs"></a>

```rust
//! RO:WHAT — Error taxonomy for svc-dht with user hints
//! RO:WHY — Deterministic, typed errors; Concerns: DX/GOV/SEC
//! RO:INTERACTS — rpc/http, pipeline, provider store
//! RO:INVARIANTS — stable Display; avoid leaking internals
//! RO:TEST — unit tests for Display and status mapping

use thiserror::Error;

#[derive(Debug, Error)]
pub enum DhtError {
    #[error("bootstrap quorum not reached")]
    NoBootstrap,
    #[error("asn diversity floor not met")]
    AsnCap,
    #[error("payload oversize")]
    OverSize,
    #[error("hop budget exceeded")]
    HopBudget,
    #[error("timeout")]
    Timeout,
    #[error("internal: {0}")]
    Internal(String),
}

```

### crates/svc-dht/src/health.rs
<a id="crates-svc-dht-src-health-rs"></a>

```rust
//! RO:WHAT — Health/liveness helpers
//! RO:WHY — Truthful health; Concerns: RES/GOV
//! RO:INTERACTS — /healthz
//! RO:INVARIANTS — cheap checks; truth over green
//! RO:TEST — healthz returns 200

use ron_kernel::HealthState;
use std::sync::Arc;

pub type HealthHandles = Arc<HealthState>;

```

### crates/svc-dht/src/invariants.rs
<a id="crates-svc-dht-src-invariants-rs"></a>

```rust
//! svc-dht invariants — compile-time and doc-level assertions that define the contract
//! RO:WHAT — Kademlia- and pipeline-related constants/invariants that other modules rely on.
//! RO:WHY  — Guard against accidental drift during refactors. Fail fast at build time.
//! RO:GATES — F (Functional), RES (Resilience), PERF (no per-call heap).
//!
//! Invariants:
//! - NodeId is 32 bytes (BLAKE3 digest); XOR distance is exactly 32 bytes.
//! - α (alpha: fanout) in [1, 16] (small, bounded concurrency per round).
//! - β (beta: hedges) in [0, 4] (limit tail-rescue parallelism).
//! - hop_budget in [1, 64] (guard against runaway traversal).
//! - Hedge stagger and leg budget are sane (stagger << budget).
//!
//! ```text
//! Kademlia rounds proceed with α parallel queries; hedging may add up to β extra legs
//! per logical lookup, spaced by a small stagger delay to rescue tail latency.
//! ```

#![allow(clippy::doc_markdown)]

pub const NODEID_LEN: usize = 32;
pub const ALPHA_MIN: usize = 1;
pub const ALPHA_MAX: usize = 16;
pub const BETA_MIN: usize = 0;
pub const BETA_MAX: usize = 4;
pub const HOPS_MIN: usize = 1;
pub const HOPS_MAX: usize = 64;

/// Sanity check helper usable in const context
const fn within(v: usize, lo: usize, hi: usize) -> bool {
    v >= lo && v <= hi
}

/// Compile-time assertions — these run when this module is referenced.
#[allow(dead_code)]
pub const fn _compile_time_guards() {
    // NodeId length must remain 32 (BLAKE3).
    // If this ever changes, XOR distance math must be updated.
    assert!(NODEID_LEN == 32);

    // Parameter envelopes (keep lookup bounded).
    assert!(within(ALPHA_MIN, 1, 32));
    assert!(within(ALPHA_MAX, 1, 32));
    assert!(ALPHA_MIN <= ALPHA_MAX);

    assert!(within(BETA_MIN, 0, 8));
    assert!(within(BETA_MAX, 0, 8));
    assert!(BETA_MIN <= BETA_MAX);

    assert!(within(HOPS_MIN, 1, 256));
    assert!(within(HOPS_MAX, 1, 256));
    assert!(HOPS_MIN <= HOPS_MAX);
}

/// Tiny doc test to lock the NodeId XOR shape without importing the full type.
/// (Keeps this module independent.)
#[cfg(test)]
mod tests {
    #[test]
    fn xor_distance_is_32_bytes() {
        let a = [0xAAu8; 32];
        let b = [0x55u8; 32];
        let mut out = [0u8; 32];
        for (i, o) in out.iter_mut().enumerate() {
            *o = a[i] ^ b[i];
        }
        assert_eq!(out.len(), 32);
        assert_eq!(out[0], 0xFF);
        assert_eq!(out[31], 0xFF);
    }
}

```

### crates/svc-dht/src/lib.rs
<a id="crates-svc-dht-src-lib-rs"></a>

```rust
//! RO:WHAT — Public crate surface & re-exports for svc-dht (Kademlia service)
//! RO:WHY — P10 Overlay/Transport/Discovery; Concerns: SEC/RES/PERF/GOV
//! RO:INTERACTS — ron-kernel (Bus/Health), ron-transport (I/O), axum (admin), ron-proto (DTOs)
//! RO:INVARIANTS — no lock across .await; single-writer per k-bucket; OAP max_frame=1MiB; chunk≈64KiB
//! RO:METRICS — exposes dht_* histograms/counters; /metrics, /healthz, /readyz
//! RO:CONFIG — svc-dht Config; amnesia honored
//! RO:SECURITY — capability checks occur at ingress/gateway; DHT path rejects oversize/abuse
//! RO:TEST — tests/* integration; loom later for kbucket single-writer

pub mod config;
pub mod errors;
pub mod health;
pub mod metrics;
pub mod readiness;
pub mod tracing;
pub use tracing as ro_tracing;

pub mod bootstrap;
pub mod cache;
pub mod codec;
pub mod peer;
pub mod pipeline;
pub mod provider;
pub mod rpc;
pub mod supervision;
pub mod transport;
pub mod types;

pub use config::Config;
pub use health::HealthHandles;
pub use metrics::DhtMetrics;
pub use provider::Store as ProviderStore;
pub use readiness::ReadyGate;

```

### crates/svc-dht/src/main.rs
<a id="crates-svc-dht-src-main-rs"></a>

```rust
//! RO:WHAT — Binary entrypoint: init tracing/metrics, load config, spawn supervisor, serve admin HTTP
//! RO:WHY — Service bootstrap; Concerns SEC/RES/PERF/GOV with observable readiness

use axum::{
    routing::{get, post},
    Router,
};
use std::{net::SocketAddr, sync::Arc, time::Duration};
use tokio::task::JoinHandle;
use tracing::{info, warn};

use ron_kernel::{wait_for_ctrl_c, HealthState};
use svc_dht::provider::ttl::spawn_pruner;
use svc_dht::rpc::http;
use svc_dht::{
    bootstrap, config::Config, metrics::DhtMetrics, pipeline::lookup::LookupCtx,
    readiness::ReadyGate, ro_tracing, ProviderStore,
};

#[tokio::main(flavor = "multi_thread")]
async fn main() -> anyhow::Result<()> {
    ro_tracing::init();
    let cfg = Config::from_env()?;
    let health = Arc::new(HealthState::default());
    let ready = Arc::new(ReadyGate::new());
    let metrics = Arc::new(DhtMetrics::new()?);
    let providers = Arc::new(ProviderStore::new(Duration::from_secs(600)));
    let _pruner = spawn_pruner(providers.clone());

    // Pipeline context — set a sane global leg concurrency
    let lookup_ctx = Arc::new(LookupCtx::new(providers.clone(), /*max_legs*/ 64));

    // Admin HTTP
    let (admin_task, admin_addr) = serve_admin(
        cfg.admin_bind,
        health.clone(),
        ready.clone(),
        metrics.clone(),
        providers.clone(),
        // pipeline knobs from Config
        cfg.alpha,
        cfg.beta,
        cfg.hop_budget,
        /* default_deadline */ Duration::from_millis(300),
        /* hedge_stagger   */ Duration::from_millis(25),
        /* min_leg_budget  */ Duration::from_millis(50),
        lookup_ctx.clone(),
    )
    .await?;
    info!(%admin_addr, "svc-dht admin up");

    // Bootstrap routing state & supervision
    let sup = bootstrap::spawn_bootstrap_supervisor(
        cfg.clone(),
        health.clone(),
        ready.clone(),
        metrics.clone(),
    )
    .await?;

    // Wait for Ctrl-C and shutdown
    wait_for_ctrl_c().await;
    warn!("shutdown requested");
    sup.shutdown().await;
    admin_task.abort();
    Ok(())
}

#[allow(clippy::too_many_arguments)]
async fn serve_admin(
    bind: SocketAddr,
    health: Arc<HealthState>,
    ready: Arc<ReadyGate>,
    metrics: Arc<DhtMetrics>,
    providers: Arc<ProviderStore>,
    alpha: usize,
    beta: usize,
    hop_budget: usize,
    default_deadline: Duration,
    hedge_stagger: Duration,
    min_leg_budget: Duration,
    lookup_ctx: Arc<LookupCtx>,
) -> anyhow::Result<(JoinHandle<()>, SocketAddr)> {
    let app = Router::new()
        .route("/healthz", get(http::healthz))
        .route("/readyz", get(http::readyz))
        .route("/version", get(http::version))
        .route("/metrics", get(http::metrics))
        .route("/dht/find_providers/:cid", get(http::find_providers))
        .route("/dht/provide", post(http::provide))
        .route("/dht/_debug/list", get(http::debug_list))
        .with_state(http::State::new(
            health,
            ready,
            metrics,
            providers,
            alpha,
            beta,
            hop_budget,
            default_deadline,
            hedge_stagger,
            min_leg_budget,
            lookup_ctx,
        ));

    let listener = tokio::net::TcpListener::bind(bind).await?;
    let addr = listener.local_addr()?;
    let task = tokio::spawn(async move {
        axum::serve(listener, app).await.unwrap();
    });
    Ok((task, addr))
}

```

### crates/svc-dht/src/metrics.rs
<a id="crates-svc-dht-src-metrics-rs"></a>

```rust
//! RO:WHAT — Prometheus metrics for svc-dht
//! RO:WHY — Observability; Concerns: PERF/GOV
//! RO:INTERACTS — rpc/http /metrics; bootstrap/pipeline update counters
//! RO:INVARIANTS — register once; cheap hot path

use once_cell::sync::Lazy;
use prometheus::{
    register_histogram, register_int_counter, Encoder, Histogram, IntCounter, TextEncoder,
};

pub struct DhtMetrics {
    pub lookups_total: IntCounter,
    pub provides_total: IntCounter,
    pub lookup_latency_seconds: Histogram,
    pub lookup_hops: Histogram,
}

impl DhtMetrics {
    pub fn new() -> anyhow::Result<Self> {
        Ok(Self {
            lookups_total: register_int_counter!("dht_lookups_total", "Total DHT lookups")?,
            provides_total: register_int_counter!("dht_provides_total", "Total DHT provides")?,
            lookup_latency_seconds: register_histogram!(
                "dht_lookup_latency_seconds",
                "Lookup latency seconds",
                vec![0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1.0]
            )?,
            lookup_hops: register_histogram!(
                "dht_lookup_hops",
                "Lookup hop count",
                vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
            )?,
        })
    }

    /// RO:WHAT — Record one lookup completion with latency + hop count.
    pub fn observe_lookup(&self, dur: std::time::Duration, hops: u32) {
        self.lookups_total.inc();
        self.lookup_latency_seconds.observe(dur.as_secs_f64());
        self.lookup_hops.observe(hops as f64);
    }

    pub fn encode() -> anyhow::Result<String> {
        static ENC: Lazy<TextEncoder> = Lazy::new(TextEncoder::new);
        let mf = prometheus::gather();
        let mut buf = Vec::with_capacity(8 * 1024);
        ENC.encode(&mf, &mut buf)?;
        Ok(String::from_utf8_lossy(&buf).to_string())
    }
}

```

### crates/svc-dht/src/peer/bucket.rs
<a id="crates-svc-dht-src-peer-bucket-rs"></a>

```rust
//! RO:WHAT — Single-writer Kademlia bucket (MVP)
//! RO:WHY — Enforce single-writer discipline; Concerns: RES
use super::id::NodeId;
use parking_lot::Mutex;

pub struct KBucket {
    k: usize,
    // single-writer: interior mut guarded, not held across await in higher layers
    inner: Mutex<Vec<NodeId>>,
}

impl KBucket {
    pub fn new(k: usize) -> Self {
        Self { k, inner: Mutex::new(Vec::with_capacity(k)) }
    }

    pub fn touch(&self, id: NodeId) {
        let mut g = self.inner.lock();
        if let Some(pos) = g.iter().position(|x| *x == id) {
            let n = g.remove(pos);
            g.insert(0, n);
            return;
        }
        if g.len() < self.k {
            g.insert(0, id);
        } else {
            // naive eviction: drop tail (older)
            g.pop();
            g.insert(0, id);
        }
    }

    pub fn snapshot(&self) -> Vec<NodeId> {
        self.inner.lock().clone()
    }
}

```

### crates/svc-dht/src/peer/id.rs
<a id="crates-svc-dht-src-peer-id-rs"></a>

```rust
//! RO:WHAT — Compact `NodeId` and XOR distance
//! RO:WHY  — Kademlia math; Concerns: PERF/RES

use blake3::hash;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NodeId([u8; 32]);

impl NodeId {
    #[inline]
    pub fn from_pubkey(pk: &[u8]) -> Self {
        let h = hash(pk);
        Self(*h.as_bytes())
    }

    /// XOR distance between two node IDs.
    #[inline]
    pub fn distance(&self, other: &Self) -> [u8; 32] {
        let mut out = [0u8; 32];
        // Avoid index-based loop to satisfy clippy::needless_range_loop.
        for (dst, (&a, &b)) in out.iter_mut().zip(self.0.iter().zip(other.0.iter())) {
            *dst = a ^ b;
        }
        out
    }

    /// Optional helpers (handy in tests/callers).
    #[inline]
    pub fn to_bytes(self) -> [u8; 32] {
        self.0
    }

    #[inline]
    pub fn from_bytes(b: [u8; 32]) -> Self {
        Self(b)
    }
}

```

### crates/svc-dht/src/peer/mod.rs
<a id="crates-svc-dht-src-peer-mod-rs"></a>

```rust
//! RO:WHAT — Peer ID, Kademlia k-buckets, routing table, selectors
//! RO:WHY — Core routing structures; Concerns: RES/PERF
pub mod bucket;
pub mod id;
pub mod selector;
pub mod table;

pub use id::NodeId;
pub use table::RoutingTable;

```

### crates/svc-dht/src/peer/selector.rs
<a id="crates-svc-dht-src-peer-selector-rs"></a>

```rust
//! RO:WHAT — α-parallel, β-hedged selection placeholder
//! RO:WHY — Tail control; Concerns: PERF/RES
pub struct Selector {
    pub alpha: usize,
    pub beta: usize,
}
impl Selector {
    pub fn new(alpha: usize, beta: usize) -> Self {
        Self { alpha, beta }
    }
}

```

### crates/svc-dht/src/peer/table.rs
<a id="crates-svc-dht-src-peer-table-rs"></a>

```rust
//! RO:WHAT — Routing table over buckets
//! RO:WHY — Find closest peers; Concerns: PERF
use super::{bucket::KBucket, id::NodeId};

pub struct RoutingTable {
    buckets: Vec<KBucket>,
    _k: usize, // kept for shape; prefixed to avoid dead_code warning until used
}

impl RoutingTable {
    pub fn new(k: usize) -> Self {
        // 256-bit space → 256 buckets (MVP)
        let buckets = (0..256).map(|_| KBucket::new(k)).collect();
        Self { buckets, _k: k }
    }

    pub fn observe(&self, me: NodeId, peer: NodeId) {
        let dist = me.distance(&peer);
        let idx = leading_zeros(&dist) as usize;
        let idx = idx.min(self.buckets.len() - 1);
        self.buckets[idx].touch(peer);
    }

    pub fn closest(&self, _me: NodeId, _target: NodeId, n: usize) -> Vec<NodeId> {
        // MVP: concat from all buckets; refine in phase 2
        let mut out = Vec::with_capacity(n);
        for b in &self.buckets {
            for id in b.snapshot() {
                out.push(id);
                if out.len() == n {
                    return out;
                }
            }
        }
        out
    }
}

fn leading_zeros(bytes: &[u8; 32]) -> u32 {
    for (i, b) in bytes.iter().enumerate() {
        if *b != 0 {
            return (i as u32) * 8 + b.leading_zeros();
        }
    }
    256
}

```

### crates/svc-dht/src/pipeline/asn_guard.rs
<a id="crates-svc-dht-src-pipeline-asnguard-rs"></a>

```rust
// pipeline::asn_guard - ASN diversity (placeholder).

```

### crates/svc-dht/src/pipeline/deadlines.rs
<a id="crates-svc-dht-src-pipeline-deadlines-rs"></a>

```rust
//! RO:WHAT — Deadline budgeting for composite operations
//! RO:WHY — Ensure hedging/fanout stays within the caller budget; Concerns: PERF/RES

use std::time::{Duration, Instant};

#[derive(Clone, Copy, Debug)]
pub struct DeadlineBudget {
    start: Instant,
    total: Duration,
}

impl DeadlineBudget {
    pub fn new(total: Duration) -> Self {
        Self { start: Instant::now(), total }
    }
    pub fn remaining(&self) -> Duration {
        let spent = self.start.elapsed();
        if spent >= self.total {
            Duration::from_millis(0)
        } else {
            self.total - spent
        }
    }
    pub fn total(&self) -> Duration {
        self.total
    }
    pub fn spent(&self) -> Duration {
        self.start.elapsed()
    }
}

```

### crates/svc-dht/src/pipeline/hedging.rs
<a id="crates-svc-dht-src-pipeline-hedging-rs"></a>

```rust
//! RO:WHAT — β-hedged race between lookup legs with stagger
//! RO:WHY — Reduce tail latency while respecting deadline; Concerns: PERF/RES

use std::future::Future;
use std::time::Duration;
use tokio::time::{sleep, timeout};

/// Race a primary future with up to `beta` hedges, each staggered by `stagger`.
/// Each leg is wrapped with `timeout(leg_budget)`. The first Ok wins; errors are
/// collected and last error is returned if all fail/timeout.
pub async fn race_hedged<F, Fut, T, E>(
    beta: usize,
    stagger: Duration,
    leg_budget: Duration,
    mut mk_leg: F,
) -> Result<T, E>
where
    F: FnMut(usize) -> Fut + Send + Sync + 'static,
    Fut: Future<Output = Result<T, E>> + Send + 'static,
    T: Send + 'static,
    E: Send + Clone + Default + 'static,
{
    // beta == 0 means: just one primary
    let hedges = beta.saturating_add(1);
    let mut handles = Vec::with_capacity(hedges);

    for i in 0..hedges {
        let fut = mk_leg(i);
        let h = tokio::spawn(async move {
            let t = timeout(leg_budget, fut).await;
            match t {
                Ok(r) => r,
                Err(_) => Err(timeout_err()),
            }
        });
        handles.push(h);
        if i + 1 < hedges && !stagger.is_zero() {
            sleep(stagger).await;
        }
    }

    let mut last_err = None;
    for h in handles {
        match h.await {
            Ok(Ok(v)) => return Ok(v),
            Ok(Err(e)) => last_err = Some(e),
            Err(_) => {}
        }
    }
    Err(last_err.expect("no legs executed"))
}

// Local error helper for timeouts in the hedge layer.
fn timeout_err<E>() -> E
where
    E: Default,
{
    E::default()
}

```

### crates/svc-dht/src/pipeline/lookup.rs
<a id="crates-svc-dht-src-pipeline-lookup-rs"></a>

```rust
//! RO:WHAT — Lookup FSM: fanout (α) → hedge (β) → converge, under a deadline & hop budget
//! RO:WHY — Tail control & budget adherence; Concerns: PERF/RES
//! RO:INTERACTS — provider::Store (local for MVP); later: transport/kad over ron-transport
//! RO:INVARIANTS — no lock held across .await; limiter bounds total leg concurrency

use super::{deadlines::DeadlineBudget, hedging::race_hedged, rate_limit::Limiter};
use crate::provider::Store;
use anyhow::{anyhow, Result};
use std::{sync::Arc, time::Duration};
use tokio::time::Instant;

#[derive(Clone, Debug)]
pub struct LookupRequest {
    pub cid: String,
    pub alpha: usize,
    pub beta: usize,
    pub hop_budget: usize,
    pub deadline: Duration,
    /// Stagger between hedge legs (β) — small to control tail.
    pub hedge_stagger: Duration,
    /// Per-leg minimum budget (clamped by remaining deadline).
    pub min_leg_budget: Duration,
}

#[derive(Clone, Debug)]
pub struct LookupResult {
    pub providers: Vec<String>,
    pub hops: u32,
    pub elapsed: Duration,
}

pub struct LookupCtx {
    store: Arc<Store>,
    limiter: Limiter,
}

impl LookupCtx {
    pub fn new(store: Arc<Store>, max_concurrent_legs: usize) -> Self {
        Self { store, limiter: Limiter::new(max_concurrent_legs) }
    }

    /// Run a lookup under α/β/hedge/deadline/hop_budget. In this MVP, legs query the local
    /// provider store (network-free), but we still exercise hedging and budgets.
    pub async fn run(&self, req: LookupRequest) -> Result<LookupResult> {
        if req.alpha == 0 {
            return Err(anyhow!("alpha must be > 0"));
        }
        if req.hop_budget == 0 {
            return Err(anyhow!("hop budget must be > 0"));
        }

        let budget = DeadlineBudget::new(req.deadline);
        let started = Instant::now();

        // Compose leg runner. Each leg simulates a "hop" by counting attempt number.
        let cid = req.cid.clone();
        let store = self.store.clone();
        let limiter = self.limiter.clone();

        // Effective leg budget: honor remaining global deadline, but not below min_leg_budget.
        let leg_budget = budget.remaining().max(req.min_leg_budget);

        // In the local MVP there is **no artificial jitter** inside legs.
        // Hedging still races futures; whichever returns first wins.
        let beta = req.beta;
        let stagger = req.hedge_stagger;

        let result = race_hedged::<_, _, _, HedgeErr>(beta, stagger, leg_budget, move |leg_idx| {
            let cid = cid.clone();
            let store = store.clone();
            let limiter = limiter.clone();
            async move {
                let _permit = limiter.acquire().await;
                let providers = store.get_live(&cid);
                if providers.is_empty() {
                    Err(HedgeErr) // in a networked version we'd query peers here
                } else {
                    Ok((providers, leg_idx as u32 + 1)) // hops ~ legs tried until success
                }
            }
        })
        .await;

        match result {
            Ok((providers, hops)) => {
                Ok(LookupResult { providers, hops, elapsed: started.elapsed() })
            }
            Err(_) => Err(anyhow!("lookup failed or timed out")),
        }
    }
}

#[derive(Clone, Copy, Debug, Default)]
struct HedgeErr;

```

### crates/svc-dht/src/pipeline/mod.rs
<a id="crates-svc-dht-src-pipeline-mod-rs"></a>

```rust
//! RO:WHAT — Request orchestration (lookup/provide/hedging/limits)
//! RO:WHY — Keep policies out of handlers; Concerns: PERF/RES
pub mod deadlines;
pub mod hedging;
pub mod lookup;
pub mod rate_limit;
// (left for later slices)
pub mod provide { /* TODO: networked replication in next slice */
}
pub mod asn_guard { /* TODO: ASN diversity guard in next slice */
}

```

### crates/svc-dht/src/pipeline/provide.rs
<a id="crates-svc-dht-src-pipeline-provide-rs"></a>

```rust
// pipeline::provide - provide flow (placeholder).

```

### crates/svc-dht/src/pipeline/rate_limit.rs
<a id="crates-svc-dht-src-pipeline-ratelimit-rs"></a>

```rust
//! RO:WHAT — Simple global rate limiter for in-flight lookup legs
//! RO:WHY — Backpressure to avoid overload; Concerns: RES/PERF

use tokio::sync::{OwnedSemaphorePermit, Semaphore};

#[derive(Clone)]
pub struct Limiter {
    sem: std::sync::Arc<Semaphore>,
}

impl Limiter {
    /// new: max concurrent legs (global)
    pub fn new(max_legs: usize) -> Self {
        Self { sem: std::sync::Arc::new(Semaphore::new(max_legs)) }
    }
    pub async fn acquire(&self) -> OwnedSemaphorePermit {
        self.sem.clone().acquire_owned().await.expect("semaphore closed")
    }
}

```

### crates/svc-dht/src/pq/algo.rs
<a id="crates-svc-dht-src-pq-algo-rs"></a>

```rust
// pq::algo - ML-DSA/SPHINCS+ selection (placeholder).

```

### crates/svc-dht/src/pq/gating.rs
<a id="crates-svc-dht-src-pq-gating-rs"></a>

```rust
// pq::gating - REQUIRE/REQUIRE_ON policy (placeholder).

```

### crates/svc-dht/src/pq/mod.rs
<a id="crates-svc-dht-src-pq-mod-rs"></a>

```rust
// pq::mod - PQ posture surface (placeholder).

```

### crates/svc-dht/src/pq/verify.rs
<a id="crates-svc-dht-src-pq-verify-rs"></a>

```rust
// pq::verify - dual-sign verify (placeholder).

```

### crates/svc-dht/src/provider/mod.rs
<a id="crates-svc-dht-src-provider-mod-rs"></a>

```rust
//! RO:WHAT — Provider record facade (RAM default; TTL pruning worker)
//! RO:WHY — Enables local provide/find_providers without network
//! RO:INVARIANTS — TTL respected; amnesia-friendly (no disk by default)

pub mod record;
pub mod republish;
pub mod store;
pub mod ttl;

pub use store::Store;

```

### crates/svc-dht/src/provider/record.rs
<a id="crates-svc-dht-src-provider-record-rs"></a>

```rust
//! RO:WHAT — ProviderRecord v1 (MVP: node string + expiry)
//! RO:WHY — Minimal schema to exercise provide/find locally

use std::time::{Duration, Instant};

#[derive(Clone, Debug)]
pub struct ProviderRecord {
    pub cid: String,
    pub node: String,
    pub expires_at: Instant,
}

impl ProviderRecord {
    pub fn new(cid: String, node: String, ttl: Duration) -> Self {
        Self { cid, node, expires_at: Instant::now() + ttl }
    }
    pub fn expired(&self, now: Instant) -> bool {
        now >= self.expires_at
    }
}

```

### crates/svc-dht/src/provider/republish.rs
<a id="crates-svc-dht-src-provider-republish-rs"></a>

```rust
//! RO:WHAT — Placeholder for republish/refresh logic
//! RO:WHY — Left for Phase 2 (networked replication)
pub struct Republisher;

```

### crates/svc-dht/src/provider/store.rs
<a id="crates-svc-dht-src-provider-store-rs"></a>

```rust
//! RO:WHAT — In-memory provider store with TTL
//! RO:WHY — Micronode default; keeps MVP simple
use super::record::ProviderRecord;
use parking_lot::RwLock;
use std::{
    collections::HashMap,
    time::{Duration, Instant},
};

#[derive(Default)]
pub struct Store {
    inner: RwLock<HashMap<String, Vec<ProviderRecord>>>, // cid -> records
    default_ttl: Duration,
}

impl Store {
    pub fn new(default_ttl: Duration) -> Self {
        Self { inner: RwLock::new(HashMap::new()), default_ttl }
    }

    pub fn default_ttl(&self) -> Duration {
        self.default_ttl
    }

    /// RO:WHAT — Add/refresh a provider record (de-duped by node) for a CID.
    pub fn add(&self, cid: String, node: String, ttl: Option<Duration>) {
        let cid = normalize(&cid);
        let node = normalize(&node);
        let ttl = ttl.unwrap_or(self.default_ttl);
        let rec = ProviderRecord::new(cid.clone(), node, ttl);

        let mut g = self.inner.write();
        let v = g.entry(cid).or_default();
        // de-dup by node
        if let Some(pos) = v.iter().position(|r| r.node == rec.node) {
            v[pos] = rec;
        } else {
            v.push(rec);
        }
    }

    /// RO:WHAT — Read-only view of live providers (no mutation).
    pub fn get_live(&self, cid: &str) -> Vec<String> {
        let cid = normalize(cid);
        let now = Instant::now();
        let g = self.inner.read();
        if let Some(v) = g.get(&cid) {
            v.iter().filter(|r| !r.expired(now)).map(|r| r.node.clone()).collect()
        } else {
            Vec::new()
        }
    }

    /// RO:WHAT — Prune expired records; called by background pruner.
    pub fn purge_expired(&self) -> usize {
        let now = Instant::now();
        let mut g = self.inner.write();
        let mut purged = 0usize;
        for v in g.values_mut() {
            let before = v.len();
            v.retain(|r| !r.expired(now));
            purged += before.saturating_sub(v.len());
        }
        // drop empty CIDs
        g.retain(|_, v| !v.is_empty());
        purged
    }

    /// RO:WHAT — Debug snapshot: all CIDs with nodes and seconds-until-expiry.
    pub fn debug_snapshot(&self) -> Vec<DebugCid> {
        let now = Instant::now();
        let g = self.inner.read();
        let mut out = Vec::new();
        for (cid, recs) in g.iter() {
            let entries = recs
                .iter()
                .map(|r| DebugEntry {
                    node: r.node.clone(),
                    secs_left: r.expires_at.saturating_duration_since(now).as_secs_f64(),
                })
                .collect();
            out.push(DebugCid { cid: cid.clone(), entries });
        }
        out
    }
}

#[derive(serde::Serialize)]
pub struct DebugCid {
    pub cid: String,
    pub entries: Vec<DebugEntry>,
}

#[derive(serde::Serialize)]
pub struct DebugEntry {
    pub node: String,
    pub secs_left: f64,
}

fn normalize(s: &str) -> String {
    s.trim().to_string()
}

```

### crates/svc-dht/src/provider/ttl.rs
<a id="crates-svc-dht-src-provider-ttl-rs"></a>

```rust
//! RO:WHAT — Background TTL pruning worker
//! RO:WHY — Keeps store clean over time without external triggers

use super::Store;
use std::sync::Arc;
use tokio::time::{sleep, Duration};
use tracing::debug;

pub fn spawn_pruner(store: Arc<Store>) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        // Small initial delay to avoid racing immediately after a provide with very short TTLs.
        sleep(Duration::from_secs(2)).await;
        loop {
            let n = store.purge_expired();
            if n > 0 {
                debug!(purged = n, "provider TTL pruned");
            }
            sleep(Duration::from_secs(1)).await;
        }
    })
}

```

### crates/svc-dht/src/readiness.rs
<a id="crates-svc-dht-src-readiness-rs"></a>

```rust
//! RO:WHAT — Readiness gate: flips when bootstrap quorum + min-fill thresholds met
//! RO:WHY — Prevents thundering herd; Concerns: RES/PERF
//! RO:INTERACTS — bootstrap, peer::table, /readyz
//! RO:INVARIANTS — set ready last; fail-closed on writes
//! RO:TEST — readiness_bootstrap.rs

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

#[derive(Default)]
pub struct ReadyGate {
    ready: AtomicBool,
}
impl ReadyGate {
    pub fn new() -> Self {
        Self { ready: AtomicBool::new(false) }
    }
    pub fn set_ready(&self) {
        self.ready.store(true, Ordering::Release);
    }
    pub fn is_ready(&self) -> bool {
        self.ready.load(Ordering::Acquire)
    }
}

pub type SharedReady = Arc<ReadyGate>;

```

### crates/svc-dht/src/rpc/bus.rs
<a id="crates-svc-dht-src-rpc-bus-rs"></a>

```rust
// rpc::bus - bus topic adapters (placeholder).

```

### crates/svc-dht/src/rpc/discv5.rs
<a id="crates-svc-dht-src-rpc-discv5-rs"></a>

```rust
// rpc::discv5 - peer discovery (placeholder).

```

### crates/svc-dht/src/rpc/http.rs
<a id="crates-svc-dht-src-rpc-http-rs"></a>

```rust
//! RO:WHAT — Admin endpoints + DHT demo endpoints (provide + find_providers via pipeline)
//! RO:WHY — Ops-first; Concerns: GOV/PERF/DX/SEC. Adds CID/node validation and stable errors.
//! RO:INTERACTS — metrics, provider::Store, pipeline::lookup, types::B3Cid.
//! RO:INVARIANTS — deny unknown fields; return 400 on bad input; no lock across .await.
//! RO:TEST — tests/provider_roundtrip.rs

use axum::{extract::Path, http::StatusCode, response::IntoResponse, Json};
use std::{
    sync::Arc,
    time::{Duration, Instant},
};

use crate::{
    metrics::DhtMetrics,
    pipeline::lookup::{LookupCtx, LookupRequest},
    provider::Store,
    readiness::ReadyGate,
    types::{validate_node_uri, B3Cid},
};
use ron_kernel::HealthState;
use serde::Deserialize;

#[derive(Clone)]
pub struct State {
    pub health: Arc<HealthState>,
    pub ready: Arc<ReadyGate>,
    pub metrics: Arc<DhtMetrics>,
    pub providers: Arc<Store>,

    // Pipeline knobs (from Config)
    pub alpha: usize,
    pub beta: usize,
    pub hop_budget: usize,
    pub default_deadline: Duration,
    pub hedge_stagger: Duration,
    pub min_leg_budget: Duration,

    // Pipeline context (rate limiter etc.)
    pub lookup_ctx: Arc<LookupCtx>,
}

impl State {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        health: Arc<HealthState>,
        ready: Arc<ReadyGate>,
        metrics: Arc<DhtMetrics>,
        providers: Arc<Store>,
        alpha: usize,
        beta: usize,
        hop_budget: usize,
        default_deadline: Duration,
        hedge_stagger: Duration,
        min_leg_budget: Duration,
        lookup_ctx: Arc<LookupCtx>,
    ) -> Self {
        Self {
            health,
            ready,
            metrics,
            providers,
            alpha,
            beta,
            hop_budget,
            default_deadline,
            hedge_stagger,
            min_leg_budget,
            lookup_ctx,
        }
    }
}

pub async fn healthz(axum::extract::State(st): axum::extract::State<State>) -> impl IntoResponse {
    if st.health.all_ready() || st.ready.is_ready() {
        (StatusCode::OK, "ok").into_response()
    } else {
        (StatusCode::OK, "starting").into_response()
    }
}

pub async fn readyz(axum::extract::State(st): axum::extract::State<State>) -> impl IntoResponse {
    if st.ready.is_ready() {
        (StatusCode::OK, "ready").into_response()
    } else {
        (StatusCode::SERVICE_UNAVAILABLE, [("Retry-After", "1")], "booting").into_response()
    }
}

pub async fn version() -> impl IntoResponse {
    let sha = option_env!("BUILD_GIT_SHA").unwrap_or("unknown");
    let ts = option_env!("BUILD_TS").unwrap_or("unknown");
    Json(serde_json::json!({ "git": sha, "built": ts }))
}

pub async fn metrics() -> impl IntoResponse {
    match crate::metrics::DhtMetrics::encode() {
        Ok(text) => (StatusCode::OK, text),
        Err(_) => (StatusCode::INTERNAL_SERVER_ERROR, "encode error".to_string()),
    }
}

/// Demo: POST /dht/provide  {"cid":"b3:...","node":"nodeA","ttl_secs":600}
#[derive(Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ProvideBody {
    pub cid: B3Cid,
    pub node: String,
    #[serde(default)]
    pub ttl_secs: Option<u64>,
}

pub async fn provide(
    axum::extract::State(st): axum::extract::State<State>,
    Json(body): Json<ProvideBody>,
) -> impl IntoResponse {
    if !validate_node_uri(&body.node) {
        return (StatusCode::BAD_REQUEST, Json(serde_json::json!({ "error": "invalid node URI" })))
            .into_response();
    }

    let ttl = body.ttl_secs.map(Duration::from_secs);
    let used_ttl = ttl.unwrap_or_else(|| st.providers.default_ttl());
    st.providers.add(body.cid.into_string(), body.node, Some(used_ttl));
    st.metrics.provides_total.inc();
    (
        StatusCode::OK,
        Json(serde_json::json!({
            "ok": true,
            "ttl_secs_used": used_ttl.as_secs()
        })),
    )
        .into_response()
}

/// GET /dht/find_providers/:cid — uses the lookup pipeline (α/β/hedge/deadline)
pub async fn find_providers(
    axum::extract::State(st): axum::extract::State<State>,
    Path(cid): Path<B3Cid>,
) -> impl IntoResponse {
    let t0 = Instant::now();

    let req = LookupRequest {
        cid: cid.to_string(),
        alpha: st.alpha,
        beta: st.beta,
        hop_budget: st.hop_budget,
        deadline: st.default_deadline,
        hedge_stagger: st.hedge_stagger,
        min_leg_budget: st.min_leg_budget,
    };

    match st.lookup_ctx.run(req).await {
        Ok(res) => {
            st.metrics.observe_lookup(t0.elapsed(), res.hops);
            Json(serde_json::json!({
                "cid": cid.to_string(),
                "providers": res.providers,
                "hops": res.hops,
                "elapsed_ms": res.elapsed.as_millis(),
            }))
            .into_response()
        }
        Err(e) => {
            st.metrics.observe_lookup(t0.elapsed(), 0);
            (StatusCode::GATEWAY_TIMEOUT, Json(serde_json::json!({ "error": e.to_string() })))
                .into_response()
        }
    }
}

/// Debug: GET /dht/_debug/list — full in-memory snapshot with TTL left
pub async fn debug_list(
    axum::extract::State(st): axum::extract::State<State>,
) -> impl IntoResponse {
    let snap = st.providers.debug_snapshot();
    Json(serde_json::json!(snap))
}

```

### crates/svc-dht/src/rpc/kad.rs
<a id="crates-svc-dht-src-rpc-kad-rs"></a>

```rust
//! RO:WHAT — Kad request/response DTOs and handlers (placeholder)
//! RO:WHY — Wire surface; Concerns: DX/RES
#[derive(serde::Serialize, serde::Deserialize)]
pub struct FindProviders {
    pub cid: String,
    pub limit: usize,
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Providers {
    pub cid: String,
    pub nodes: Vec<String>,
}

```

### crates/svc-dht/src/rpc/mod.rs
<a id="crates-svc-dht-src-rpc-mod-rs"></a>

```rust
//! RO:WHAT — RPC surfaces: Kad + admin HTTP (MVP includes HTTP)
//! RO:WHY — Entry points; Concerns: DX/SEC
pub mod bus; // TODO phase 2
pub mod discv5;
pub mod http;
pub mod kad; // TODO phase 2

```

### crates/svc-dht/src/supervision/backoff.rs
<a id="crates-svc-dht-src-supervision-backoff-rs"></a>

```rust
//! RO:WHAT — Exponential backoff with jitter
//! RO:WHY — Prevents stampedes; Concerns: RES/PERF
pub fn next(prev_ms: u64) -> u64 {
    (prev_ms.saturating_mul(2)).min(30_000)
}

```

### crates/svc-dht/src/supervision/mod.rs
<a id="crates-svc-dht-src-supervision-mod-rs"></a>

```rust
//! RO:WHAT — Supervision helpers (backoff/signals)
//! RO:WHY — Crash-only discipline; Concerns: RES
pub mod backoff;
pub mod signals;

```

### crates/svc-dht/src/supervision/signals.rs
<a id="crates-svc-dht-src-supervision-signals-rs"></a>

```rust
//! RO:WHAT — Signal helpers (placeholder)
//! RO:WHY — Wiring space for future supervised tasks
pub fn install() {}

```

### crates/svc-dht/src/supervision/supervisor.rs
<a id="crates-svc-dht-src-supervision-supervisor-rs"></a>

```rust
// supervisor.rs (placeholder).

```

### crates/svc-dht/src/tracing.rs
<a id="crates-svc-dht-src-tracing-rs"></a>

```rust
//! RO:WHAT — Tracing initialization (env-filter aware)
//! RO:WHY — Uniform logs; Concerns: GOV/DX
//! RO:INTERACTS — all modules via tracing
//! RO:INVARIANTS — JSON optional; defaults to INFO

use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

pub fn init() {
    let filter =
        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info,svc_dht=info"));
    tracing_subscriber::registry().with(filter).with(fmt::layer().with_target(false)).init();
}

```

### crates/svc-dht/src/transport/clients.rs
<a id="crates-svc-dht-src-transport-clients-rs"></a>

```rust
// transport::clients - pools & timeouts (placeholder).

```

### crates/svc-dht/src/transport/mod.rs
<a id="crates-svc-dht-src-transport-mod-rs"></a>

```rust
//! RO:WHAT — Thin wrapper around ron-transport clients
//! RO:WHY — Keep svc-dht transport-agnostic; Concerns: SEC/RES
pub mod clients; // TODO phase 2
#[cfg(feature = "arti")]
pub mod tor; // TODO phase 2

```

### crates/svc-dht/src/transport/tor.rs
<a id="crates-svc-dht-src-transport-tor-rs"></a>

```rust
// transport::tor - arti support (placeholder).

```

### crates/svc-dht/src/types.rs
<a id="crates-svc-dht-src-types-rs"></a>

```rust
//! RO:WHAT — Common types (B3Cid validator, NodeUri placeholder).
//! RO:WHY  — DX/SEC hardening: validate CIDs early; avoid junk through the pipeline.
//! RO:INTERACTS — rpc::http, provider::Store, pipeline::lookup.
//! RO:INVARIANTS — BLAKE3-256 only; lowercase hex; "b3:<64-hex>"; no locks across .await.
//! RO:SECURITY — Rejects malformed IDs with 400; prevents cache poisoning.
//! RO:TEST — unit in tests/provider_roundtrip.rs and rpc/http tests.

use std::fmt;
use std::str::FromStr;

/// Canonical content address: "b3:<64-lowercase-hex>" (BLAKE3-256)
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct B3Cid(String);

impl B3Cid {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn into_string(self) -> String {
        self.0
    }
}

impl fmt::Display for B3Cid {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

impl FromStr for B3Cid {
    type Err = &'static str;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // Strict: exactly "b3:" + 64 lowercase hex chars.
        const PREFIX: &str = "b3:";
        if !s.starts_with(PREFIX) {
            return Err("bad-prefix");
        }
        let hex = &s[PREFIX.len()..];
        if hex.len() != 64 {
            return Err("bad-length");
        }
        if !hex.as_bytes().iter().all(|b| matches!(b, b'0'..=b'9'|b'a'..=b'f')) {
            return Err("bad-hex");
        }
        Ok(B3Cid(s.to_string()))
    }
}

// Serde glue so DTOs can use B3Cid directly.
impl<'de> serde::Deserialize<'de> for B3Cid {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}
impl serde::Serialize for B3Cid {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

/// Very light Node URI checker (MVP): "<scheme>://<id>"
/// We only require non-empty and forbid whitespace; detailed validation left for transport layer.
pub fn validate_node_uri(s: &str) -> bool {
    let s = s.trim();
    if s.is_empty() {
        return false;
    }
    if s.contains(char::is_whitespace) {
        return false;
    }
    s.contains("://")
}

```

### crates/svc-dht/tests/api_smoke.rs
<a id="crates-svc-dht-tests-apismoke-rs"></a>

```rust
//! Happy-path handler smoke test (no sockets).
//! Verifies: provide → find_providers JSON shape + 400 on bad input.

use std::sync::{Arc, OnceLock};
use std::time::Duration;

use axum::extract::State as AxumState;
use axum::http::StatusCode;
use axum::response::IntoResponse;
use ron_kernel::HealthState;
use svc_dht::metrics::DhtMetrics;
use svc_dht::pipeline::lookup::LookupCtx;
use svc_dht::provider::Store;
use svc_dht::readiness::ReadyGate;
use svc_dht::rpc::http::{find_providers, provide, ProvideBody, State};
use svc_dht::types::B3Cid;

// ---- test-global metrics to avoid duplicate Prometheus registration
static METRICS: OnceLock<Arc<DhtMetrics>> = OnceLock::new();
fn metrics() -> Arc<DhtMetrics> {
    METRICS.get_or_init(|| Arc::new(DhtMetrics::new().expect("metrics"))).clone()
}

fn make_state() -> State {
    let health = Arc::new(HealthState::default());
    let ready = Arc::new(ReadyGate::new());
    ready.set_ready();

    let providers = Arc::new(Store::new(Duration::from_secs(60)));
    let lookup_ctx = Arc::new(LookupCtx::new(providers.clone(), 16));

    State::new(
        health,
        ready,
        metrics(),
        providers,
        3, // alpha
        1, // beta
        6, // hop_budget
        Duration::from_millis(300),
        Duration::from_millis(15),
        Duration::from_millis(50),
        lookup_ctx,
    )
}

#[tokio::test]
async fn provide_and_find_basic() {
    let st = make_state();

    // Provide a short-lived record.
    let cid: B3Cid =
        "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef".parse().unwrap();

    let body =
        ProvideBody { cid: cid.clone(), node: "local://nodeA".to_string(), ttl_secs: Some(2) };
    let resp = provide(AxumState(st.clone()), axum::Json(body)).await.into_response();
    assert_eq!(resp.status(), StatusCode::OK);

    // Find providers (should see exactly 1).
    let resp = find_providers(AxumState(st), axum::extract::Path(cid)).await.into_response();
    assert_eq!(resp.status(), StatusCode::OK);

    let body_bytes = axum::body::to_bytes(resp.into_body(), 1024 * 1024).await.expect("body bytes");
    let v: serde_json::Value = serde_json::from_slice(&body_bytes).expect("json");
    assert_eq!(
        v.get("providers").unwrap().as_array().unwrap().len(),
        1,
        "exactly one provider expected"
    );
}

#[tokio::test]
async fn provide_rejects_bad_node_uri() {
    let st = make_state();

    let cid: B3Cid =
        "b3:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa".parse().unwrap();

    // Bad node URI should be rejected with 400.
    let bad = ProvideBody { cid, node: "not a uri".into(), ttl_secs: None };
    let resp = provide(AxumState(st), axum::Json(bad)).await.into_response();
    assert_eq!(resp.status(), StatusCode::BAD_REQUEST);
}

```

### crates/svc-dht/tests/asn_diversity.rs
<a id="crates-svc-dht-tests-asndiversity-rs"></a>

```rust
//! RO:WHAT — Local, self-contained test for "ASN diversity" selection logic.
//! RO:WHY  — We don’t have a real ASN guard yet; this models the policy in-test
//!           so we can lock behavior now and swap to the real guard later.
//! RO:NOTES — Pure test logic; no crate changes needed to pass.

use std::collections::HashSet;

/// Minimal stand-in for an "ASN diversity" filter:
/// Keep candidates while ensuring at least `min_unique_asn` distinct ASNs stay present.
/// Returns Err if impossible.
fn select_with_asn_diversity(
    mut candidates: Vec<(String, u32)>,
    min_unique_asn: usize,
    limit: usize,
) -> Result<Vec<(String, u32)>, &'static str> {
    // Greedy: first ensure we include one per ASN to hit the floor, then fill up to limit.
    candidates.sort_by_key(|(_, asn)| *asn);

    let mut seen = HashSet::new();
    let mut out = Vec::new();

    // Phase A: one per ASN until we hit the floor (or run out)
    for (node, asn) in candidates.iter().cloned() {
        if seen.insert(asn) {
            out.push((node, asn));
            if seen.len() >= min_unique_asn {
                break;
            }
        }
    }
    if seen.len() < min_unique_asn {
        return Err("asn_floor_unmet");
    }

    // Phase B: fill remainder by round-robin (here just linear pass) without ASN constraint
    for (node, asn) in candidates.into_iter() {
        if out.len() >= limit {
            break;
        }
        // allow duplicates of ASNs now
        if !out.iter().any(|(n, _)| *n == node) {
            out.push((node, asn));
        }
    }

    if out.len() > limit {
        out.truncate(limit);
    }
    Ok(out)
}

#[test]
fn rejects_all_same_asn_when_floor_gt1() {
    let candidates =
        vec![("n1".to_string(), 64512), ("n2".to_string(), 64512), ("n3".to_string(), 64512)];
    let res = select_with_asn_diversity(candidates, /*min_unique_asn*/ 2, /*limit*/ 2);
    assert!(res.is_err(), "should reject when all candidates share the same ASN");
}

#[test]
fn accepts_mix_and_meets_floor() {
    let candidates = vec![
        ("a".to_string(), 64512),
        ("b".to_string(), 64513),
        ("c".to_string(), 64512),
        ("d".to_string(), 64514),
    ];
    let out = select_with_asn_diversity(candidates, /*min_unique_asn*/ 2, /*limit*/ 3).unwrap();
    let unique_asn: HashSet<_> = out.iter().map(|(_, a)| *a).collect();
    assert!(unique_asn.len() >= 2, "expected ASN diversity floor met");
    assert!(out.len() <= 3);
}

```

### crates/svc-dht/tests/chaos/netem.rs
<a id="crates-svc-dht-tests-chaos-netem-rs"></a>

```rust
// chaos/netem.rs: latency/loss model tests (placeholder).

```

### crates/svc-dht/tests/chaos/partition.rs
<a id="crates-svc-dht-tests-chaos-partition-rs"></a>

```rust
// chaos/partition.rs: split-brain healing (placeholder).

```

### crates/svc-dht/tests/chaos/soak_churn.rs
<a id="crates-svc-dht-tests-chaos-soakchurn-rs"></a>

```rust
// chaos/soak_churn.rs: long soak & churn (placeholder).

```

### crates/svc-dht/tests/deadline_hedge.rs
<a id="crates-svc-dht-tests-deadlinehedge-rs"></a>

```rust
use std::time::Duration;
use svc_dht::pipeline::hedging::race_hedged;
use tokio::time::sleep;

#[tokio::test]
async fn hedger_respects_budget_and_stagger() {
    // NOTE: We intentionally set budget to 20ms and stagger to 5ms, then make the
    // primary slow and hedges fast. Expect total elapsed < ~25ms and Ok(()).

    let budget = Duration::from_millis(20);
    let stagger = Duration::from_millis(5);

    let started = std::time::Instant::now();

    let out = race_hedged::<_, _, (), ()>(2, stagger, budget, |leg_idx| async move {
        if leg_idx == 0 {
            sleep(Duration::from_millis(100)).await; // slow primary hits timeout → hedges win
        } else {
            sleep(Duration::from_millis(1)).await; // fast hedge
        }
        Ok(())
    })
    .await;

    let elapsed = started.elapsed();
    assert!(out.is_ok(), "hedged race should succeed via hedge");
    assert!(elapsed < Duration::from_millis(30), "elapsed too large: {elapsed:?}");
}

```

### crates/svc-dht/tests/kbucket_props.rs
<a id="crates-svc-dht-tests-kbucketprops-rs"></a>

```rust
//! RO:WHAT — Routing table properties that hold for the MVP implementation.
//! RO:WHY  — Catch regressions in bucket indexing and "closest N" behavior.
//! RO:INTERACTS — peer::{NodeId, RoutingTable}

use svc_dht::peer::{NodeId, RoutingTable};

fn nid(bytes: &[u8]) -> NodeId {
    // NodeId::from_pubkey() hashes input; that's fine for deterministic construction
    NodeId::from_pubkey(bytes)
}

#[test]
fn distance_xor_zero_for_identical_ids() {
    let a = nid(&[0xAA; 32]);
    let d = a.distance(&a);
    assert!(d.iter().all(|&b| b == 0), "distance(self,self) must be zero");
}

#[test]
fn closest_respects_limit_and_has_no_duplicates() {
    let me = nid(&[0x11; 32]);
    let rt = RoutingTable::new(/*k*/ 8);

    // Observe > 8 peers; closest(.., n) must never return more than n
    for i in 0..50u8 {
        let pk = [i; 32];
        rt.observe(me, nid(&pk));
    }

    let out = rt.closest(me, nid(&[0x22; 32]), 8);
    assert!(out.len() <= 8);

    // no duplicates
    let mut set = std::collections::HashSet::new();
    for id in &out {
        assert!(set.insert(id.clone()), "duplicate NodeId in closest()");
    }
}

#[test]
fn bucket_index_monotonicity_smoke() {
    // As distance grows, we *tend* to hit different buckets. We can't see buckets directly,
    // but we can at least ensure observe() doesn't panic and closest() is stable.
    let me = nid(&[0u8; 32]);
    let rt = RoutingTable::new(8);

    // Craft peers at different XOR distances
    let peers = [
        nid(&[0x00; 32]), // identical (distance 0)
        nid(&[0x80; 32]), // highest bit diff
        nid(&[0x7F; 32]), // many lower bits diff
        nid(&[0x01; 32]), // only LSB diff
        nid(&[0xFF; 32]), // all bits diff
    ];

    for p in peers {
        rt.observe(me, p);
    }

    let out = rt.closest(me, nid(&[0x10; 32]), 5);
    assert!(!out.is_empty());
}

```

### crates/svc-dht/tests/nodeid_and_store.rs
<a id="crates-svc-dht-tests-nodeidandstore-rs"></a>

```rust
use std::time::Duration;
use svc_dht::peer::id::NodeId;
use svc_dht::provider::Store;
use svc_dht::types::B3Cid;

#[test]
fn nodeid_distance_xor() {
    let a = NodeId::from_pubkey(b"A");
    let b = NodeId::from_pubkey(b"B");
    let d_ab = a.distance(&b);
    let d_ba = b.distance(&a);
    assert_eq!(d_ab, d_ba, "XOR is symmetric");
    assert_eq!(a.distance(&a), [0u8; 32], "distance to self is zero");
}

#[test]
fn provider_store_ttl_expiry() {
    let ttl = Duration::from_millis(20);
    let st = Store::new(ttl);
    let cid: B3Cid = "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
        .parse()
        .unwrap();

    st.add(cid.clone(), "local://nodeA".into());
    let now = std::time::Instant::now();
    let got1 = st.get(&cid);
    assert_eq!(got1, vec!["local://nodeA".to_string()]);

    // wait out TTL and prune
    std::thread::sleep(ttl + Duration::from_millis(5));
    st.prune(now + ttl + Duration::from_millis(5));
    let got2 = st.get(&cid);
    assert!(got2.is_empty(), "expired provider should be pruned");
}

```

### crates/svc-dht/tests/provider_roundtrip.rs
<a id="crates-svc-dht-tests-providerroundtrip-rs"></a>

```rust
use std::time::Duration;
use svc_dht::provider::Store;

#[test]
fn provider_add_get_prune_roundtrip() {
    let store = Store::new(Duration::from_secs(2));
    let cid = "b3:deadbeef".to_string();

    // Add two providers; ensure de-dup by node works
    store.add(cid.clone(), "local://A".into(), Some(Duration::from_millis(250)));
    store.add(cid.clone(), "local://B".into(), Some(Duration::from_millis(250)));
    store.add(cid.clone(), "local://A".into(), Some(Duration::from_millis(250))); // refresh

    let mut live = store.get_live(&cid);
    live.sort();
    assert_eq!(live, vec!["local://A", "local://B"]);

    // After expiry window, purge removes both
    std::thread::sleep(Duration::from_millis(300));
    let purged = store.purge_expired();
    assert!(purged >= 1, "expected at least one purged; got {purged}");

    let live2 = store.get_live(&cid);
    assert!(live2.is_empty(), "expected no live providers after purge, got {live2:?}");
}

```

### crates/svc-dht/tests/readiness_bootstrap.rs
<a id="crates-svc-dht-tests-readinessbootstrap-rs"></a>

```rust
#[tokio::test]
async fn boot_and_ready() {
    // Smoke: start the server main() would, but here we just hit the handlers directly
    // (Integration rig lives in the crate’s examples in phase 2)
    assert!(true);
}

```



---



# ron-naming

_Source: crates/ron-naming/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:54:34Z -->
# Code Bundle — `ron-naming`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-naming/.cargo/config.toml](#crates-ron-naming--cargo-config-toml)
- [crates/ron-naming/Cargo.toml](#crates-ron-naming-Cargo-toml)
- [crates/ron-naming/benches/encode_bench.rs](#crates-ron-naming-benches-encodebench-rs)
- [crates/ron-naming/benches/normalize_bench.rs](#crates-ron-naming-benches-normalizebench-rs)
- [crates/ron-naming/deny.toml](#crates-ron-naming-deny-toml)
- [crates/ron-naming/examples/encode_decode.rs](#crates-ron-naming-examples-encodedecode-rs)
- [crates/ron-naming/examples/normalize_roundtrip.rs](#crates-ron-naming-examples-normalizeroundtrip-rs)
- [crates/ron-naming/rust-toolchain.toml](#crates-ron-naming-rust-toolchain-toml)
- [crates/ron-naming/scripts/hash_vectors.sh](#crates-ron-naming-scripts-hashvectors-sh)
- [crates/ron-naming/scripts/render_mermaid.sh](#crates-ron-naming-scripts-rendermermaid-sh)
- [crates/ron-naming/scripts/verify_vectors_attestation.sh](#crates-ron-naming-scripts-verifyvectorsattestation-sh)
- [crates/ron-naming/src/address.rs](#crates-ron-naming-src-address-rs)
- [crates/ron-naming/src/bin/tldctl.rs](#crates-ron-naming-src-bin-tldctl-rs)
- [crates/ron-naming/src/lib.rs](#crates-ron-naming-src-lib-rs)
- [crates/ron-naming/src/normalize.rs](#crates-ron-naming-src-normalize-rs)
- [crates/ron-naming/src/types.rs](#crates-ron-naming-src-types-rs)
- [crates/ron-naming/src/verify/mod.rs](#crates-ron-naming-src-verify-mod-rs)
- [crates/ron-naming/src/version.rs](#crates-ron-naming-src-version-rs)
- [crates/ron-naming/src/wire/cbor.rs](#crates-ron-naming-src-wire-cbor-rs)
- [crates/ron-naming/src/wire/json.rs](#crates-ron-naming-src-wire-json-rs)
- [crates/ron-naming/src/wire/mod.rs](#crates-ron-naming-src-wire-mod-rs)
- [crates/ron-naming/testdata/vectors/names_ascii.json](#crates-ron-naming-testdata-vectors-namesascii-json)
- [crates/ron-naming/testdata/vectors/names_unicode_mixed.json](#crates-ron-naming-testdata-vectors-namesunicodemixed-json)
- [crates/ron-naming/testdata/vectors/tldmap_minimal.json](#crates-ron-naming-testdata-vectors-tldmapminimal-json)
- [crates/ron-naming/testdata/vectors/vectors.manifest.json](#crates-ron-naming-testdata-vectors-vectors-manifest-json)
- [crates/ron-naming/tests/address_hygiene.rs](#crates-ron-naming-tests-addresshygiene-rs)
- [crates/ron-naming/tests/cli_contract.rs](#crates-ron-naming-tests-clicontract-rs)
- [crates/ron-naming/tests/dto_wire_vectors.rs](#crates-ron-naming-tests-dtowirevectors-rs)
- [crates/ron-naming/tests/normalize_idempotence.rs](#crates-ron-naming-tests-normalizeidempotence-rs)

### crates/ron-naming/.cargo/config.toml
<a id="crates-ron-naming--cargo-config-toml"></a>

```toml
[build]
rustflags = ["-Dwarnings"]

[target.'cfg(all())']
# Keep builds deterministic and clean.

[term]
verbose = true

```

### crates/ron-naming/Cargo.toml
<a id="crates-ron-naming-Cargo-toml"></a>

```toml
[package]
name = "ron-naming"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RON-CORE naming & addressing types (schema-only; no runtime lookups)."
repository = "https://github.com/RustyOnions/RustyOnions"
readme = "README.md"
categories = ["network-programming", "encoding", "data-structures"]
keywords = ["RON", "naming", "addressing", "BLAKE3", "IDNA"]

[features]
default = []
cli = ["dep:clap", "dep:anyhow", "dep:base64"]
verify = []

[dependencies]
# Core
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_cbor = "0.11"
thiserror = "1.0"
bytes = "1.6"
blake3 = "1.5"
semver = { version = "1.0", features = ["serde"] }

# Naming / normalization
idna = "0.5"
unicode-normalization = "0.1"
regex = "1.11"
once_cell = "1.19"

# CLI (feature-gated)
clap = { version = "4.5", features = ["derive"], optional = true }
anyhow = { version = "1.0", optional = true }
base64 = { version = "0.22", optional = true }

[dev-dependencies]
proptest = "1.5"
insta = { version = "1.39", features = ["yaml"] }
criterion = "0.5"
assert_cmd = "2.0"
predicates = "3.1"

[[bin]]
name = "tldctl"
path = "src/bin/tldctl.rs"
required-features = ["cli"]

[[bench]]
name = "normalize_bench"
harness = false

[[bench]]
name = "encode_bench"
harness = false

```

### crates/ron-naming/benches/encode_bench.rs
<a id="crates-ron-naming-benches-encodebench-rs"></a>

```rust
//! RO:WHAT — Criterion benches for JSON/CBOR encode/decode of DTOs.
//! RO:WHY  — Wire-format throughput snapshot for SDK users.

use criterion::{black_box, criterion_group, criterion_main, Criterion};
use ron_naming::{
    types::{ContentId, Fqdn, NameRecord},
    version::parse_version,
    wire, Address,
};

fn bench_json_cbor(c: &mut Criterion) {
    let addr = Address::Name {
        fqdn: Fqdn("files.example".into()),
        version: Some(parse_version("1.2.3").unwrap()),
    };
    let rec = NameRecord {
        name: Fqdn("files.example".into()),
        version: Some(parse_version("1.2.3").unwrap()),
        content: ContentId(
            "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef".into(),
        ),
    };

    c.bench_function("json/address_roundtrip", |b| {
        b.iter(|| {
            let a = wire::json::roundtrip_address_json(black_box(&addr)).unwrap();
            black_box(a);
        })
    });

    c.bench_function("json/record_roundtrip", |b| {
        b.iter(|| {
            let r = wire::json::roundtrip_record_json(black_box(&rec)).unwrap();
            black_box(r);
        })
    });

    c.bench_function("cbor/address_roundtrip", |b| {
        b.iter(|| {
            let a = wire::cbor::roundtrip_address_cbor(black_box(&addr)).unwrap();
            black_box(a);
        })
    });

    c.bench_function("cbor/record_roundtrip", |b| {
        b.iter(|| {
            let r = wire::cbor::roundtrip_record_cbor(black_box(&rec)).unwrap();
            black_box(r);
        })
    });
}

criterion_group!(naming_encode, bench_json_cbor);
criterion_main!(naming_encode);

```

### crates/ron-naming/benches/normalize_bench.rs
<a id="crates-ron-naming-benches-normalizebench-rs"></a>

```rust
//! RO:WHAT — Criterion bench for domain normalization (Unicode → ASCII FQDN).
//! RO:WHY  — Track perf and regressions for IDNA/NFC pipeline.
//! RO:NOTES — Keep vectors tiny; this is a types crate (no I/O).

use criterion::{black_box, criterion_group, criterion_main, BatchSize, Criterion};
use ron_naming::normalize::normalize_fqdn_ascii;

fn bench_normalize(c: &mut Criterion) {
    let cases = [
        "example.com",
        "Café.Example",
        "bücher.example",
        "δοκιμή.Ελλάδα",       // Greek
        "пример.рф",           // Cyrillic
        "예시.테스트",         // Korean
        "مثال.إختبار",         // Arabic
        "παράδειγμα.δοκιμή",   // Greek extended
        "xn--caf-dma.example", // already punycoded
    ];

    c.bench_function("normalize_fqdn_ascii/mixed", |b| {
        b.iter_batched(
            || cases.to_vec(),
            |inputs| {
                for s in inputs {
                    let out = normalize_fqdn_ascii(black_box(s)).unwrap();
                    black_box(out);
                }
            },
            BatchSize::SmallInput,
        )
    });

    c.bench_function("normalize_fqdn_ascii/hot_ascii", |b| {
        b.iter(|| {
            let out = normalize_fqdn_ascii(black_box("sub.service.ron.dev")).unwrap();
            black_box(out);
        })
    });
}

criterion_group!(naming_norm, bench_normalize);
criterion_main!(naming_norm);

```

### crates/ron-naming/deny.toml
<a id="crates-ron-naming-deny-toml"></a>

```toml
# cargo-deny baseline for ron-naming2 (minimal, expand as needed)
[advisories]
yanked = "deny"

[licenses]
unlicensed = "deny"
copyleft = "deny"
allow = [
  "Apache-2.0",
  "MIT",
  "Unicode-DFS-2016",
  "Unicode-3.0",
  "CC0-1.0",
  "CDLA-Permissive-2.0",
  "BSD-3-Clause",
]
confidence-threshold = 0.8

```

### crates/ron-naming/examples/encode_decode.rs
<a id="crates-ron-naming-examples-encodedecode-rs"></a>

```rust
use ron_naming::{
    types::{ContentId, Fqdn, NameRecord},
    version::parse_version,
    wire,
};

fn main() {
    let rec = NameRecord {
        name: Fqdn("files.example".into()),
        version: Some(parse_version("1.0.0").unwrap()),
        content: ContentId(
            "b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef".into(),
        ),
    };
    let jb = wire::json::to_json_bytes(&rec).unwrap();
    let round: NameRecord = wire::json::from_json_bytes(&jb).unwrap();
    assert_eq!(rec, round);
    println!("{}", String::from_utf8(jb).unwrap());
}

```

### crates/ron-naming/examples/normalize_roundtrip.rs
<a id="crates-ron-naming-examples-normalizeroundtrip-rs"></a>

```rust
fn main() {
    let input = std::env::args().nth(1).expect("name");
    let out = ron_naming::normalize::normalize_fqdn_ascii(&input).expect("normalize");
    println!("{}", (out.0).0);
}

```

### crates/ron-naming/rust-toolchain.toml
<a id="crates-ron-naming-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["clippy", "rustfmt"]
profile = "minimal"

```

### crates/ron-naming/scripts/hash_vectors.sh
<a id="crates-ron-naming-scripts-hashvectors-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Portable BLAKE3 hashing: prefer 'b3sum' if available, else fallback to 'shasum -a 256' as placeholder.
# Replace fallback with a real BLAKE3 tool in your env/CI.

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
VEC_DIR="$DIR/testdata/vectors"
OUT="$DIR/testdata/signatures/vectors.b3.txt"

if command -v b3sum >/dev/null 2>&1; then
  (cd "$VEC_DIR" && b3sum names_ascii.json names_unicode_mixed.json tldmap_minimal.json tldmap_minimal.cbor) > "$OUT"
  echo "algo=BLAKE3-256" >> "$OUT"
  echo "OK wrote $OUT (BLAKE3)"
else
  (cd "$VEC_DIR" && shasum -a 256 names_ascii.json names_unicode_mixed.json tldmap_minimal.json tldmap_minimal.cbor) > "$OUT"
  echo "algo=SHA-256 (TEMPORARY FALLBACK — replace with BLAKE3 in CI)" >> "$OUT"
  echo "Wrote $OUT (SHA-256 fallback)"
fi

```

### crates/ron-naming/scripts/render_mermaid.sh
<a id="crates-ron-naming-scripts-rendermermaid-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Render Mermaid diagrams locally (optional).
# Requires 'mmdc' (mermaid-cli): npm install -g @mermaid-js/mermaid-cli
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
SRC="$ROOT/docs/diagrams/arch.mmd"
DST="$ROOT/docs/diagrams/arch.svg"

if command -v mmdc >/dev/null 2>&1; then
  mmdc -i "$SRC" -o "$DST"
  echo "Rendered $DST"
else
  echo "mermaid-cli (mmdc) not found; skipped render."
fi

```

### crates/ron-naming/scripts/verify_vectors_attestation.sh
<a id="crates-ron-naming-scripts-verifyvectorsattestation-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

# Placeholder: call your organization-approved verifier here.
# Intended to verify testdata/signatures/vectors.attestation.txt against vectors and vectors.b3.txt.
echo "verify_vectors_attestation.sh: placeholder (no-op)"

```

### crates/ron-naming/src/address.rs
<a id="crates-ron-naming-src-address-rs"></a>

```rust
//! RO:WHAT — High-level Name/Content addressing grammar.
//! RO:WHY  — Single, portable enum to represent user-facing addresses.
//! RO:INTERACTS — types::{Fqdn, ContentId}, version::NameVersion, normalize.
//! RO:INVARIANTS — Content ids are "b3:<hex>"; names are normalized ASCII; optional "@<semver>" suffix for versions.
//! RO:TEST — tests/address_hygiene.rs

use crate::normalize::{normalize_fqdn_ascii, NormalizedFqdn};
use crate::types::{ContentId, Fqdn};
use crate::version::{parse_version, NameVersion};
use serde::{Deserialize, Serialize};

/// A user-facing address: either content-id (b3:...) or a (name[@version]) tuple.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "kind", rename_all = "snake_case", deny_unknown_fields)]
pub enum Address {
    /// Canonical content-address (BLAKE3-256).
    ///
    /// The `id` must be of the form `"b3:<64 hex>"`, all lowercase.
    Content {
        /// Canonical content identifier (`"b3:<hex>"`).
        id: ContentId,
    },
    /// Named address with optional semantic version.
    Name {
        /// Normalized ASCII FQDN (no trailing dot).
        fqdn: Fqdn,
        /// Optional semantic version tagged to the name (e.g., `1.2.3`).
        version: Option<NameVersion>,
    },
}

impl Address {
    /// Parse from a user string: either `b3:<hex>` or `name[@semver]`.
    pub fn parse(s: &str) -> Result<Self, ParseAddressError> {
        let s = s.trim();
        if s.starts_with("b3:") {
            let id = ContentId(s.to_owned());
            if !id.validate() {
                return Err(ParseAddressError::InvalidContentId);
            }
            return Ok(Address::Content { id });
        }
        // version suffix: name@1.2.3 (optional)
        let (name_part, ver_opt) = match s.rsplit_once('@') {
            Some((left, right)) if !right.is_empty() && left.contains('.') => (left, Some(right)),
            _ => (s, None),
        };
        let NormalizedFqdn(Fqdn(name)) =
            normalize_fqdn_ascii(name_part).map_err(|_| ParseAddressError::InvalidName)?;
        let fqdn = Fqdn(name);
        let version = match ver_opt {
            Some(vs) => Some(parse_version(vs).map_err(|_| ParseAddressError::InvalidVersion)?),
            None => None,
        };
        Ok(Address::Name { fqdn, version })
    }

    /// Render compact string form: `b3:<hex>` or `name[@ver]`.
    pub fn to_compact(&self) -> String {
        match self {
            Address::Content { id } => id.0.clone(),
            Address::Name { fqdn, version } => match version {
                Some(v) => format!("{}@{}", fqdn.0, v),
                None => fqdn.0.clone(),
            },
        }
    }
}

/// Parse errors for [`Address::parse`].
#[derive(thiserror::Error, Debug)]
pub enum ParseAddressError {
    /// The content id is not a valid `"b3:<64 hex>"` string.
    #[error("invalid content id")]
    InvalidContentId,
    /// The provided name failed IDNA/ASCII hygiene.
    #[error("invalid name")]
    InvalidName,
    /// The version part is not valid semantic versioning.
    #[error("invalid version")]
    InvalidVersion,
}

```

### crates/ron-naming/src/bin/tldctl.rs
<a id="crates-ron-naming-src-bin-tldctl-rs"></a>

```rust
//! RO:WHAT — Minimal CLI for naming hygiene: parse/normalize/encode.
//! RO:WHY  — Folded from tldctl into ron-naming (canon); DX helper only.
//! RO:INTERACTS — address, normalize, wire::{json,cbor}
//! RO:INVARIANTS — No network; stdout-only. Errors are structured.

#![cfg(feature = "cli")]

use base64::Engine; // bring trait in-scope for .encode()
use clap::{Parser, Subcommand};
use ron_naming::{
    address::ParseAddressError, normalize::normalize_fqdn_ascii, wire, Address, NameRecord,
};

/// tldctl — RON naming toolbox (normalize, parse, encode)
#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Cli {
    #[command(subcommand)]
    cmd: Cmd,
}

#[derive(Subcommand, Debug)]
enum Cmd {
    /// Normalize a domain name to ASCII (UTS-46/IDNA)
    Normalize { name: String },

    /// Parse a user address string (b3:... or name[@ver]) and print JSON DTO
    Parse { addr: String },

    /// Encode a NameRecord as JSON
    Json {
        name: String,
        /// Optional semantic version like 1.2.3
        #[arg(long)]
        version: Option<String>,
        /// Content id in the form b3:<64hex>
        #[arg(long)]
        content: String,
    },

    /// Encode a NameRecord as CBOR (base64 to stdout)
    Cbor {
        name: String,
        /// Optional semantic version like 1.2.3
        #[arg(long)]
        version: Option<String>,
        /// Content id in the form b3:<64hex>
        #[arg(long)]
        content: String,
    },
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Cmd::Normalize { name } => {
            let nfqdn = normalize_fqdn_ascii(&name)?;
            println!("{}", (nfqdn.0).0);
        }
        Cmd::Parse { addr } => {
            let a = Address::parse(&addr).map_err(map_addr_err)?;
            let bytes = wire::json::to_json_bytes(&a)?;
            println!("{}", String::from_utf8(bytes).unwrap());
        }
        Cmd::Json {
            name,
            version,
            content,
        } => {
            let a = Address::parse(&format!(
                "{}{}",
                name,
                version
                    .as_deref()
                    .map(|v| format!("@{v}"))
                    .unwrap_or_default()
            ))?;
            let nr = match a {
                Address::Name { fqdn, version } => NameRecord {
                    name: fqdn,
                    version,
                    content: ron_naming::types::ContentId(content),
                },
                Address::Content { .. } => anyhow::bail!(
                    "content id form is not allowed for NameRecord 'name' (expect a domain)"
                ),
            };
            let bytes = wire::json::to_json_bytes(&nr)?;
            println!("{}", String::from_utf8(bytes).unwrap());
        }
        Cmd::Cbor {
            name,
            version,
            content,
        } => {
            let a = Address::parse(&format!(
                "{}{}",
                name,
                version
                    .as_deref()
                    .map(|v| format!("@{v}"))
                    .unwrap_or_default()
            ))?;
            let nr = match a {
                Address::Name { fqdn, version } => NameRecord {
                    name: fqdn,
                    version,
                    content: ron_naming::types::ContentId(content),
                },
                Address::Content { .. } => anyhow::bail!(
                    "content id form is not allowed for NameRecord 'name' (expect a domain)"
                ),
            };
            let bytes = wire::cbor::to_cbor_bytes(&nr)?;
            let b64 = base64::engine::general_purpose::STANDARD.encode(bytes);
            println!("{b64}");
        }
    }
    Ok(())
}

fn map_addr_err(e: ParseAddressError) -> anyhow::Error {
    match e {
        ParseAddressError::InvalidContentId => {
            anyhow::anyhow!("invalid content id (expect b3:<64 hex>)")
        }
        ParseAddressError::InvalidName => {
            anyhow::anyhow!("invalid name (IDNA/ASCII hygiene failed)")
        }
        ParseAddressError::InvalidVersion => {
            anyhow::anyhow!("invalid version (semver)")
        }
    }
}

```

### crates/ron-naming/src/lib.rs
<a id="crates-ron-naming-src-lib-rs"></a>

```rust
//! RO:WHAT — Public entry for RON naming/addressing types and wire helpers.
//! RO:WHY  — Pillar 9 (Content & Naming). This crate defines schemas & hygiene only;
//!           runtime lookups live in svc-index (DHT/overlay are elsewhere).
//! RO:INTERACTS — crate::types, crate::normalize, crate::address, crate::version, crate::wire::*
//! RO:INVARIANTS — DTOs are pure (serde, deny_unknown_fields); content ids are "b3:<hex>"; no locks across .await.
//! RO:SECURITY — No ambient I/O or network; pure value types; amnesia posture is N/A here.
//! RO:TEST — unit tests in module files; round-trip vectors in tests/ (JSON/CBOR).

#![forbid(unsafe_code)]
#![deny(rust_2018_idioms, missing_docs, clippy::all)]

pub mod address;
pub mod normalize;
pub mod types;
pub mod version;

/// Wire-encoding helpers (JSON/CBOR) for DTO round-trips.
///
/// These are thin serde wrappers used by tests/examples/SDKs. Transport/runtime
/// concerns live in services (e.g., svc-index); this module is schema-focused.
pub mod wire {
    /// CBOR helpers.
    pub mod cbor;
    /// JSON helpers.
    pub mod json;
}

#[cfg(feature = "verify")]
pub mod verify;

pub use address::{Address, ParseAddressError};
pub use normalize::{normalize_fqdn_ascii, NormalizedFqdn};
pub use types::{ContentId, Fqdn, NameRecord};
pub use version::{NameVersion, VersionParseError};

```

### crates/ron-naming/src/normalize.rs
<a id="crates-ron-naming-src-normalize-rs"></a>

```rust
//! RO:WHAT — Unicode/IDNA normalization to canonical ASCII FQDNs.
//! RO:WHY  — Interop & safety: enforce UTS-46/IDNA processing and local hygiene.
//! RO:INTERACTS — types::Fqdn
//! RO:INVARIANTS — Lowercase; NFC; IDNA ASCII (Punycode) with trailing dot stripped; collapse consecutive dots.
//! RO:TEST — tests/normalize_idempotence.rs; examples/normalize_roundtrip.rs

use idna::domain_to_ascii;
use once_cell::sync::Lazy;
use regex::Regex;
use unicode_normalization::UnicodeNormalization;

use crate::types::Fqdn;

/// Normalized ASCII FQDN (newtype wrapper for type-safety).
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct NormalizedFqdn(pub Fqdn);

static DOTS: Lazy<Regex> = Lazy::new(|| Regex::new(r"\.+").expect("regex"));

/// Normalize an input domain (Unicode or ASCII) into canonical ASCII FQDN.
///
/// Steps:
/// 1. Trim whitespace; strip any leading/trailing dots.
/// 2. Unicode NFC normalize.
/// 3. Collapse consecutive dots to a single dot.
/// 4. Apply UTS-46 / IDNA to ASCII (punycode).
/// 5. Lowercase; validate ASCII FQDN hygiene.
pub fn normalize_fqdn_ascii(input: &str) -> Result<NormalizedFqdn, NormalizeError> {
    let trimmed = input.trim();
    if trimmed.is_empty() {
        return Err(NormalizeError::Empty);
    }
    let nfc = trimmed.nfc().collect::<String>();
    let no_edges = nfc.trim_matches('.');
    let collapsed = DOTS.replace_all(no_edges, ".").into_owned();
    let ascii = domain_to_ascii(&collapsed).map_err(|_| NormalizeError::Idna)?;
    let lower = ascii.to_ascii_lowercase();
    let fqdn = Fqdn(lower);
    if !fqdn.is_valid() {
        return Err(NormalizeError::InvalidAscii);
    }
    Ok(NormalizedFqdn(fqdn))
}

/// Normalization errors.
#[derive(thiserror::Error, Debug)]
pub enum NormalizeError {
    /// Empty input.
    #[error("empty input")]
    Empty,
    /// IDNA/UTS-46 mapping failed.
    #[error("invalid domain (IDNA)")]
    Idna,
    /// Resulting ASCII FQDN failed hygiene checks.
    #[error("invalid ascii fqdn")]
    InvalidAscii,
}

```

### crates/ron-naming/src/types.rs
<a id="crates-ron-naming-src-types-rs"></a>

```rust
//! RO:WHAT — Fundamental naming/addressing DTOs used across RON.
//! RO:WHY  — Keep schemas/validation centralized; services (svc-index) consume these types.
//! RO:INTERACTS — address, normalize, version, wire::{json,cbor}
//! RO:INVARIANTS — DTO hygiene with #[serde(deny_unknown_fields)]; content id prefix "b3:" only.
//! RO:METRICS — none here (types-only).
//! RO:SECURITY — No secrets; no I/O.
//! RO:TEST — see tests/address_hygiene.rs and dto_wire_vectors.rs.

use serde::{Deserialize, Serialize};

/// Fully Qualified Domain Name (ASCII, normalized, no trailing dot).
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct Fqdn(pub String);

impl Fqdn {
    /// Returns `true` if this FQDN looks syntactically valid (cheap checks).
    pub fn is_valid(&self) -> bool {
        // Minimal hygiene: 1..=253 bytes, labels 1..=63, allowed chars (a-z0-9-), no leading/trailing hyphen.
        let s = self.0.as_str();
        if s.is_empty() || s.len() > 253 || s.starts_with('.') || s.ends_with('.') {
            return false;
        }
        for label in s.split('.') {
            if label.is_empty() || label.len() > 63 {
                return false;
            }
            if label.starts_with('-') || label.ends_with('-') {
                return false;
            }
            if !label
                .chars()
                .all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '-')
            {
                return false;
            }
        }
        true
    }
}

/// Content ID — canonical BLAKE3-256 address, always `"b3:<hex>"`.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct ContentId(pub String);

impl ContentId {
    /// Validate the `b3:<hex>` shape (lowercase, 64 hex chars).
    pub fn validate(&self) -> bool {
        let s = self.0.as_str();
        if !s.starts_with("b3:") {
            return false;
        }
        let hex = &s[3..];
        hex.len() == 64 && hex.bytes().all(|b| matches!(b, b'0'..=b'9' | b'a'..=b'f'))
    }
}

/// Example DTO representing a name→manifest mapping (types-only).
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct NameRecord {
    /// Normalized ASCII FQDN.
    pub name: Fqdn,
    /// Optional semantic version of the record (e.g., for app packages).
    pub version: Option<crate::version::NameVersion>,
    /// Addressed manifest/content.
    pub content: ContentId,
}

```

### crates/ron-naming/src/verify/mod.rs
<a id="crates-ron-naming-src-verify-mod-rs"></a>

```rust
//! RO:WHAT — Optional verification helpers for test vectors / attestations.
//! RO:WHY  — Keep checks in-library for CI without introducing runtime owners.
//! RO:INVARIANTS — No network or disk I/O beyond caller-provided bytes.

use blake3::Hasher;

/// Compute a BLAKE3-256 hex for provided bytes (lowercase).
pub fn blake3_hex(bytes: &[u8]) -> String {
    let mut h = Hasher::new();
    h.update(bytes);
    h.finalize().to_hex().to_string()
}

```

### crates/ron-naming/src/version.rs
<a id="crates-ron-naming-src-version-rs"></a>

```rust
//! RO:WHAT — Name version wrapper atop semver for optional versioned records.
//! RO:WHY  — Keep version grammar stable and decoupled from services.
//! RO:INVARIANTS — Strict semver parse; serialized as plain string.
//! RO:TEST — unit tests in this module.

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::fmt;

/// Semantic Version wrapper (e.g., "1.2.3").
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct NameVersion(pub semver::Version);

impl Serialize for NameVersion {
    fn serialize<S: Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        s.serialize_str(&self.0.to_string())
    }
}

impl<'de> Deserialize<'de> for NameVersion {
    fn deserialize<D: Deserializer<'de>>(d: D) -> Result<Self, D::Error> {
        let s = String::deserialize(d)?;
        semver::Version::parse(&s)
            .map(NameVersion)
            .map_err(|e| serde::de::Error::custom(e.to_string()))
    }
}

/// Parser error.
#[derive(thiserror::Error, Debug)]
#[error("invalid version: {0}")]
pub struct VersionParseError(pub String);

impl fmt::Display for NameVersion {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

/// Parse a version string into `NameVersion`.
pub fn parse_version(s: &str) -> Result<NameVersion, VersionParseError> {
    semver::Version::parse(s)
        .map(NameVersion)
        .map_err(|e| VersionParseError(e.to_string()))
}

```

### crates/ron-naming/src/wire/cbor.rs
<a id="crates-ron-naming-src-wire-cbor-rs"></a>

```rust
//! RO:WHAT — CBOR encode/decode helpers for Address and NameRecord.
//! RO:WHY  — Compact vectors for interop; mirrors JSON helpers.
//! RO:INVARIANTS — Pure serde; canonical map ordering is a caller concern.

use crate::{types::NameRecord, Address};
use serde::{de::DeserializeOwned, Serialize};

/// Encode any serializable DTO to CBOR bytes.
pub fn to_cbor_bytes<T: Serialize>(v: &T) -> Result<Vec<u8>, serde_cbor::Error> {
    serde_cbor::to_vec(v)
}

/// Decode any DTO from CBOR bytes.
pub fn from_cbor_bytes<T: DeserializeOwned>(bytes: &[u8]) -> Result<T, serde_cbor::Error> {
    serde_cbor::from_slice(bytes)
}

/// Round-trip an [`Address`] through CBOR (encode then decode).
pub fn roundtrip_address_cbor(a: &Address) -> Result<Address, serde_cbor::Error> {
    let bytes = to_cbor_bytes(a)?;
    from_cbor_bytes::<Address>(&bytes)
}

/// Round-trip a [`NameRecord`] through CBOR (encode then decode).
pub fn roundtrip_record_cbor(r: &NameRecord) -> Result<NameRecord, serde_cbor::Error> {
    let bytes = to_cbor_bytes(r)?;
    from_cbor_bytes::<NameRecord>(&bytes)
}

```

### crates/ron-naming/src/wire/json.rs
<a id="crates-ron-naming-src-wire-json-rs"></a>

```rust
//! RO:WHAT — JSON encode/decode helpers for Address and NameRecord.
//! RO:WHY  — Test vectors & SDK interop in a single place.
//! RO:INVARIANTS — Pure serde; deny unknown fields via parent DTOs.

use crate::{types::NameRecord, Address};
use serde::{de::DeserializeOwned, Serialize};

/// Encode any serializable DTO to JSON bytes.
pub fn to_json_bytes<T: Serialize>(v: &T) -> Result<Vec<u8>, serde_json::Error> {
    serde_json::to_vec_pretty(v)
}

/// Decode any DTO from JSON bytes.
pub fn from_json_bytes<T: DeserializeOwned>(bytes: &[u8]) -> Result<T, serde_json::Error> {
    serde_json::from_slice(bytes)
}

/// Convenience: round-trip an Address to JSON and back.
pub fn roundtrip_address_json(a: &Address) -> Result<Address, serde_json::Error> {
    let bytes = to_json_bytes(a)?;
    from_json_bytes::<Address>(&bytes)
}

/// Convenience: round-trip a NameRecord to JSON and back.
pub fn roundtrip_record_json(r: &NameRecord) -> Result<NameRecord, serde_json::Error> {
    let bytes = to_json_bytes(r)?;
    from_json_bytes::<NameRecord>(&bytes)
}

```

### crates/ron-naming/src/wire/mod.rs
<a id="crates-ron-naming-src-wire-mod-rs"></a>

```rust
//! RO:WHAT — Wire (encoding) helpers for JSON/CBOR round-trips.
//! RO:WHY  — Interop hygiene; DTOs are pure; services pick the transport.
//! RO:INVARIANTS — #[serde(deny_unknown_fields)] on message shapes.

pub mod json;
pub mod cbor;

```

### crates/ron-naming/testdata/vectors/names_ascii.json
<a id="crates-ron-naming-testdata-vectors-namesascii-json"></a>

```json
{
  "note": "placeholder ASCII names for normalization vectors",
  "items": ["example", "test", "alpha", "beta"]
}

```

### crates/ron-naming/testdata/vectors/names_unicode_mixed.json
<a id="crates-ron-naming-testdata-vectors-namesunicodemixed-json"></a>

```json
{
  "note": "placeholder mixed-script names for confusables/IDNA tests",
  "items": ["ｅxample", "Εxample", "ｅхампⅼе"]
}

```

### crates/ron-naming/testdata/vectors/tldmap_minimal.json
<a id="crates-ron-naming-testdata-vectors-tldmapminimal-json"></a>

```json
{
  "note": "placeholder minimal TLD map",
  "tlds": { "example": { "policy": "placeholder" } }
}

```

### crates/ron-naming/testdata/vectors/vectors.manifest.json
<a id="crates-ron-naming-testdata-vectors-vectors-manifest-json"></a>

```json
{
  "bundle": "ron-naming2-vectors",
  "files": [
    "names_ascii.json",
    "names_unicode_mixed.json",
    "tldmap_minimal.json",
    "tldmap_minimal.cbor"
  ],
  "integrity": {
    "algo": "BLAKE3-256",
    "hash_file": "../signatures/vectors.b3.txt"
  }
}

```

### crates/ron-naming/tests/address_hygiene.rs
<a id="crates-ron-naming-tests-addresshygiene-rs"></a>

```rust
use ron_naming::{normalize::normalize_fqdn_ascii, Address};

#[test]
fn parse_b3_ok() {
    let addr =
        Address::parse("b3:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef")
            .unwrap();
    assert!(matches!(addr, Address::Content { .. }));
}

#[test]
fn parse_name_with_version() {
    let addr = Address::parse("files.example@1.2.3").unwrap();
    match addr {
        Address::Name { fqdn, version } => {
            assert_eq!(fqdn.0, "files.example");
            assert_eq!(version.unwrap().0.to_string(), "1.2.3");
        }
        _ => panic!("expected name"),
    }
}

#[test]
fn normalize_then_parse() {
    let nf = normalize_fqdn_ascii(" Café.EXAMPLE ").unwrap();
    let addr = Address::parse(&nf.0 .0).unwrap();
    matches!(addr, Address::Name { .. });
}

```

### crates/ron-naming/tests/cli_contract.rs
<a id="crates-ron-naming-tests-clicontract-rs"></a>

```rust
//! RO:WHAT — CLI contract tests for `tldctl`.
//! RO:WHY  — Ensure CLI stays stable. Only runs with `--features cli`.

#![cfg(feature = "cli")]

use assert_cmd::Command;

#[test]
fn normalize_cli_outputs_ascii() {
    let mut cmd = Command::cargo_bin("tldctl").expect("build tldctl");
    cmd.args(["normalize", "Café.Example"]);
    let assert = cmd.assert().success();
    let out = String::from_utf8(assert.get_output().stdout.clone()).unwrap();
    assert_eq!(out.trim(), "xn--caf-dma.example");
}

#[test]
fn parse_cli_emits_json() {
    let mut cmd = Command::cargo_bin("tldctl").expect("build tldctl");
    cmd.args(["parse", "files.example@1.2.3"]);
    let assert = cmd.assert().success();
    let out = String::from_utf8(assert.get_output().stdout.clone()).unwrap();
    assert!(out.contains(r#""kind": "name""#));
    assert!(out.contains(r#""fqdn": "files.example""#));
    assert!(out.contains(r#""version": "1.2.3""#));
}

```

### crates/ron-naming/tests/dto_wire_vectors.rs
<a id="crates-ron-naming-tests-dtowirevectors-rs"></a>

```rust
#[test]
fn placeholder_dto_wire_vectors() {
    // This will later load testdata/vectors/*.json|*.cbor and assert deterministic bytes.
    assert!(true);
}

```

### crates/ron-naming/tests/normalize_idempotence.rs
<a id="crates-ron-naming-tests-normalizeidempotence-rs"></a>

```rust
use ron_naming::normalize::normalize_fqdn_ascii;

#[test]
fn idempotent_ascii() {
    let a = normalize_fqdn_ascii("EXAMPLE.COM").unwrap();
    let b = normalize_fqdn_ascii(&a.0 .0).unwrap();
    assert_eq!(a, b);
}

#[test]
fn unicode_maps_to_ascii() {
    let a = normalize_fqdn_ascii("café.example").unwrap();
    assert_eq!(a.0 .0, "xn--caf-dma.example");
}

```



---



# svc-index

_Source: crates/svc-index/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:53:28Z -->
# Code Bundle — `svc-index`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/svc-index/.cargo/config.toml](#crates-svc-index--cargo-config-toml)
- [crates/svc-index/.github/workflows/chaos.yml](#crates-svc-index--github-workflows-chaos-yml)
- [crates/svc-index/.github/workflows/ci.yml](#crates-svc-index--github-workflows-ci-yml)
- [crates/svc-index/.github/workflows/coverage.yml](#crates-svc-index--github-workflows-coverage-yml)
- [crates/svc-index/.github/workflows/fuzz.yml](#crates-svc-index--github-workflows-fuzz-yml)
- [crates/svc-index/.github/workflows/perf-regress.yml](#crates-svc-index--github-workflows-perf-regress-yml)
- [crates/svc-index/.github/workflows/render-mermaid.yml](#crates-svc-index--github-workflows-render-mermaid-yml)
- [crates/svc-index/Cargo.toml](#crates-svc-index-Cargo-toml)
- [crates/svc-index/benches/resolve.rs](#crates-svc-index-benches-resolve-rs)
- [crates/svc-index/deny.toml](#crates-svc-index-deny-toml)
- [crates/svc-index/examples/client.rs](#crates-svc-index-examples-client-rs)
- [crates/svc-index/fuzz/Cargo.toml](#crates-svc-index-fuzz-Cargo-toml)
- [crates/svc-index/fuzz/fuzz.toml](#crates-svc-index-fuzz-fuzz-toml)
- [crates/svc-index/fuzz/fuzz_targets/http_resolve.rs](#crates-svc-index-fuzz-fuzztargets-httpresolve-rs)
- [crates/svc-index/fuzz/fuzz_targets/parse_manifest.rs](#crates-svc-index-fuzz-fuzztargets-parsemanifest-rs)
- [crates/svc-index/scripts/bench_http.sh](#crates-svc-index-scripts-benchhttp-sh)
- [crates/svc-index/scripts/bench_http_release.sh](#crates-svc-index-scripts-benchhttprelease-sh)
- [crates/svc-index/scripts/bench_resolve.sh](#crates-svc-index-scripts-benchresolve-sh)
- [crates/svc-index/scripts/chaos_inject.sh](#crates-svc-index-scripts-chaosinject-sh)
- [crates/svc-index/scripts/mermaid_render.sh](#crates-svc-index-scripts-mermaidrender-sh)
- [crates/svc-index/scripts/smoke.sh](#crates-svc-index-scripts-smoke-sh)
- [crates/svc-index/scripts/smoke_index.sh](#crates-svc-index-scripts-smokeindex-sh)
- [crates/svc-index/scripts/soak.sh](#crates-svc-index-scripts-soak-sh)
- [crates/svc-index/src/app.rs](#crates-svc-index-src-app-rs)
- [crates/svc-index/src/audit/events.rs](#crates-svc-index-src-audit-events-rs)
- [crates/svc-index/src/audit/mod.rs](#crates-svc-index-src-audit-mod-rs)
- [crates/svc-index/src/auth/caps.rs](#crates-svc-index-src-auth-caps-rs)
- [crates/svc-index/src/auth/mod.rs](#crates-svc-index-src-auth-mod-rs)
- [crates/svc-index/src/auth/uds_allow.rs](#crates-svc-index-src-auth-udsallow-rs)
- [crates/svc-index/src/bus/events.rs](#crates-svc-index-src-bus-events-rs)
- [crates/svc-index/src/bus/mod.rs](#crates-svc-index-src-bus-mod-rs)
- [crates/svc-index/src/cache/manifest.rs](#crates-svc-index-src-cache-manifest-rs)
- [crates/svc-index/src/cache/mod.rs](#crates-svc-index-src-cache-mod-rs)
- [crates/svc-index/src/cache/negative.rs](#crates-svc-index-src-cache-negative-rs)
- [crates/svc-index/src/cache/providers.rs](#crates-svc-index-src-cache-providers-rs)
- [crates/svc-index/src/config.rs](#crates-svc-index-src-config-rs)
- [crates/svc-index/src/constants.rs](#crates-svc-index-src-constants-rs)
- [crates/svc-index/src/dht/client.rs](#crates-svc-index-src-dht-client-rs)
- [crates/svc-index/src/dht/hedge.rs](#crates-svc-index-src-dht-hedge-rs)
- [crates/svc-index/src/dht/mod.rs](#crates-svc-index-src-dht-mod-rs)
- [crates/svc-index/src/dht/rank.rs](#crates-svc-index-src-dht-rank-rs)
- [crates/svc-index/src/error.rs](#crates-svc-index-src-error-rs)
- [crates/svc-index/src/http/extractors/capability.rs](#crates-svc-index-src-http-extractors-capability-rs)
- [crates/svc-index/src/http/extractors/corr_id.rs](#crates-svc-index-src-http-extractors-corrid-rs)
- [crates/svc-index/src/http/extractors/limits.rs](#crates-svc-index-src-http-extractors-limits-rs)
- [crates/svc-index/src/http/extractors/mod.rs](#crates-svc-index-src-http-extractors-mod-rs)
- [crates/svc-index/src/http/middleware/body_limits.rs](#crates-svc-index-src-http-middleware-bodylimits-rs)
- [crates/svc-index/src/http/middleware/decompress_guard.rs](#crates-svc-index-src-http-middleware-decompressguard-rs)
- [crates/svc-index/src/http/middleware/mod.rs](#crates-svc-index-src-http-middleware-mod-rs)
- [crates/svc-index/src/http/middleware/rate_limit.rs](#crates-svc-index-src-http-middleware-ratelimit-rs)
- [crates/svc-index/src/http/middleware/trace_layer.rs](#crates-svc-index-src-http-middleware-tracelayer-rs)
- [crates/svc-index/src/http/mod.rs](#crates-svc-index-src-http-mod-rs)
- [crates/svc-index/src/http/routes/admin.rs](#crates-svc-index-src-http-routes-admin-rs)
- [crates/svc-index/src/http/routes/health.rs](#crates-svc-index-src-http-routes-health-rs)
- [crates/svc-index/src/http/routes/metrics.rs](#crates-svc-index-src-http-routes-metrics-rs)
- [crates/svc-index/src/http/routes/mod.rs](#crates-svc-index-src-http-routes-mod-rs)
- [crates/svc-index/src/http/routes/providers.rs](#crates-svc-index-src-http-routes-providers-rs)
- [crates/svc-index/src/http/routes/resolve.rs](#crates-svc-index-src-http-routes-resolve-rs)
- [crates/svc-index/src/http/routes/version.rs](#crates-svc-index-src-http-routes-version-rs)
- [crates/svc-index/src/lib.rs](#crates-svc-index-src-lib-rs)
- [crates/svc-index/src/logging.rs](#crates-svc-index-src-logging-rs)
- [crates/svc-index/src/main.rs](#crates-svc-index-src-main-rs)
- [crates/svc-index/src/net/listener.rs](#crates-svc-index-src-net-listener-rs)
- [crates/svc-index/src/net/mod.rs](#crates-svc-index-src-net-mod-rs)
- [crates/svc-index/src/net/tls.rs](#crates-svc-index-src-net-tls-rs)
- [crates/svc-index/src/net/uds.rs](#crates-svc-index-src-net-uds-rs)
- [crates/svc-index/src/pipeline/mod.rs](#crates-svc-index-src-pipeline-mod-rs)
- [crates/svc-index/src/pipeline/providers.rs](#crates-svc-index-src-pipeline-providers-rs)
- [crates/svc-index/src/pipeline/resolve.rs](#crates-svc-index-src-pipeline-resolve-rs)
- [crates/svc-index/src/router.rs](#crates-svc-index-src-router-rs)
- [crates/svc-index/src/state/metrics.rs](#crates-svc-index-src-state-metrics-rs)
- [crates/svc-index/src/state/mod.rs](#crates-svc-index-src-state-mod-rs)
- [crates/svc-index/src/state/readiness.rs](#crates-svc-index-src-state-readiness-rs)
- [crates/svc-index/src/state/shutdown.rs](#crates-svc-index-src-state-shutdown-rs)
- [crates/svc-index/src/store/keys.rs](#crates-svc-index-src-store-keys-rs)
- [crates/svc-index/src/store/mod.rs](#crates-svc-index-src-store-mod-rs)
- [crates/svc-index/src/store/schema.rs](#crates-svc-index-src-store-schema-rs)
- [crates/svc-index/src/store/sled_store.rs](#crates-svc-index-src-store-sledstore-rs)
- [crates/svc-index/src/telemetry.rs](#crates-svc-index-src-telemetry-rs)
- [crates/svc-index/src/types.rs](#crates-svc-index-src-types-rs)
- [crates/svc-index/src/utils/mod.rs](#crates-svc-index-src-utils-mod-rs)
- [crates/svc-index/src/utils/timeouts.rs](#crates-svc-index-src-utils-timeouts-rs)
- [crates/svc-index/tests/chaos.rs](#crates-svc-index-tests-chaos-rs)
- [crates/svc-index/tests/golden/resolve/not_found.json](#crates-svc-index-tests-golden-resolve-notfound-json)
- [crates/svc-index/tests/golden/resolve/ok_basic.json](#crates-svc-index-tests-golden-resolve-okbasic-json)
- [crates/svc-index/tests/golden/resolve/over_capacity.json](#crates-svc-index-tests-golden-resolve-overcapacity-json)
- [crates/svc-index/tests/golden/resolve/providers_ranked.json](#crates-svc-index-tests-golden-resolve-providersranked-json)
- [crates/svc-index/tests/http_contract.rs](#crates-svc-index-tests-httpcontract-rs)
- [crates/svc-index/tests/integration.rs](#crates-svc-index-tests-integration-rs)
- [crates/svc-index/tests/loom_index.rs](#crates-svc-index-tests-loomindex-rs)
- [crates/svc-index/tests/prop_index.rs](#crates-svc-index-tests-propindex-rs)

### crates/svc-index/.cargo/config.toml
<a id="crates-svc-index--cargo-config-toml"></a>

```toml
# local build defaults — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
[build]
rustflags = []

[target.'cfg(all())']
rustflags = []

[term]
verbose = true

```

### crates/svc-index/.github/workflows/chaos.yml
<a id="crates-svc-index--github-workflows-chaos-yml"></a>

```yaml
name: chaos
on:
  workflow_dispatch: {}
jobs:
  chaos:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'inject latency/drop into mocked DHT during tests; stub only'

```

### crates/svc-index/.github/workflows/ci.yml
<a id="crates-svc-index--github-workflows-ci-yml"></a>

```yaml
name: ci
on: [push, pull_request]
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo fmt --all -- --check
      - run: cargo clippy -p svc-index2 -- -D warnings
      - run: cargo test -p svc-index2 --all-features
      - run: cargo deny check

```

### crates/svc-index/.github/workflows/coverage.yml
<a id="crates-svc-index--github-workflows-coverage-yml"></a>

```yaml
name: coverage
on:
  workflow_dispatch: {}
jobs:
  coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: taiki-e/install-action@cargo-llvm-cov
      - run: cargo llvm-cov --workspace --lcov --output-path lcov.info

```

### crates/svc-index/.github/workflows/fuzz.yml
<a id="crates-svc-index--github-workflows-fuzz-yml"></a>

```yaml
name: fuzz
on:
  workflow_dispatch: {}
jobs:
  fuzz:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'run cargo-fuzz locally or in a container; stub only'

```

### crates/svc-index/.github/workflows/perf-regress.yml
<a id="crates-svc-index--github-workflows-perf-regress-yml"></a>

```yaml
name: perf-regress
on:
  workflow_dispatch: {}
jobs:
  perf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo 'run Criterion and compare vs baseline; stub only'

```

### crates/svc-index/.github/workflows/render-mermaid.yml
<a id="crates-svc-index--github-workflows-render-mermaid-yml"></a>

```yaml
name: render-mermaid
on: [push, pull_request]
jobs:
  mmdc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g @mermaid-js/mermaid-cli
      - run: |
          for f in $(git ls-files 'crates/svc-index2/docs/*.mmd'); do
            out="${f%.mmd}.svg"
            mmdc -i "$f" -o "$out"
          done

```

### crates/svc-index/Cargo.toml
<a id="crates-svc-index-Cargo-toml"></a>

```toml
[package]
name = "svc-index"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "RustyOnions index service (resolve name/cid -> manifest/providers)."
repository = "https://github.com/your/repo"
keywords = ["rust", "axum", "index", "dht", "blake3"]

[features]
# Keep sled-store as the default (no regressions).
default = ["sled-store"]
sled-store = ["dep:sled"]
# New: in-memory store for tests/CI; off by default.
inmem = []
otel = ["dep:opentelemetry", "dep:tracing-opentelemetry", "dep:opentelemetry-otlp"]
facets = []

[dependencies]
axum = { version = "0.7", features = ["tokio", "http1", "http2", "json"] }
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time", "net", "sync", "io-util"] }
bytes = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
serde_with = "3"
thiserror = "1"
prometheus = "0.14"
once_cell = "1"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt", "ansi"] }
opentelemetry = { version = "0.24", optional = true }
tracing-opentelemetry = { version = "0.26", optional = true }
opentelemetry-otlp = { version = "0.17", optional = true }
http = "1"
headers = "0.4"
ulid = "1"
uuid = { version = "1", features = ["v4", "fast-rng"] }
blake3 = "1"
time = { version = "0.3", features = ["formatting"] }
parking_lot = "0.12"
dashmap = "6"
anyhow = "1"
tower = "0.5"
tower-http = { version = "0.6", features = ["trace"] }
mime = "0.3"
arc-swap = "1"
rand = "0.9"

# New for store + middleware:
bincode = "1"
hex = "0.4"
futures-util = "0.3"

# Optional sled store (kept as-is)
sled = { version = "0.34", optional = true }

[dev-dependencies]
reqwest = { version = "0.12", default-features = false, features = ["json", "rustls-tls-native-roots"] }
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }

```

### crates/svc-index/benches/resolve.rs
<a id="crates-svc-index-benches-resolve-rs"></a>

```rust
// Criterion bench placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
fn main() {}

```

### crates/svc-index/deny.toml
<a id="crates-svc-index-deny-toml"></a>

```toml
# cargo-deny config (baseline) — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
[advisories]
vulnerability = "deny"
yanked = "deny"
unmaintained = "warn"

[bans]
multiple-versions = "warn"

[sources]
unknown-registry = "deny"
unknown-git = "deny"
allow-git = []

```

### crates/svc-index/examples/client.rs
<a id="crates-svc-index-examples-client-rs"></a>

```rust
// example client placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
fn main() {}

```

### crates/svc-index/fuzz/Cargo.toml
<a id="crates-svc-index-fuzz-Cargo-toml"></a>

```toml
[package]
name = "svc-index2-fuzz"
version = "0.0.0"
publish = false
edition = "2021"

[workspace]
members = []

[package.metadata]
cargo-fuzz = true

```

### crates/svc-index/fuzz/fuzz.toml
<a id="crates-svc-index-fuzz-fuzz-toml"></a>

```toml
# fuzz seeds and budgets — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
[http_resolve]
max_total_time = 30

[parse_manifest]
max_total_time = 30

```

### crates/svc-index/fuzz/fuzz_targets/http_resolve.rs
<a id="crates-svc-index-fuzz-fuzztargets-httpresolve-rs"></a>

```rust
// fuzz target placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
fn main() { }

```

### crates/svc-index/fuzz/fuzz_targets/parse_manifest.rs
<a id="crates-svc-index-fuzz-fuzztargets-parsemanifest-rs"></a>

```rust
// fuzz target placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
fn main() { }

```

### crates/svc-index/scripts/bench_http.sh
<a id="crates-svc-index-scripts-benchhttp-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

cargo build -p svc-index

INDEX_BIND="${INDEX_BIND:-127.0.0.1:5304}"
RUST_LOG="${RUST_LOG:-warn}"

target/debug/svc-index >/tmp/svc-index.bench.log 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true' EXIT

# Wait for service
for i in $(seq 1 120); do
  code=$(curl -s -o /dev/null -w "%{http_code}" "http://$INDEX_BIND/healthz" || true)
  [ "$code" = "200" ] && break
  sleep 0.05
done

bench_wrk() {
  wrk -t4 -c64 -d15s "http://$INDEX_BIND/healthz"
  echo
  wrk -t4 -c64 -d15s "http://$INDEX_BIND/version"
  echo
  wrk -t4 -c32 -d15s "http://$INDEX_BIND/metrics"
}

bench_hey() {
  hey -z 15s -c 64 "http://$INDEX_BIND/healthz"
  echo
  hey -z 15s -c 64 "http://$INDEX_BIND/version"
  echo
  hey -z 15s -c 32 "http://$INDEX_BIND/metrics"
}

bench_pure() {
  one() {
    URL="$1"; CONC="$2"; DUR="$3"
    end=$(( $(date +%s) + DUR ))
    tmpdir="$(mktemp -d)"
    pids=()
    for w in $(seq 1 "$CONC"); do
      (
        cnt=0
        while [ "$(date +%s)" -lt "$end" ]; do
          curl -s -o /dev/null "$URL" || true
          cnt=$((cnt+1))
        done
        echo "$cnt" > "$tmpdir/$w.count"
      ) &
      pids+=("$!")
    done
    for p in "${pids[@]}"; do wait "$p"; done
    total=0
    for f in "$tmpdir"/*.count; do
      [ -f "$f" ] || continue
      n=$(cat "$f")
      total=$((total + n))
    done
    rm -rf "$tmpdir"
    rps=$(awk "BEGIN { printf \"%.1f\", $total/$DUR }")
    echo "purebash url=$URL conc=$CONC dur=${DUR}s total_reqs=$total rps=$rps"
  }
  one "http://$INDEX_BIND/healthz" 64 15
  echo
  one "http://$INDEX_BIND/version" 64 15
  echo
  one "http://$INDEX_BIND/metrics" 32 15
}

if command -v wrk >/dev/null 2>&1; then
  bench_wrk
elif command -v hey >/dev/null 2>&1; then
  bench_hey
else
  bench_pure
fi

```

### crates/svc-index/scripts/bench_http_release.sh
<a id="crates-svc-index-scripts-benchhttprelease-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

cargo build -p svc-index --release

INDEX_BIND="${INDEX_BIND:-127.0.0.1:5304}"
RUST_LOG="${RUST_LOG:-warn}"

target/release/svc-index >/tmp/svc-index.bench.release.log 2>&1 &
PID=$!
trap 'kill $PID >/dev/null 2>&1 || true' EXIT

# wait for server
for i in $(seq 1 200); do
  code=$(curl -s -o /dev/null -w "%{http_code}" "http://$INDEX_BIND/healthz" || true)
  [ "$code" = "200" ] && break
  sleep 0.05
done

warmup() {
  D=${1:-5}
  end=$(( $(date +%s) + D ))
  while [ "$(date +%s)" -lt "$end" ]; do curl -s -o /dev/null "http://$INDEX_BIND/healthz" || true; done
}

run_wrk() {
  echo "wrk /healthz"
  wrk -t4 -c128 -d30s "http://$INDEX_BIND/healthz"
  echo
  echo "wrk /version"
  wrk -t4 -c128 -d30s "http://$INDEX_BIND/version"
  echo
  echo "wrk /metrics"
  wrk -t4 -c64  -d30s "http://$INDEX_BIND/metrics"
}

run_hey() {
  echo "hey /healthz"
  hey -z 30s -c 128 "http://$INDEX_BIND/healthz"
  echo
  echo "hey /version"
  hey -z 30s -c 128 "http://$INDEX_BIND/version"
  echo
  echo "hey /metrics"
  hey -z 30s -c 64  "http://$INDEX_BIND/metrics"
}

run_pure() {
  one() {
    URL="$1"; CONC="$2"; DUR="$3"
    end=$(( $(date +%s) + DUR ))
    tmpdir="$(mktemp -d)"
    pids=()
    for w in $(seq 1 "$CONC"); do
      (
        cnt=0
        while [ "$(date +%s)" -lt "$end" ]; do curl -s -o /dev/null "$URL" || true; cnt=$((cnt+1)); done
        echo "$cnt" > "$tmpdir/$w.count"
      ) & pids+=("$!")
    done
    for p in "${pids[@]}"; do wait "$p"; done
    total=0
    for f in "$tmpdir"/*.count; do [ -f "$f" ] && total=$(( total + $(cat "$f") )); done
    rm -rf "$tmpdir"
    rps=$(awk "BEGIN { printf \"%.1f\", $total/$DUR }")
    echo "purebash url=$URL conc=$CONC dur=${DUR}s total_reqs=$total rps=$rps"
  }
  one "http://$INDEX_BIND/healthz" 128 30
  echo
  one "http://$INDEX_BIND/version" 128 30
  echo
  one "http://$INDEX_BIND/metrics" 64  30
}

warmup 5

if command -v wrk >/dev/null 2>&1; then
  run_wrk
elif command -v hey >/dev/null 2>&1; then
  run_hey
else
  run_pure
fi

```

### crates/svc-index/scripts/bench_resolve.sh
<a id="crates-svc-index-scripts-benchresolve-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "bench: would run Criterion on benches/resolve.rs with datasets"

```

### crates/svc-index/scripts/chaos_inject.sh
<a id="crates-svc-index-scripts-chaosinject-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "chaos: would inject latency/drop into mocked DHT for tests"

```

### crates/svc-index/scripts/mermaid_render.sh
<a id="crates-svc-index-scripts-mermaidrender-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "render: would run mmdc for docs/*.mmd -> *.svg"

```

### crates/svc-index/scripts/smoke.sh
<a id="crates-svc-index-scripts-smoke-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Smoke test for svc-index: boot and hit endpoints.
# RO:WHY  — CI/local quick check without magic sleeps.

set -euo pipefail
BIND="${BIND:-127.0.0.1:5304}"
BIN="${BIN:-cargo run -p svc-index}"
LOG="/tmp/svc-index.log"

$BIN > "$LOG" 2>&1 &
PID=$!

deadline=$((SECONDS+10))
until curl -fsS "http://$BIND/readyz" >/dev/null; do
  [[ $SECONDS -gt $deadline ]] && { echo "readyz timeout"; kill $PID || true; exit 1; }
  sleep 0.2
done

curl -fsS "http://$BIND/healthz" | grep -q ok
curl -fsS "http://$BIND/version" | grep -q svc-index
curl -fsS "http://$BIND/resolve/name:hello" || true
curl -fsS "http://$BIND/providers/b3:0000000000000000000000000000000000000000000000000000000000000000" || true

kill $PID || true
echo "✅ svc-index smoke passed"

```

### crates/svc-index/scripts/smoke_index.sh
<a id="crates-svc-index-scripts-smokeindex-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail

cargo fmt -p svc-index
cargo clippy -p svc-index --no-deps -- -D warnings
cargo build -p svc-index

INDEX_BIND="${INDEX_BIND:-127.0.0.1:5304}"
RUST_LOG="${RUST_LOG:-info}"

target/debug/svc-index >/tmp/svc-index.log 2>&1 &
PID=$!

trap 'kill $PID >/dev/null 2>&1 || true' EXIT

for i in $(seq 1 60); do
  code=$(curl -s -o /dev/null -w "%{http_code}" "http://$INDEX_BIND/healthz" || true)
  [ "$code" = "200" ] && break
  sleep 0.1
done

CID_ZERO="b3:0000000000000000000000000000000000000000000000000000000000000000"

curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/healthz"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/readyz"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/version"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/resolve/name:does-not-exist"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/providers/not-a-cid"
curl -s -o /dev/null -w "%{http_code}\n" "http://$INDEX_BIND/providers/$CID_ZERO"

kill $PID

```

### crates/svc-index/scripts/soak.sh
<a id="crates-svc-index-scripts-soak-sh"></a>

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "soak: would run a short soak test and write histograms to artifacts/"

```

### crates/svc-index/src/app.rs
<a id="crates-svc-index-src-app-rs"></a>

```rust
//! App wiring helpers (bootstrap)

use crate::state::AppState;
use std::sync::Arc;
use tracing::info;

impl AppState {
    pub async fn bootstrap(state: Arc<AppState>) -> Arc<AppState> {
        // Verify deps here later; for MVP, set ready immediately.
        state.health.mark_ready();
        info!("svc-index ready");
        state
    }
}

```

### crates/svc-index/src/audit/events.rs
<a id="crates-svc-index-src-audit-events-rs"></a>

```rust
// audit events placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/audit/mod.rs
<a id="crates-svc-index-src-audit-mod-rs"></a>

```rust
//! RO:WHAT — Audit emit stubs.

pub mod events {
    pub fn emit(_kind: &str, _msg: &str) {}
}

```

### crates/svc-index/src/auth/caps.rs
<a id="crates-svc-index-src-auth-caps-rs"></a>

```rust
// capability policies placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/auth/mod.rs
<a id="crates-svc-index-src-auth-mod-rs"></a>

```rust
//! RO:WHAT — Placeholder for capability checks (macaroon etc).

pub mod caps {
    pub fn check_read() -> bool {
        true
    }
    pub fn check_admin() -> bool {
        false
    } // TODO
}
pub mod uds_allow {} // placeholder

```

### crates/svc-index/src/auth/uds_allow.rs
<a id="crates-svc-index-src-auth-udsallow-rs"></a>

```rust
// uds allowlist placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/bus/events.rs
<a id="crates-svc-index-src-bus-events-rs"></a>

```rust
// bus events placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/bus/mod.rs
<a id="crates-svc-index-src-bus-mod-rs"></a>

```rust
//! RO:WHAT — Bus event stubs (tie to ron-bus later).

pub mod events {
    #[derive(Clone, Debug)]
    pub enum BusEvent {
        ConfigUpdated,
        Shutdown,
    }
}

```

### crates/svc-index/src/cache/manifest.rs
<a id="crates-svc-index-src-cache-manifest-rs"></a>

```rust
// manifest cache placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/cache/mod.rs
<a id="crates-svc-index-src-cache-mod-rs"></a>

```rust
//! RO:WHAT — Tiny TTL cache for resolves/providers.
//! RO:WHY  — Read-optimized service; avoid hot DHT/DB hits.
//! RO:INVARIANTS — bounded by TTL only (simple MVP).

use dashmap::DashMap;
use std::time::{Duration, Instant};

pub struct IndexCache {
    ttl: Duration,
    resolve: DashMap<String, (crate::types::ResolveResponse, Instant)>,
    providers: DashMap<String, (crate::types::ProvidersResponse, Instant)>,
}

impl IndexCache {
    pub fn new(ttl_secs: u64) -> Self {
        Self {
            ttl: Duration::from_secs(ttl_secs),
            resolve: DashMap::new(),
            providers: DashMap::new(),
        }
    }

    pub fn get_resolve(&self, key: &str) -> Option<crate::types::ResolveResponse> {
        self.resolve.get(key).and_then(|v| {
            let (val, ins) = v.value();
            if ins.elapsed() <= self.ttl {
                Some(val.clone())
            } else {
                None
            }
        })
    }
    pub fn put_resolve(&self, key: String, val: crate::types::ResolveResponse) {
        self.resolve.insert(key, (val, Instant::now()));
    }

    pub fn get_providers(&self, cid: &str) -> Option<crate::types::ProvidersResponse> {
        self.providers.get(cid).and_then(|v| {
            let (val, ins) = v.value();
            if ins.elapsed() <= self.ttl {
                Some(val.clone())
            } else {
                None
            }
        })
    }
    pub fn put_providers(&self, cid: String, val: crate::types::ProvidersResponse) {
        self.providers.insert(cid, (val, Instant::now()));
    }
}

```

### crates/svc-index/src/cache/negative.rs
<a id="crates-svc-index-src-cache-negative-rs"></a>

```rust
// negative cache placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/cache/providers.rs
<a id="crates-svc-index-src-cache-providers-rs"></a>

```rust
// providers cache placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/config.rs
<a id="crates-svc-index-src-config-rs"></a>

```rust
//! RO:WHAT — Load and validate service configuration (env + optional file).
//! RO:WHY  — Governance & Hardening defaults (timeouts, limits).

use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Config {
    pub bind: String,
    pub body_cap_bytes: usize,
    pub cache_ttl_secs: u64,
    pub ready_dep_timeout_ms: u64,
    pub enable_sled: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            bind: "127.0.0.1:5304".into(),
            body_cap_bytes: 1024 * 1024, // 1 MiB
            cache_ttl_secs: 30,
            ready_dep_timeout_ms: 1500,
            enable_sled: true,
        }
    }
}

impl Config {
    pub fn load() -> anyhow::Result<Self> {
        let mut cfg = Config::default();
        if let Ok(v) = std::env::var("BIND") {
            cfg.bind = v;
        }
        if let Ok(v) = std::env::var("BODY_CAP_BYTES") {
            cfg.body_cap_bytes = v.parse().unwrap_or(cfg.body_cap_bytes);
        }
        if let Ok(v) = std::env::var("CACHE_TTL_SECS") {
            cfg.cache_ttl_secs = v.parse().unwrap_or(cfg.cache_ttl_secs);
        }
        if let Ok(v) = std::env::var("READY_DEP_TIMEOUT_MS") {
            cfg.ready_dep_timeout_ms = v.parse().unwrap_or(cfg.ready_dep_timeout_ms);
        }
        if let Ok(v) = std::env::var("ENABLE_SLED") {
            cfg.enable_sled = v == "1" || v.eq_ignore_ascii_case("true");
        }
        Ok(cfg)
    }
}

```

### crates/svc-index/src/constants.rs
<a id="crates-svc-index-src-constants-rs"></a>

```rust
//! RO:WHAT — Service-wide constants (OAP/HTTP bounds, header keys).

pub const OAP_MAX_FRAME_BYTES: usize = 1024 * 1024; // 1 MiB
pub const STORAGE_STREAM_CHUNK_HINT: usize = 64 * 1024;

pub const HDR_CORR_ID: &str = "x-corr-id";
pub const HDR_IDEMPOTENCY_KEY: &str = "idempotency-key";

/// Default max accepted body size for inbound HTTP requests (bytes).
/// Set to 1 MiB. Keep aligned with CONFIG.md defaults and body_limits middleware.
pub const MAX_BODY_BYTES: usize = 1_048_576; // 1 MiB

```

### crates/svc-index/src/dht/client.rs
<a id="crates-svc-index-src-dht-client-rs"></a>

```rust
//! RO:WHAT — DHT client stub for provider lookups (to be wired to svc-dht).

use crate::types::ProviderEntry;

#[derive(Clone, Default)]
pub struct DhtClient;

impl DhtClient {
    pub fn new() -> Self {
        Self
    }
    pub async fn providers_for(&self, _cid: &str, limit: usize) -> Vec<ProviderEntry> {
        vec![ProviderEntry {
            id: "local://stub".into(),
            region: Some("local".into()),
            score: 0.5,
        }]
        .into_iter()
        .take(limit)
        .collect()
    }
}

```

### crates/svc-index/src/dht/hedge.rs
<a id="crates-svc-index-src-dht-hedge-rs"></a>

```rust
// hedged lookups placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/dht/mod.rs
<a id="crates-svc-index-src-dht-mod-rs"></a>

```rust
pub mod client;
pub mod rank;

```

### crates/svc-index/src/dht/rank.rs
<a id="crates-svc-index-src-dht-rank-rs"></a>

```rust
//! RO:WHAT — Simple ranking heuristics placeholder.

use crate::types::ProviderEntry;

pub fn rank(mut v: Vec<ProviderEntry>) -> Vec<ProviderEntry> {
    v.sort_by(|a, b| b.score.total_cmp(&a.score));
    v
}

```

### crates/svc-index/src/error.rs
<a id="crates-svc-index-src-error-rs"></a>

```rust
//! Service error type ↔ HTTP mapping.

use crate::types::ErrorResponse;
use axum::{http::StatusCode, response::IntoResponse, Json};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum SvcError {
    #[error("not_found")]
    NotFound,
    #[error("bad_request: {0}")]
    BadRequest(String),
    #[error("over_capacity")]
    OverCapacity,
    #[error("upstream_unready")]
    UpstreamUnready,
    #[error("unauthorized")]
    Unauthorized,
    #[error("forbidden")]
    Forbidden,
    #[error("internal")]
    Internal(anyhow::Error),
}

impl IntoResponse for SvcError {
    fn into_response(self) -> axum::response::Response {
        let (status, code, message): (StatusCode, &'static str, String) = match self {
            SvcError::NotFound => (StatusCode::NOT_FOUND, "not_found", "Not found".to_string()),
            SvcError::BadRequest(m) => (StatusCode::BAD_REQUEST, "bad_request", m),
            SvcError::OverCapacity => (
                StatusCode::TOO_MANY_REQUESTS,
                "over_capacity",
                "Over capacity".to_string(),
            ),
            SvcError::UpstreamUnready => (
                StatusCode::SERVICE_UNAVAILABLE,
                "upstream_unready",
                "Upstream not ready".to_string(),
            ),
            SvcError::Unauthorized => (
                StatusCode::UNAUTHORIZED,
                "unauthorized",
                "Unauthorized".to_string(),
            ),
            SvcError::Forbidden => (StatusCode::FORBIDDEN, "forbidden", "Forbidden".to_string()),
            SvcError::Internal(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "internal",
                "Internal error".to_string(),
            ),
        };
        (
            status,
            Json(ErrorResponse {
                code: code.into(),
                message,
            }),
        )
            .into_response()
    }
}

```

### crates/svc-index/src/http/extractors/capability.rs
<a id="crates-svc-index-src-http-extractors-capability-rs"></a>

```rust
//! RO:WHAT — Capability placeholder (no-op for public GETs).
#[derive(Clone, Copy)]
pub struct Capability;

```

### crates/svc-index/src/http/extractors/corr_id.rs
<a id="crates-svc-index-src-http-extractors-corrid-rs"></a>

```rust
//! RO:WHAT — Simple correlation id generator/injector for responses.

use axum::{http::HeaderValue, response::Response};
use ulid::Ulid;

pub fn add_corr_id(mut r: Response) -> Response {
    let id = Ulid::new().to_string();
    r.headers_mut()
        .insert("x-corr-id", HeaderValue::from_str(&id).unwrap());
    r
}

```

### crates/svc-index/src/http/extractors/limits.rs
<a id="crates-svc-index-src-http-extractors-limits-rs"></a>

```rust
//! RO:WHAT — Request body cap placeholder (Hardening v2.0).

#[derive(Clone, Copy)]
pub struct BodyLimits {
    pub max_bytes: usize,
}

```

### crates/svc-index/src/http/extractors/mod.rs
<a id="crates-svc-index-src-http-extractors-mod-rs"></a>

```rust
//! RO:WHAT — Extractors module root.

pub mod capability;
pub mod corr_id;
pub mod limits;

```

### crates/svc-index/src/http/middleware/body_limits.rs
<a id="crates-svc-index-src-http-middleware-bodylimits-rs"></a>

```rust
//! RO:WHAT — Body size cap middleware placeholder (MVP).
//! RO:WHY  — Hardening v2.0 will wire strict limits per extractor/route.
//! NOTE: Using identity layer for now to avoid unused imports/warnings.

pub fn layer(_max: usize) -> tower::layer::util::Identity {
    tower::layer::util::Identity::new()
}

```

### crates/svc-index/src/http/middleware/decompress_guard.rs
<a id="crates-svc-index-src-http-middleware-decompressguard-rs"></a>

```rust
// decompress ratio guard middleware placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/http/middleware/mod.rs
<a id="crates-svc-index-src-http-middleware-mod-rs"></a>

```rust
//! RO:WHAT — Middleware module root.

pub mod body_limits;
pub mod trace_layer;

```

### crates/svc-index/src/http/middleware/rate_limit.rs
<a id="crates-svc-index-src-http-middleware-ratelimit-rs"></a>

```rust
// rate limit middleware placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/http/middleware/trace_layer.rs
<a id="crates-svc-index-src-http-middleware-tracelayer-rs"></a>

```rust
//! Tower HTTP TraceLayer (Axum + tower-http 0.6.x).
//! Minimal sane defaults using DefaultMakeSpan at INFO level.

use tower_http::classify::{ServerErrorsAsFailures, SharedClassifier};
use tower_http::trace::{
    DefaultMakeSpan, DefaultOnBodyChunk, DefaultOnEos, DefaultOnFailure, DefaultOnRequest,
    DefaultOnResponse, TraceLayer,
};
use tracing::Level;

/// Return a concrete, cloneable TraceLayer with the default classifier
/// (treat 5xx as failures) and the default span builder at INFO.
pub fn layer() -> TraceLayer<
    SharedClassifier<ServerErrorsAsFailures>,
    DefaultMakeSpan,
    DefaultOnRequest,
    DefaultOnResponse,
    DefaultOnBodyChunk,
    DefaultOnEos,
    DefaultOnFailure,
> {
    TraceLayer::new_for_http().make_span_with(DefaultMakeSpan::new().level(Level::INFO))
}

```

### crates/svc-index/src/http/mod.rs
<a id="crates-svc-index-src-http-mod-rs"></a>

```rust
//! RO:WHAT — HTTP module root: submodules for routes, extractors, middleware.

pub mod extractors;
pub mod middleware;
pub mod routes;

```

### crates/svc-index/src/http/routes/admin.rs
<a id="crates-svc-index-src-http-routes-admin-rs"></a>

```rust
//! Admin endpoints (MVP): reindex/pin stubs + name→CID seeding.
//! Adds: X-Admin-Token guard, strict b3 validator, name: normalization.

use axum::{
    extract::State,
    http::{HeaderMap, StatusCode},
    response::IntoResponse,
    Json,
};
use serde::Deserialize;
use std::sync::Arc;

use crate::{error::SvcError, AppState};

pub async fn reindex() -> impl IntoResponse {
    (StatusCode::ACCEPTED, "queued")
}

pub async fn pin() -> impl IntoResponse {
    (StatusCode::ACCEPTED, "queued")
}

#[derive(Deserialize)]
pub struct SeedBody {
    /// Name key. If missing "name:" prefix, it will be added.
    pub name: String,
    /// Content ID (BLAKE3) of the manifest to associate.
    pub cid: String,
}

#[inline]
fn is_b3(s: &str) -> bool {
    let s = s.strip_prefix("b3:").unwrap_or("");
    s.len() == 64 && s.bytes().all(|b| matches!(b, b'0'..=b'9'|b'a'..=b'f'))
}

/// PUT /admin/seed { "name": "hello", "cid": "b3:<64hex>" }
///
/// - requires header X-Admin-Token equal to env INDEX_ADMIN_TOKEN
/// - normalizes name to "name:<value>" if not already prefixed
/// - validates CID as b3:<64hex>
/// - stores mapping so /resolve/name:<value> works
pub async fn seed(
    State(state): State<Arc<AppState>>,
    headers: HeaderMap,
    Json(body): Json<SeedBody>,
) -> Result<impl IntoResponse, SvcError> {
    // Token guard (simple pre-beta protection)
    let required = std::env::var("INDEX_ADMIN_TOKEN").unwrap_or_default();
    let provided = headers
        .get("X-Admin-Token")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();

    if required.is_empty() || provided != required {
        return Err(SvcError::Unauthorized);
    }

    if !is_b3(&body.cid) {
        return Err(SvcError::BadRequest("invalid cid".into()));
    }

    let name = if body.name.starts_with("name:") {
        body.name
    } else {
        format!("name:{}", body.name)
    };

    state.store.put_manifest(&name, &body.cid);

    Ok((
        StatusCode::ACCEPTED,
        Json(serde_json::json!({ "ok": true, "name": name, "cid": body.cid })),
    ))
}

```

### crates/svc-index/src/http/routes/health.rs
<a id="crates-svc-index-src-http-routes-health-rs"></a>

```rust
//! /healthz and /readyz

use crate::AppState;
use axum::{extract::State, http::StatusCode, response::IntoResponse};
use std::sync::Arc;

pub async fn healthz() -> impl IntoResponse {
    (StatusCode::OK, "ok")
}

pub async fn readyz(State(state): State<Arc<AppState>>) -> impl IntoResponse {
    if state.health.all_ready() {
        (StatusCode::OK, "ready").into_response()
    } else {
        (
            StatusCode::SERVICE_UNAVAILABLE,
            [("Retry-After", "1")],
            "booting",
        )
            .into_response()
    }
}

```

### crates/svc-index/src/http/routes/metrics.rs
<a id="crates-svc-index-src-http-routes-metrics-rs"></a>

```rust
//! /metrics

use crate::AppState;
use axum::{
    extract::State,
    response::{IntoResponse, Response},
};
use std::sync::Arc;

pub async fn metrics(State(state): State<Arc<AppState>>) -> Response {
    match state.metrics.render() {
        Ok(s) => s.into_response(),
        Err(_) => axum::http::StatusCode::INTERNAL_SERVER_ERROR.into_response(),
    }
}

```

### crates/svc-index/src/http/routes/mod.rs
<a id="crates-svc-index-src-http-routes-mod-rs"></a>

```rust
pub mod admin;
pub mod health;
pub mod metrics;
pub mod providers;
pub mod resolve;
pub mod version;

```

### crates/svc-index/src/http/routes/providers.rs
<a id="crates-svc-index-src-http-routes-providers-rs"></a>

```rust
//! GET /providers/:cid
//! RO:WHY  Return 404 when no providers are found. Preserve body shape.
//! RO:INVARIANTS Only status code changes on miss; JSON fields unchanged.

use crate::{error::SvcError, pipeline, AppState};
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use std::collections::HashMap;
use std::sync::Arc;

pub async fn providers(
    Path(cid): Path<String>,
    Query(q): Query<HashMap<String, String>>,
    State(state): State<Arc<AppState>>,
) -> Result<impl IntoResponse, SvcError> {
    let limit = q
        .get("limit")
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(5);

    let out = pipeline::providers::run(state, &cid, limit).await?;

    if out.providers.is_empty() {
        return Ok((StatusCode::NOT_FOUND, Json(out)).into_response());
    }

    Ok(Json(out).into_response())
}

```

### crates/svc-index/src/http/routes/resolve.rs
<a id="crates-svc-index-src-http-routes-resolve-rs"></a>

```rust
//! GET /resolve/:key
//! RO:WHY  Return 404 for well-formed misses (manifest:null AND providers:[]).
//! RO:INVARIANTS Keep the JSON body identical; only the HTTP status changes.

use std::sync::Arc;

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use serde_json::Value;

use crate::{error::SvcError, pipeline, AppState};

pub async fn resolve(
    Path(key): Path<String>,
    State(state): State<Arc<AppState>>,
) -> Result<impl IntoResponse, SvcError> {
    let out = pipeline::resolve::run(state, &key, false).await?;

    // miss := manifest == null && providers == []
    let miss = match serde_json::to_value(&out) {
        Ok(Value::Object(map)) => {
            let manifest_is_null = map.get("manifest").is_some_and(|m| m.is_null());
            let providers_empty = map
                .get("providers")
                .and_then(|p| p.as_array())
                .is_none_or(|arr| arr.is_empty());
            manifest_is_null && providers_empty
        }
        _ => false,
    };

    if miss {
        return Ok((StatusCode::NOT_FOUND, Json(out)).into_response());
    }

    Ok(Json(out).into_response())
}

```

### crates/svc-index/src/http/routes/version.rs
<a id="crates-svc-index-src-http-routes-version-rs"></a>

```rust
//! /version

pub async fn version() -> String {
    format!("svc-index/{}", env!("CARGO_PKG_VERSION"))
}

```

### crates/svc-index/src/lib.rs
<a id="crates-svc-index-src-lib-rs"></a>

```rust
#![forbid(unsafe_code)]

// Public modules
pub mod app;
pub mod audit;
pub mod auth;
pub mod bus;
pub mod cache;
pub mod config;
pub mod constants;
pub mod dht;
pub mod error;
pub mod http;
pub mod logging;
pub mod net;
pub mod pipeline;
pub mod router;
pub mod state;
pub mod store;
pub mod telemetry;
pub mod types;
pub mod utils;

// Re-exports
pub use config::Config;
pub use router::build_router;
pub use state::AppState; // <-- from state, not app

```

### crates/svc-index/src/logging.rs
<a id="crates-svc-index-src-logging-rs"></a>

```rust
//! RO:WHAT — Tracing subscriber initialization with EnvFilter.
//! RO:WHY  — Observability baseline.
//! RO:CONFIG — RUST_LOG; defaults to info,hyper=warn.

use tracing_subscriber::{fmt, EnvFilter};

pub fn init() {
    let env = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,hyper=warn,tower_http=warn"));
    fmt().with_env_filter(env).compact().init();
}

```

### crates/svc-index/src/main.rs
<a id="crates-svc-index-src-main-rs"></a>

```rust
//! RO:WHAT — svc-index entry: config → state → router → server (Axum 0.7).
//! RO:WHY  — Avoid stateful Router at serve-time; inject state with `.with_state`.
//! RO:INTERACTS — crate::{config, state, router, logging}.
//! RO:INVARIANTS — single bind; AppState behind Arc; graceful shutdown.

use std::{net::SocketAddr, sync::Arc};

use tokio::net::TcpListener;
use tokio::signal;
use tracing::{error, info, warn};

use svc_index::{build_router, config::Config, logging, AppState};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 0) logging/telemetry
    logging::init();

    // 1) Load config
    let cfg = Config::load()?;

    // 2) Build shared state
    let state: Arc<AppState> = Arc::new(AppState::new(cfg.clone()).await?);

    // 3) Optional bootstrap gates (flip readiness, warm caches, etc.)
    let state = AppState::bootstrap(state).await;

    // 4) Build router WITHOUT state and inject state at the end
    //    This turns Router<Arc<AppState>> → Router<()>, which Axum 0.7 can serve.
    let app = build_router().with_state(state.clone());

    // 5) Bind (+ env override) + serve
    //    Respect INDEX_BIND if present; otherwise use cfg.bind; fallback to 127.0.0.1:5304.
    let bind_str = std::env::var("INDEX_BIND").unwrap_or_else(|_| cfg.bind.clone());
    let bind: SocketAddr = bind_str
        .parse()
        .unwrap_or_else(|_| SocketAddr::from(([127, 0, 0, 1], 5304)));

    let listener: TcpListener = TcpListener::bind(bind).await?;
    info!(
        version = env!("CARGO_PKG_VERSION"),
        %bind,
        "svc-index starting"
    );

    // Serve with graceful shutdown
    let server = axum::serve(listener, app).with_graceful_shutdown(shutdown_signal());
    if let Err(e) = server.await {
        error!(error=?e, "server error");
    }

    Ok(())
}

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        use tokio::signal::unix::{signal, SignalKind};
        signal(SignalKind::terminate())
            .expect("failed to install SIGTERM handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }

    warn!("shutdown signal received");
}

```

### crates/svc-index/src/net/listener.rs
<a id="crates-svc-index-src-net-listener-rs"></a>

```rust
// http listener bootstrap placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/net/mod.rs
<a id="crates-svc-index-src-net-mod-rs"></a>

```rust
//! RO:WHAT — Net placeholders (UDS/TLS if needed later).
pub mod listener {}
pub mod uds {}
pub mod tls {}

```

### crates/svc-index/src/net/tls.rs
<a id="crates-svc-index-src-net-tls-rs"></a>

```rust
// tls server config placeholder (tokio_rustls::rustls::ServerConfig) — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/net/uds.rs
<a id="crates-svc-index-src-net-uds-rs"></a>

```rust
// uds server setup placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/pipeline/mod.rs
<a id="crates-svc-index-src-pipeline-mod-rs"></a>

```rust
pub mod providers;
pub mod resolve;

```

### crates/svc-index/src/pipeline/providers.rs
<a id="crates-svc-index-src-pipeline-providers-rs"></a>

```rust
//! RO:WHAT — Providers pipeline: cid -> ranked provider list (MVP).
//! RO:WHY  Validate CID, pull from DHT, filter synthetic stubs, rank, clamp, cache.
//! RO:INVARIANTS Do not synthesize providers; never cache stub entries.

use crate::{error::SvcError, types::ProvidersResponse, AppState};
use std::sync::Arc;

#[inline]
fn is_b3(s: &str) -> bool {
    let s = s.strip_prefix("b3:").unwrap_or("");
    s.len() == 64 && s.bytes().all(|b| matches!(b, b'0'..=b'9' | b'a'..=b'f'))
}

pub async fn run(
    state: Arc<AppState>,
    cid: &str,
    limit: usize,
) -> Result<ProvidersResponse, SvcError> {
    // 1) Validate input (malformed -> 400)
    if !is_b3(cid) {
        return Err(SvcError::BadRequest("invalid cid".into()));
    }

    // 2) Cache fast-path (already a cleaned object)
    if let Some(cached) = state.cache.get_providers(cid) {
        return Ok(cached);
    }

    // 3) Query DHT (upper-bound to avoid large allocations)
    let lim = limit.clamp(1, 32);
    let mut providers = state.dht.providers_for(cid, lim).await;

    // 4) Remove any synthetic stub providers
    providers.retain(|p| p.id != "local://stub");

    // 5) Rank descending by score
    providers.sort_by(|a, b| b.score.total_cmp(&a.score));

    // 6) Truncate after filtering; mark truncated truthfully
    let truncated = providers.len() > lim;
    if truncated {
        providers.truncate(lim);
    }

    // 7) Build response (no synthesis)
    let resp = ProvidersResponse {
        cid: cid.to_string(),
        providers,
        truncated,
        etag: None,
    };

    // 8) Cache cleaned response
    state.cache.put_providers(cid.to_string(), resp.clone());

    Ok(resp)
}

```

### crates/svc-index/src/pipeline/resolve.rs
<a id="crates-svc-index-src-pipeline-resolve-rs"></a>

```rust
//! RO:WHAT — Resolve pipeline: key (name|b3) -> manifest + providers (MVP).
//! RO:WHY  — Encapsulate read-optimized logic with cache & store.

use crate::{
    error::SvcError,
    types::{ProviderEntry, ResolveResponse},
    AppState,
};
use std::sync::Arc;

#[inline]
fn is_b3(s: &str) -> bool {
    let s = s.strip_prefix("b3:").unwrap_or("");
    s.len() == 64 && s.bytes().all(|b| matches!(b, b'0'..=b'9'|b'a'..=b'f'))
}

pub async fn run(
    state: Arc<AppState>,
    key: &str,
    fresh: bool,
) -> Result<ResolveResponse, SvcError> {
    if !is_b3(key) && !key.starts_with("name:") {
        return Err(SvcError::BadRequest("invalid key".into()));
    }
    if !fresh {
        if let Some(cached) = state.cache.get_resolve(key) {
            return Ok(cached);
        }
    }

    // Manifest lookup (store is authority for names; b3 maps to itself in MVP)
    let manifest = if is_b3(key) {
        Some(key.to_string())
    } else {
        state.store.get_manifest(key)
    };

    // Provider set (stubbed to DHT client)
    let providers = if let Some(cid) = manifest.as_ref() {
        state.dht.providers_for(cid, 5).await
    } else {
        Vec::<ProviderEntry>::new()
    };

    let resp = ResolveResponse {
        key: key.to_string(),
        manifest,
        providers,
        etag: None,
        cached: false,
    };
    state.cache.put_resolve(key.to_string(), resp.clone());
    Ok(resp)
}

```

### crates/svc-index/src/router.rs
<a id="crates-svc-index-src-router-rs"></a>

```rust
//! RO:WHAT — HTTP router (routes + middleware).
//! RO:WHY  — Keep as Router<Arc<AppState>>; main.rs injects state via .with_state(...).
//! RO:INVARIANTS — Handlers use State<Arc<AppState>>.

use std::sync::Arc;

use axum::{routing::get, Router};

use crate::{
    constants::MAX_BODY_BYTES,
    http::{middleware, routes},
    state::AppState,
};

pub fn build_router() -> Router<Arc<AppState>> {
    let api = Router::new()
        .route("/healthz", get(routes::health::healthz))
        .route("/readyz", get(routes::health::readyz))
        .route("/version", get(routes::version::version))
        .route("/metrics", get(routes::metrics::metrics))
        // Generic key resolver: supports "name:*" or "b3:*"
        .route("/resolve/:key", get(routes::resolve::resolve))
        .route("/providers/:cid", get(routes::providers::providers));

    Router::new()
        .nest("/", api)
        .layer(middleware::trace_layer::layer())
        .layer(middleware::body_limits::layer(MAX_BODY_BYTES))
}

```

### crates/svc-index/src/state/metrics.rs
<a id="crates-svc-index-src-state-metrics-rs"></a>

```rust
//! RO:WHAT — Prometheus metrics registry and golden histograms.
//! RO:WHY  — Observability; consistent metric names.

use prometheus::{Encoder, Histogram, HistogramOpts, IntCounterVec, Opts, Registry, TextEncoder};

pub struct Metrics {
    pub registry: Registry,
    pub http_requests_total: IntCounterVec,
    pub request_latency_seconds: Histogram,
    pub rejected_total: IntCounterVec,
}

impl Metrics {
    pub fn new() -> anyhow::Result<Self> {
        let registry = Registry::new();
        let http_requests_total = IntCounterVec::new(
            Opts::new("http_requests_total", "HTTP request count"),
            &["route", "method", "status"],
        )?;
        let request_latency_seconds = Histogram::with_opts(HistogramOpts::new(
            "request_latency_seconds",
            "Request latency",
        ))?;
        let rejected_total = IntCounterVec::new(
            Opts::new("rejected_total", "Rejected requests by reason"),
            &["reason"],
        )?;
        registry.register(Box::new(http_requests_total.clone()))?;
        registry.register(Box::new(request_latency_seconds.clone()))?;
        registry.register(Box::new(rejected_total.clone()))?;
        Ok(Self {
            registry,
            http_requests_total,
            request_latency_seconds,
            rejected_total,
        })
    }

    pub fn render(&self) -> anyhow::Result<String> {
        let mut buf = Vec::new();
        let enc = TextEncoder::new();
        enc.encode(&self.registry.gather(), &mut buf)?;
        Ok(String::from_utf8(buf).unwrap_or_default())
    }
}

```

### crates/svc-index/src/state/mod.rs
<a id="crates-svc-index-src-state-mod-rs"></a>

```rust
//! RO:WHAT — AppState: health, metrics, cfg, cache, store, dht client.
//! RO:WHY  — Centralized handles; ready/health truth.
//! RO:INVARIANTS — set ready last; clone handles; register metrics once.

pub mod metrics;
pub mod readiness;
pub mod shutdown;

use crate::{cache, config::Config, dht::client::DhtClient, store::Store};

pub struct AppState {
    pub cfg: Config,
    pub health: readiness::HealthState,
    pub metrics: metrics::Metrics,
    pub cache: cache::IndexCache,
    pub store: Store,
    pub dht: DhtClient,
}

impl AppState {
    pub async fn new(cfg: Config) -> anyhow::Result<Self> {
        let metrics = metrics::Metrics::new()?;
        let health = readiness::HealthState::new();
        let cache = cache::IndexCache::new(cfg.cache_ttl_secs);
        let store = Store::new(cfg.enable_sled)?;
        let dht = DhtClient::new();

        Ok(Self {
            cfg,
            health,
            metrics,
            cache,
            store,
            dht,
        })
    }
}

```

### crates/svc-index/src/state/readiness.rs
<a id="crates-svc-index-src-state-readiness-rs"></a>

```rust
//! RO:WHAT — Health/Readiness gate with truthful signals.

use std::sync::atomic::{AtomicBool, Ordering};

#[derive(Clone)]
pub struct HealthState {
    ready: std::sync::Arc<AtomicBool>,
}

impl Default for HealthState {
    fn default() -> Self {
        Self {
            ready: std::sync::Arc::new(AtomicBool::new(false)),
        }
    }
}

impl HealthState {
    pub fn new() -> Self {
        Self::default()
    }
    pub fn mark_ready(&self) {
        self.ready.store(true, Ordering::SeqCst);
    }
    pub fn mark_not_ready(&self) {
        self.ready.store(false, Ordering::SeqCst);
    }
    pub fn all_ready(&self) -> bool {
        self.ready.load(std::sync::atomic::Ordering::SeqCst)
    }
}

```

### crates/svc-index/src/state/shutdown.rs
<a id="crates-svc-index-src-state-shutdown-rs"></a>

```rust
// graceful shutdown placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/store/keys.rs
<a id="crates-svc-index-src-store-keys-rs"></a>

```rust
// keyspace layout placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/store/mod.rs
<a id="crates-svc-index-src-store-mod-rs"></a>

```rust
//! Store abstraction; sled-backed (feature) or in-memory.

mod sled_store; // declare the sibling module within `store/`

#[derive(Clone)]
pub enum Store {
    #[cfg(feature = "sled-store")]
    Sled(self::sled_store::SledStore),
    Memory(self::sled_store::MemStore),
}

impl Store {
    pub fn new(enable_sled: bool) -> anyhow::Result<Self> {
        if cfg!(feature = "sled-store") && enable_sled {
            Ok(Self::Sled(self::sled_store::SledStore::open()?))
        } else {
            Ok(Self::Memory(self::sled_store::MemStore::default()))
        }
    }

    pub fn get_manifest(&self, key: &str) -> Option<String> {
        match self {
            #[cfg(feature = "sled-store")]
            Store::Sled(s) => s.get_manifest(key),
            Store::Memory(m) => m.get_manifest(key),
        }
    }

    pub fn put_manifest(&self, key: &str, cid: &str) {
        match self {
            #[cfg(feature = "sled-store")]
            Store::Sled(s) => s.put_manifest(key, cid),
            Store::Memory(m) => m.put_manifest(key, cid),
        }
    }
}

```

### crates/svc-index/src/store/schema.rs
<a id="crates-svc-index-src-store-schema-rs"></a>

```rust
// schema versions & migrations placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)

```

### crates/svc-index/src/store/sled_store.rs
<a id="crates-svc-index-src-store-sledstore-rs"></a>

```rust
//! Sled-backed (or in-memory) key→manifest store (MVP).
//! Changes: honor RON_INDEX_DB env; flush after writes for durability.

#[cfg(feature = "sled-store")]
#[derive(Clone)]
pub struct SledStore {
    /// Tree that holds key → manifest CID
    man: sled::Tree,
    _db: sled::Db,
}

#[cfg(feature = "sled-store")]
impl SledStore {
    pub fn open() -> anyhow::Result<Self> {
        let path = std::env::var("RON_INDEX_DB").unwrap_or_else(|_| "svc-index.db".into());
        let db = sled::open(path)?;
        let man = db.open_tree("manifest")?;
        Ok(Self { man, _db: db })
    }
    pub fn get_manifest(&self, key: &str) -> Option<String> {
        self.man
            .get(key.as_bytes())
            .ok()
            .flatten()
            .and_then(|ivec| String::from_utf8(ivec.to_vec()).ok())
    }
    pub fn put_manifest(&self, key: &str, cid: &str) {
        let _ = self.man.insert(key.as_bytes(), cid.as_bytes());
        let _ = self.man.flush(); // ensure durability for beta MVP
    }
}

#[derive(Clone, Default)]
pub struct MemStore {
    map: std::sync::Arc<parking_lot::RwLock<std::collections::HashMap<String, String>>>,
}

impl MemStore {
    pub fn get_manifest(&self, key: &str) -> Option<String> {
        self.map.read().get(key).cloned()
    }
    pub fn put_manifest(&self, key: &str, cid: &str) {
        self.map.write().insert(key.to_string(), cid.to_string());
    }
}

```

### crates/svc-index/src/telemetry.rs
<a id="crates-svc-index-src-telemetry-rs"></a>

```rust
//! RO:WHAT — OpenTelemetry glue (optional feature).
//! RO:WHY  — Trace export to OTLP if enabled.
//! RO:CONFIG — OTEL_EXPORTER_OTLP_ENDPOINT, etc.
//! RO:TEST — manual in perf/chaos workflows.

#[cfg(feature = "otel")]
pub mod otel {
    use opentelemetry::sdk::trace as sdktrace;
    use opentelemetry::KeyValue;
    use tracing_subscriber::layer::SubscriberExt;
    use tracing_subscriber::Registry;

    pub fn init(service_name: &str) {
        let tracer = opentelemetry_otlp::new_pipeline()
            .tracing()
            .with_trace_config(
                sdktrace::config().with_resource(opentelemetry::sdk::Resource::new(vec![
                    KeyValue::new("service.name", service_name.to_string()),
                ])),
            )
            .install_batch(opentelemetry::runtime::Tokio)
            .expect("install otlp");

        let telem = tracing_opentelemetry::layer().with_tracer(tracer);
        let subscriber = Registry::default().with(telem);
        tracing::subscriber::set_global_default(subscriber).ok();
    }
}

```

### crates/svc-index/src/types.rs
<a id="crates-svc-index-src-types-rs"></a>

```rust
//! RO:WHAT — DTOs for HTTP responses/requests.
//! RO:WHY  — Interop hygiene; `#[serde(deny_unknown_fields)]`.
//! RO:INVARIANTS — b3: hex shape; stable error taxonomy.
//! RO:SECURITY — no secrets in payloads.

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ResolveResponse {
    pub key: String,              // name:* or b3:<hex>
    pub manifest: Option<String>, // usually a CID of a manifest
    pub providers: Vec<ProviderEntry>,
    pub etag: Option<String>, // "b3:<hex>" when applicable
    pub cached: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ProviderEntry {
    pub id: String, // provider id (e.g., node addr)
    pub region: Option<String>,
    pub score: f32, // ranking hint
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ProvidersResponse {
    pub cid: String, // b3:<hex>
    pub providers: Vec<ProviderEntry>,
    pub truncated: bool,
    pub etag: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ErrorResponse {
    pub code: String, // "not_found" | "over_capacity" | ...
    pub message: String,
}

```

### crates/svc-index/src/utils/mod.rs
<a id="crates-svc-index-src-utils-mod-rs"></a>

```rust
//! RO:WHAT — utils module root.
//! RO:WHY  — Houses common helpers (timeouts, etc).

pub mod timeouts;

```

### crates/svc-index/src/utils/timeouts.rs
<a id="crates-svc-index-src-utils-timeouts-rs"></a>

```rust
//! RO:WHAT — Common timeout helpers.
//! RO:WHY  — Keep await-time discipline explicit.

use tokio::time::{timeout, Duration};

pub async fn with_timeout<F, T>(ms: u64, fut: F) -> Result<T, ()>
where
    F: std::future::Future<Output = T>,
{
    timeout(Duration::from_millis(ms), fut)
        .await
        .map_err(|_| ())
}

```

### crates/svc-index/tests/chaos.rs
<a id="crates-svc-index-tests-chaos-rs"></a>

```rust
// chaos tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn chaos_placeholder() {
    assert!(true);
}

```

### crates/svc-index/tests/golden/resolve/not_found.json
<a id="crates-svc-index-tests-golden-resolve-notfound-json"></a>

```json
{ "case": "not_found", "expect": 404 }\n
```

### crates/svc-index/tests/golden/resolve/ok_basic.json
<a id="crates-svc-index-tests-golden-resolve-okbasic-json"></a>

```json
{ "case": "ok_basic", "expect": "Resolved" }\n
```

### crates/svc-index/tests/golden/resolve/over_capacity.json
<a id="crates-svc-index-tests-golden-resolve-overcapacity-json"></a>

```json
{ "case": "over_capacity", "expect": 429 }\n
```

### crates/svc-index/tests/golden/resolve/providers_ranked.json
<a id="crates-svc-index-tests-golden-resolve-providersranked-json"></a>

```json
{ "case": "providers_ranked", "expect": ["p1","p2"] }\n
```

### crates/svc-index/tests/http_contract.rs
<a id="crates-svc-index-tests-httpcontract-rs"></a>

```rust
// http contract tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn http_contract_placeholder() {
    assert!(true);
}

```

### crates/svc-index/tests/integration.rs
<a id="crates-svc-index-tests-integration-rs"></a>

```rust
// integration tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn integration_placeholder() {
    assert!(true);
}

```

### crates/svc-index/tests/loom_index.rs
<a id="crates-svc-index-tests-loomindex-rs"></a>

```rust
// loom tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn loom_placeholder() {
    assert!(true);
}

```

### crates/svc-index/tests/prop_index.rs
<a id="crates-svc-index-tests-propindex-rs"></a>

```rust
// property tests placeholder — (auto-generated by scaffold_svc_index2.sh; replace with real content later)
#[test]
fn prop_placeholder() {
    assert!(true);
}

```



---



# ron-policy

_Source: crates/ron-policy/CODEBUNDLE.MD_

<!-- Generated by scripts/make_crate_codex.sh on 2025-10-30T21:44:52Z -->
# Code Bundle — `ron-policy`

> Generated for review/sharing. Source of truth remains the repo.
> Skips `docs/` and all `*.md`; includes common code/config extensions.

## Table of Contents
- [crates/ron-policy/.cargo/config.toml](#crates-ron-policy--cargo-config-toml)
- [crates/ron-policy/.github/workflows/policy.yml](#crates-ron-policy--github-workflows-policy-yml)
- [crates/ron-policy/Cargo.toml](#crates-ron-policy-Cargo-toml)
- [crates/ron-policy/benches/eval_throughput.rs](#crates-ron-policy-benches-evalthroughput-rs)
- [crates/ron-policy/deny.toml](#crates-ron-policy-deny-toml)
- [crates/ron-policy/examples/minimal_allow_deny.rs](#crates-ron-policy-examples-minimalallowdeny-rs)
- [crates/ron-policy/examples/ron_policy_cli.rs](#crates-ron-policy-examples-ronpolicycli-rs)
- [crates/ron-policy/fuzz/Cargo.toml](#crates-ron-policy-fuzz-Cargo-toml)
- [crates/ron-policy/fuzz/fuzz_targets/fuzz_bundle_parse.rs](#crates-ron-policy-fuzz-fuzztargets-fuzzbundleparse-rs)
- [crates/ron-policy/fuzz/fuzz_targets/fuzz_eval.rs](#crates-ron-policy-fuzz-fuzztargets-fuzzeval-rs)
- [crates/ron-policy/rust-toolchain.toml](#crates-ron-policy-rust-toolchain-toml)
- [crates/ron-policy/schema/policybundle.schema.json](#crates-ron-policy-schema-policybundle-schema-json)
- [crates/ron-policy/scripts/ci_invariants.sh](#crates-ron-policy-scripts-ciinvariants-sh)
- [crates/ron-policy/src/ctx/clock.rs](#crates-ron-policy-src-ctx-clock-rs)
- [crates/ron-policy/src/ctx/mod.rs](#crates-ron-policy-src-ctx-mod-rs)
- [crates/ron-policy/src/ctx/normalize.rs](#crates-ron-policy-src-ctx-normalize-rs)
- [crates/ron-policy/src/engine/eval.rs](#crates-ron-policy-src-engine-eval-rs)
- [crates/ron-policy/src/engine/index.rs](#crates-ron-policy-src-engine-index-rs)
- [crates/ron-policy/src/engine/metrics.rs](#crates-ron-policy-src-engine-metrics-rs)
- [crates/ron-policy/src/engine/mod.rs](#crates-ron-policy-src-engine-mod-rs)
- [crates/ron-policy/src/engine/obligations.rs](#crates-ron-policy-src-engine-obligations-rs)
- [crates/ron-policy/src/engine/reason.rs](#crates-ron-policy-src-engine-reason-rs)
- [crates/ron-policy/src/errors.rs](#crates-ron-policy-src-errors-rs)
- [crates/ron-policy/src/explain/mod.rs](#crates-ron-policy-src-explain-mod-rs)
- [crates/ron-policy/src/explain/trace.rs](#crates-ron-policy-src-explain-trace-rs)
- [crates/ron-policy/src/features.rs](#crates-ron-policy-src-features-rs)
- [crates/ron-policy/src/lib.rs](#crates-ron-policy-src-lib-rs)
- [crates/ron-policy/src/model.rs](#crates-ron-policy-src-model-rs)
- [crates/ron-policy/src/parse/json.rs](#crates-ron-policy-src-parse-json-rs)
- [crates/ron-policy/src/parse/mod.rs](#crates-ron-policy-src-parse-mod-rs)
- [crates/ron-policy/src/parse/toml.rs](#crates-ron-policy-src-parse-toml-rs)
- [crates/ron-policy/src/parse/validate.rs](#crates-ron-policy-src-parse-validate-rs)
- [crates/ron-policy/tests/golden_reasons.rs](#crates-ron-policy-tests-goldenreasons-rs)
- [crates/ron-policy/tests/helpers/bundle_load.rs](#crates-ron-policy-tests-helpers-bundleload-rs)
- [crates/ron-policy/tests/unit_churn_protection.rs](#crates-ron-policy-tests-unitchurnprotection-rs)
- [crates/ron-policy/tests/unit_eu_only.rs](#crates-ron-policy-tests-uniteuonly-rs)
- [crates/ron-policy/tests/unit_eval_determinism.rs](#crates-ron-policy-tests-unitevaldeterminism-rs)
- [crates/ron-policy/tests/unit_first_match_wins.rs](#crates-ron-policy-tests-unitfirstmatchwins-rs)
- [crates/ron-policy/tests/unit_large_body_default_deny.rs](#crates-ron-policy-tests-unitlargebodydefaultdeny-rs)
- [crates/ron-policy/tests/unit_method_matrix.rs](#crates-ron-policy-tests-unitmethodmatrix-rs)
- [crates/ron-policy/tests/unit_model_serde_strict.rs](#crates-ron-policy-tests-unitmodelserdestrict-rs)
- [crates/ron-policy/tests/unit_tags_all.rs](#crates-ron-policy-tests-unittagsall-rs)
- [crates/ron-policy/tests/unit_tighten_only.rs](#crates-ron-policy-tests-unittightenonly-rs)
- [crates/ron-policy/tests/vectors/body_too_large.json](#crates-ron-policy-tests-vectors-bodytoolarge-json)
- [crates/ron-policy/tests/vectors/decompress_guard.json](#crates-ron-policy-tests-vectors-decompressguard-json)
- [crates/ron-policy/tests/vectors/deny_region.json](#crates-ron-policy-tests-vectors-denyregion-json)
- [crates/ron-policy/tests/vectors/eu_only.json](#crates-ron-policy-tests-vectors-euonly-json)
- [crates/ron-policy/tests/vectors/large_body_default_deny.json](#crates-ron-policy-tests-vectors-largebodydefaultdeny-json)
- [crates/ron-policy/tests/vectors/method_matrix.json](#crates-ron-policy-tests-vectors-methodmatrix-json)
- [crates/ron-policy/tests/vectors/tags_all.json](#crates-ron-policy-tests-vectors-tagsall-json)

### crates/ron-policy/.cargo/config.toml
<a id="crates-ron-policy--cargo-config-toml"></a>

```toml
[build]
rustflags = ["-Dwarnings"]

[target.'cfg(all())']
rustdocflags = ["-Dwarnings"]

```

### crates/ron-policy/.github/workflows/policy.yml
<a id="crates-ron-policy--github-workflows-policy-yml"></a>

```yaml
name: ron-policy2
on:
  pull_request:
  push:
    branches: [ main ]
jobs:
  placeholder:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "CI placeholder for ron-policy2 (lint/tests/deny/benches/fuzz to be added)."

```

### crates/ron-policy/Cargo.toml
<a id="crates-ron-policy-Cargo-toml"></a>

```toml
[package]
name = "ron-policy"
version = "0.1.0-beta.1"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Declarative policy engine for RustyOnions (deny-by-default, quotas, geo, residency, reasons/obligations)"
repository = "https://example.invalid/RustyOnions"
authors = ["RustyOnions Contributors"]
rust-version = "1.78"

[lib]
name = "ron_policy"
path = "src/lib.rs"

[features]
# Tight JSON/TOML parsing with #[serde(deny_unknown_fields)] everywhere.
strict = []
# Avoids time dependencies in core; enables std::time-based clock by default.
default = ["strict"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"
thiserror = "1.0"
bytes = "1.7"
prometheus = "0.14"
regex = "1.10"
# NOTE: we migrated metrics statics to std::sync::LazyLock, so once_cell is no longer needed.

[dev-dependencies]
criterion = "0.5"
insta = { version = "1.43", features = ["json"] }
rand = "0.9"
pico-args = "0.5"        # for examples/ron_policy_cli.rs

[package.metadata.cargo-udeps.ignore]
normal = ["prometheus"]

[[bench]]
name = "eval_throughput"
harness = false

# Explicitly list the CLI example so it builds with dev-deps.
[[example]]
name = "ron_policy_cli"
path = "examples/ron_policy_cli.rs"

# Minimal example runs without extra deps; auto-discovery also works,
# but we keep it explicit for clarity.
[[example]]
name = "minimal_allow_deny"
path = "examples/minimal_allow_deny.rs"

```

### crates/ron-policy/benches/eval_throughput.rs
<a id="crates-ron-policy-benches-evalthroughput-rs"></a>

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

fn bench_eval(c: &mut Criterion) {
    let bundle = load_json(include_bytes!("../tests/vectors/deny_region.json")).unwrap();
    let ev = Evaluator::new(&bundle).unwrap();
    let clock = SystemClock::default();

    c.bench_function("eval:get/us", |b| {
        b.iter(|| {
            let ctx = Context::builder()
                .tenant("t")
                .method("GET")
                .region("US")
                .build(&clock);
            let d = ev.evaluate(&ctx).unwrap();
            black_box(d);
        })
    });
}

criterion_group!(benches, bench_eval);
criterion_main!(benches);

```

### crates/ron-policy/deny.toml
<a id="crates-ron-policy-deny-toml"></a>

```toml
# RO:WHAT — cargo-deny policy aligned to workspace gates
[advisories]
ignore = []

[bans]
multiple-versions = "deny"

[sources]
unknown-registry = "deny"
unknown-git = "deny"

[licenses]
unlicensed = "deny"
allow = [
  "MIT",
  "Apache-2.0",
  "Unicode-3.0",
  "Unicode-DFS-2016",
  "CC0-1.0",
  "CDLA-Permissive-2.0",
  "OpenSSL"
]

```

### crates/ron-policy/examples/minimal_allow_deny.rs
<a id="crates-ron-policy-examples-minimalallowdeny-rs"></a>

```rust
//! RO:WHAT — Minimal usage example: parse bundle → evaluate context → print result.
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

fn main() {
    let bundle = load_json(
        br#"{
        "version":1,
        "rules":[
            {"id":"deny-fl","when":{"region":"US-FL"},"action":"deny","reason":"geo block"},
            {"id":"allow","when":{},"action":"allow","reason":"open"}
        ]
    }"#,
    )
    .unwrap();

    let ev = Evaluator::new(&bundle).unwrap();
    let ctx = Context::builder()
        .tenant("acme")
        .method("GET")
        .region("US")
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();
    println!("effect={:?} reason={:?}", d.effect, d.reason);
}

```

### crates/ron-policy/examples/ron_policy_cli.rs
<a id="crates-ron-policy-examples-ronpolicycli-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::{load_json, load_toml, Context, Evaluator};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = pico_args::Arguments::from_env();

    let bundle: String = args.value_from_str("--bundle")?;
    let tenant: String = args
        .opt_value_from_str("--tenant")?
        .unwrap_or_else(|| "*".into());
    let method: String = args
        .opt_value_from_str("--method")?
        .unwrap_or_else(|| "*".into());
    let region: String = args
        .opt_value_from_str("--region")?
        .unwrap_or_else(|| "*".into());
    let body: u64 = args.opt_value_from_str("--body")?.unwrap_or(0);

    // Collect repeated flags: --tag paid --tag verified ...
    // Note: values_from_str<A, T>(...) — we specify T and let A be inferred via `_`.
    let tags: Vec<String> = args
        .values_from_str::<_, String>("--tag")
        .unwrap_or_default();

    let bytes = std::fs::read(&bundle)?;
    let bundle_val = if bundle.ends_with(".json") {
        load_json(&bytes)?
    } else if bundle.ends_with(".toml") {
        load_toml(&bytes)?
    } else {
        return Err("bundle must be .json or .toml".into());
    };

    let ev = Evaluator::new(&bundle_val)?;
    let mut b = Context::builder()
        .tenant(tenant)
        .method(method)
        .region(region)
        .body_bytes(body);
    for t in tags {
        b = b.tag(t);
    }
    let ctx = b.build(&SystemClock);

    let d = ev.evaluate(&ctx)?;
    println!("effect={:?} reason={:?}", d.effect, d.reason);
    println!("trace={:?}", d.trace.steps);
    Ok(())
}

```

### crates/ron-policy/fuzz/Cargo.toml
<a id="crates-ron-policy-fuzz-Cargo-toml"></a>

```toml
[package]
name = "ron-policy-fuzz"
version = "0.1.0"
publish = false
edition = "2021"

[package.metadata]
cargo-fuzz = true

[dependencies]
libfuzzer-sys = "0.4"
serde_json = "1.0"
toml = "0.8"
ron-policy = { path = ".." }

[[bin]]
name = "fuzz_bundle_parse"
path = "fuzz_targets/fuzz_bundle_parse.rs"

[[bin]]
name = "fuzz_eval"
path = "fuzz_targets/fuzz_eval.rs"

```

### crates/ron-policy/fuzz/fuzz_targets/fuzz_bundle_parse.rs
<a id="crates-ron-policy-fuzz-fuzztargets-fuzzbundleparse-rs"></a>

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;
use ron_policy::{load_json, load_toml};

fuzz_target!(|data: &[u8]| {
    let _ = load_json(data);
    let _ = load_toml(data);
});

```

### crates/ron-policy/fuzz/fuzz_targets/fuzz_eval.rs
<a id="crates-ron-policy-fuzz-fuzztargets-fuzzeval-rs"></a>

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;
use ron_policy::{load_json, Evaluator, Context, ctx::clock::SystemClock};

fuzz_target!(|data: &[u8]| {
    if let Ok(b) = load_json(data) {
        if let Ok(ev) = Evaluator::new(&b) {
            let c = Context::builder().tenant("t").method("GET").region("US").build(&SystemClock);
            let _ = ev.evaluate(&c);
        }
    }
});

```

### crates/ron-policy/rust-toolchain.toml
<a id="crates-ron-policy-rust-toolchain-toml"></a>

```toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

```

### crates/ron-policy/schema/policybundle.schema.json
<a id="crates-ron-policy-schema-policybundle-schema-json"></a>

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "PolicyBundle",
  "type": "object",
  "required": ["version", "rules"],
  "additionalProperties": false,
  "properties": {
    "version": { "type": "integer", "minimum": 1 },
    "meta": { "type": "object", "additionalProperties": { "type": "string" } },
    "defaults": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "default_action": { "enum": ["allow", "deny"] },
        "max_body_bytes": { "type": "integer", "minimum": 0, "maximum": 1048576 }
      }
    },
    "rules": {
      "type": "array",
      "items": { "$ref": "#/definitions/rule" }
    }
  },
  "definitions": {
    "rule": {
      "type": "object",
      "required": ["id", "when", "action"],
      "additionalProperties": false,
      "properties": {
        "id": { "type": "string", "minLength": 1 },
        "when": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "tenant": { "type": "string" },
            "method": { "type": "string" },
            "region": { "type": "string" },
            "max_body_bytes": { "type": "integer", "minimum": 0, "maximum": 1048576 },
            "require_tags_all": { "type": "array", "items": { "type": "string" } }
          }
        },
        "action": { "enum": ["allow", "deny"] },
        "obligations": {
          "type": "array",
          "items": { "$ref": "#/definitions/obligation" }
        },
        "reason": { "type": "string" }
      }
    },
    "obligation": {
      "type": "object",
      "required": ["kind"],
      "additionalProperties": false,
      "properties": {
        "kind": { "type": "string" },
        "params": { "type": "object", "additionalProperties": { "type": "string" } }
      }
    }
  }
}

```

### crates/ron-policy/scripts/ci_invariants.sh
<a id="crates-ron-policy-scripts-ciinvariants-sh"></a>

```bash
#!/usr/bin/env bash
# RO:WHAT — Fast CI invariants for ron-policy (fmt, clippy, tests)
# RO:INVARIANTS — no magic sleeps; fail fast on errors
set -euo pipefail
cargo fmt -p ron-policy -- --check
cargo clippy -p ron-policy --no-deps -- -D warnings
cargo test -p ron-policy

```

### crates/ron-policy/src/ctx/clock.rs
<a id="crates-ron-policy-src-ctx-clock-rs"></a>

```rust
//! RO:WHAT — Clock trait for deterministic tests and prod time access.
//!
//! RO:WHY  — Keep engine free of direct time deps; easy to mock.

pub trait Clock {
    fn now_ms(&self) -> u64;
}

#[derive(Default)]
pub struct SystemClock;

impl Clock for SystemClock {
    fn now_ms(&self) -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        let ms = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis();
        u64::try_from(ms).unwrap_or(u64::MAX)
    }
}

```

### crates/ron-policy/src/ctx/mod.rs
<a id="crates-ron-policy-src-ctx-mod-rs"></a>

```rust
//! RO:WHAT — Evaluation context types (normalized request facts) and clock trait.
//!
//! RO:WHY  — Deterministic, testable evaluation independent of actual services.
//!
//! RO:INTERACTS — `engine::eval` (consumes `Context`), `ctx::{normalize,clock}`

pub mod clock;
pub mod normalize;

use std::collections::BTreeSet;

/// Minimal context the engine needs to decide.
#[derive(Debug, Clone)]
pub struct Context {
    pub tenant: String,
    pub method: String,
    pub region: String,
    pub body_bytes: u64,
    pub tags: BTreeSet<String>,
    pub now_ms: u64,
}

impl Context {
    #[must_use]
    pub fn builder() -> normalize::ContextBuilder {
        normalize::ContextBuilder::default()
    }
}

```

### crates/ron-policy/src/ctx/normalize.rs
<a id="crates-ron-policy-src-ctx-normalize-rs"></a>

```rust
//! RO:WHAT — Builders and normalizers to construct a `Context` safely.
//!
//! RO:WHY  — Avoid ad-hoc normalization in callers; ensure consistent casing and defaults.

use super::clock::Clock;
use super::Context;
use std::collections::BTreeSet;

#[derive(Default)]
pub struct ContextBuilder {
    tenant: Option<String>,
    method: Option<String>,
    region: Option<String>,
    body_bytes: Option<u64>,
    tags: BTreeSet<String>,
}

impl ContextBuilder {
    #[must_use]
    pub fn tenant(mut self, t: impl Into<String>) -> Self {
        self.tenant = Some(t.into());
        self
    }

    #[must_use]
    pub fn method(mut self, m: impl Into<String>) -> Self {
        self.method = Some(m.into());
        self
    }

    #[must_use]
    pub fn region(mut self, r: impl Into<String>) -> Self {
        self.region = Some(r.into());
        self
    }

    #[must_use]
    pub const fn body_bytes(mut self, n: u64) -> Self {
        self.body_bytes = Some(n);
        self
    }

    #[must_use]
    pub fn tag(mut self, t: impl Into<String>) -> Self {
        self.tags.insert(t.into().to_ascii_lowercase());
        self
    }

    pub fn build<C: Clock>(self, clock: &C) -> Context {
        Context {
            tenant: self.tenant.unwrap_or_else(|| "*".to_string()),
            method: self
                .method
                .map_or_else(|| "*".to_string(), |s| s.to_ascii_uppercase()),
            region: self.region.unwrap_or_else(|| "*".to_string()),
            body_bytes: self.body_bytes.unwrap_or(0),
            tags: self.tags,
            now_ms: clock.now_ms(),
        }
    }
}

```

### crates/ron-policy/src/engine/eval.rs
<a id="crates-ron-policy-src-engine-eval-rs"></a>

```rust
//! RO:WHAT — Core evaluation logic producing a Decision + Trace.
//!
//! RO:WHY  — Deterministic, explainable allow/deny with reasons and obligations.

use super::{index::RuleIndex, metrics, obligations::ObligationSet};
use crate::{
    errors::Error,
    explain::trace::{DecisionTrace, TraceStep},
    model::{Action, PolicyBundle, Rule},
    Context,
};
use std::time::Instant;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DecisionEffect {
    Allow,
    Deny,
}

#[derive(Debug, Clone)]
pub struct Decision {
    pub effect: DecisionEffect,
    pub obligations: ObligationSet,
    pub reason: Option<String>,
    pub trace: DecisionTrace,
}

pub struct Evaluator<'a> {
    bundle: &'a PolicyBundle,
    index: RuleIndex<'a>,
}

impl<'a> Evaluator<'a> {
    /// Construct an evaluator over a validated bundle.
    ///
    /// # Errors
    ///
    /// Currently infallible; reserved for future index build errors.
    pub fn new(bundle: &'a PolicyBundle) -> Result<Self, Error> {
        Ok(Self {
            index: RuleIndex::build(bundle),
            bundle,
        })
    }

    /// Evaluate a decision for `ctx`.
    ///
    /// # Errors
    ///
    /// Returns `Error::Eval` if evaluation cannot complete (reserved; not used today).
    pub fn evaluate(&self, ctx: &Context) -> Result<Decision, Error> {
        metrics::REQUESTS_TOTAL.inc();
        let t0 = Instant::now();

        let mut trace = DecisionTrace::default();
        let mut obligations = ObligationSet::default();

        // Hard guard: body cap from defaults first.
        if let Some(max) = self.bundle.defaults.max_body_bytes {
            if ctx.body_bytes > max {
                metrics::REJECTED_TOTAL
                    .with_label_values(&["body_too_large"])
                    .inc();
                trace
                    .steps
                    .push(TraceStep::note("defaults.max_body_bytes", "exceeded"));
                metrics::EVAL_LATENCY_SECONDS.observe(t0.elapsed().as_secs_f64());
                return Ok(Decision {
                    effect: DecisionEffect::Deny,
                    obligations,
                    reason: Some("body too large (defaults)".into()),
                    trace,
                });
            }
        }

        // Candidate rules restricted by method (and then checked fully).
        // `ctx.method` is already uppercased by the builder; reuse it to avoid alloc.
        let method: &str = &ctx.method;
        for r in self.index.candidates(method) {
            if rule_matches(r, ctx) {
                if matches!(r.action, Action::Deny) {
                    metrics::REJECTED_TOTAL
                        .with_label_values(&["rule_deny"])
                        .inc();
                }
                obligations.extend(&r.obligations);
                trace.steps.push(TraceStep::rule_hit(
                    &r.id,
                    r.reason.as_deref().unwrap_or(""),
                ));
                metrics::EVAL_LATENCY_SECONDS.observe(t0.elapsed().as_secs_f64());
                return Ok(Decision {
                    effect: match r.action {
                        Action::Allow => DecisionEffect::Allow,
                        Action::Deny => DecisionEffect::Deny,
                    },
                    obligations,
                    reason: r.reason.clone(),
                    trace,
                });
            }
            // Miss path (the `if` branch returns on hit).
            trace.steps.push(TraceStep::rule_miss(&r.id));
        }

        // No matches → default action (deny-by-default if unspecified)
        let effect = self.bundle.defaults.default_action.unwrap_or(Action::Deny);

        if matches!(effect, Action::Deny) {
            metrics::REJECTED_TOTAL
                .with_label_values(&["default_deny"])
                .inc();
        }

        metrics::EVAL_LATENCY_SECONDS.observe(t0.elapsed().as_secs_f64());
        Ok(Decision {
            effect: match effect {
                Action::Allow => DecisionEffect::Allow,
                Action::Deny => DecisionEffect::Deny,
            },
            obligations,
            reason: Some("default".into()),
            trace,
        })
    }
}

fn rule_matches(r: &Rule, ctx: &Context) -> bool {
    if let Some(t) = &r.when.tenant {
        if t != "*" && t != &ctx.tenant {
            return false;
        }
    }
    if let Some(m) = &r.when.method {
        if m != "*" && m.to_ascii_uppercase() != ctx.method {
            return false;
        }
    }
    if let Some(g) = &r.when.region {
        if g != "*" && g != &ctx.region {
            return false;
        }
    }
    if let Some(n) = r.when.max_body_bytes {
        if ctx.body_bytes > n {
            return false;
        }
    }
    if !r.when.require_tags_all.is_empty() {
        for tag in &r.when.require_tags_all {
            if !ctx.tags.contains(&tag.to_ascii_lowercase()) {
                return false;
            }
        }
    }
    true
}

```

### crates/ron-policy/src/engine/index.rs
<a id="crates-ron-policy-src-engine-index-rs"></a>

```rust
//! RO:WHAT — In-memory index to accelerate rule lookup by HTTP method.
//!
//! RO:WHY  — Avoid scanning all rules; common case is method-restricted rules.
//!
//! RO:INVARIANTS — Keys are uppercased method names or "*".

use crate::model::{PolicyBundle, Rule};
use std::collections::BTreeMap;

pub struct RuleIndex<'a> {
    by_method: BTreeMap<String, Vec<&'a Rule>>,
}

impl<'a> RuleIndex<'a> {
    /// Build an index from a validated `PolicyBundle`.
    ///
    /// # Errors
    ///
    /// Currently infallible; reserved for future index-build errors.
    #[must_use]
    pub fn build(bundle: &'a PolicyBundle) -> Self {
        let mut by_method: BTreeMap<String, Vec<&'a Rule>> = BTreeMap::new();
        for r in &bundle.rules {
            // clippy(map_unwrap_or): use map_or_else
            let key = r
                .when
                .method
                .as_ref()
                .map_or_else(|| "*".to_string(), |s| s.to_ascii_uppercase());
            by_method.entry(key).or_default().push(r);
        }
        Self { by_method }
    }

    /// Return candidates for a given (already UPPERCASED) method,
    /// falling back to "*" rules as well.
    pub fn candidates(&'a self, method: &str) -> impl Iterator<Item = &'a Rule> + 'a {
        // Avoid map/unwrap and redundant closures; iterate directly.
        self.by_method
            .get(method)
            .into_iter()
            .flat_map(|v| v.iter().copied())
            .chain(
                self.by_method
                    .get("*")
                    .into_iter()
                    .flat_map(|v| v.iter().copied()),
            )
    }
}

```

### crates/ron-policy/src/engine/metrics.rs
<a id="crates-ron-policy-src-engine-metrics-rs"></a>

```rust
//! RO:WHAT — Prometheus metrics for policy evaluations.
//!
//! RO:INVARIANTS — register once; use default registry.

use prometheus::{
    register_histogram, register_int_counter, register_int_counter_vec, Histogram, HistogramOpts,
    IntCounter, IntCounterVec, Opts,
};

pub static REQUESTS_TOTAL: std::sync::LazyLock<IntCounter> = std::sync::LazyLock::new(|| {
    register_int_counter!(Opts::new("policy_requests_total", "Policy evaluations")).unwrap()
});

pub static REJECTED_TOTAL: std::sync::LazyLock<IntCounterVec> = std::sync::LazyLock::new(|| {
    register_int_counter_vec!(
        Opts::new("policy_rejected_total", "Total rejects by reason"),
        &["reason"]
    )
    .unwrap()
});

pub static EVAL_LATENCY_SECONDS: std::sync::LazyLock<Histogram> = std::sync::LazyLock::new(|| {
    register_histogram!(HistogramOpts::new(
        "policy_eval_latency_seconds",
        "Evaluation latency"
    ))
    .unwrap()
});

```

### crates/ron-policy/src/engine/mod.rs
<a id="crates-ron-policy-src-engine-mod-rs"></a>

```rust
//! RO:WHAT — Policy evaluation engine modules.
pub mod eval;
pub mod index;
pub mod metrics;
pub mod obligations;
pub mod reason;

```

### crates/ron-policy/src/engine/obligations.rs
<a id="crates-ron-policy-src-engine-obligations-rs"></a>

```rust
//! RO:WHAT — Obligation handling (logical; no side effects here).
//! RO:WHY  — Services will interpret obligations; engine just aggregates.

use crate::model::Obligation;

#[derive(Debug, Clone, Default)]
pub struct ObligationSet {
    pub items: Vec<Obligation>,
}

impl ObligationSet {
    pub fn extend(&mut self, more: &[Obligation]) {
        self.items.extend_from_slice(more);
    }
}

```

### crates/ron-policy/src/engine/reason.rs
<a id="crates-ron-policy-src-engine-reason-rs"></a>

```rust
//! RO:WHAT — Machine+human readable reasons for decisions.

#[derive(Debug, Clone)]
pub struct Reason {
    pub code: &'static str,
    pub message: String,
}

impl Reason {
    pub fn new(code: &'static str, message: impl Into<String>) -> Self {
        Self {
            code,
            message: message.into(),
        }
    }
}

```

### crates/ron-policy/src/errors.rs
<a id="crates-ron-policy-src-errors-rs"></a>

```rust
//! RO:WHAT — Error taxonomy for ron-policy.
//!
//! RO:WHY  — Stable, deterministic error envelope for services/tests.
//!
//! RO:INTERACTS — `parse::{json,toml,validate}`, `engine::eval`
//!
//! RO:INVARIANTS — human-safe messages; no leaking secrets
//!
//! RO:TEST — unit tests exercise all variants

use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("parse error: {0}")]
    Parse(String),
    #[error("validation error: {0}")]
    Validation(String),
    #[error("evaluation error: {0}")]
    Eval(String),
}

```

### crates/ron-policy/src/explain/mod.rs
<a id="crates-ron-policy-src-explain-mod-rs"></a>

```rust
//! RO:WHAT — Explainability surface (trace).
pub mod trace;

```

### crates/ron-policy/src/explain/trace.rs
<a id="crates-ron-policy-src-explain-trace-rs"></a>

```rust
//! RO:WHAT — Structured trace steps for explain/debug/audit.

#[derive(Debug, Clone, Default)]
pub struct DecisionTrace {
    pub steps: Vec<TraceStep>,
}

#[derive(Debug, Clone)]
pub enum TraceStep {
    Note { key: String, msg: String },
    RuleHit { id: String, reason: String },
    RuleMiss { id: String },
}

impl DecisionTrace {
    pub fn note(key: impl Into<String>, msg: impl Into<String>) -> Self {
        let mut d = Self::default();
        d.steps.push(TraceStep::Note {
            key: key.into(),
            msg: msg.into(),
        });
        d
    }
}

impl TraceStep {
    pub fn note(key: impl Into<String>, msg: impl Into<String>) -> Self {
        Self::Note {
            key: key.into(),
            msg: msg.into(),
        }
    }
    pub fn rule_hit(id: impl Into<String>, reason: impl Into<String>) -> Self {
        Self::RuleHit {
            id: id.into(),
            reason: reason.into(),
        }
    }
    pub fn rule_miss(id: impl Into<String>) -> Self {
        Self::RuleMiss { id: id.into() }
    }
}

```

### crates/ron-policy/src/features.rs
<a id="crates-ron-policy-src-features-rs"></a>

```rust
//! RO:WHAT — Feature switches (placeholder for future toggles).
//!
//! RO:WHY  — Keep public surface stable while allowing internal perf/security opts.
//!
//! RO:INTERACTS — N/A today
//!
//! RO:INVARIANTS — default = strict parsing on

#[allow(dead_code)]
pub const STRICT: bool = cfg!(feature = "strict");

```

### crates/ron-policy/src/lib.rs
<a id="crates-ron-policy-src-lib-rs"></a>

```rust
//! RO:WHAT — ron-policy public API: load/validate bundles and evaluate decisions.
//!
//! RO:WHY  — Pillar 2 (Policy & Governance); Concerns: SEC/GOV. Deny-by-default guardrail.
//!
//! RO:INTERACTS — model, `parse::{json,toml,validate}`, `engine::{eval,index,obligations,metrics}`, `explain::trace`
//!
//! RO:INVARIANTS — DTOs are strict; no locks across `.await`; OAP caps: frame=1 MiB, chunk≈64 KiB (context only)
//!
//! RO:METRICS — `requests_total`, `rejected_total{reason}`, `eval_latency_seconds`
//!
//! RO:CONFIG — none (pure library); amnesia has no persistence here
//!
//! RO:SECURITY — capability enforcement happens in services; this crate only decides allow/deny
//!
//! RO:TEST — unit tests under `tests/*.rs`; bench: `benches/eval_throughput.rs`

#![forbid(unsafe_code)]
#![deny(clippy::all, clippy::pedantic, clippy::nursery)]

pub mod errors;
pub mod features;
pub mod model;

pub mod ctx;
pub mod engine;
pub mod explain;
pub mod parse;

pub use ctx::Context;
pub use engine::eval::{Decision, DecisionEffect, Evaluator};
pub use explain::trace::{DecisionTrace, TraceStep};
pub use model::{Action, Obligation, PolicyBundle, Rule, RuleCondition};

/// Convenience: load a bundle from JSON bytes.
///
/// # Errors
///
/// Returns `Error::Parse` on malformed JSON or `Error::Validation` if the
/// resulting `PolicyBundle` violates invariants.
pub fn load_json(bytes: &[u8]) -> Result<PolicyBundle, errors::Error> {
    let bundle = parse::json::from_slice(bytes)?;
    parse::validate::validate(&bundle)?;
    Ok(bundle)
}

/// Convenience: load a bundle from TOML bytes.
///
/// # Errors
///
/// Returns `Error::Parse` on malformed TOML or `Error::Validation` if the
/// resulting `PolicyBundle` violates invariants.
pub fn load_toml(bytes: &[u8]) -> Result<PolicyBundle, errors::Error> {
    let bundle = parse::toml::from_slice(bytes)?;
    parse::validate::validate(&bundle)?;
    Ok(bundle)
}

```

### crates/ron-policy/src/model.rs
<a id="crates-ron-policy-src-model-rs"></a>

```rust
//! RO:WHAT — Policy model (DTOs): `PolicyBundle`, Rule, Conditions, Actions, Obligations.
//!
//! RO:WHY  — DTO hygiene: `#[serde(deny_unknown_fields)]` so policies are explicit and auditable.
//!
//! RO:INTERACTS — parse loaders, engine eval, explain trace
//!
//! RO:INVARIANTS — deny-by-default; stable enums; versioned bundle

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct PolicyBundle {
    pub version: u32,
    /// Optional metadata bag (stringly typed, for governance/notes).
    #[serde(default)]
    pub meta: BTreeMap<String, String>,
    /// Global defaults. If `default_action` is omitted -> deny-by-default.
    #[serde(default)]
    pub defaults: Defaults,
    /// Rules are evaluated in order; first match wins (unless `strategy` overrides).
    #[serde(default)]
    pub rules: Vec<Rule>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct Defaults {
    #[serde(default)]
    pub default_action: Option<Action>,
    /// Max request body the engine expects callers to allow before evaluation (bytes).
    #[serde(default)]
    pub max_body_bytes: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Rule {
    pub id: String,
    pub when: RuleCondition,
    pub action: Action,
    #[serde(default)]
    pub obligations: Vec<Obligation>,
    /// Optional human-readable reason to surface if this rule triggers.
    #[serde(default)]
    pub reason: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct RuleCondition {
    /// Tenant or "*" for any.
    #[serde(default)]
    pub tenant: Option<String>,
    /// Method verb (e.g., "GET", "PUT") or "*" for any.
    #[serde(default)]
    pub method: Option<String>,
    /// Region/Geo (e.g., "US", "EU", "US-CA", "US-FL") or "*" for any.
    #[serde(default)]
    pub region: Option<String>,
    /// If present, deny if `body_bytes` exceeds this.
    #[serde(default)]
    pub max_body_bytes: Option<u64>,
    /// Arbitrary tags (all must be present in context if specified).
    #[serde(default)]
    pub require_tags_all: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Obligation {
    /// Name (e.g., "add-header", "mask-field", "log-audit")
    pub kind: String,
    /// Arbitrary parameters.
    #[serde(default)]
    pub params: BTreeMap<String, String>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "lowercase")]
pub enum Action {
    Allow,
    #[default]
    Deny,
}

```

### crates/ron-policy/src/parse/json.rs
<a id="crates-ron-policy-src-parse-json-rs"></a>

```rust
//! RO:WHAT — JSON loader for `PolicyBundle` (strict).
//!
//! RO:INVARIANTS — `deny_unknown_fields` enforced by DTOs.

use crate::{errors::Error, model::PolicyBundle};

/// Parse a `PolicyBundle` from JSON bytes.
///
/// # Errors
///
/// Returns `Error::Parse` if the input is not valid JSON for `PolicyBundle`.
pub fn from_slice(bytes: &[u8]) -> Result<PolicyBundle, Error> {
    serde_json::from_slice::<PolicyBundle>(bytes).map_err(|e| Error::Parse(e.to_string()))
}

```

### crates/ron-policy/src/parse/mod.rs
<a id="crates-ron-policy-src-parse-mod-rs"></a>

```rust
//! RO:WHAT — Parse entry points and validation.
pub mod json;
pub mod toml;
pub mod validate;

```

### crates/ron-policy/src/parse/toml.rs
<a id="crates-ron-policy-src-parse-toml-rs"></a>

```rust
//! RO:WHAT — TOML loader for `PolicyBundle` (strict).

use crate::{errors::Error, model::PolicyBundle};

/// Parse a `PolicyBundle` from TOML bytes.
///
/// # Errors
///
/// Returns `Error::Parse` if the input is not valid UTF-8 or not valid TOML for `PolicyBundle`.
pub fn from_slice(bytes: &[u8]) -> Result<PolicyBundle, Error> {
    let s = std::str::from_utf8(bytes).map_err(|e| Error::Parse(e.to_string()))?;
    toml::from_str::<PolicyBundle>(s).map_err(|e| Error::Parse(e.to_string()))
}

```

### crates/ron-policy/src/parse/validate.rs
<a id="crates-ron-policy-src-parse-validate-rs"></a>

```rust
//! RO:WHAT — Structural validation for `PolicyBundle`.
//!
//! Returns early with human-readable reasons on invariant violations.

use crate::{errors::Error, model::PolicyBundle};
use std::collections::BTreeSet;

/// Validate a `PolicyBundle` for basic invariants (e.g., duplicate IDs, body caps).
///
/// # Errors
///
/// Returns `Error::Validation` if the bundle violates invariants (e.g., duplicate rule IDs,
/// empty IDs, or caps exceeding 1 MiB).
pub fn validate(b: &PolicyBundle) -> Result<(), Error> {
    if b.version == 0 {
        return Err(Error::Validation("version must be ≥ 1".into()));
    }

    let mut ids = BTreeSet::<&str>::new();
    for r in &b.rules {
        if r.id.trim().is_empty() {
            return Err(Error::Validation("rule.id must be non-empty".into()));
        }
        if !ids.insert(&r.id) {
            return Err(Error::Validation(format!("duplicate rule id: {}", r.id)));
        }
        if let Some(n) = r.when.max_body_bytes {
            if n > 1_048_576 {
                // 1 MiB guard per Hardening blueprint
                return Err(Error::Validation(format!(
                    "rule {} max_body_bytes > 1MiB",
                    r.id
                )));
            }
        }
    }
    if let Some(n) = b.defaults.max_body_bytes {
        if n > 1_048_576 {
            return Err(Error::Validation("defaults.max_body_bytes > 1MiB".into()));
        }
    }
    Ok(())
}

```

### crates/ron-policy/tests/golden_reasons.rs
<a id="crates-ron-policy-tests-goldenreasons-rs"></a>

```rust
use ron_policy::engine::eval::DecisionEffect;
use ron_policy::explain::trace::TraceStep;
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

#[test]
fn explain_trace_is_stable() {
    let b = load_json(include_bytes!("vectors/decompress_guard.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();
    let ctx = Context::builder()
        .tenant("t")
        .method("PUT")
        .region("US")
        .body_bytes(512)
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();

    assert!(matches!(d.effect, DecisionEffect::Deny));
    assert_eq!(d.reason.as_deref(), Some("per-rule cap"));
    assert_eq!(d.trace.steps.len(), 1);
    match &d.trace.steps[0] {
        TraceStep::RuleHit { id, reason } => {
            assert_eq!(id, "deny-large-put");
            assert_eq!(reason, "per-rule cap");
        }
        other => panic!("unexpected trace step: {other:?}"),
    }
}

```

### crates/ron-policy/tests/helpers/bundle_load.rs
<a id="crates-ron-policy-tests-helpers-bundleload-rs"></a>

```rust
//! Helper to load test vectors.

use ron_policy::{load_json, PolicyBundle};

pub fn load_vector(name: &str) -> PolicyBundle {
    let path = format!("tests/vectors/{}", name);
    let bytes = std::fs::read(path).expect("read vector");
    load_json(&bytes).expect("parse bundle")
}

```

### crates/ron-policy/tests/unit_churn_protection.rs
<a id="crates-ron-policy-tests-unitchurnprotection-rs"></a>

```rust
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

#[test]
fn rule_deny_region() {
    let b = load_json(include_bytes!("vectors/deny_region.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();
    let ctx = Context::builder()
        .tenant("any")
        .method("GET")
        .region("US-FL")
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();
    assert!(matches!(
        d.effect,
        ron_policy::engine::eval::DecisionEffect::Deny
    ));
}

```

### crates/ron-policy/tests/unit_eu_only.rs
<a id="crates-ron-policy-tests-uniteuonly-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::engine::eval::{DecisionEffect, Evaluator};
use ron_policy::{load_json, Context};

#[test]
fn eu_allows_us_denies() {
    let b = load_json(include_bytes!("vectors/eu_only.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();

    let eu = Context::builder()
        .tenant("t")
        .method("GET")
        .region("EU")
        .build(&SystemClock);
    let us = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .build(&SystemClock);

    let de = ev.evaluate(&eu).unwrap();
    assert!(matches!(de.effect, DecisionEffect::Allow));
    assert_eq!(de.reason.as_deref(), Some("eu residency"));

    let du = ev.evaluate(&us).unwrap();
    assert!(matches!(du.effect, DecisionEffect::Deny));
    assert_eq!(du.reason.as_deref(), Some("default"));
}

```

### crates/ron-policy/tests/unit_eval_determinism.rs
<a id="crates-ron-policy-tests-unitevaldeterminism-rs"></a>

```rust
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

#[test]
fn deterministic_default_deny() {
    let bundle = load_json(br#"{"version":1,"rules":[]}"#).unwrap();
    let clock = SystemClock::default();
    let ctx = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .build(&clock);
    let ev = Evaluator::new(&bundle).unwrap();
    let d = ev.evaluate(&ctx).unwrap();
    assert!(matches!(
        d.effect,
        ron_policy::engine::eval::DecisionEffect::Deny
    ));
}

```

### crates/ron-policy/tests/unit_first_match_wins.rs
<a id="crates-ron-policy-tests-unitfirstmatchwins-rs"></a>

```rust
use ron_policy::{PolicyBundle, Rule, RuleCondition, Action};
use ron_policy::engine::eval::{Evaluator, DecisionEffect};
use ron_policy::{parse, Context};
use ron_policy::ctx::clock::SystemClock;

#[test]
fn first_match_wins_and_default_applies() {
    // Bundle: two overlapping allows for GET; no catch-all rule.
    // Expectations:
    //  - GET hits the *first* allow rule and returns immediately ("first").
    //  - POST has no matching rule and falls back to defaults ("default" deny).
    let b = PolicyBundle {
        version: 1,
        defaults: Default::default(), // default_action = None -> deny by default
        meta: Default::default(),
        rules: vec![
            Rule {
                id: "allow-1".into(),
                when: RuleCondition {
                    tenant: None,
                    method: Some("GET".into()),
                    region: None,
                    max_body_bytes: None,
                    require_tags_all: vec![],
                },
                action: Action::Allow,
                obligations: vec![],
                reason: Some("first".into()),
            },
            Rule {
                id: "allow-2".into(),
                when: RuleCondition {
                    tenant: None,
                    method: Some("GET".into()),
                    region: None,
                    max_body_bytes: None,
                    require_tags_all: vec![],
                },
                action: Action::Allow,
                obligations: vec![],
                reason: Some("second".into()),
            },
            // NOTE: No deny-fallback "*" rule here; we want POST to fall through to defaults.
        ],
    };

    parse::validate::validate(&b).unwrap();
    let ev = Evaluator::new(&b).unwrap();

    let getc = Context::builder().tenant("t").method("GET").region("US").build(&SystemClock);
    let postc = Context::builder().tenant("t").method("POST").region("US").build(&SystemClock);

    let d_get = ev.evaluate(&getc).unwrap();
    assert!(matches!(d_get.effect, DecisionEffect::Allow));
    assert_eq!(d_get.reason.as_deref(), Some("first"));

    let d_post = ev.evaluate(&postc).unwrap();
    assert!(matches!(d_post.effect, DecisionEffect::Deny));
    assert_eq!(d_post.reason.as_deref(), Some("default"));
}

```

### crates/ron-policy/tests/unit_large_body_default_deny.rs
<a id="crates-ron-policy-tests-unitlargebodydefaultdeny-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::engine::eval::{DecisionEffect, Evaluator};
use ron_policy::{load_json, Context};

#[test]
fn large_body_defaults_trips_deny() {
    let b = load_json(include_bytes!("vectors/large_body_default_deny.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();
    let ctx = Context::builder()
        .tenant("t")
        .method("PUT")
        .region("US")
        .body_bytes(512 * 1024)
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();
    assert!(matches!(d.effect, DecisionEffect::Deny));
    assert_eq!(d.reason.as_deref(), Some("body too large (defaults)"));
}

```

### crates/ron-policy/tests/unit_method_matrix.rs
<a id="crates-ron-policy-tests-unitmethodmatrix-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::engine::eval::{DecisionEffect, Evaluator};
use ron_policy::{load_json, Context};

#[test]
fn method_matrix_behaves() {
    let b = load_json(include_bytes!("vectors/method_matrix.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();

    let getc = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .build(&SystemClock);
    let putc = Context::builder()
        .tenant("t")
        .method("PUT")
        .region("US")
        .build(&SystemClock);
    let postc = Context::builder()
        .tenant("t")
        .method("POST")
        .region("US")
        .build(&SystemClock);

    let d_get = ev.evaluate(&getc).unwrap();
    assert!(matches!(d_get.effect, DecisionEffect::Allow));
    assert_eq!(d_get.reason.as_deref(), Some("get ok"));

    let d_put = ev.evaluate(&putc).unwrap();
    assert!(matches!(d_put.effect, DecisionEffect::Deny));
    assert_eq!(d_put.reason.as_deref(), Some("put blocked"));

    let d_post = ev.evaluate(&postc).unwrap();
    assert!(matches!(d_post.effect, DecisionEffect::Deny));
    assert_eq!(d_post.reason.as_deref(), Some("default"));
}

```

### crates/ron-policy/tests/unit_model_serde_strict.rs
<a id="crates-ron-policy-tests-unitmodelserdestrict-rs"></a>

```rust
use ron_policy::load_json;

#[test]
fn strict_deny_unknown_fields() {
    // Unknown field "oops" should be rejected.
    let bad = br#"{"version":1,"oops":true,"rules":[]}"#;
    let err = load_json(bad).unwrap_err();
    let msg = format!("{err}");
    assert!(msg.contains("validation error") || msg.contains("parse error"));
}

#[test]
fn round_trip_minimal() {
    let good = br#"{"version":1,"rules":[]}"#;
    let b = load_json(good).unwrap();
    assert_eq!(b.version, 1);
}

```

### crates/ron-policy/tests/unit_tags_all.rs
<a id="crates-ron-policy-tests-unittagsall-rs"></a>

```rust
use ron_policy::ctx::clock::SystemClock;
use ron_policy::engine::eval::{DecisionEffect, Evaluator};
use ron_policy::{load_json, Context};

#[test]
fn all_required_tags_must_exist() {
    let b = load_json(include_bytes!("vectors/tags_all.json")).unwrap();
    let ev = Evaluator::new(&b).unwrap();

    let ok = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .tag("paid")
        .tag("verified")
        .build(&SystemClock);

    let missing_one = Context::builder()
        .tenant("t")
        .method("GET")
        .region("US")
        .tag("paid")
        .build(&SystemClock);

    let d1 = ev.evaluate(&ok).unwrap();
    assert!(matches!(d1.effect, DecisionEffect::Allow));
    assert_eq!(d1.reason.as_deref(), Some("all-required-tags-present"));

    let d2 = ev.evaluate(&missing_one).unwrap();
    assert!(matches!(d2.effect, DecisionEffect::Deny));
    assert_eq!(d2.reason.as_deref(), Some("default"));
}

```

### crates/ron-policy/tests/unit_tighten_only.rs
<a id="crates-ron-policy-tests-unittightenonly-rs"></a>

```rust
use ron_policy::{ctx::clock::SystemClock, load_json, Context, Evaluator};

#[test]
fn defaults_cap_applies() {
    let b = load_json(
        br#"{
        "version":1,
        "defaults":{"max_body_bytes": 10},
        "rules":[]
    }"#,
    )
    .unwrap();
    let ev = Evaluator::new(&b).unwrap();
    let ctx = Context::builder()
        .tenant("a")
        .method("PUT")
        .region("US")
        .body_bytes(11)
        .build(&SystemClock);
    let d = ev.evaluate(&ctx).unwrap();
    assert!(matches!(
        d.effect,
        ron_policy::engine::eval::DecisionEffect::Deny
    ));
}

```

### crates/ron-policy/tests/vectors/body_too_large.json
<a id="crates-ron-policy-tests-vectors-bodytoolarge-json"></a>

```json
{
  "version": 1,
  "defaults": { "max_body_bytes": 1024 },
  "rules": [
    { "id": "allow-gets", "when": { "method": "GET" }, "action": "allow" }
  ]
}

```

### crates/ron-policy/tests/vectors/decompress_guard.json
<a id="crates-ron-policy-tests-vectors-decompressguard-json"></a>

```json
{
  "version": 1,
  "rules": [
    {
      "id": "deny-large-put",
      "when": { "method": "PUT", "max_body_bytes": 512 },
      "action": "deny",
      "reason": "per-rule cap"
    },
    { "id": "allow-others", "when": {}, "action": "allow" }
  ]
}

```

### crates/ron-policy/tests/vectors/deny_region.json
<a id="crates-ron-policy-tests-vectors-denyregion-json"></a>

```json
{
  "version": 1,
  "rules": [
    {
      "id": "deny-us-fl",
      "when": { "region": "US-FL" },
      "action": "deny",
      "reason": "region denied"
    },
    {
      "id": "allow-rest",
      "when": {},
      "action": "allow",
      "reason": "fallback allow"
    }
  ]
}

```

### crates/ron-policy/tests/vectors/eu_only.json
<a id="crates-ron-policy-tests-vectors-euonly-json"></a>

```json
{
  "version": 1,
  "defaults": { "default_action": "deny" },
  "rules": [
    { "id": "allow-eu", "when": { "region": "EU" }, "action": "allow", "reason": "eu residency" }
  ]
}

```

### crates/ron-policy/tests/vectors/large_body_default_deny.json
<a id="crates-ron-policy-tests-vectors-largebodydefaultdeny-json"></a>

```json
{
  "version": 1,
  "defaults": { "max_body_bytes": 262144 },
  "rules": []
}

```

### crates/ron-policy/tests/vectors/method_matrix.json
<a id="crates-ron-policy-tests-vectors-methodmatrix-json"></a>

```json
{
  "version": 1,
  "rules": [
    { "id": "allow-get", "when": { "method": "GET" }, "action": "allow", "reason": "get ok" },
    { "id": "deny-put",  "when": { "method": "PUT" }, "action": "deny",  "reason": "put blocked" }
  ]
}

```

### crates/ron-policy/tests/vectors/tags_all.json
<a id="crates-ron-policy-tests-vectors-tagsall-json"></a>

```json
{
  "version": 1,
  "defaults": { "default_action": "deny" },
  "rules": [
    {
      "id": "allow-paid-verified",
      "when": { "require_tags_all": ["paid", "verified"] },
      "action": "allow",
      "reason": "all-required-tags-present"
    }
  ]
}

```



---

